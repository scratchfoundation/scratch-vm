(self["webpackChunkscratch_vm"] = self["webpackChunkscratch_vm"] || []).push([["src_index-exposed_js"],{

/***/ "./src/index-exposed.js":
/*!******************************!*\
  !*** ./src/index-exposed.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ "./src/index.js");
var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../node_modules/expose-loader/dist/runtime/getGlobalThis.js */ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js");
var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
if (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["VirtualMachine"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___["VirtualMachine"] = ___EXPOSE_LOADER_IMPORT___;else throw new Error('[exposes-loader] The "VirtualMachine" value exists in the global scope, it may not be safe to overwrite it, use the "override" option');
module.exports = ___EXPOSE_LOADER_IMPORT___;

/***/ }),

/***/ "./src/blocks/scratch3_control.js":
/*!****************************************!*\
  !*** ./src/blocks/scratch3_control.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
class Scratch3ControlBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * The "counter" block value. For compatibility with 2.0.
     * @type {number}
     */
    this._counter = 0;
    this.runtime.on('RUNTIME_DISPOSED', this.clearCounter.bind(this));
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      control_repeat: this.repeat,
      control_repeat_until: this.repeatUntil,
      control_while: this.repeatWhile,
      control_for_each: this.forEach,
      control_forever: this.forever,
      control_wait: this.wait,
      control_wait_until: this.waitUntil,
      control_if: this.if,
      control_if_else: this.ifElse,
      control_stop: this.stop,
      control_create_clone_of: this.createClone,
      control_delete_this_clone: this.deleteClone,
      control_get_counter: this.getCounter,
      control_incr_counter: this.incrCounter,
      control_clear_counter: this.clearCounter,
      control_all_at_once: this.allAtOnce
    };
  }
  getHats() {
    return {
      control_start_as_clone: {
        restartExistingThreads: false
      }
    };
  }
  repeat(args, util) {
    const times = Math.round(Cast.toNumber(args.TIMES));
    // Initialize loop
    if (typeof util.stackFrame.loopCounter === 'undefined') {
      util.stackFrame.loopCounter = times;
    }
    // Only execute once per frame.
    // When the branch finishes, `repeat` will be executed again and
    // the second branch will be taken, yielding for the rest of the frame.
    // Decrease counter
    util.stackFrame.loopCounter--;
    // If we still have some left, start the branch.
    if (util.stackFrame.loopCounter >= 0) {
      util.startBranch(1, true);
    }
  }
  repeatUntil(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);
    // If the condition is false (repeat UNTIL), start the branch.
    if (!condition) {
      util.startBranch(1, true);
    }
  }
  repeatWhile(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);
    // If the condition is true (repeat WHILE), start the branch.
    if (condition) {
      util.startBranch(1, true);
    }
  }
  forEach(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    if (typeof util.stackFrame.index === 'undefined') {
      util.stackFrame.index = 0;
    }
    if (util.stackFrame.index < Number(args.VALUE)) {
      util.stackFrame.index++;
      variable.value = util.stackFrame.index;
      util.startBranch(1, true);
    }
  }
  waitUntil(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);
    if (!condition) {
      util.yield();
    }
  }
  forever(args, util) {
    util.startBranch(1, true);
  }
  wait(args, util) {
    if (util.stackTimerNeedsInit()) {
      const duration = Math.max(0, 1000 * Cast.toNumber(args.DURATION));
      util.startStackTimer(duration);
      this.runtime.requestRedraw();
      util.yield();
    } else if (!util.stackTimerFinished()) {
      util.yield();
    }
  }
  if(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);
    if (condition) {
      util.startBranch(1, false);
    }
  }
  ifElse(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);
    if (condition) {
      util.startBranch(1, false);
    } else {
      util.startBranch(2, false);
    }
  }
  stop(args, util) {
    const option = args.STOP_OPTION;
    if (option === 'all') {
      util.stopAll();
    } else if (option === 'other scripts in sprite' || option === 'other scripts in stage') {
      util.stopOtherTargetThreads();
    } else if (option === 'this script') {
      util.stopThisScript();
    }
  }
  createClone(args, util) {
    // Cast argument to string
    args.CLONE_OPTION = Cast.toString(args.CLONE_OPTION);

    // Set clone target
    let cloneTarget;
    if (args.CLONE_OPTION === '_myself_') {
      cloneTarget = util.target;
    } else {
      cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);
    }

    // If clone target is not found, return
    if (!cloneTarget) return;

    // Create clone
    const newClone = cloneTarget.makeClone();
    if (newClone) {
      this.runtime.addTarget(newClone);

      // Place behind the original target.
      newClone.goBehindOther(cloneTarget);
    }
  }
  deleteClone(args, util) {
    if (util.target.isOriginal) return;
    this.runtime.disposeTarget(util.target);
    this.runtime.stopForTarget(util.target);
  }
  getCounter() {
    return this._counter;
  }
  clearCounter() {
    this._counter = 0;
  }
  incrCounter() {
    this._counter++;
  }
  allAtOnce(args, util) {
    // Since the "all at once" block is implemented for compatiblity with
    // Scratch 2.0 projects, it behaves the same way it did in 2.0, which
    // is to simply run the contained script (like "if 1 = 1").
    // (In early versions of Scratch 2.0, it would work the same way as
    // "run without screen refresh" custom blocks do now, but this was
    // removed before the release of 2.0.)
    util.startBranch(1, false);
  }
}
module.exports = Scratch3ControlBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_core_example.js":
/*!*********************************************!*\
  !*** ./src/blocks/scratch3_core_example.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");
const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");

/* eslint-disable-next-line max-len */
const blockIconURI = 'data:image/svg+xml,%3Csvg id="rotate-counter-clockwise" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%233d79cc;%7D.cls-2%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3Erotate-counter-clockwise%3C/title%3E%3Cpath class="cls-1" d="M22.68,12.2a1.6,1.6,0,0,1-1.27.63H13.72a1.59,1.59,0,0,1-1.16-2.58l1.12-1.41a4.82,4.82,0,0,0-3.14-.77,4.31,4.31,0,0,0-2,.8,4.25,4.25,0,0,0-1.34,1.73,5.06,5.06,0,0,0,.54,4.62A5.58,5.58,0,0,0,12,17.74h0a2.26,2.26,0,0,1-.16,4.52A10.25,10.25,0,0,1,3.74,18,10.14,10.14,0,0,1,2.25,8.78,9.7,9.7,0,0,1,5.08,4.64,9.92,9.92,0,0,1,9.66,2.5a10.66,10.66,0,0,1,7.72,1.68l1.08-1.35a1.57,1.57,0,0,1,1.24-.6,1.6,1.6,0,0,1,1.54,1.21l1.7,7.37A1.57,1.57,0,0,1,22.68,12.2Z"/%3E%3Cpath class="cls-2" d="M21.38,11.83H13.77a.59.59,0,0,1-.43-1l1.75-2.19a5.9,5.9,0,0,0-4.7-1.58,5.07,5.07,0,0,0-4.11,3.17A6,6,0,0,0,7,15.77a6.51,6.51,0,0,0,5,2.92,1.31,1.31,0,0,1-.08,2.62,9.3,9.3,0,0,1-7.35-3.82A9.16,9.16,0,0,1,3.17,9.12,8.51,8.51,0,0,1,5.71,5.4,8.76,8.76,0,0,1,9.82,3.48a9.71,9.71,0,0,1,7.75,2.07l1.67-2.1a.59.59,0,0,1,1,.21L22,11.08A.59.59,0,0,1,21.38,11.83Z"/%3E%3C/svg%3E';

/**
 * An example core block implemented using the extension spec.
 * This is not loaded as part of the core blocks in the VM but it is provided
 * and used as part of tests.
 */
class Scratch3CoreExample {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: 'coreExample',
      name: 'CoreEx',
      // This string does not need to be translated as this extension is only used as an example.
      blocks: [{
        func: 'MAKE_A_VARIABLE',
        blockType: BlockType.BUTTON,
        text: 'make a variable (CoreEx)'
      }, {
        opcode: 'exampleOpcode',
        blockType: BlockType.REPORTER,
        text: 'example block'
      }, {
        opcode: 'exampleWithInlineImage',
        blockType: BlockType.COMMAND,
        text: 'block with image [CLOCKWISE] inline',
        arguments: {
          CLOCKWISE: {
            type: ArgumentType.IMAGE,
            dataURI: blockIconURI
          }
        }
      }]
    };
  }

  /**
   * Example opcode just returns the name of the stage target.
   * @returns {string} The name of the first target in the project.
   */
  exampleOpcode() {
    const stage = this.runtime.getTargetForStage();
    return stage ? stage.getName() : 'no stage yet';
  }
  exampleWithInlineImage() {
    return;
  }
}
module.exports = Scratch3CoreExample;

/***/ }),

/***/ "./src/blocks/scratch3_data.js":
/*!*************************************!*\
  !*** ./src/blocks/scratch3_data.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
class Scratch3DataBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      data_variable: this.getVariable,
      data_setvariableto: this.setVariableTo,
      data_changevariableby: this.changeVariableBy,
      data_hidevariable: this.hideVariable,
      data_showvariable: this.showVariable,
      data_listcontents: this.getListContents,
      data_addtolist: this.addToList,
      data_deleteoflist: this.deleteOfList,
      data_deletealloflist: this.deleteAllOfList,
      data_insertatlist: this.insertAtList,
      data_replaceitemoflist: this.replaceItemOfList,
      data_itemoflist: this.getItemOfList,
      data_itemnumoflist: this.getItemNumOfList,
      data_lengthoflist: this.lengthOfList,
      data_listcontainsitem: this.listContainsItem,
      data_hidelist: this.hideList,
      data_showlist: this.showList
    };
  }
  getVariable(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    return variable.value;
  }
  setVariableTo(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    variable.value = args.VALUE;
    if (variable.isCloud) {
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, args.VALUE]);
    }
  }
  changeVariableBy(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    const castedValue = Cast.toNumber(variable.value);
    const dValue = Cast.toNumber(args.VALUE);
    const newValue = castedValue + dValue;
    variable.value = newValue;
    if (variable.isCloud) {
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, newValue]);
    }
  }
  changeMonitorVisibility(id, visible) {
    // Send the monitor blocks an event like the flyout checkbox event.
    // This both updates the monitor state and changes the isMonitored block flag.
    this.runtime.monitorBlocks.changeBlock({
      id: id,
      // Monitor blocks for variables are the variable ID.
      element: 'checkbox',
      // Mimic checkbox event from flyout.
      value: visible
    }, this.runtime);
  }
  showVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, true);
  }
  hideVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, false);
  }
  showList(args) {
    this.changeMonitorVisibility(args.LIST.id, true);
  }
  hideList(args) {
    this.changeMonitorVisibility(args.LIST.id, false);
  }
  getListContents(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    // If block is running for monitors, return copy of list as an array if changed.
    if (util.thread.updateMonitor) {
      // Return original list value if up-to-date, which doesn't trigger monitor update.
      if (list._monitorUpToDate) return list.value;
      // If value changed, reset the flag and return a copy to trigger monitor update.
      // Because monitors use Immutable data structures, only new objects trigger updates.
      list._monitorUpToDate = true;
      return list.value.slice();
    }

    // Determine if the list is all single letters.
    // If it is, report contents joined together with no separator.
    // If it's not, report contents joined together with a space.
    let allSingleLetters = true;
    for (let i = 0; i < list.value.length; i++) {
      const listItem = list.value[i];
      if (!(typeof listItem === 'string' && listItem.length === 1)) {
        allSingleLetters = false;
        break;
      }
    }
    if (allSingleLetters) {
      return list.value.join('');
    }
    return list.value.join(' ');
  }
  addToList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    if (list.value.length < Scratch3DataBlocks.LIST_ITEM_LIMIT) {
      list.value.push(args.ITEM);
      list._monitorUpToDate = false;
    }
  }
  deleteOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, true);
    if (index === Cast.LIST_INVALID) {
      return;
    } else if (index === Cast.LIST_ALL) {
      list.value = [];
      return;
    }
    list.value.splice(index - 1, 1);
    list._monitorUpToDate = false;
  }
  deleteAllOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    list.value = [];
    return;
  }
  insertAtList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length + 1, false);
    if (index === Cast.LIST_INVALID) {
      return;
    }
    const listLimit = Scratch3DataBlocks.LIST_ITEM_LIMIT;
    if (index > listLimit) return;
    list.value.splice(index - 1, 0, item);
    if (list.value.length > listLimit) {
      // If inserting caused the list to grow larger than the limit,
      // remove the last element in the list
      list.value.pop();
    }
    list._monitorUpToDate = false;
  }
  replaceItemOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, false);
    if (index === Cast.LIST_INVALID) {
      return;
    }
    list.value[index - 1] = item;
    list._monitorUpToDate = false;
  }
  getItemOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, false);
    if (index === Cast.LIST_INVALID) {
      return '';
    }
    return list.value[index - 1];
  }
  getItemNumOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    // Go through the list items one-by-one using Cast.compare. This is for
    // cases like checking if 123 is contained in a list [4, 7, '123'] --
    // Scratch considers 123 and '123' to be equal.
    for (let i = 0; i < list.value.length; i++) {
      if (Cast.compare(list.value[i], item) === 0) {
        return i + 1;
      }
    }

    // We don't bother using .indexOf() at all, because it would end up with
    // edge cases such as the index of '123' in [4, 7, 123, '123', 9].
    // If we use indexOf(), this block would return 4 instead of 3, because
    // indexOf() sees the first occurence of the string 123 as the fourth
    // item in the list. With Scratch, this would be confusing -- after all,
    // '123' and 123 look the same, so one would expect the block to say
    // that the first occurrence of '123' (or 123) to be the third item.

    // Default to 0 if there's no match. Since Scratch lists are 1-indexed,
    // we don't have to worry about this conflicting with the "this item is
    // the first value" number (in JS that is 0, but in Scratch it's 1).
    return 0;
  }
  lengthOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    return list.value.length;
  }
  listContainsItem(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    if (list.value.indexOf(item) >= 0) {
      return true;
    }
    // Try using Scratch comparison operator on each item.
    // (Scratch considers the string '123' equal to the number 123).
    for (let i = 0; i < list.value.length; i++) {
      if (Cast.compare(list.value[i], item) === 0) {
        return true;
      }
    }
    return false;
  }

  /**
   * Type representation for list variables.
   * @const {number}
   */
  static get LIST_ITEM_LIMIT() {
    return 200000;
  }
}
module.exports = Scratch3DataBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_event.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_event.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
class Scratch3EventBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.runtime.on('KEY_PRESSED', key => {
      this.runtime.startHats('event_whenkeypressed', {
        KEY_OPTION: key
      });
      this.runtime.startHats('event_whenkeypressed', {
        KEY_OPTION: 'any'
      });
    });
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      event_whentouchingobject: this.touchingObject,
      event_broadcast: this.broadcast,
      event_broadcastandwait: this.broadcastAndWait,
      event_whengreaterthan: this.hatGreaterThanPredicate
    };
  }
  getHats() {
    return {
      event_whenflagclicked: {
        restartExistingThreads: true
      },
      event_whenkeypressed: {
        restartExistingThreads: false
      },
      event_whenthisspriteclicked: {
        restartExistingThreads: true
      },
      event_whentouchingobject: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenstageclicked: {
        restartExistingThreads: true
      },
      event_whenbackdropswitchesto: {
        restartExistingThreads: true
      },
      event_whengreaterthan: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenbroadcastreceived: {
        restartExistingThreads: true
      }
    };
  }
  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }
  hatGreaterThanPredicate(args, util) {
    const option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();
    const value = Cast.toNumber(args.VALUE);
    switch (option) {
      case 'timer':
        return util.ioQuery('clock', 'projectTimer') > value;
      case 'loudness':
        return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;
    }
    return false;
  }
  broadcast(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
    if (broadcastVar) {
      const broadcastOption = broadcastVar.name;
      util.startHats('event_whenbroadcastreceived', {
        BROADCAST_OPTION: broadcastOption
      });
    }
  }
  broadcastAndWait(args, util) {
    if (!util.stackFrame.broadcastVar) {
      util.stackFrame.broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
    }
    if (util.stackFrame.broadcastVar) {
      const broadcastOption = util.stackFrame.broadcastVar.name;
      // Have we run before, starting threads?
      if (!util.stackFrame.startedThreads) {
        // No - start hats for this broadcast.
        util.stackFrame.startedThreads = util.startHats('event_whenbroadcastreceived', {
          BROADCAST_OPTION: broadcastOption
        });
        if (util.stackFrame.startedThreads.length === 0) {
          // Nothing was started.
          return;
        }
      }
      // We've run before; check if the wait is still going on.
      const instance = this;
      // Scratch 2 considers threads to be waiting if they are still in
      // runtime.threads. Threads that have run all their blocks, or are
      // marked done but still in runtime.threads are still considered to
      // be waiting.
      const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);
      if (waiting) {
        // If all threads are waiting for the next tick or later yield
        // for a tick as well. Otherwise yield until the next loop of
        // the threads.
        if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
          util.yieldTick();
        } else {
          util.yield();
        }
      }
    }
  }
}
module.exports = Scratch3EventBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_looks.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_looks.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");
const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");
const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

/**
 * @typedef {object} BubbleState - the bubble state associated with a particular target.
 * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.
 * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.
 * @property {string} text - the text of the bubble.
 * @property {string} type - the type of the bubble, "say" or "think"
 * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.
 *      Used for comparison when determining whether to clear a say/think bubble.
 */

class Scratch3LooksBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this._onTargetChanged = this._onTargetChanged.bind(this);
    this._onResetBubbles = this._onResetBubbles.bind(this);
    this._onTargetWillExit = this._onTargetWillExit.bind(this);
    this._updateBubble = this._updateBubble.bind(this);

    // Reset all bubbles on start/stop
    this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);
    this.runtime.on('targetWasRemoved', this._onTargetWillExit);

    // Enable other blocks to use bubbles like ask/answer
    this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);
  }

  /**
   * The default bubble state, to be used when a target has no existing bubble state.
   * @type {BubbleState}
   */
  static get DEFAULT_BUBBLE_STATE() {
    return {
      drawableId: null,
      onSpriteRight: true,
      skinId: null,
      text: '',
      type: 'say',
      usageId: null
    };
  }

  /**
   * The key to load & store a target's bubble-related state.
   * @type {string}
   */
  static get STATE_KEY() {
    return 'Scratch.looks';
  }

  /**
   * Event name for a text bubble being created or updated.
   * @const {string}
   */
  static get SAY_OR_THINK() {
    // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',
    // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.
    return 'SAY';
  }

  /**
   * Limit for say bubble string.
   * @const {string}
   */
  static get SAY_BUBBLE_LIMIT() {
    return 330;
  }

  /**
   * Limit for ghost effect
   * @const {object}
   */
  static get EFFECT_GHOST_LIMIT() {
    return {
      min: 0,
      max: 100
    };
  }

  /**
   * Limit for brightness effect
   * @const {object}
   */
  static get EFFECT_BRIGHTNESS_LIMIT() {
    return {
      min: -100,
      max: 100
    };
  }

  /**
   * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.
   * @private
   */
  _getBubbleState(target) {
    let bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);
    if (!bubbleState) {
      bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);
      target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);
    }
    return bubbleState;
  }

  /**
   * Handle a target which has moved.
   * @param {RenderedTarget} target - the target which has moved.
   * @private
   */
  _onTargetChanged(target) {
    const bubbleState = this._getBubbleState(target);
    if (bubbleState.drawableId) {
      this._positionBubble(target);
    }
  }

  /**
   * Handle a target which is exiting.
   * @param {RenderedTarget} target - the target.
   * @private
   */
  _onTargetWillExit(target) {
    const bubbleState = this._getBubbleState(target);
    if (bubbleState.drawableId && bubbleState.skinId) {
      this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);
      this.runtime.renderer.destroySkin(bubbleState.skinId);
      bubbleState.drawableId = null;
      bubbleState.skinId = null;
      this.runtime.requestRedraw();
    }
    target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
  }

  /**
   * Handle project start/stop by clearing all visible bubbles.
   * @private
   */
  _onResetBubbles() {
    for (let n = 0; n < this.runtime.targets.length; n++) {
      const bubbleState = this._getBubbleState(this.runtime.targets[n]);
      bubbleState.text = '';
      this._onTargetWillExit(this.runtime.targets[n]);
    }
    clearTimeout(this._bubbleTimeout);
  }

  /**
   * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.
   * @param {!Target} target Target whose bubble needs positioning.
   * @private
   */
  _positionBubble(target) {
    if (!target.visible) return;
    const bubbleState = this._getBubbleState(target);
    const [bubbleWidth, bubbleHeight] = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId);
    let targetBounds;
    try {
      targetBounds = target.getBoundsForBubble();
    } catch (error_) {
      // Bounds calculation could fail (e.g. on empty costumes), in that case
      // use the x/y position of the target.
      targetBounds = {
        left: target.x,
        right: target.x,
        top: target.y,
        bottom: target.y
      };
    }
    const stageSize = this.runtime.renderer.getNativeSize();
    const stageBounds = {
      left: -stageSize[0] / 2,
      right: stageSize[0] / 2,
      top: stageSize[1] / 2,
      bottom: -stageSize[1] / 2
    };
    if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = false;
      this._renderBubble(target);
    } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = true;
      this._renderBubble(target);
    } else {
      this.runtime.renderer.updateDrawablePosition(bubbleState.drawableId, [bubbleState.onSpriteRight ? Math.max(stageBounds.left,
      // Bubble should not extend past left edge of stage
      Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth,
      // Bubble should not extend past right edge of stage
      Math.max(stageBounds.left, targetBounds.left - bubbleWidth)),
      // Bubble should not extend past the top of the stage
      Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]);
      this.runtime.requestRedraw();
    }
  }

  /**
   * Create a visible bubble for a target. If a bubble exists for the target,
   * just set it to visible and update the type/text. Otherwise create a new
   * bubble and update the relevant custom state.
   * @param {!Target} target Target who needs a bubble.
   * @return {undefined} Early return if text is empty string.
   * @private
   */
  _renderBubble(target) {
    if (!this.runtime.renderer) return;
    const bubbleState = this._getBubbleState(target);
    const {
      type,
      text,
      onSpriteRight
    } = bubbleState;

    // Remove the bubble if target is not visible, or text is being set to blank.
    if (!target.visible || text === '') {
      this._onTargetWillExit(target);
      return;
    }
    if (bubbleState.skinId) {
      this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);
    } else {
      target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
      bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);
      bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);
      this.runtime.renderer.updateDrawableSkinId(bubbleState.drawableId, bubbleState.skinId);
    }
    this._positionBubble(target);
  }

  /**
   * Properly format text for a text bubble.
   * @param {string} text The text to be formatted
   * @return {string} The formatted text
   * @private
   */
  _formatBubbleText(text) {
    if (text === '') return text;

    // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that
    // rounding would display them as 0.00. This matches 2.0's behavior:
    // https://github.com/scratchfoundation/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585
    if (typeof text === 'number' && Math.abs(text) >= 0.01 && text % 1 !== 0) {
      text = text.toFixed(2);
    }

    // Limit the length of the string.
    text = String(text).substr(0, Scratch3LooksBlocks.SAY_BUBBLE_LIMIT);
    return text;
  }

  /**
   * The entry point for say/think blocks. Clears existing bubble if the text is empty.
   * Set the bubble custom state and then call _renderBubble.
   * @param {!Target} target Target that say/think blocks are being called on.
   * @param {!string} type Either "say" or "think"
   * @param {!string} text The text for the bubble, empty string clears the bubble.
   * @private
   */
  _updateBubble(target, type, text) {
    const bubbleState = this._getBubbleState(target);
    bubbleState.type = type;
    bubbleState.text = this._formatBubbleText(text);
    bubbleState.usageId = uid();
    this._renderBubble(target);
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      looks_say: this.say,
      looks_sayforsecs: this.sayforsecs,
      looks_think: this.think,
      looks_thinkforsecs: this.thinkforsecs,
      looks_show: this.show,
      looks_hide: this.hide,
      looks_hideallsprites: () => {},
      // legacy no-op block
      looks_switchcostumeto: this.switchCostume,
      looks_switchbackdropto: this.switchBackdrop,
      looks_switchbackdroptoandwait: this.switchBackdropAndWait,
      looks_nextcostume: this.nextCostume,
      looks_nextbackdrop: this.nextBackdrop,
      looks_changeeffectby: this.changeEffect,
      looks_seteffectto: this.setEffect,
      looks_cleargraphiceffects: this.clearEffects,
      looks_changesizeby: this.changeSize,
      looks_setsizeto: this.setSize,
      looks_changestretchby: () => {},
      // legacy no-op blocks
      looks_setstretchto: () => {},
      looks_gotofrontback: this.goToFrontBack,
      looks_goforwardbackwardlayers: this.goForwardBackwardLayers,
      looks_size: this.getSize,
      looks_costumenumbername: this.getCostumeNumberName,
      looks_backdropnumbername: this.getBackdropNumberName
    };
  }
  getMonitored() {
    return {
      looks_size: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_size")
      },
      looks_costumenumbername: {
        isSpriteSpecific: true,
        getId: (targetId, fields) => getMonitorIdForBlockWithArgs("".concat(targetId, "_costumenumbername"), fields)
      },
      looks_backdropnumbername: {
        getId: (_, fields) => getMonitorIdForBlockWithArgs('backdropnumbername', fields)
      }
    };
  }
  say(args, util) {
    // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
    this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'say', args.MESSAGE);
  }
  sayforsecs(args, util) {
    this.say(args, util);
    const target = util.target;
    const usageId = this._getBubbleState(target).usageId;
    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null;
        // Clear say bubble if it hasn't been changed and proceed.
        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, 'say', '');
        }
        resolve();
      }, 1000 * args.SECS);
    });
  }
  think(args, util) {
    this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);
  }
  thinkforsecs(args, util) {
    this.think(args, util);
    const target = util.target;
    const usageId = this._getBubbleState(target).usageId;
    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null;
        // Clear think bubble if it hasn't been changed and proceed.
        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, 'think', '');
        }
        resolve();
      }, 1000 * args.SECS);
    });
  }
  show(args, util) {
    util.target.setVisible(true);
    this._renderBubble(util.target);
  }
  hide(args, util) {
    util.target.setVisible(false);
    this._renderBubble(util.target);
  }

  /**
   * Utility function to set the costume of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} target Target to set costume to.
   * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */
  _setCostume(target, requestedCostume, optZeroIndex) {
    if (typeof requestedCostume === 'number') {
      // Numbers should be treated as costume indices, always
      target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);
    } else {
      // Strings should be treated as costume names, where possible
      const costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());
      if (costumeIndex !== -1) {
        target.setCostume(costumeIndex);
      } else if (requestedCostume === 'next costume') {
        target.setCostume(target.currentCostume + 1);
      } else if (requestedCostume === 'previous costume') {
        target.setCostume(target.currentCostume - 1);
        // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN
      } else if (!(isNaN(requestedCostume) || Cast.isWhiteSpace(requestedCostume))) {
        target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);
      }
    }

    // Per 2.0, 'switch costume' can't start threads even in the Stage.
    return [];
  }

  /**
   * Utility function to set the backdrop of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} stage Target to set backdrop to.
   * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */
  _setBackdrop(stage, requestedBackdrop, optZeroIndex) {
    if (typeof requestedBackdrop === 'number') {
      // Numbers should be treated as backdrop indices, always
      stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);
    } else {
      // Strings should be treated as backdrop names where possible
      const costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());
      if (costumeIndex !== -1) {
        stage.setCostume(costumeIndex);
      } else if (requestedBackdrop === 'next backdrop') {
        stage.setCostume(stage.currentCostume + 1);
      } else if (requestedBackdrop === 'previous backdrop') {
        stage.setCostume(stage.currentCostume - 1);
      } else if (requestedBackdrop === 'random backdrop') {
        const numCostumes = stage.getCostumes().length;
        if (numCostumes > 1) {
          // Don't pick the current backdrop, so that the block
          // will always have an observable effect.
          const lowerBound = 0;
          const upperBound = numCostumes - 1;
          const costumeToExclude = stage.currentCostume;
          const nextCostume = MathUtil.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);
          stage.setCostume(nextCostume);
        }
        // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN
      } else if (!(isNaN(requestedBackdrop) || Cast.isWhiteSpace(requestedBackdrop))) {
        stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);
      }
    }
    const newName = stage.getCostumes()[stage.currentCostume].name;
    return this.runtime.startHats('event_whenbackdropswitchesto', {
      BACKDROP: newName
    });
  }
  switchCostume(args, util) {
    this._setCostume(util.target, args.COSTUME);
  }
  nextCostume(args, util) {
    this._setCostume(util.target, util.target.currentCostume + 1, true);
  }
  switchBackdrop(args) {
    this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
  }
  switchBackdropAndWait(args, util) {
    // Have we run before, starting threads?
    if (!util.stackFrame.startedThreads) {
      // No - switch the backdrop.
      util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
      if (util.stackFrame.startedThreads.length === 0) {
        // Nothing was started.
        return;
      }
    }
    // We've run before; check if the wait is still going on.
    const instance = this;
    // Scratch 2 considers threads to be waiting if they are still in
    // runtime.threads. Threads that have run all their blocks, or are
    // marked done but still in runtime.threads are still considered to
    // be waiting.
    const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);
    if (waiting) {
      // If all threads are waiting for the next tick or later yield
      // for a tick as well. Otherwise yield until the next loop of
      // the threads.
      if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
        util.yieldTick();
      } else {
        util.yield();
      }
    }
  }
  nextBackdrop() {
    const stage = this.runtime.getTargetForStage();
    this._setBackdrop(stage, stage.currentCostume + 1, true);
  }
  clampEffect(effect, value) {
    let clampedValue = value;
    switch (effect) {
      case 'ghost':
        clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.min, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.max);
        break;
      case 'brightness':
        clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);
        break;
    }
    return clampedValue;
  }
  changeEffect(args, util) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    const change = Cast.toNumber(args.CHANGE);
    if (!Object.prototype.hasOwnProperty.call(util.target.effects, effect)) return;
    let newValue = change + util.target.effects[effect];
    newValue = this.clampEffect(effect, newValue);
    util.target.setEffect(effect, newValue);
  }
  setEffect(args, util) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    let value = Cast.toNumber(args.VALUE);
    value = this.clampEffect(effect, value);
    util.target.setEffect(effect, value);
  }
  clearEffects(args, util) {
    util.target.clearEffects();
  }
  changeSize(args, util) {
    const change = Cast.toNumber(args.CHANGE);
    util.target.setSize(util.target.size + change);
  }
  setSize(args, util) {
    const size = Cast.toNumber(args.SIZE);
    util.target.setSize(size);
  }
  goToFrontBack(args, util) {
    if (!util.target.isStage) {
      if (args.FRONT_BACK === 'front') {
        util.target.goToFront();
      } else {
        util.target.goToBack();
      }
    }
  }
  goForwardBackwardLayers(args, util) {
    if (!util.target.isStage) {
      if (args.FORWARD_BACKWARD === 'forward') {
        util.target.goForwardLayers(Cast.toNumber(args.NUM));
      } else {
        util.target.goBackwardLayers(Cast.toNumber(args.NUM));
      }
    }
  }
  getSize(args, util) {
    return Math.round(util.target.size);
  }
  getBackdropNumberName(args) {
    const stage = this.runtime.getTargetForStage();
    if (args.NUMBER_NAME === 'number') {
      return stage.currentCostume + 1;
    }
    // Else return name
    return stage.getCostumes()[stage.currentCostume].name;
  }
  getCostumeNumberName(args, util) {
    if (args.NUMBER_NAME === 'number') {
      return util.target.currentCostume + 1;
    }
    // Else return name
    return util.target.getCostumes()[util.target.currentCostume].name;
  }
}
module.exports = Scratch3LooksBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_motion.js":
/*!***************************************!*\
  !*** ./src/blocks/scratch3_motion.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
class Scratch3MotionBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      motion_movesteps: this.moveSteps,
      motion_gotoxy: this.goToXY,
      motion_goto: this.goTo,
      motion_turnright: this.turnRight,
      motion_turnleft: this.turnLeft,
      motion_pointindirection: this.pointInDirection,
      motion_pointtowards: this.pointTowards,
      motion_glidesecstoxy: this.glide,
      motion_glideto: this.glideTo,
      motion_ifonedgebounce: this.ifOnEdgeBounce,
      motion_setrotationstyle: this.setRotationStyle,
      motion_changexby: this.changeX,
      motion_setx: this.setX,
      motion_changeyby: this.changeY,
      motion_sety: this.setY,
      motion_xposition: this.getX,
      motion_yposition: this.getY,
      motion_direction: this.getDirection,
      // Legacy no-op blocks:
      motion_scroll_right: () => {},
      motion_scroll_up: () => {},
      motion_align_scene: () => {},
      motion_xscroll: () => {},
      motion_yscroll: () => {}
    };
  }
  getMonitored() {
    return {
      motion_xposition: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_xposition")
      },
      motion_yposition: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_yposition")
      },
      motion_direction: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_direction")
      }
    };
  }
  moveSteps(args, util) {
    const steps = Cast.toNumber(args.STEPS);
    const radians = MathUtil.degToRad(90 - util.target.direction);
    const dx = steps * Math.cos(radians);
    const dy = steps * Math.sin(radians);
    util.target.setXY(util.target.x + dx, util.target.y + dy);
  }
  goToXY(args, util) {
    const x = Cast.toNumber(args.X);
    const y = Cast.toNumber(args.Y);
    util.target.setXY(x, y);
  }
  getTargetXY(targetName, util) {
    let targetX = 0;
    let targetY = 0;
    if (targetName === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else if (targetName === '_random_') {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      targetX = Math.round(stageWidth * (Math.random() - 0.5));
      targetY = Math.round(stageHeight * (Math.random() - 0.5));
    } else {
      targetName = Cast.toString(targetName);
      const goToTarget = this.runtime.getSpriteTargetByName(targetName);
      if (!goToTarget) return;
      targetX = goToTarget.x;
      targetY = goToTarget.y;
    }
    return [targetX, targetY];
  }
  goTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);
    if (targetXY) {
      util.target.setXY(targetXY[0], targetXY[1]);
    }
  }
  turnRight(args, util) {
    const degrees = Cast.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction + degrees);
  }
  turnLeft(args, util) {
    const degrees = Cast.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction - degrees);
  }
  pointInDirection(args, util) {
    const direction = Cast.toNumber(args.DIRECTION);
    util.target.setDirection(direction);
  }
  pointTowards(args, util) {
    let targetX = 0;
    let targetY = 0;
    if (args.TOWARDS === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else if (args.TOWARDS === '_random_') {
      util.target.setDirection(Math.round(Math.random() * 360) - 180);
      return;
    } else {
      args.TOWARDS = Cast.toString(args.TOWARDS);
      const pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);
      if (!pointTarget) return;
      targetX = pointTarget.x;
      targetY = pointTarget.y;
    }
    const dx = targetX - util.target.x;
    const dy = targetY - util.target.y;
    const direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));
    util.target.setDirection(direction);
  }
  glide(args, util) {
    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();
      if (timeElapsed < util.stackFrame.duration * 1000) {
        // In progress: move to intermediate position.
        const frac = timeElapsed / (util.stackFrame.duration * 1000);
        const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);
        util.yield();
      } else {
        // Finished: move to final position.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
      }
    } else {
      // First time: save data for future use.
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Cast.toNumber(args.SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Cast.toNumber(args.X);
      util.stackFrame.endY = Cast.toNumber(args.Y);
      if (util.stackFrame.duration <= 0) {
        // Duration too short to glide.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
        return;
      }
      util.yield();
    }
  }
  glideTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);
    if (targetXY) {
      this.glide({
        SECS: args.SECS,
        X: targetXY[0],
        Y: targetXY[1]
      }, util);
    }
  }
  ifOnEdgeBounce(args, util) {
    const bounds = util.target.getBounds();
    if (!bounds) {
      return;
    }
    // Measure distance to edges.
    // Values are positive when the sprite is far away,
    // and clamped to zero when the sprite is beyond.
    const stageWidth = this.runtime.constructor.STAGE_WIDTH;
    const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
    const distLeft = Math.max(0, stageWidth / 2 + bounds.left);
    const distTop = Math.max(0, stageHeight / 2 - bounds.top);
    const distRight = Math.max(0, stageWidth / 2 - bounds.right);
    const distBottom = Math.max(0, stageHeight / 2 + bounds.bottom);
    // Find the nearest edge.
    let nearestEdge = '';
    let minDist = Infinity;
    if (distLeft < minDist) {
      minDist = distLeft;
      nearestEdge = 'left';
    }
    if (distTop < minDist) {
      minDist = distTop;
      nearestEdge = 'top';
    }
    if (distRight < minDist) {
      minDist = distRight;
      nearestEdge = 'right';
    }
    if (distBottom < minDist) {
      minDist = distBottom;
      nearestEdge = 'bottom';
    }
    if (minDist > 0) {
      return; // Not touching any edge.
    }
    // Point away from the nearest edge.
    const radians = MathUtil.degToRad(90 - util.target.direction);
    let dx = Math.cos(radians);
    let dy = -Math.sin(radians);
    if (nearestEdge === 'left') {
      dx = Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === 'top') {
      dy = Math.max(0.2, Math.abs(dy));
    } else if (nearestEdge === 'right') {
      dx = 0 - Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === 'bottom') {
      dy = 0 - Math.max(0.2, Math.abs(dy));
    }
    const newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;
    util.target.setDirection(newDirection);
    // Keep within the stage.
    const fencedPosition = util.target.keepInFence(util.target.x, util.target.y);
    util.target.setXY(fencedPosition[0], fencedPosition[1]);
  }
  setRotationStyle(args, util) {
    util.target.setRotationStyle(args.STYLE);
  }
  changeX(args, util) {
    const dx = Cast.toNumber(args.DX);
    util.target.setXY(util.target.x + dx, util.target.y);
  }
  setX(args, util) {
    const x = Cast.toNumber(args.X);
    util.target.setXY(x, util.target.y);
  }
  changeY(args, util) {
    const dy = Cast.toNumber(args.DY);
    util.target.setXY(util.target.x, util.target.y + dy);
  }
  setY(args, util) {
    const y = Cast.toNumber(args.Y);
    util.target.setXY(util.target.x, y);
  }
  getX(args, util) {
    return this.limitPrecision(util.target.x);
  }
  getY(args, util) {
    return this.limitPrecision(util.target.y);
  }
  getDirection(args, util) {
    return util.target.direction;
  }

  // This corresponds to snapToInteger in Scratch 2
  limitPrecision(coordinate) {
    const rounded = Math.round(coordinate);
    const delta = coordinate - rounded;
    const limitedCoord = Math.abs(delta) < 1e-9 ? rounded : coordinate;
    return limitedCoord;
  }
}
module.exports = Scratch3MotionBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_operators.js":
/*!******************************************!*\
  !*** ./src/blocks/scratch3_operators.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast.js */ "./src/util/cast.js");
const MathUtil = __webpack_require__(/*! ../util/math-util.js */ "./src/util/math-util.js");
class Scratch3OperatorsBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      operator_add: this.add,
      operator_subtract: this.subtract,
      operator_multiply: this.multiply,
      operator_divide: this.divide,
      operator_lt: this.lt,
      operator_equals: this.equals,
      operator_gt: this.gt,
      operator_and: this.and,
      operator_or: this.or,
      operator_not: this.not,
      operator_random: this.random,
      operator_join: this.join,
      operator_letter_of: this.letterOf,
      operator_length: this.length,
      operator_contains: this.contains,
      operator_mod: this.mod,
      operator_round: this.round,
      operator_mathop: this.mathop
    };
  }
  add(args) {
    return Cast.toNumber(args.NUM1) + Cast.toNumber(args.NUM2);
  }
  subtract(args) {
    return Cast.toNumber(args.NUM1) - Cast.toNumber(args.NUM2);
  }
  multiply(args) {
    return Cast.toNumber(args.NUM1) * Cast.toNumber(args.NUM2);
  }
  divide(args) {
    return Cast.toNumber(args.NUM1) / Cast.toNumber(args.NUM2);
  }
  lt(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) < 0;
  }
  equals(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) === 0;
  }
  gt(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) > 0;
  }
  and(args) {
    return Cast.toBoolean(args.OPERAND1) && Cast.toBoolean(args.OPERAND2);
  }
  or(args) {
    return Cast.toBoolean(args.OPERAND1) || Cast.toBoolean(args.OPERAND2);
  }
  not(args) {
    return !Cast.toBoolean(args.OPERAND);
  }
  random(args) {
    const nFrom = Cast.toNumber(args.FROM);
    const nTo = Cast.toNumber(args.TO);
    const low = nFrom <= nTo ? nFrom : nTo;
    const high = nFrom <= nTo ? nTo : nFrom;
    if (low === high) return low;
    // If both arguments are ints, truncate the result to an int.
    if (Cast.isInt(args.FROM) && Cast.isInt(args.TO)) {
      return low + Math.floor(Math.random() * (high + 1 - low));
    }
    return Math.random() * (high - low) + low;
  }
  join(args) {
    return Cast.toString(args.STRING1) + Cast.toString(args.STRING2);
  }
  letterOf(args) {
    const index = Cast.toNumber(args.LETTER) - 1;
    const str = Cast.toString(args.STRING);
    // Out of bounds?
    if (index < 0 || index >= str.length) {
      return '';
    }
    return str.charAt(index);
  }
  length(args) {
    return Cast.toString(args.STRING).length;
  }
  contains(args) {
    const format = function format(string) {
      return Cast.toString(string).toLowerCase();
    };
    return format(args.STRING1).includes(format(args.STRING2));
  }
  mod(args) {
    const n = Cast.toNumber(args.NUM1);
    const modulus = Cast.toNumber(args.NUM2);
    let result = n % modulus;
    // Scratch mod uses floored division instead of truncated division.
    if (result / modulus < 0) result += modulus;
    return result;
  }
  round(args) {
    return Math.round(Cast.toNumber(args.NUM));
  }
  mathop(args) {
    const operator = Cast.toString(args.OPERATOR).toLowerCase();
    const n = Cast.toNumber(args.NUM);
    switch (operator) {
      case 'abs':
        return Math.abs(n);
      case 'floor':
        return Math.floor(n);
      case 'ceiling':
        return Math.ceil(n);
      case 'sqrt':
        return Math.sqrt(n);
      case 'sin':
        return parseFloat(Math.sin(Math.PI * n / 180).toFixed(10));
      case 'cos':
        return parseFloat(Math.cos(Math.PI * n / 180).toFixed(10));
      case 'tan':
        return MathUtil.tan(n);
      case 'asin':
        return Math.asin(n) * 180 / Math.PI;
      case 'acos':
        return Math.acos(n) * 180 / Math.PI;
      case 'atan':
        return Math.atan(n) * 180 / Math.PI;
      case 'ln':
        return Math.log(n);
      case 'log':
        return Math.log(n) / Math.LN10;
      case 'e ^':
        return Math.exp(n);
      case '10 ^':
        return Math.pow(10, n);
    }
    return 0;
  }
}
module.exports = Scratch3OperatorsBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_procedures.js":
/*!*******************************************!*\
  !*** ./src/blocks/scratch3_procedures.js ***!
  \*******************************************/
/***/ ((module) => {

class Scratch3ProcedureBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      procedures_definition: this.definition,
      procedures_call: this.call,
      argument_reporter_string_number: this.argumentReporterStringNumber,
      argument_reporter_boolean: this.argumentReporterBoolean
    };
  }
  definition() {
    // No-op: execute the blocks.
  }
  call(args, util) {
    if (!util.stackFrame.executed) {
      const procedureCode = args.mutation.proccode;
      const paramNamesIdsAndDefaults = util.getProcedureParamNamesIdsAndDefaults(procedureCode);

      // If null, procedure could not be found, which can happen if custom
      // block is dragged between sprites without the definition.
      // Match Scratch 2.0 behavior and noop.
      if (paramNamesIdsAndDefaults === null) {
        return;
      }
      const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;

      // Initialize params for the current stackFrame to {}, even if the procedure does
      // not take any arguments. This is so that `getParam` down the line does not look
      // at earlier stack frames for the values of a given parameter (#1729)
      util.initParams();
      for (let i = 0; i < paramIds.length; i++) {
        if (Object.prototype.hasOwnProperty.call(args, paramIds[i])) {
          util.pushParam(paramNames[i], args[paramIds[i]]);
        } else {
          util.pushParam(paramNames[i], paramDefaults[i]);
        }
      }
      util.stackFrame.executed = true;
      util.startProcedure(procedureCode);
    }
  }
  argumentReporterStringNumber(args, util) {
    const value = util.getParam(args.VALUE);
    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }
    return value;
  }
  argumentReporterBoolean(args, util) {
    const value = util.getParam(args.VALUE);
    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }
    return value;
  }
}
module.exports = Scratch3ProcedureBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_sensing.js":
/*!****************************************!*\
  !*** ./src/blocks/scratch3_sensing.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");
class Scratch3SensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * The "answer" block value.
     * @type {string}
     */
    this._answer = '';

    /**
     * The timer utility.
     * @type {Timer}
     */
    this._timer = new Timer();

    /**
     * The stored microphone loudness measurement.
     * @type {number}
     */
    this._cachedLoudness = -1;

    /**
     * The time of the most recent microphone loudness measurement.
     * @type {number}
     */
    this._cachedLoudnessTimestamp = 0;

    /**
     * The list of queued questions and respective `resolve` callbacks.
     * @type {!Array}
     */
    this._questionList = [];
    this.runtime.on('ANSWER', this._onAnswer.bind(this));
    this.runtime.on('PROJECT_START', this._resetAnswer.bind(this));
    this.runtime.on('PROJECT_STOP_ALL', this._clearAllQuestions.bind(this));
    this.runtime.on('STOP_FOR_TARGET', this._clearTargetQuestions.bind(this));
    this.runtime.on('RUNTIME_DISPOSED', this._resetAnswer.bind(this));
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      sensing_touchingobject: this.touchingObject,
      sensing_touchingcolor: this.touchingColor,
      sensing_coloristouchingcolor: this.colorTouchingColor,
      sensing_distanceto: this.distanceTo,
      sensing_timer: this.getTimer,
      sensing_resettimer: this.resetTimer,
      sensing_of: this.getAttributeOf,
      sensing_mousex: this.getMouseX,
      sensing_mousey: this.getMouseY,
      sensing_setdragmode: this.setDragMode,
      sensing_mousedown: this.getMouseDown,
      sensing_keypressed: this.getKeyPressed,
      sensing_current: this.current,
      sensing_dayssince2000: this.daysSince2000,
      sensing_loudness: this.getLoudness,
      sensing_loud: this.isLoud,
      sensing_askandwait: this.askAndWait,
      sensing_answer: this.getAnswer,
      sensing_username: this.getUsername,
      sensing_userid: () => {} // legacy no-op block
    };
  }
  getMonitored() {
    return {
      sensing_answer: {
        getId: () => 'answer'
      },
      sensing_loudness: {
        getId: () => 'loudness'
      },
      sensing_timer: {
        getId: () => 'timer'
      },
      sensing_current: {
        // This is different from the default toolbox xml id in order to support
        // importing multiple monitors from the same opcode from sb2 files,
        // something that is not currently supported in scratch 3.
        getId: (_, fields) => getMonitorIdForBlockWithArgs('current', fields) // _${param}`
      }
    };
  }
  _onAnswer(answer) {
    this._answer = answer;
    const questionObj = this._questionList.shift();
    if (questionObj) {
      const [_question, resolve, target, wasVisible, wasStage] = questionObj;
      // If the target was visible when asked, hide the say bubble unless the target was the stage.
      if (wasVisible && !wasStage) {
        this.runtime.emit('SAY', target, 'say', '');
      }
      resolve();
      this._askNextQuestion();
    }
  }
  _resetAnswer() {
    this._answer = '';
  }
  _enqueueAsk(question, resolve, target, wasVisible, wasStage) {
    this._questionList.push([question, resolve, target, wasVisible, wasStage]);
  }
  _askNextQuestion() {
    if (this._questionList.length > 0) {
      const [question, _resolve, target, wasVisible, wasStage] = this._questionList[0];
      // If the target is visible, emit a blank question and use the
      // say event to trigger a bubble unless the target was the stage.
      if (wasVisible && !wasStage) {
        this.runtime.emit('SAY', target, 'say', question);
        this.runtime.emit('QUESTION', '');
      } else {
        this.runtime.emit('QUESTION', question);
      }
    }
  }
  _clearAllQuestions() {
    this._questionList = [];
    this.runtime.emit('QUESTION', null);
  }
  _clearTargetQuestions(stopTarget) {
    const currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;
    this._questionList = this._questionList.filter(question => question[2] !== stopTarget);
    if (currentlyAsking) {
      this.runtime.emit('SAY', stopTarget, 'say', '');
      if (this._questionList.length > 0) {
        this._askNextQuestion();
      } else {
        this.runtime.emit('QUESTION', null);
      }
    }
  }
  askAndWait(args, util) {
    const _target = util.target;
    return new Promise(resolve => {
      const isQuestionAsked = this._questionList.length > 0;
      this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);
      if (!isQuestionAsked) {
        this._askNextQuestion();
      }
    });
  }
  getAnswer() {
    return this._answer;
  }
  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }
  touchingColor(args, util) {
    const color = Cast.toRgbColorList(args.COLOR);
    return util.target.isTouchingColor(color);
  }
  colorTouchingColor(args, util) {
    const maskColor = Cast.toRgbColorList(args.COLOR);
    const targetColor = Cast.toRgbColorList(args.COLOR2);
    return util.target.colorIsTouchingColor(targetColor, maskColor);
  }
  distanceTo(args, util) {
    if (util.target.isStage) return 10000;
    let targetX = 0;
    let targetY = 0;
    if (args.DISTANCETOMENU === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else {
      args.DISTANCETOMENU = Cast.toString(args.DISTANCETOMENU);
      const distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);
      if (!distTarget) return 10000;
      targetX = distTarget.x;
      targetY = distTarget.y;
    }
    const dx = util.target.x - targetX;
    const dy = util.target.y - targetY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  setDragMode(args, util) {
    util.target.setDraggable(args.DRAG_MODE === 'draggable');
  }
  getTimer(args, util) {
    return util.ioQuery('clock', 'projectTimer');
  }
  resetTimer(args, util) {
    util.ioQuery('clock', 'resetProjectTimer');
  }
  getMouseX(args, util) {
    return util.ioQuery('mouse', 'getScratchX');
  }
  getMouseY(args, util) {
    return util.ioQuery('mouse', 'getScratchY');
  }
  getMouseDown(args, util) {
    return util.ioQuery('mouse', 'getIsDown');
  }
  current(args) {
    const menuOption = Cast.toString(args.CURRENTMENU).toLowerCase();
    const date = new Date();
    switch (menuOption) {
      case 'year':
        return date.getFullYear();
      case 'month':
        return date.getMonth() + 1;
      // getMonth is zero-based
      case 'date':
        return date.getDate();
      case 'dayofweek':
        return date.getDay() + 1;
      // getDay is zero-based, Sun=0
      case 'hour':
        return date.getHours();
      case 'minute':
        return date.getMinutes();
      case 'second':
        return date.getSeconds();
    }
    return 0;
  }
  getKeyPressed(args, util) {
    return util.ioQuery('keyboard', 'getKeyIsDown', [args.KEY_OPTION]);
  }
  daysSince2000() {
    const msPerDay = 24 * 60 * 60 * 1000;
    const start = new Date(2000, 0, 1); // Months are 0-indexed.
    const today = new Date();
    const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
    let mSecsSinceStart = today.valueOf() - start.valueOf();
    mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
    return mSecsSinceStart / msPerDay;
  }
  getLoudness() {
    if (typeof this.runtime.audioEngine === 'undefined') return -1;
    if (this.runtime.currentStepTime === null) return -1;

    // Only measure loudness once per step
    const timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;
    if (timeSinceLoudness < this.runtime.currentStepTime) {
      return this._cachedLoudness;
    }
    this._cachedLoudnessTimestamp = this._timer.time();
    this._cachedLoudness = this.runtime.audioEngine.getLoudness();
    return this._cachedLoudness;
  }
  isLoud() {
    return this.getLoudness() > 10;
  }
  getAttributeOf(args) {
    let attrTarget;
    if (args.OBJECT === '_stage_') {
      attrTarget = this.runtime.getTargetForStage();
    } else {
      args.OBJECT = Cast.toString(args.OBJECT);
      attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);
    }

    // attrTarget can be undefined if the target does not exist
    // (e.g. single sprite uploaded from larger project referencing
    // another sprite that wasn't uploaded)
    if (!attrTarget) return 0;

    // Generic attributes
    if (attrTarget.isStage) {
      switch (args.PROPERTY) {
        // Scratch 1.4 support
        case 'background #':
          return attrTarget.currentCostume + 1;
        case 'backdrop #':
          return attrTarget.currentCostume + 1;
        case 'backdrop name':
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;
        case 'volume':
          return attrTarget.volume;
      }
    } else {
      switch (args.PROPERTY) {
        case 'x position':
          return attrTarget.x;
        case 'y position':
          return attrTarget.y;
        case 'direction':
          return attrTarget.direction;
        case 'costume #':
          return attrTarget.currentCostume + 1;
        case 'costume name':
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;
        case 'size':
          return attrTarget.size;
        case 'volume':
          return attrTarget.volume;
      }
    }

    // Target variables.
    const varName = args.PROPERTY;
    const variable = attrTarget.lookupVariableByNameAndType(varName, '', true);
    if (variable) {
      return variable.value;
    }

    // Otherwise, 0
    return 0;
  }
  getUsername(args, util) {
    return util.ioQuery('userData', 'getUsername');
  }
}
module.exports = Scratch3SensingBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_sound.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_sound.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");

/**
 * Occluded boolean value to make its use more understandable.
 * @const {boolean}
 */
const STORE_WAITING = true;
class Scratch3SoundBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.waitingSounds = {};

    // Clear sound effects on green flag and stop button events.
    this.stopAllSounds = this.stopAllSounds.bind(this);
    this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);
    this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);
    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this.stopAllSounds);
      this.runtime.on('PROJECT_STOP_ALL', this._clearEffectsForAllTargets);
      this.runtime.on('STOP_FOR_TARGET', this._stopWaitingSoundsForTarget);
      this.runtime.on('PROJECT_START', this._clearEffectsForAllTargets);
    }
    this._onTargetCreated = this._onTargetCreated.bind(this);
    if (this.runtime) {
      runtime.on('targetWasCreated', this._onTargetCreated);
    }
  }

  /**
   * The key to load & store a target's sound-related state.
   * @type {string}
   */
  static get STATE_KEY() {
    return 'Scratch.sound';
  }

  /**
   * The default sound-related state, to be used when a target has no existing sound state.
   * @type {SoundState}
   */
  static get DEFAULT_SOUND_STATE() {
    return {
      effects: {
        pitch: 0,
        pan: 0
      }
    };
  }

  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */
  static get MIDI_NOTE_RANGE() {
    return {
      min: 36,
      max: 96
    }; // C2 to C7
  }

  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */
  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }

  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */
  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }

  /** The minimum and maximum values for each sound effect.
   * @type {{effect:{min: number, max: number}}}
   */
  static get EFFECT_RANGE() {
    return {
      pitch: {
        min: -360,
        max: 360
      },
      // -3 to 3 octaves
      pan: {
        min: -100,
        max: 100
      } // 100% left to 100% right
    };
  }

  /**
   * @param {Target} target - collect sound state for this target.
   * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
   * @private
   */
  _getSoundState(target) {
    let soundState = target.getCustomState(Scratch3SoundBlocks.STATE_KEY);
    if (!soundState) {
      soundState = Clone.simple(Scratch3SoundBlocks.DEFAULT_SOUND_STATE);
      target.setCustomState(Scratch3SoundBlocks.STATE_KEY, soundState);
      target.soundEffects = soundState.effects;
    }
    return soundState;
  }

  /**
   * When a Target is cloned, clone the sound state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */
  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const soundState = sourceTarget.getCustomState(Scratch3SoundBlocks.STATE_KEY);
      if (soundState && newTarget) {
        newTarget.setCustomState(Scratch3SoundBlocks.STATE_KEY, Clone.simple(soundState));
        this._syncEffectsForTarget(newTarget);
      }
    }
  }

  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */
  getPrimitives() {
    return {
      sound_play: this.playSound,
      sound_playuntildone: this.playSoundAndWait,
      sound_stopallsounds: this.stopAllSounds,
      sound_seteffectto: this.setEffect,
      sound_changeeffectby: this.changeEffect,
      sound_cleareffects: this.clearEffects,
      sound_sounds_menu: this.soundsMenu,
      sound_beats_menu: this.beatsMenu,
      sound_effects_menu: this.effectsMenu,
      sound_setvolumeto: this.setVolume,
      sound_changevolumeby: this.changeVolume,
      sound_volume: this.getVolume
    };
  }
  getMonitored() {
    return {
      sound_volume: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_volume")
      }
    };
  }
  playSound(args, util) {
    // Don't return the promise, it's the only difference for AndWait
    this._playSound(args, util);
  }
  playSoundAndWait(args, util) {
    return this._playSound(args, util, STORE_WAITING);
  }
  _playSound(args, util, storeWaiting) {
    const index = this._getSoundIndex(args.SOUND_MENU, util);
    if (index >= 0) {
      const {
        target
      } = util;
      const {
        sprite
      } = target;
      const {
        soundId
      } = sprite.sounds[index];
      if (sprite.soundBank) {
        if (storeWaiting === STORE_WAITING) {
          this._addWaitingSound(target.id, soundId);
        } else {
          this._removeWaitingSound(target.id, soundId);
        }
        return sprite.soundBank.playSound(target, soundId);
      }
    }
  }
  _addWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      this.waitingSounds[targetId] = new Set();
    }
    this.waitingSounds[targetId].add(soundId);
  }
  _removeWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      return;
    }
    this.waitingSounds[targetId].delete(soundId);
  }
  _getSoundIndex(soundName, util) {
    // if the sprite has no sounds, return -1
    const len = util.target.sprite.sounds.length;
    if (len === 0) {
      return -1;
    }

    // look up by name first
    const index = this.getSoundIndexByName(soundName, util);
    if (index !== -1) {
      return index;
    }

    // then try using the sound name as a 1-indexed index
    const oneIndexedIndex = parseInt(soundName, 10);
    if (!isNaN(oneIndexedIndex)) {
      return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
    }

    // could not be found as a name or converted to index, return -1
    return -1;
  }
  getSoundIndexByName(soundName, util) {
    const sounds = util.target.sprite.sounds;
    for (let i = 0; i < sounds.length; i++) {
      if (sounds[i].name === soundName) {
        return i;
      }
    }
    // if there is no sound by that name, return -1
    return -1;
  }
  stopAllSounds() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;
    for (let i = 0; i < allTargets.length; i++) {
      this._stopAllSoundsForTarget(allTargets[i]);
    }
  }
  _stopAllSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      target.sprite.soundBank.stopAllSounds(target);
      if (this.waitingSounds[target.id]) {
        this.waitingSounds[target.id].clear();
      }
    }
  }
  _stopWaitingSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      if (this.waitingSounds[target.id]) {
        for (const soundId of this.waitingSounds[target.id].values()) {
          target.sprite.soundBank.stop(target, soundId);
        }
        this.waitingSounds[target.id].clear();
      }
    }
  }
  setEffect(args, util) {
    return this._updateEffect(args, util, false);
  }
  changeEffect(args, util) {
    return this._updateEffect(args, util, true);
  }
  _updateEffect(args, util, change) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    const value = Cast.toNumber(args.VALUE);
    const soundState = this._getSoundState(util.target);
    if (!Object.prototype.hasOwnProperty.call(soundState.effects, effect)) return;
    if (change) {
      soundState.effects[effect] += value;
    } else {
      soundState.effects[effect] = value;
    }
    const {
      min,
      max
    } = Scratch3SoundBlocks.EFFECT_RANGE[effect];
    soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], min, max);
    this._syncEffectsForTarget(util.target);
    // Yield until the next tick.
    return Promise.resolve();
  }
  _syncEffectsForTarget(target) {
    if (!target || !target.sprite.soundBank) return;
    target.soundEffects = this._getSoundState(target).effects;
    target.sprite.soundBank.setEffects(target);
  }
  clearEffects(args, util) {
    this._clearEffectsForTarget(util.target);
  }
  _clearEffectsForTarget(target) {
    const soundState = this._getSoundState(target);
    for (const effect in soundState.effects) {
      if (!Object.prototype.hasOwnProperty.call(soundState.effects, effect)) continue;
      soundState.effects[effect] = 0;
    }
    this._syncEffectsForTarget(target);
  }
  _clearEffectsForAllTargets() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;
    for (let i = 0; i < allTargets.length; i++) {
      this._clearEffectsForTarget(allTargets[i]);
    }
  }
  setVolume(args, util) {
    const volume = Cast.toNumber(args.VOLUME);
    return this._updateVolume(volume, util);
  }
  changeVolume(args, util) {
    const volume = Cast.toNumber(args.VOLUME) + util.target.volume;
    return this._updateVolume(volume, util);
  }
  _updateVolume(volume, util) {
    volume = MathUtil.clamp(volume, 0, 100);
    util.target.volume = volume;
    this._syncEffectsForTarget(util.target);

    // Yield until the next tick.
    return Promise.resolve();
  }
  getVolume(args, util) {
    return util.target.volume;
  }
  soundsMenu(args) {
    return args.SOUND_MENU;
  }
  beatsMenu(args) {
    return args.BEATS;
  }
  effectsMenu(args) {
    return args.EFFECT;
  }
}
module.exports = Scratch3SoundBlocks;

/***/ }),

/***/ "./src/dispatch/central-dispatch.js":
/*!******************************************!*\
  !*** ./src/dispatch/central-dispatch.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ "./src/dispatch/shared-dispatch.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

/**
 * This class serves as the central broker for message dispatch. It expects to operate on the main thread / Window and
 * it must be informed of any Worker threads which will participate in the messaging system. From any context in the
 * messaging system, the dispatcher's "call" method can call any method on any "service" provided in any participating
 * context. The dispatch system will forward function arguments and return values across worker boundaries as needed.
 * @see {WorkerDispatch}
 */
class CentralDispatch extends SharedDispatch {
  constructor() {
    super();

    /**
     * Map of channel name to worker or local service provider.
     * If the entry is a Worker, the service is provided by an object on that worker.
     * Otherwise, the service is provided locally and methods on the service will be called directly.
     * @see {setService}
     * @type {object.<Worker|object>}
     */
    this.services = {};

    /**
     * The constructor we will use to recognize workers.
     * @type {Function}
     */
    this.workerClass = typeof Worker === 'undefined' ? null : Worker;

    /**
     * List of workers attached to this dispatcher.
     * @type {Array}
     */
    this.workers = [];
  }

  /**
   * Synchronously call a particular method on a particular service provided locally.
   * Calling this function on a remote service will fail.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {*} - the return value of the service method.
   */
  callSync(service, method) {
    const {
      provider,
      isRemote
    } = this._getServiceProvider(service);
    if (provider) {
      if (isRemote) {
        throw new Error("Cannot use 'callSync' on remote provider for service ".concat(service, "."));
      }

      // TODO: verify correct `this` after switching from apply to spread
      // eslint-disable-next-line prefer-spread
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return provider[method].apply(provider, args);
    }
    throw new Error("Provider not found for service: ".concat(service));
  }

  /**
   * Synchronously set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   */
  setServiceSync(service, provider) {
    if (Object.prototype.hasOwnProperty.call(this.services, service)) {
      log.warn("Central dispatch replacing existing service provider for ".concat(service));
    }
    this.services[service] = provider;
  }

  /**
   * Set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   * @returns {Promise} - a promise which will resolve once the service is registered.
   */
  setService(service, provider) {
    /** Return a promise for consistency with {@link WorkerDispatch#setService} */
    try {
      this.setServiceSync(service, provider);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }

  /**
   * Add a worker to the message dispatch system. The worker must implement a compatible message dispatch framework.
   * The dispatcher will immediately attempt to "handshake" with the worker.
   * @param {Worker} worker - the worker to add into the dispatch system.
   */
  addWorker(worker) {
    if (this.workers.indexOf(worker) === -1) {
      this.workers.push(worker);
      worker.onmessage = this._onMessage.bind(this, worker);
      this._remoteCall(worker, 'dispatch', 'handshake').catch(e => {
        log.error("Could not handshake with worker: ".concat(JSON.stringify(e)));
      });
    } else {
      log.warn('Central dispatch ignoring attempt to add duplicate worker');
    }
  }

  /**
   * Fetch the service provider object for a particular service name.
   * @override
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */
  _getServiceProvider(service) {
    const provider = this.services[service];
    return provider && {
      provider,
      isRemote: Boolean(this.workerClass && provider instanceof this.workerClass)
    };
  }

  /**
   * Handle a call message sent to the dispatch service itself
   * @override
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @protected
   */
  _onDispatchMessage(worker, message) {
    let promise;
    switch (message.method) {
      case 'setService':
        promise = this.setService(message.args[0], worker);
        break;
      default:
        log.error("Central dispatch received message for unknown method: ".concat(message.method));
    }
    return promise;
  }
}
module.exports = new CentralDispatch();

/***/ }),

/***/ "./src/dispatch/shared-dispatch.js":
/*!*****************************************!*\
  !*** ./src/dispatch/shared-dispatch.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

/**
 * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call
 * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}
 * @property {string} service - the name of the service to be called
 * @property {string} method - the name of the method to be called
 * @property {Array|undefined} args - the arguments to be passed to the method
 */

/**
 * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call
 * @property {*} responseId - a copy of the response ID from the call which generated this response
 * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)
 * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)
 */

/**
 * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage
 * Any message to the dispatch system.
 */

/**
 * The SharedDispatch class is responsible for dispatch features shared by
 * {@link CentralDispatch} and {@link WorkerDispatch}.
 */
class SharedDispatch {
  constructor() {
    /**
     * List of callback registrations for promises waiting for a response from a call to a service on another
     * worker. A callback registration is an array of [resolve,reject] Promise functions.
     * Calls to local services don't enter this list.
     * @type {Array.<Function[]>}
     */
    this.callbacks = [];

    /**
     * The next response ID to be used.
     * @type {int}
     */
    this.nextResponseId = 0;
  }

  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.call('vm', 'setData', 'cat', 42);
   *      // this finds the worker for the 'vm' service, then on that worker calls:
   *      vm.setData('cat', 42);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */
  call(service, method) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return this.transferCall(service, method, null, ...args);
  }

  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);
   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:
   *      vm.setData('cat', myArrayBuffer);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */
  transferCall(service, method, transfer) {
    try {
      const {
        provider,
        isRemote
      } = this._getServiceProvider(service);
      if (provider) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          args[_key2 - 3] = arguments[_key2];
        }
        if (isRemote) {
          return this._remoteTransferCall(provider, service, method, transfer, ...args);
        }

        // TODO: verify correct `this` after switching from apply to spread
        // eslint-disable-next-line prefer-spread
        const result = provider[method].apply(provider, args);
        return Promise.resolve(result);
      }
      return Promise.reject(new Error("Service not found: ".concat(service)));
    } catch (e) {
      return Promise.reject(e);
    }
  }

  /**
   * Check if a particular service lives on another worker.
   * @param {string} service - the service to check.
   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.
   * @private
   */
  _isRemoteService(service) {
    return this._getServiceProvider(service).isRemote;
  }

  /**
   * Like {@link call}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */
  _remoteCall(provider, service, method) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
      args[_key3 - 3] = arguments[_key3];
    }
    return this._remoteTransferCall(provider, service, method, null, ...args);
  }

  /**
   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */
  _remoteTransferCall(provider, service, method, transfer) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {
      args[_key4 - 4] = arguments[_key4];
    }
    return new Promise((resolve, reject) => {
      const responseId = this._storeCallbacks(resolve, reject);

      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */
      if (args.length > 0 && typeof args[args.length - 1].yield === 'function') {
        args.pop();
      }
      if (transfer) {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        }, transfer);
      } else {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        });
      }
    });
  }

  /**
   * Store callback functions pending a response message.
   * @param {Function} resolve - function to call if the service method returns.
   * @param {Function} reject - function to call if the service method throws.
   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.
   * @protected
   */
  _storeCallbacks(resolve, reject) {
    const responseId = this.nextResponseId++;
    this.callbacks[responseId] = [resolve, reject];
    return responseId;
  }

  /**
   * Deliver call response from a worker. This should only be called as the result of a message from a worker.
   * @param {int} responseId - the response ID of the callback set to call.
   * @param {DispatchResponseMessage} message - the message containing the response value(s).
   * @protected
   */
  _deliverResponse(responseId, message) {
    try {
      const [resolve, reject] = this.callbacks[responseId];
      delete this.callbacks[responseId];
      if (message.error) {
        reject(message.error);
      } else {
        resolve(message.result);
      }
    } catch (e) {
      log.error("Dispatch callback failed: ".concat(JSON.stringify(e)));
    }
  }

  /**
   * Handle a message event received from a connected worker.
   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.
   * @param {MessageEvent} event - the message event to be handled.
   * @protected
   */
  _onMessage(worker, event) {
    /** @type {DispatchMessage} */
    const message = event.data;
    message.args = message.args || [];
    let promise;
    if (message.service) {
      if (message.service === 'dispatch') {
        promise = this._onDispatchMessage(worker, message);
      } else {
        promise = this.call(message.service, message.method, ...message.args);
      }
    } else if (typeof message.responseId === 'undefined') {
      log.error("Dispatch caught malformed message from a worker: ".concat(JSON.stringify(event)));
    } else {
      this._deliverResponse(message.responseId, message);
    }
    if (promise) {
      if (typeof message.responseId === 'undefined') {
        log.error("Dispatch message missing required response ID: ".concat(JSON.stringify(event)));
      } else {
        promise.then(result => worker.postMessage({
          responseId: message.responseId,
          result
        }), error => worker.postMessage({
          responseId: message.responseId,
          error
        }));
      }
    }
  }

  /**
   * Fetch the service provider object for a particular service name.
   * @abstract
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */
  _getServiceProvider(service) {
    throw new Error("Could not get provider for ".concat(service, ": _getServiceProvider not implemented"));
  }

  /**
   * Handle a call message sent to the dispatch service itself
   * @abstract
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @private
   */
  _onDispatchMessage(worker, message) {
    throw new Error("Unimplemented dispatch message handler cannot handle ".concat(message.method, " method"));
  }
}
module.exports = SharedDispatch;

/***/ }),

/***/ "./src/engine/adapter.js":
/*!*******************************!*\
  !*** ./src/engine/adapter.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");
const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @return {undefined}
 */
const domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {
  if (!blockDOM.attribs.id) {
    blockDOM.attribs.id = uid();
  }

  // Block skeleton.
  const block = {
    id: blockDOM.attribs.id,
    // Block ID
    opcode: blockDOM.attribs.type,
    // For execution, "event_whengreenflag".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block in the stack, if one exists.
    topLevel: isTopBlock,
    // If this block starts a stack.
    parent: parent,
    // Parent block ID, if available.
    shadow: blockDOM.name === 'shadow',
    // If this represents a shadow/slot.
    x: blockDOM.attribs.x,
    // X position of script, if top-level.
    y: blockDOM.attribs.y // Y position of script, if top-level.
  };

  // Add the block to the representation tree.
  blocks[block.id] = block;

  // Process XML children and find enclosed blocks, fields, etc.
  for (let i = 0; i < blockDOM.children.length; i++) {
    const xmlChild = blockDOM.children[i];
    // Enclosed blocks and shadows
    let childBlockNode = null;
    let childShadowNode = null;
    for (let j = 0; j < xmlChild.children.length; j++) {
      const grandChildNode = xmlChild.children[j];
      if (!grandChildNode.name) {
        // Non-XML tag node.
        continue;
      }
      const grandChildNodeName = grandChildNode.name.toLowerCase();
      if (grandChildNodeName === 'block') {
        childBlockNode = grandChildNode;
      } else if (grandChildNodeName === 'shadow') {
        childShadowNode = grandChildNode;
      }
    }

    // Use shadow block only if there's no real block node.
    if (!childBlockNode && childShadowNode) {
      childBlockNode = childShadowNode;
    }

    // Not all Blockly-type blocks are handled here,
    // as we won't be using all of them for Scratch.
    switch (xmlChild.name.toLowerCase()) {
      case 'field':
        {
          // Add the field to this block.
          const fieldName = xmlChild.attribs.name;
          // Add id in case it is a variable field
          const fieldId = xmlChild.attribs.id;
          let fieldData = '';
          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
            fieldData = xmlChild.children[0].data;
          } else {
            // If the child of the field with a data property
            // doesn't exist, set the data to an empty string.
            fieldData = '';
          }
          block.fields[fieldName] = {
            name: fieldName,
            id: fieldId,
            value: fieldData
          };
          const fieldVarType = xmlChild.attribs.variabletype;
          if (typeof fieldVarType === 'string') {
            block.fields[fieldName].variableType = fieldVarType;
          }
          break;
        }
      case 'comment':
        {
          block.comment = xmlChild.attribs.id;
          break;
        }
      case 'value':
      case 'statement':
        {
          // Recursively generate block structure for input block.
          domToBlock(childBlockNode, blocks, false, block.id);
          if (childShadowNode && childBlockNode !== childShadowNode) {
            // Also generate the shadow block.
            domToBlock(childShadowNode, blocks, false, block.id);
          }
          // Link this block's input to the child block.
          const inputName = xmlChild.attribs.name;
          block.inputs[inputName] = {
            name: inputName,
            block: childBlockNode.attribs.id,
            shadow: childShadowNode ? childShadowNode.attribs.id : null
          };
          break;
        }
      case 'next':
        {
          if (!childBlockNode || !childBlockNode.attribs) {
            // Invalid child block.
            continue;
          }
          // Recursively generate block structure for next block.
          domToBlock(childBlockNode, blocks, false, block.id);
          // Link next block to this block.
          block.next = childBlockNode.attribs.id;
          break;
        }
      case 'mutation':
        {
          block.mutation = mutationAdapter(xmlChild);
          break;
        }
    }
  }
};

/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @return {Array.<object>} Usable list of blocks from this CREATE event.
 */
const domToBlocks = function domToBlocks(blocksDOM) {
  // At this level, there could be multiple blocks adjacent in the DOM tree.
  const blocks = {};
  for (let i = 0; i < blocksDOM.length; i++) {
    const block = blocksDOM[i];
    if (!block.name || !block.attribs) {
      continue;
    }
    const tagName = block.name.toLowerCase();
    if (tagName === 'block' || tagName === 'shadow') {
      domToBlock(block, blocks, true, null);
    }
  }
  // Flatten blocks object into a list.
  const blocksList = [];
  for (const b in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, b)) continue;
    blocksList.push(blocks[b]);
  }
  return blocksList;
};

/**
 * Adapter between block creation events and block representation which can be
 * used by the Scratch runtime.
 * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`
 * @return {Array.<object>} List of blocks from this CREATE event.
 */
const adapter = function adapter(e) {
  // Validate input
  if (typeof e !== 'object') return;
  if (typeof e.xml !== 'object') return;
  return domToBlocks(html.parseDOM(e.xml.outerHTML, {
    decodeEntities: true
  }));
};
module.exports = adapter;

/***/ }),

/***/ "./src/engine/block-utility.js":
/*!*************************************!*\
  !*** ./src/engine/block-utility.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");
const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

/**
 * @fileoverview
 * Interface provided to block primitive functions for interacting with the
 * runtime, thread, target, and convenient methods.
 */

class BlockUtility {
  constructor() {
    let sequencer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let thread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    /**
     * A sequencer block primitives use to branch or start procedures with
     * @type {?Sequencer}
     */
    this.sequencer = sequencer;

    /**
     * The block primitives thread with the block's target, stackFrame and
     * modifiable status.
     * @type {?Thread}
     */
    this.thread = thread;
    this._nowObj = {
      now: () => this.sequencer.runtime.currentMSecs
    };
  }

  /**
   * The target the primitive is working on.
   * @type {Target}
   */
  get target() {
    return this.thread.target;
  }

  /**
   * The runtime the block primitive is running in.
   * @type {Runtime}
   */
  get runtime() {
    return this.sequencer.runtime;
  }

  /**
   * Use the runtime's currentMSecs value as a timestamp value for now
   * This is useful in some cases where we need compatibility with Scratch 2
   * @type {function}
   */
  get nowObj() {
    if (this.runtime) {
      return this._nowObj;
    }
    return null;
  }

  /**
   * The stack frame used by loop and other blocks to track internal state.
   * @type {object}
   */
  get stackFrame() {
    const frame = this.thread.peekStackFrame();
    if (frame.executionContext === null) {
      frame.executionContext = {};
    }
    return frame.executionContext;
  }

  /**
   * Check the stack timer and return a boolean based on whether it has finished or not.
   * @return {boolean} - true if the stack timer has finished.
   */
  stackTimerFinished() {
    const timeElapsed = this.stackFrame.timer.timeElapsed();
    if (timeElapsed < this.stackFrame.duration) {
      return false;
    }
    return true;
  }

  /**
   * Check if the stack timer needs initialization.
   * @return {boolean} - true if the stack timer needs to be initialized.
   */
  stackTimerNeedsInit() {
    return !this.stackFrame.timer;
  }

  /**
   * Create and start a stack timer
   * @param {number} duration - a duration in milliseconds to set the timer for.
   */
  startStackTimer(duration) {
    if (this.nowObj) {
      this.stackFrame.timer = new Timer(this.nowObj);
    } else {
      this.stackFrame.timer = new Timer();
    }
    this.stackFrame.timer.start();
    this.stackFrame.duration = duration;
  }

  /**
   * Set the thread to yield.
   */
  yield() {
    this.thread.status = Thread.STATUS_YIELD;
  }

  /**
   * Set the thread to yield until the next tick of the runtime.
   */
  yieldTick() {
    this.thread.status = Thread.STATUS_YIELD_TICK;
  }

  /**
   * Start a branch in the current block.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */
  startBranch(branchNum, isLoop) {
    this.sequencer.stepToBranch(this.thread, branchNum, isLoop);
  }

  /**
   * Stop all threads.
   */
  stopAll() {
    this.sequencer.runtime.stopAll();
  }

  /**
   * Stop threads other on this target other than the thread holding the
   * executed block.
   */
  stopOtherTargetThreads() {
    this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);
  }

  /**
   * Stop this thread.
   */
  stopThisScript() {
    this.thread.stopThisScript();
  }

  /**
   * Start a specified procedure on this thread.
   * @param {string} procedureCode Procedure code for procedure to start.
   */
  startProcedure(procedureCode) {
    this.sequencer.stepToProcedure(this.thread, procedureCode);
  }

  /**
   * Get names and ids of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */
  getProcedureParamNamesAndIds(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);
  }

  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */
  getProcedureParamNamesIdsAndDefaults(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
  }

  /**
   * Initialize procedure parameters in the thread before pushing parameters.
   */
  initParams() {
    this.thread.initParams();
  }

  /**
   * Store a procedure parameter value by its name.
   * @param {string} paramName The procedure's parameter name.
   * @param {*} paramValue The procedure's parameter value.
   */
  pushParam(paramName, paramValue) {
    this.thread.pushParam(paramName, paramValue);
  }

  /**
   * Retrieve the stored parameter value for a given parameter name.
   * @param {string} paramName The procedure's parameter name.
   * @return {*} The parameter's current stored value.
   */
  getParam(paramName) {
    return this.thread.getParam(paramName);
  }

  /**
   * Start all relevant hats.
   * @param {!string} requestedHat Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */
  startHats(requestedHat, optMatchFields, optTarget) {
    // Store thread and sequencer to ensure we can return to the calling block's context.
    // startHats may execute further blocks and dirty the BlockUtility's execution context
    // and confuse the calling block when we return to it.
    const callerThread = this.thread;
    const callerSequencer = this.sequencer;
    const result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget);

    // Restore thread and sequencer to prior values before we return to the calling block.
    this.thread = callerThread;
    this.sequencer = callerSequencer;
    return result;
  }

  /**
   * Query a named IO device.
   * @param {string} device The name of like the device, like keyboard.
   * @param {string} func The name of the device's function to query.
   * @param {Array.<*>} args Arguments to pass to the device's function.
   * @return {*} The expected output for the device's function.
   */
  ioQuery(device, func, args) {
    // Find the I/O device and execute the query/function call.
    if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {
      const devObject = this.sequencer.runtime.ioDevices[device];
      // TODO: verify correct `this` after switching from apply to spread
      // eslint-disable-next-line prefer-spread
      return devObject[func].apply(devObject, args);
    }
  }
}
module.exports = BlockUtility;

/***/ }),

/***/ "./src/engine/blocks-execute-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-execute-cache.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @fileoverview
 * Access point for private method shared between blocks.js and execute.js for
 * caching execute information.
 */

/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 */
exports.getCached = function () {
  throw new Error('blocks.js has not initialized BlocksExecuteCache');
};

// Call after the default throwing getCached is assigned for Blocks to replace.
__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks-runtime-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-runtime-cache.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @fileoverview
 * The BlocksRuntimeCache caches data about the top block of scripts so that
 * Runtime can iterate a targeted opcode and iterate the returned set faster.
 * Many top blocks need to match fields as well as opcode, since that matching
 * compares strings in uppercase we can go ahead and uppercase the cached value
 * so we don't need to in the future.
 */

/**
 * A set of cached data about the top block of a script.
 * @param {Blocks} container - Container holding the block and related data
 * @param {string} blockId - Id for whose block data is cached in this instance
 */
class RuntimeScriptCache {
  constructor(container, blockId) {
    /**
     * Container with block data for blockId.
     * @type {Blocks}
     */
    this.container = container;

    /**
     * ID for block this instance caches.
     * @type {string}
     */
    this.blockId = blockId;
    const block = container.getBlock(blockId);
    const fields = container.getFields(block);

    /**
     * Formatted fields or fields of input blocks ready for comparison in
     * runtime.
     *
     * This is a clone of parts of the targeted blocks. Changes to these
     * clones are limited to copies under RuntimeScriptCache and will not
     * appear in the original blocks in their container. This copy is
     * modified changing the case of strings to uppercase. These uppercase
     * values will be compared later by the VM.
     * @type {object}
     */
    this.fieldsOfInputs = Object.assign({}, fields);
    if (Object.keys(fields).length === 0) {
      const inputs = container.getInputs(block);
      for (const input in inputs) {
        if (!Object.prototype.hasOwnProperty.call(inputs, input)) continue;
        const id = inputs[input].block;
        const inputBlock = container.getBlock(id);
        const inputFields = container.getFields(inputBlock);
        Object.assign(this.fieldsOfInputs, inputFields);
      }
    }
    for (const key in this.fieldsOfInputs) {
      const field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);
      if (field.value.toUpperCase) {
        field.value = field.value.toUpperCase();
      }
    }
  }
}

/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} container - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 */
exports.getScripts = function () {
  throw new Error('blocks.js has not initialized BlocksRuntimeCache');
};

/**
 * Exposed RuntimeScriptCache class used by integration in blocks.js.
 * @private
 */
exports._RuntimeScriptCache = RuntimeScriptCache;
__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks.js":
/*!******************************!*\
  !*** ./src/engine/blocks.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const adapter = __webpack_require__(/*! ./adapter */ "./src/engine/adapter.js");
const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");
const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");
const MonitorRecord = __webpack_require__(/*! ./monitor-record */ "./src/engine/monitor-record.js");
const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");
const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");
const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");
const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");

/**
 * @fileoverview
 * Store and mutate the VM block representation,
 * and handle updates from Scratch Blocks events.
 */

/**
 * Create a block container.
 * @param {Runtime} runtime The runtime this block container operates within
 * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container
 * should not request glows. This does not affect glows when clicking on a block to execute it.
 */
class Blocks {
  constructor(runtime, optNoGlow) {
    this.runtime = runtime;

    /**
     * All blocks in the workspace.
     * Keys are block IDs, values are metadata about the block.
     * @type {Object.<string, Object>}
     */
    this._blocks = {};

    /**
     * All top-level scripts in the workspace.
     * A list of block IDs that represent scripts (i.e., first block in script).
     * @type {Array.<String>}
     */
    this._scripts = [];

    /**
     * Runtime Cache
     * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
     * @private
     */
    Object.defineProperty(this, '_cache', {
      writable: true,
      enumerable: false
    });
    this._cache = {
      /**
       * Cache block inputs by block id
       * @type {object.<string, !Array.<object>>}
       */
      inputs: {},
      /**
       * Cache procedure Param Names by block id
       * @type {object.<string, ?Array.<string>>}
       */
      procedureParamNames: {},
      /**
       * Cache procedure definitions by block id
       * @type {object.<string, ?string>}
       */
      procedureDefinitions: {},
      /**
       * A cache for execute to use and store on. Only available to
       * execute.
       * @type {object.<string, object>}
       */
      _executeCached: {},
      /**
       * A cache of block IDs and targets to start threads on as they are
       * actively monitored.
       * @type {Array<{blockId: string, target: Target}>}
       */
      _monitored: null,
      /**
       * A cache of hat opcodes to collection of theads to execute.
       * @type {object.<string, object>}
       */
      scripts: {}
    };

    /**
     * Flag which indicates that blocks in this container should not glow.
     * Blocks will still glow when clicked on, but this flag is used to control
     * whether the blocks in this container can request a glow as part of
     * a running stack. E.g. the flyout block container and the monitor block container
     * should not be able to request a glow, but blocks containers belonging to
     * sprites should.
     * @type {boolean}
     */
    this.forceNoGlow = optNoGlow || false;
  }

  /**
   * Blockly inputs that represent statements/branch.
   * are prefixed with this string.
   * @const{string}
   */
  static get BRANCH_INPUT_PREFIX() {
    return 'SUBSTACK';
  }

  /**
   * Provide an object with metadata for the requested block ID.
   * @param {!string} blockId ID of block we have stored.
   * @return {?object} Metadata about the block, if it exists.
   */
  getBlock(blockId) {
    return this._blocks[blockId];
  }

  /**
   * Get all known top-level blocks that start scripts.
   * @return {Array.<string>} List of block IDs.
   */
  getScripts() {
    return this._scripts;
  }

  /**
    * Get the next block for a particular block
    * @param {?string} id ID of block to get the next block for
    * @return {?string} ID of next block in the sequence
    */
  getNextBlock(id) {
    const block = this._blocks[id];
    return typeof block === 'undefined' ? null : block.next;
  }

  /**
   * Get the branch for a particular C-shaped block.
   * @param {?string} id ID for block to get the branch for.
   * @param {?number} branchNum Which branch to select (e.g. for if-else).
   * @return {?string} ID of block in the branch.
   */
  getBranch(id, branchNum) {
    const block = this._blocks[id];
    if (typeof block === 'undefined') return null;
    if (!branchNum) branchNum = 1;
    let inputName = Blocks.BRANCH_INPUT_PREFIX;
    if (branchNum > 1) {
      inputName += branchNum;
    }

    // Empty C-block?
    const input = block.inputs[inputName];
    return typeof input === 'undefined' ? null : input.block;
  }

  /**
   * Get the opcode for a particular block
   * @param {?object} block The block to query
   * @return {?string} the opcode corresponding to that block
   */
  getOpcode(block) {
    return typeof block === 'undefined' ? null : block.opcode;
  }

  /**
   * Get all fields and their values for a block.
   * @param {?object} block The block to query.
   * @return {?object} All fields and their values.
   */
  getFields(block) {
    return typeof block === 'undefined' ? null : block.fields;
  }

  /**
   * Get all non-branch inputs for a block.
   * @param {?object} block the block to query.
   * @return {?Array.<object>} All non-branch inputs and their associated blocks.
   */
  getInputs(block) {
    if (typeof block === 'undefined') return null;
    let inputs = this._cache.inputs[block.id];
    if (typeof inputs !== 'undefined') {
      return inputs;
    }
    inputs = {};
    for (const input in block.inputs) {
      // Ignore blocks prefixed with branch prefix.
      if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
        inputs[input] = block.inputs[input];
      }
    }
    this._cache.inputs[block.id] = inputs;
    return inputs;
  }

  /**
   * Get mutation data for a block.
   * @param {?object} block The block to query.
   * @return {?object} Mutation for the block.
   */
  getMutation(block) {
    return typeof block === 'undefined' ? null : block.mutation;
  }

  /**
   * Get the top-level script for a given block.
   * @param {?string} id ID of block to query.
   * @return {?string} ID of top-level script block.
   */
  getTopLevelScript(id) {
    let block = this._blocks[id];
    if (typeof block === 'undefined') return null;
    while (block.parent !== null) {
      block = this._blocks[block.parent];
    }
    return block.id;
  }

  /**
   * Get the procedure definition for a given name.
   * @param {?string} name Name of procedure to query.
   * @return {?string} ID of procedure definition.
   */
  getProcedureDefinition(name) {
    const blockID = this._cache.procedureDefinitions[name];
    if (typeof blockID !== 'undefined') {
      return blockID;
    }
    for (const id in this._blocks) {
      if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;
      const block = this._blocks[id];
      if (block.opcode === 'procedures_definition') {
        const internal = this._getCustomBlockInternal(block);
        if (internal && internal.mutation.proccode === name) {
          this._cache.procedureDefinitions[name] = id; // The outer define block id
          return id;
        }
      }
    }
    this._cache.procedureDefinitions[name] = null;
    return null;
  }

  /**
   * Get names and ids of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */
  getProcedureParamNamesAndIds(name) {
    return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);
  }

  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */
  getProcedureParamNamesIdsAndDefaults(name) {
    const cachedNames = this._cache.procedureParamNames[name];
    if (typeof cachedNames !== 'undefined') {
      return cachedNames;
    }
    for (const id in this._blocks) {
      if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;
      const block = this._blocks[id];
      if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {
        const names = JSON.parse(block.mutation.argumentnames);
        const ids = JSON.parse(block.mutation.argumentids);
        const defaults = JSON.parse(block.mutation.argumentdefaults);
        this._cache.procedureParamNames[name] = [names, ids, defaults];
        return this._cache.procedureParamNames[name];
      }
    }
    this._cache.procedureParamNames[name] = null;
    return null;
  }
  duplicate() {
    const newBlocks = new Blocks(this.runtime, this.forceNoGlow);
    newBlocks._blocks = Clone.simple(this._blocks);
    newBlocks._scripts = Clone.simple(this._scripts);
    return newBlocks;
  }
  // ---------------------------------------------------------------------

  /**
   * Create event listener for blocks, variables, and comments. Handles validation and
   * serves as a generic adapter between the blocks, variables, and the
   * runtime interface.
   * @param {object} e Blockly "block" or "variable" event
   */
  blocklyListen(e) {
    // Validate event
    if (typeof e !== 'object') return;
    if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {
      return;
    }
    const stage = this.runtime.getTargetForStage();
    const editingTarget = this.runtime.getEditingTarget();

    // UI event: clicked scripts toggle in the runtime.
    if (e.element === 'stackclick') {
      this.runtime.toggleScript(e.blockId, {
        stackClick: true
      });
      return;
    }

    // Block create/update/destroy
    switch (e.type) {
      case 'create':
        {
          const newBlocks = adapter(e);
          // A create event can create many blocks. Add them all.
          for (let i = 0; i < newBlocks.length; i++) {
            this.createBlock(newBlocks[i]);
          }
          break;
        }
      case 'change':
        this.changeBlock({
          id: e.blockId,
          element: e.element,
          name: e.name,
          value: e.newValue
        });
        break;
      case 'move':
        this.moveBlock({
          id: e.blockId,
          oldParent: e.oldParentId,
          oldInput: e.oldInputName,
          newParent: e.newParentId,
          newInput: e.newInputName,
          newCoordinate: e.newCoordinate
        });
        break;
      case 'dragOutside':
        this.runtime.emitBlockDragUpdate(e.isOutside);
        break;
      case 'endDrag':
        this.runtime.emitBlockDragUpdate(false /* areBlocksOverGui */);

        // Drag blocks onto another sprite
        if (e.isOutside) {
          const newBlocks = adapter(e);
          this.runtime.emitBlockEndDrag(newBlocks, e.blockId);
        }
        break;
      case 'delete':
        // Don't accept delete events for missing blocks,
        // or shadow blocks being obscured.
        if (!Object.prototype.hasOwnProperty.call(this._blocks, e.blockId) || this._blocks[e.blockId].shadow) {
          return;
        }
        // Inform any runtime to forget about glows on this script.
        if (this._blocks[e.blockId].topLevel) {
          this.runtime.quietGlow(e.blockId);
        }
        this.deleteBlock(e.blockId);
        break;
      case 'var_create':
        // Check if the variable being created is global or local
        // If local, create a local var on the current editing target, as long
        // as there are no conflicts, and the current target is actually a sprite
        // If global or if the editing target is not present or we somehow got
        // into a state where a local var was requested for the stage,
        // create a stage (global) var after checking for name conflicts
        // on all the sprites.
        if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {
          if (!editingTarget.lookupVariableById(e.varId)) {
            editingTarget.createVariable(e.varId, e.varName, e.varType);
            this.emitProjectChanged();
          }
        } else {
          if (stage.lookupVariableById(e.varId)) {
            // Do not re-create a variable if it already exists
            return;
          }
          // Check for name conflicts in all of the targets
          const allTargets = this.runtime.targets.filter(t => t.isOriginal);
          for (const target of allTargets) {
            if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {
              return;
            }
          }
          stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);
          this.emitProjectChanged();
        }
        break;
      case 'var_rename':
        if (editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId)) {
          // This is a local variable, rename on the current target
          editingTarget.renameVariable(e.varId, e.newName);
          // Update all the blocks on the current target that use
          // this variable
          editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
        } else {
          // This is a global variable
          stage.renameVariable(e.varId, e.newName);
          // Update all blocks on all targets that use the renamed variable
          const targets = this.runtime.targets;
          for (let i = 0; i < targets.length; i++) {
            const currTarget = targets[i];
            currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
          }
        }
        this.emitProjectChanged();
        break;
      case 'var_delete':
        {
          const target = editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId) ? editingTarget : stage;
          target.deleteVariable(e.varId);
          this.emitProjectChanged();
          break;
        }
      case 'comment_create':
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);
          if (currTarget.comments[e.commentId].x === null && currTarget.comments[e.commentId].y === null) {
            // Block comments imported from 2.0 projects are imported with their
            // x and y coordinates set to null so that scratch-blocks can
            // auto-position them. If we are receiving a create event for these
            // comments, then the auto positioning should have taken place.
            // Update the x and y position of these comments to match the
            // one from the event.
            currTarget.comments[e.commentId].x = e.xy.x;
            currTarget.comments[e.commentId].y = e.xy.y;
          }
        }
        this.emitProjectChanged();
        break;
      case 'comment_change':
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          if (!Object.prototype.hasOwnProperty.call(currTarget.comments, e.commentId)) {
            log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
            return;
          }
          const comment = currTarget.comments[e.commentId];
          const change = e.newContents_;
          if (Object.prototype.hasOwnProperty.call(change, 'minimized')) {
            comment.minimized = change.minimized;
          }
          if (Object.prototype.hasOwnProperty.call(change, 'width') && Object.prototype.hasOwnProperty.call(change, 'height')) {
            comment.width = change.width;
            comment.height = change.height;
          }
          if (Object.prototype.hasOwnProperty.call(change, 'text')) {
            comment.text = change.text;
          }
          this.emitProjectChanged();
        }
        break;
      case 'comment_move':
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          if (currTarget && !Object.prototype.hasOwnProperty.call(currTarget.comments, e.commentId)) {
            log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
            return;
          }
          const comment = currTarget.comments[e.commentId];
          const newCoord = e.newCoordinate_;
          comment.x = newCoord.x;
          comment.y = newCoord.y;
          this.emitProjectChanged();
        }
        break;
      case 'comment_delete':
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          if (!Object.prototype.hasOwnProperty.call(currTarget.comments, e.commentId)) {
            // If we're in this state, we have probably received
            // a delete event from a workspace that we switched from
            // (e.g. a delete event for a comment on sprite a's workspace
            // when switching from sprite a to sprite b)
            return;
          }
          delete currTarget.comments[e.commentId];
          if (e.blockId) {
            const block = currTarget.blocks.getBlock(e.blockId);
            if (!block) {
              log.warn("Could not find block referenced by comment with id: ".concat(e.commentId));
              return;
            }
            delete block.comment;
          }
          this.emitProjectChanged();
        }
        break;
    }
  }

  // ---------------------------------------------------------------------

  /**
   * Reset all runtime caches.
   */
  resetCache() {
    this._cache.inputs = {};
    this._cache.procedureParamNames = {};
    this._cache.procedureDefinitions = {};
    this._cache._executeCached = {};
    this._cache._monitored = null;
    this._cache.scripts = {};
  }

  /**
   * Emit a project changed event if this is a block container
   * that can affect the project state.
   */
  emitProjectChanged() {
    if (!this.forceNoGlow) {
      this.runtime.emitProjectChanged();
    }
  }

  /**
   * Block management: create blocks and scripts from a `create` event
   * @param {!object} block Blockly create event to be processed
   */
  createBlock(block) {
    // Does the block already exist?
    // Could happen, e.g., for an unobscured shadow.
    if (Object.prototype.hasOwnProperty.call(this._blocks, block.id)) {
      return;
    }
    // Create new block.
    this._blocks[block.id] = block;
    // Push block id to scripts array.
    // Blocks are added as a top-level stack if they are marked as a top-block
    // (if they were top-level XML in the event).
    if (block.topLevel) {
      this._addScript(block.id);
    }
    this.resetCache();

    // A new block was actually added to the block container,
    // emit a project changed event
    this.emitProjectChanged();
  }

  /**
   * Block management: change block field values
   * @param {!object} args Blockly change event to be processed
   */
  changeBlock(args) {
    // Validate
    if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;
    let block = this._blocks[args.id];
    if (typeof block === 'undefined') return;
    switch (args.element) {
      case 'field':
        // TODO when the field of a monitored block changes,
        // update the checkbox in the flyout based on whether
        // a monitor for that current combination of selected parameters exists
        // e.g.
        // 1. check (current [v year])
        // 2. switch dropdown in flyout block to (current [v minute])
        // 3. the checkbox should become unchecked if we're not already
        //    monitoring current minute

        // Update block value
        if (!block.fields[args.name]) return;
        if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {
          // Get variable name using the id in args.value.
          const variable = this.runtime.getEditingTarget().lookupVariableById(args.value);
          if (variable) {
            block.fields[args.name].value = variable.name;
            block.fields[args.name].id = args.value;
          }
        } else {
          // Changing the value in a dropdown
          block.fields[args.name].value = args.value;

          // The selected item in the sensing of block menu needs to change based on the
          // selected target.  Set it to the first item in the menu list.
          // TODO: (#1787)
          if (block.opcode === 'sensing_of_object_menu') {
            if (block.fields.OBJECT.value === '_stage_') {
              this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';
            } else {
              this._blocks[block.parent].fields.PROPERTY.value = 'x position';
            }
            this.runtime.requestBlocksUpdate();
          }
          const flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;
          if (flyoutBlock.isMonitored) {
            this.runtime.requestUpdateMonitor(Map({
              id: flyoutBlock.id,
              params: this._getBlockParams(flyoutBlock)
            }));
          }
        }
        break;
      case 'mutation':
        block.mutation = mutationAdapter(args.value);
        break;
      case 'checkbox':
        {
          // A checkbox usually has a one to one correspondence with the monitor
          // block but in the case of monitored reporters that have arguments,
          // map the old id to a new id, creating a new monitor block if necessary
          if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {
            // This block has an argument which needs to get separated out into
            // multiple monitor blocks with ids based on the selected argument
            const newId = getMonitorIdForBlockWithArgs(block.id, block.fields);
            // Note: we're not just constantly creating a longer and longer id everytime we check
            // the checkbox because we're using the id of the block in the flyout as the base

            // check if a block with the new id already exists, otherwise create
            let newBlock = this.runtime.monitorBlocks.getBlock(newId);
            if (!newBlock) {
              newBlock = JSON.parse(JSON.stringify(block));
              newBlock.id = newId;
              this.runtime.monitorBlocks.createBlock(newBlock);
            }
            block = newBlock; // Carry on through the rest of this code with newBlock
          }
          const wasMonitored = block.isMonitored;
          block.isMonitored = args.value;

          // Variable blocks may be sprite specific depending on the owner of the variable
          let isSpriteLocalVariable = false;
          if (block.opcode === 'data_variable') {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];
          } else if (block.opcode === 'data_listcontents') {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];
          }
          const isSpriteSpecific = isSpriteLocalVariable || Object.prototype.hasOwnProperty.call(this.runtime.monitorBlockInfo, block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;
          if (isSpriteSpecific) {
            // If creating a new sprite specific monitor, the only possible target is
            // the current editing one b/c you cannot dynamically create monitors.
            // Also, do not change the targetId if it has already been assigned
            block.targetId = block.targetId || this.runtime.getEditingTarget().id;
          } else {
            block.targetId = null;
          }
          if (wasMonitored && !block.isMonitored) {
            this.runtime.requestHideMonitor(block.id);
          } else if (!wasMonitored && block.isMonitored) {
            // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.
            if (!this.runtime.requestShowMonitor(block.id)) {
              this.runtime.requestAddMonitor(MonitorRecord({
                id: block.id,
                targetId: block.targetId,
                spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,
                opcode: block.opcode,
                params: this._getBlockParams(block),
                // @todo(vm#565) for numerical values with decimals, some countries use comma
                value: '',
                mode: block.opcode === 'data_listcontents' ? 'list' : 'default'
              }));
            }
          }
          break;
        }
    }
    this.emitProjectChanged();
    this.resetCache();
  }

  /**
   * Block management: move blocks from parent to parent
   * @param {!object} e Blockly move event to be processed
   */
  moveBlock(e) {
    if (!Object.prototype.hasOwnProperty.call(this._blocks, e.id)) {
      return;
    }
    const block = this._blocks[e.id];
    // Track whether a change actually occurred
    // ignoring changes like routine re-positioning
    // of a block when loading a workspace
    let didChange = false;

    // Move coordinate changes.
    if (e.newCoordinate) {
      didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;
      block.x = e.newCoordinate.x;
      block.y = e.newCoordinate.y;
    }

    // Remove from any old parent.
    if (typeof e.oldParent !== 'undefined') {
      const oldParent = this._blocks[e.oldParent];
      if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {
        // This block was connected to the old parent's input.
        oldParent.inputs[e.oldInput].block = null;
      } else if (oldParent.next === e.id) {
        // This block was connected to the old parent's next connection.
        oldParent.next = null;
      }
      this._blocks[e.id].parent = null;
      didChange = true;
    }

    // Is this block a top-level block?
    if (typeof e.newParent === 'undefined') {
      this._addScript(e.id);
    } else {
      // Remove script, if one exists.
      this._deleteScript(e.id);
      // Otherwise, try to connect it in its new place.
      if (typeof e.newInput === 'undefined') {
        // Moved to the new parent's next connection.
        this._blocks[e.newParent].next = e.id;
      } else {
        // Moved to the new parent's input.
        // Don't obscure the shadow block.
        let oldShadow = null;
        if (Object.prototype.hasOwnProperty.call(this._blocks[e.newParent].inputs, e.newInput)) {
          oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
        }

        // If the block being attached is itself a shadow, make sure to set
        // both block and shadow to that blocks ID. This happens when adding
        // inputs to a custom procedure.
        if (this._blocks[e.id].shadow) oldShadow = e.id;
        this._blocks[e.newParent].inputs[e.newInput] = {
          name: e.newInput,
          block: e.id,
          shadow: oldShadow
        };
      }
      this._blocks[e.id].parent = e.newParent;
      didChange = true;
    }
    this.resetCache();
    if (didChange) this.emitProjectChanged();
  }

  /**
   * Block management: run all blocks.
   * @param {!object} runtime Runtime to run all blocks in.
   */
  runAllMonitored(runtime) {
    if (this._cache._monitored === null) {
      this._cache._monitored = Object.keys(this._blocks).filter(blockId => this.getBlock(blockId).isMonitored).map(blockId => {
        const targetId = this.getBlock(blockId).targetId;
        return {
          blockId,
          target: targetId ? runtime.getTargetById(targetId) : null
        };
      });
    }
    const monitored = this._cache._monitored;
    for (let i = 0; i < monitored.length; i++) {
      const {
        blockId,
        target
      } = monitored[i];
      runtime.addMonitorScript(blockId, target);
    }
  }

  /**
   * Block management: delete blocks and their associated scripts. Does nothing if a block
   * with the given ID does not exist.
   * @param {!string} blockId Id of block to delete
   */
  deleteBlock(blockId) {
    // @todo In runtime, stop threads running on this script.

    // Get block
    const block = this._blocks[blockId];
    if (!block) {
      // No block with the given ID exists
      return;
    }

    // Delete children
    if (block.next !== null) {
      this.deleteBlock(block.next);
    }

    // Delete inputs (including branches)
    for (const input in block.inputs) {
      // If it's null, the block in this input moved away.
      if (block.inputs[input].block !== null) {
        this.deleteBlock(block.inputs[input].block);
      }
      // Delete obscured shadow blocks.
      if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
        this.deleteBlock(block.inputs[input].shadow);
      }
    }

    // Delete any script starting with this block.
    this._deleteScript(blockId);

    // Delete block itself.
    delete this._blocks[blockId];
    this.resetCache();
    this.emitProjectChanged();
  }

  /**
   * Delete all blocks and their associated scripts.
   */
  deleteAllBlocks() {
    const blockIds = Object.keys(this._blocks);
    blockIds.forEach(blockId => this.deleteBlock(blockId));
  }

  /**
   * Returns a map of all references to variables or lists from blocks
   * in this block container.
   * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
   * This is useful for getting variable/list references for a stack of blocks instead
   * of all blocks on the workspace
   * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
   * @return {object} A map of variable ID to a list of all variable references
   * for that ID. A variable reference contains the field referencing that variable
   * and also the type of the variable being referenced.
   */
  getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {
    const blocks = optBlocks ? optBlocks : this._blocks;
    const allReferences = Object.create(null);
    for (const blockId in blocks) {
      let varOrListField = null;
      let varType = null;
      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
        varType = Variable.SCALAR_TYPE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
        varType = Variable.LIST_TYPE;
      } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {
        varOrListField = blocks[blockId].fields.BROADCAST_OPTION;
        varType = Variable.BROADCAST_MESSAGE_TYPE;
      }
      if (varOrListField) {
        const currVarId = varOrListField.id;
        if (allReferences[currVarId]) {
          allReferences[currVarId].push({
            referencingField: varOrListField,
            type: varType
          });
        } else {
          allReferences[currVarId] = [{
            referencingField: varOrListField,
            type: varType
          }];
        }
      }
    }
    return allReferences;
  }

  /**
   * Keep blocks up to date after a variable gets renamed.
   * @param {string} varId The id of the variable that was renamed
   * @param {string} newName The new name of the variable that was renamed
   */
  updateBlocksAfterVarRename(varId, newName) {
    const blocks = this._blocks;
    for (const blockId in blocks) {
      let varOrListField = null;
      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
      }
      if (varOrListField) {
        const currFieldId = varOrListField.id;
        if (varId === currFieldId) {
          varOrListField.value = newName;
        }
      }
    }
  }

  /**
   * Keep blocks up to date after they are shared between targets.
   * @param {boolean} isStage If the new target is a stage.
   */
  updateTargetSpecificBlocks(isStage) {
    const blocks = this._blocks;
    for (const blockId in blocks) {
      if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {
        blocks[blockId].opcode = 'event_whenstageclicked';
      } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {
        blocks[blockId].opcode = 'event_whenthisspriteclicked';
      }
    }
  }

  /**
   * Update blocks after a sound, costume, or backdrop gets renamed.
   * Any block referring to the old name of the asset should get updated
   * to refer to the new name.
   * @param {string} oldName The old name of the asset that was renamed.
   * @param {string} newName The new name of the asset that was renamed.
   * @param {string} assetType String representation of the kind of asset
   * that was renamed. This can be one of 'sprite','costume', 'sound', or
   * 'backdrop'.
   */
  updateAssetName(oldName, newName, assetType) {
    let getAssetField;
    if (assetType === 'costume') {
      getAssetField = this._getCostumeField.bind(this);
    } else if (assetType === 'sound') {
      getAssetField = this._getSoundField.bind(this);
    } else if (assetType === 'backdrop') {
      getAssetField = this._getBackdropField.bind(this);
    } else if (assetType === 'sprite') {
      getAssetField = this._getSpriteField.bind(this);
    } else {
      return;
    }
    const blocks = this._blocks;
    for (const blockId in blocks) {
      const assetField = getAssetField(blockId);
      if (assetField && assetField.value === oldName) {
        assetField.value = newName;
      }
    }
  }

  /**
   * Update sensing_of blocks after a variable gets renamed.
   * @param {string} oldName The old name of the variable that was renamed.
   * @param {string} newName The new name of the variable that was renamed.
   * @param {string} targetName The name of the target the variable belongs to.
   * @return {boolean} Returns true if any of the blocks were updated.
   */
  updateSensingOfReference(oldName, newName, targetName) {
    const blocks = this._blocks;
    let blockUpdated = false;
    for (const blockId in blocks) {
      const block = blocks[blockId];
      if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName &&
      // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.
      block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {
        const inputBlock = this.getBlock(block.inputs.OBJECT.block);
        if (inputBlock.fields.OBJECT.value === targetName) {
          block.fields.PROPERTY.value = newName;
          blockUpdated = true;
        }
      }
    }
    if (blockUpdated) this.resetCache();
    return blockUpdated;
  }

  /**
   * Helper function to retrieve a costume menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The costume menu field of the block with the given block id.
   * Null if either a block with the given id doesn't exist or if a costume menu field
   * does not exist on the block with the given id.
   */
  _getCostumeField(blockId) {
    const block = this.getBlock(blockId);
    if (block && Object.prototype.hasOwnProperty.call(block.fields, 'COSTUME')) {
      return block.fields.COSTUME;
    }
    return null;
  }

  /**
   * Helper function to retrieve a sound menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sound menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sound menu field
   * does not exist on the block with the given id.
   */
  _getSoundField(blockId) {
    const block = this.getBlock(blockId);
    if (block && Object.prototype.hasOwnProperty.call(block.fields, 'SOUND_MENU')) {
      return block.fields.SOUND_MENU;
    }
    return null;
  }

  /**
   * Helper function to retrieve a backdrop menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The backdrop menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a backdrop menu field
   * does not exist on the block with the given id.
   */
  _getBackdropField(blockId) {
    const block = this.getBlock(blockId);
    if (block && Object.prototype.hasOwnProperty.call(block.fields, 'BACKDROP')) {
      return block.fields.BACKDROP;
    }
    return null;
  }

  /**
   * Helper function to retrieve a sprite menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sprite menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sprite menu field
   * does not exist on the block with the given id.
   */
  _getSpriteField(blockId) {
    const block = this.getBlock(blockId);
    if (!block) {
      return null;
    }
    const spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];
    for (let i = 0; i < spriteMenuNames.length; i++) {
      const menuName = spriteMenuNames[i];
      if (Object.prototype.hasOwnProperty.call(block.fields, menuName)) {
        return block.fields[menuName];
      }
    }
    return null;
  }

  // ---------------------------------------------------------------------

  /**
   * Encode all of `this._blocks` as an XML string usable
   * by a Blockly/scratch-blocks workspace.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this object's blocks.
   */
  toXML(comments) {
    return this._scripts.map(script => this.blockToXML(script, comments)).join();
  }

  /**
   * Recursively encode an individual block and its children
   * into a Blockly/scratch-blocks XML string.
   * @param {!string} blockId ID of block to encode.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this block and any children.
   */
  blockToXML(blockId, comments) {
    const block = this._blocks[blockId];
    // block should exist, but currently some blocks' next property point
    // to a blockId for non-existent blocks. Until we track down that behavior,
    // this early exit allows the project to load.
    if (!block) return;
    // Encode properties of this block.
    const tagName = block.shadow ? 'shadow' : 'block';
    let xmlString = "<".concat(tagName, "\n                id=\"").concat(block.id, "\"\n                type=\"").concat(block.opcode, "\"\n                ").concat(block.topLevel ? "x=\"".concat(block.x, "\" y=\"").concat(block.y, "\"") : '', "\n            >");
    const commentId = block.comment;
    if (commentId) {
      if (comments) {
        if (Object.prototype.hasOwnProperty.call(comments, commentId)) {
          xmlString += comments[commentId].toXML();
        } else {
          log.warn("Could not find comment with id: ".concat(commentId, " in provided comment descriptions."));
        }
      } else {
        log.warn("Cannot serialize comment with id: ".concat(commentId, "; no comment descriptions provided."));
      }
    }
    // Add any mutation. Must come before inputs.
    if (block.mutation) {
      xmlString += this.mutationToXML(block.mutation);
    }
    // Add any inputs on this block.
    for (const input in block.inputs) {
      if (!Object.prototype.hasOwnProperty.call(block.inputs, input)) continue;
      const blockInput = block.inputs[input];
      // Only encode a value tag if the value input is occupied.
      if (blockInput.block || blockInput.shadow) {
        xmlString += "<value name=\"".concat(blockInput.name, "\">");
        if (blockInput.block) {
          xmlString += this.blockToXML(blockInput.block, comments);
        }
        if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
          // Obscured shadow.
          xmlString += this.blockToXML(blockInput.shadow, comments);
        }
        xmlString += '</value>';
      }
    }
    // Add any fields on this block.
    for (const field in block.fields) {
      if (!Object.prototype.hasOwnProperty.call(block.fields, field)) continue;
      const blockField = block.fields[field];
      xmlString += "<field name=\"".concat(blockField.name, "\"");
      const fieldId = blockField.id;
      if (fieldId) {
        xmlString += " id=\"".concat(fieldId, "\"");
      }
      const varType = blockField.variableType;
      if (typeof varType === 'string') {
        xmlString += " variabletype=\"".concat(varType, "\"");
      }
      let value = blockField.value;
      if (typeof value === 'string') {
        value = xmlEscape(blockField.value);
      }
      xmlString += ">".concat(value, "</field>");
    }
    // Add blocks connected to the next connection.
    if (block.next) {
      xmlString += "<next>".concat(this.blockToXML(block.next, comments), "</next>");
    }
    xmlString += "</".concat(tagName, ">");
    return xmlString;
  }

  /**
   * Recursively encode a mutation object to XML.
   * @param {!object} mutation Object representing a mutation.
   * @return {string} XML string representing a mutation.
   */
  mutationToXML(mutation) {
    let mutationString = "<".concat(mutation.tagName);
    for (const prop in mutation) {
      if (prop === 'children' || prop === 'tagName') continue;
      let mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop];

      // Handle dynamic extension blocks
      if (prop === 'blockInfo') {
        mutationValue = xmlEscape(JSON.stringify(mutation[prop]));
      }
      mutationString += " ".concat(prop, "=\"").concat(mutationValue, "\"");
    }
    mutationString += '>';
    for (let i = 0; i < mutation.children.length; i++) {
      mutationString += this.mutationToXML(mutation.children[i]);
    }
    mutationString += "</".concat(mutation.tagName, ">");
    return mutationString;
  }

  // ---------------------------------------------------------------------
  /**
   * Helper to serialize block fields and input fields for reporting new monitors
   * @param {!object} block Block to be paramified.
   * @return {!object} object of param key/values.
   */
  _getBlockParams(block) {
    const params = {};
    for (const key in block.fields) {
      params[key] = block.fields[key].value;
    }
    for (const inputKey in block.inputs) {
      const inputBlock = this._blocks[block.inputs[inputKey].block];
      for (const key in inputBlock.fields) {
        params[key] = inputBlock.fields[key].value;
      }
    }
    return params;
  }

  /**
   * Helper to get the corresponding internal procedure definition block
   * @param {!object} defineBlock Outer define block.
   * @return {!object} internal definition block which has the mutation.
   */
  _getCustomBlockInternal(defineBlock) {
    if (defineBlock.inputs && defineBlock.inputs.custom_block) {
      return this._blocks[defineBlock.inputs.custom_block.block];
    }
  }

  /**
   * Helper to add a stack to `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */
  _addScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);
    if (i > -1) return; // Already in scripts.
    this._scripts.push(topBlockId);
    // Update `topLevel` property on the top block.
    this._blocks[topBlockId].topLevel = true;
  }

  /**
   * Helper to remove a script from `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */
  _deleteScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);
    if (i > -1) this._scripts.splice(i, 1);
    // Update `topLevel` property on the top block.
    if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
  }
}

/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 * @param {function} CacheType constructor for cached block information
 * @return {object} execute cache object
 */
BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {
  let cached = blocks._cache._executeCached[blockId];
  if (typeof cached !== 'undefined') {
    return cached;
  }
  const block = blocks.getBlock(blockId);
  if (typeof block === 'undefined') return null;
  if (typeof CacheType === 'undefined') {
    cached = {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    };
  } else {
    cached = new CacheType(blocks, {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    });
  }
  blocks._cache._executeCached[blockId] = cached;
  return cached;
};

/**
 * Cache class constructor for runtime. Used to consider what threads should
 * start based on hat data.
 * @type {function}
 */
const RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;

/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} blocks - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache
 *   objects
 */
BlocksRuntimeCache.getScripts = function (blocks, opcode) {
  let scripts = blocks._cache.scripts[opcode];
  if (!scripts) {
    scripts = blocks._cache.scripts[opcode] = [];
    const allScripts = blocks._scripts;
    for (let i = 0; i < allScripts.length; i++) {
      const topBlockId = allScripts[i];
      const block = blocks.getBlock(topBlockId);
      if (block.opcode === opcode) {
        scripts.push(new RuntimeScriptCache(blocks, topBlockId));
      }
    }
  }
  return scripts;
};
module.exports = Blocks;

/***/ }),

/***/ "./src/engine/comment.js":
/*!*******************************!*\
  !*** ./src/engine/comment.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * Object representing a Scratch Comment (block or workspace).
 */

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");
class Comment {
  /**
   * @param {string} id Id of the comment.
   * @param {string} text Text content of the comment.
   * @param {number} x X position of the comment on the workspace.
   * @param {number} y Y position of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size.
   * @param {number} height The height of the comment when it is full size.
   * @param {boolean} minimized Whether the comment is minimized.
   * @constructor
   */
  constructor(id, text, x, y, width, height, minimized) {
    this.id = id || uid();
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = Math.max(Number(width), Comment.MIN_WIDTH);
    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);
    this.minimized = minimized || false;
    this.blockId = null;
  }
  toXML() {
    return "<comment id=\"".concat(this.id, "\" x=\"").concat(this.x, "\" y=\"").concat(this.y, "\" w=\"").concat(this.width, "\" h=\"").concat(this.height, "\" pinned=\"").concat(this.blockId !== null, "\" minimized=\"").concat(this.minimized, "\">").concat(xmlEscape(this.text), "</comment>");
  }

  // TODO choose min and defaults for width and height
  static get MIN_WIDTH() {
    return 20;
  }
  static get MIN_HEIGHT() {
    return 20;
  }
  static get DEFAULT_WIDTH() {
    return 100;
  }
  static get DEFAULT_HEIGHT() {
    return 100;
  }
}
module.exports = Comment;

/***/ }),

/***/ "./src/engine/execute.js":
/*!*******************************!*\
  !*** ./src/engine/execute.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BlockUtility = __webpack_require__(/*! ./block-utility */ "./src/engine/block-utility.js");
const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");
const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
const cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

/**
 * Single BlockUtility instance reused by execute for every pritimive ran.
 * @const
 */
const blockUtility = new BlockUtility();

/**
 * Profiler frame name for block functions.
 * @const {string}
 */
const blockFunctionProfilerFrame = 'blockFunction';

/**
 * Profiler frame ID for 'blockFunction'.
 * @type {number}
 */
let blockFunctionProfilerId = -1;

/**
 * Utility function to determine if a value is a Promise.
 * @param {*} value Value to check for a Promise.
 * @return {boolean} True if the value appears to be a Promise.
 */
const isPromise = function isPromise(value) {
  return value !== null && typeof value === 'object' && typeof value.then === 'function';
};

/**
 * Handle any reported value from the primitive, either directly returned
 * or after a promise resolves.
 * @param {*} resolvedValue Value eventually returned from the primitive.
 * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran
 * primitive.
 * @param {!Thread} thread Thread containing the primitive.
 * @param {!string} currentBlockId Id of the block in its thread for value from
 * the primitive.
 * @param {!string} opcode opcode used to identify a block function primitive.
 * @param {!boolean} isHat Is the current block a hat?
 */
// @todo move this to callback attached to the thread when we have performance
// metrics (dd)
const handleReport = function handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation) {
  const currentBlockId = blockCached.id;
  const opcode = blockCached.opcode;
  const isHat = blockCached._isHat;
  thread.pushReportedValue(resolvedValue);
  if (isHat) {
    // Hat predicate was evaluated.
    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {
      // If this is an edge-activated hat, only proceed if the value is
      // true and used to be false, or the stack was activated explicitly
      // via stack click
      if (!thread.stackClick) {
        const hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);
        const oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);
        const edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;
        if (!edgeWasActivated) {
          sequencer.retireThread(thread);
        }
      }
    } else if (!resolvedValue) {
      // Not an edge-activated hat: retire the thread
      // if predicate was false.
      sequencer.retireThread(thread);
    }
  } else {
    // In a non-hat, report the value visually if necessary if
    // at the top of the thread stack.
    if (lastOperation && typeof resolvedValue !== 'undefined' && thread.atStackTop()) {
      if (thread.stackClick) {
        sequencer.runtime.visualReport(currentBlockId, resolvedValue);
      }
      if (thread.updateMonitor) {
        const targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;
        if (targetId && !sequencer.runtime.getTargetById(targetId)) {
          // Target no longer exists
          return;
        }
        sequencer.runtime.requestUpdateMonitor(Map({
          id: currentBlockId,
          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,
          value: resolvedValue
        }));
      }
    }
    // Finished any yields.
    thread.status = Thread.STATUS_RUNNING;
  }
};
const handlePromise = (primitiveReportedValue, sequencer, thread, blockCached, lastOperation) => {
  if (thread.status === Thread.STATUS_RUNNING) {
    // Primitive returned a promise; automatically yield thread.
    thread.status = Thread.STATUS_PROMISE_WAIT;
  }
  // Promise handlers
  primitiveReportedValue.then(resolvedValue => {
    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation);
    // If it's a command block or a top level reporter in a stackClick.
    if (lastOperation) {
      let stackFrame;
      let nextBlockId;
      do {
        // In the case that the promise is the last block in the current thread stack
        // We need to pop out repeatedly until we find the next block.
        const popped = thread.popStack();
        if (popped === null) {
          return;
        }
        nextBlockId = thread.target.blocks.getNextBlock(popped);
        if (nextBlockId !== null) {
          // A next block exists so break out this loop
          break;
        }
        // Investigate the next block and if not in a loop,
        // then repeat and pop the next item off the stack frame
        stackFrame = thread.peekStackFrame();
      } while (stackFrame !== null && !stackFrame.isLoop);
      thread.pushStack(nextBlockId);
    }
  }, rejectionReason => {
    // Promise rejected: the primitive had some error.
    // Log it and proceed.
    log.warn('Primitive rejected promise: ', rejectionReason);
    thread.status = Thread.STATUS_RUNNING;
    thread.popStack();
  });
};

/**
 * A execute.js internal representation of a block to reduce the time spent in
 * execute as the same blocks are called the most.
 *
 * With the help of the Blocks class create a mutable copy of block
 * information. The members of BlockCached derived values of block information
 * that does not need to be reevaluated until a change in Blocks. Since Blocks
 * handles where the cache instance is stored, it drops all cache versions of a
 * block when any change happens to it. This way we can quickly execute blocks
 * and keep perform the right action according to the current block information
 * in the editor.
 *
 * @param {Blocks} blockContainer the related Blocks instance
 * @param {object} cached default set of cached values
 */
class BlockCached {
  constructor(blockContainer, cached) {
    /**
     * Block id in its parent set of blocks.
     * @type {string}
     */
    this.id = cached.id;

    /**
     * Block operation code for this block.
     * @type {string}
     */
    this.opcode = cached.opcode;

    /**
     * Original block object containing argument values for static fields.
     * @type {object}
     */
    this.fields = cached.fields;

    /**
     * Original block object containing argument values for executable inputs.
     * @type {object}
     */
    this.inputs = cached.inputs;

    /**
     * Procedure mutation.
     * @type {?object}
     */
    this.mutation = cached.mutation;

    /**
     * The profiler the block is configured with.
     * @type {?Profiler}
     */
    this._profiler = null;

    /**
     * Profiler information frame.
     * @type {?ProfilerFrame}
     */
    this._profilerFrame = null;

    /**
     * Is the opcode a hat (event responder) block.
     * @type {boolean}
     */
    this._isHat = false;

    /**
     * The block opcode's implementation function.
     * @type {?function}
     */
    this._blockFunction = null;

    /**
     * Is the block function defined for this opcode?
     * @type {boolean}
     */
    this._definedBlockFunction = false;

    /**
     * Is this block a block with no function but a static value to return.
     * @type {boolean}
     */
    this._isShadowBlock = false;

    /**
     * The static value of this block if it is a shadow block.
     * @type {?any}
     */
    this._shadowValue = null;

    /**
     * A copy of the block's fields that may be modified.
     * @type {object}
     */
    this._fields = Object.assign({}, this.fields);

    /**
     * A copy of the block's inputs that may be modified.
     * @type {object}
     */
    this._inputs = Object.assign({}, this.inputs);

    /**
     * An arguments object for block implementations. All executions of this
     * specific block will use this objecct.
     * @type {object}
     */
    this._argValues = {
      mutation: this.mutation
    };

    /**
     * The inputs key the parent refers to this BlockCached by.
     * @type {string}
     */
    this._parentKey = null;

    /**
     * The target object where the parent wants the resulting value stored
     * with _parentKey as the key.
     * @type {object}
     */
    this._parentValues = null;

    /**
     * A sequence of non-shadow operations that can must be performed. This
     * list recreates the order this block and its children are executed.
     * Since the order is always the same we can safely store that order
     * and iterate over the operations instead of dynamically walking the
     * tree every time.
     * @type {Array<BlockCached>}
     */
    this._ops = [];
    const {
      runtime
    } = blockUtility.sequencer;
    const {
      opcode,
      fields,
      inputs
    } = this;

    // Assign opcode isHat and blockFunction data to avoid dynamic lookups.
    this._isHat = runtime.getIsHat(opcode);
    this._blockFunction = runtime.getOpcodeFunction(opcode);
    this._definedBlockFunction = typeof this._blockFunction !== 'undefined';

    // Store the current shadow value if there is a shadow value.
    const fieldKeys = Object.keys(fields);
    this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;
    this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value;

    // Store the static fields onto _argValues.
    for (const fieldName in fields) {
      if (fieldName === 'VARIABLE' || fieldName === 'LIST' || fieldName === 'BROADCAST_OPTION') {
        this._argValues[fieldName] = {
          id: fields[fieldName].id,
          name: fields[fieldName].value
        };
      } else {
        this._argValues[fieldName] = fields[fieldName].value;
      }
    }

    // Remove custom_block. It is not part of block execution.
    delete this._inputs.custom_block;
    if ('BROADCAST_INPUT' in this._inputs) {
      // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an
      // object with an unchanging shape.
      this._argValues.BROADCAST_OPTION = {
        id: null,
        name: null
      };

      // We can go ahead and compute BROADCAST_INPUT if it is a shadow
      // value.
      const broadcastInput = this._inputs.BROADCAST_INPUT;
      if (broadcastInput.block === broadcastInput.shadow) {
        // Shadow dropdown menu is being used.
        // Get the appropriate information out of it.
        const shadow = blockContainer.getBlock(broadcastInput.shadow);
        const broadcastField = shadow.fields.BROADCAST_OPTION;
        this._argValues.BROADCAST_OPTION.id = broadcastField.id;
        this._argValues.BROADCAST_OPTION.name = broadcastField.value;

        // Evaluating BROADCAST_INPUT here we do not need to do so
        // later.
        delete this._inputs.BROADCAST_INPUT;
      }
    }

    // Cache all input children blocks in the operation lists. The
    // operations can later be run in the order they appear in correctly
    // executing the operations quickly in a flat loop instead of needing to
    // recursivly iterate them.
    for (const inputName in this._inputs) {
      const input = this._inputs[inputName];
      if (input.block) {
        const inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);
        if (inputCached._isHat) {
          continue;
        }
        this._ops.push(...inputCached._ops);
        inputCached._parentKey = inputName;
        inputCached._parentValues = this._argValues;

        // Shadow values are static and do not change, go ahead and
        // store their value on args.
        if (inputCached._isShadowBlock) {
          this._argValues[inputName] = inputCached._shadowValue;
        }
      }
    }

    // The final operation is this block itself. At the top most block is a
    // command block or a block that is being run as a monitor.
    if (this._definedBlockFunction) {
      this._ops.push(this);
    }
  }
}

/**
 * Initialize a BlockCached instance so its command/hat
 * block and reporters can be profiled during execution.
 * @param {Profiler} profiler - The profiler that is currently enabled.
 * @param {BlockCached} blockCached - The blockCached instance to profile.
 */
const _prepareBlockProfiling = function _prepareBlockProfiling(profiler, blockCached) {
  blockCached._profiler = profiler;
  if (blockFunctionProfilerId === -1) {
    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);
  }
  const ops = blockCached._ops;
  for (let i = 0; i < ops.length; i++) {
    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);
  }
};

/**
 * Execute a block.
 * @param {!Sequencer} sequencer Which sequencer is executing.
 * @param {!Thread} thread Thread which to read and execute.
 */
const execute = function execute(sequencer, thread) {
  const runtime = sequencer.runtime;

  // store sequencer and thread so block functions can access them through
  // convenience methods.
  blockUtility.sequencer = sequencer;
  blockUtility.thread = thread;

  // Current block to execute is the one on the top of the stack.
  const currentBlockId = thread.peekStack();
  const currentStackFrame = thread.peekStackFrame();
  let blockContainer = thread.blockContainer;
  let blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);
  if (blockCached === null) {
    blockContainer = runtime.flyoutBlocks;
    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);
    // Stop if block or target no longer exists.
    if (blockCached === null) {
      // No block found: stop the thread; script no longer exists.
      sequencer.retireThread(thread);
      return;
    }
  }
  const ops = blockCached._ops;
  const length = ops.length;
  let i = 0;
  if (currentStackFrame.reported !== null) {
    const reported = currentStackFrame.reported;
    // Reinstate all the previous values.
    for (; i < reported.length; i++) {
      const {
        opCached: oldOpCached,
        inputValue
      } = reported[i];
      const opCached = ops.find(op => op.id === oldOpCached);
      if (opCached) {
        const inputName = opCached._parentKey;
        const argValues = opCached._parentValues;
        if (inputName === 'BROADCAST_INPUT') {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          argValues.BROADCAST_OPTION.id = null;
          argValues.BROADCAST_OPTION.name = cast.toString(inputValue);
        } else {
          argValues[inputName] = inputValue;
        }
      }
    }

    // Find the last reported block that is still in the set of operations.
    // This way if the last operation was removed, we'll find the next
    // candidate. If an earlier block that was performed was removed then
    // we'll find the index where the last operation is now.
    if (reported.length > 0) {
      const lastExisting = reported.reverse().find(report => ops.find(op => op.id === report.opCached));
      if (lastExisting) {
        i = ops.findIndex(opCached => opCached.id === lastExisting.opCached) + 1;
      } else {
        i = 0;
      }
    }

    // The reporting block must exist and must be the next one in the sequence of operations.
    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {
      const opCached = ops[i];
      const inputValue = thread.justReported;
      thread.justReported = null;
      const inputName = opCached._parentKey;
      const argValues = opCached._parentValues;
      if (inputName === 'BROADCAST_INPUT') {
        // Something is plugged into the broadcast input.
        // Cast it to a string. We don't need an id here.
        argValues.BROADCAST_OPTION.id = null;
        argValues.BROADCAST_OPTION.name = cast.toString(inputValue);
      } else {
        argValues[inputName] = inputValue;
      }
      i += 1;
    }
    currentStackFrame.reporting = null;
    currentStackFrame.reported = null;
  }
  const start = i;
  for (; i < length; i++) {
    const lastOperation = i === length - 1;
    const opCached = ops[i];
    const blockFunction = opCached._blockFunction;

    // Update values for arguments (inputs).
    const argValues = opCached._argValues;

    // Fields are set during opCached initialization.

    // Blocks should glow when a script is starting,
    // not after it has finished (see #1404).
    // Only blocks in blockContainers that don't forceNoGlow
    // should request a glow.
    if (!blockContainer.forceNoGlow) {
      thread.requestScriptGlowInFrame = true;
    }

    // Inputs are set during previous steps in the loop.

    const primitiveReportedValue = blockFunction(argValues, blockUtility);

    // If it's a promise, wait until promise resolves.
    if (isPromise(primitiveReportedValue)) {
      handlePromise(primitiveReportedValue, sequencer, thread, opCached, lastOperation);

      // Store the already reported values. They will be thawed into the
      // future versions of the same operations by block id. The reporting
      // operation if it is promise waiting will set its parent value at
      // that time.
      thread.justReported = null;
      currentStackFrame.reporting = ops[i].id;
      currentStackFrame.reported = ops.slice(0, i).map(reportedCached => {
        const inputName = reportedCached._parentKey;
        const reportedValues = reportedCached._parentValues;
        if (inputName === 'BROADCAST_INPUT') {
          return {
            opCached: reportedCached.id,
            inputValue: reportedValues[inputName].BROADCAST_OPTION.name
          };
        }
        return {
          opCached: reportedCached.id,
          inputValue: reportedValues[inputName]
        };
      });

      // We are waiting for a promise. Stop running this set of operations
      // and continue them later after thawing the reported values.
      break;
    } else if (thread.status === Thread.STATUS_RUNNING) {
      if (lastOperation) {
        handleReport(primitiveReportedValue, sequencer, thread, opCached, lastOperation);
      } else {
        // By definition a block that is not last in the list has a
        // parent.
        const inputName = opCached._parentKey;
        const parentValues = opCached._parentValues;
        if (inputName === 'BROADCAST_INPUT') {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          parentValues.BROADCAST_OPTION.id = null;
          parentValues.BROADCAST_OPTION.name = cast.toString(primitiveReportedValue);
        } else {
          parentValues[inputName] = primitiveReportedValue;
        }
      }
    }
  }
  if (runtime.profiler !== null) {
    if (blockCached._profiler !== runtime.profiler) {
      _prepareBlockProfiling(runtime.profiler, blockCached);
    }
    // Determine the index that is after the last executed block. `i` is
    // currently the block that was just executed. `i + 1` will be the block
    // after that. `length` with the min call makes sure we don't try to
    // reference an operation outside of the set of operations.
    const end = Math.min(i + 1, length);
    for (let p = start; p < end; p++) {
      ops[p]._profilerFrame.count += 1;
    }
  }
};
module.exports = execute;

/***/ }),

/***/ "./src/engine/monitor-record.js":
/*!**************************************!*\
  !*** ./src/engine/monitor-record.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  Record
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
const MonitorRecord = Record({
  id: null,
  // Block Id
  /** Present only if the monitor is sprite-specific, such as x position */
  spriteName: null,
  /** Present only if the monitor is sprite-specific, such as x position */
  targetId: null,
  opcode: null,
  value: null,
  params: null,
  mode: 'default',
  sliderMin: 0,
  sliderMax: 100,
  isDiscrete: true,
  x: null,
  // (x: null, y: null) Indicates that the monitor should be auto-positioned
  y: null,
  width: 0,
  height: 0,
  visible: true
});
module.exports = MonitorRecord;

/***/ }),

/***/ "./src/engine/mutation-adapter.js":
/*!****************************************!*\
  !*** ./src/engine/mutation-adapter.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");
const decodeHtml = __webpack_require__(/*! decode-html */ "./node_modules/decode-html/index.js");

/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @return {object} Object representing useful parts of this mutation.
 */
const mutatorTagToObject = function mutatorTagToObject(dom) {
  const obj = Object.create(null);
  obj.tagName = dom.name;
  obj.children = [];
  for (const prop in dom.attribs) {
    if (prop === 'xmlns') continue;
    obj[prop] = decodeHtml(dom.attribs[prop]);
    // Note: the capitalization of block info in the following lines is important.
    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.
    if (prop === 'blockinfo') {
      obj.blockInfo = JSON.parse(obj.blockinfo);
      delete obj.blockinfo;
    }
  }
  for (let i = 0; i < dom.children.length; i++) {
    obj.children.push(mutatorTagToObject(dom.children[i]));
  }
  return obj;
};

/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @return {object} Object representing the mutation.
 */
const mutationAdpater = function mutationAdpater(mutation) {
  let mutationParsed;
  // Check if the mutation is already parsed; if not, parse it.
  if (typeof mutation === 'object') {
    mutationParsed = mutation;
  } else {
    mutationParsed = html.parseDOM(mutation)[0];
  }
  return mutatorTagToObject(mutationParsed);
};
module.exports = mutationAdpater;

/***/ }),

/***/ "./src/engine/profiler.js":
/*!********************************!*\
  !*** ./src/engine/profiler.js ***!
  \********************************/
/***/ ((module) => {

/**
 * @fileoverview
 * A way to profile Scratch internal performance. Like what blocks run during a
 * step? How much time do they take? How much time is spent inbetween blocks?
 *
 * Profiler aims for to spend as little time inside its functions while
 * recording. For this it has a simple internal record structure that records a
 * series of values for each START and STOP event in a single array. This lets
 * all the values be pushed in one call for the array. This simplicity allows
 * the contents of the start() and stop() calls to be inlined in areas that are
 * called frequently enough to want even greater performance from Profiler so
 * what is recorded better reflects on the profiled code and not Profiler
 * itself.
 */

/**
 * The next id returned for a new profile'd function.
 * @type {number}
 */
let nextId = 0;

/**
 * The mapping of names to ids.
 * @const {Object.<string, number>}
 */
const profilerNames = {};

/**
 * The START event identifier in Profiler records.
 * @const {number}
 */
const START = 0;

/**
 * The STOP event identifier in Profiler records.
 * @const {number}
 */
const STOP = 1;

/**
 * The number of cells used in the records array by a START event.
 * @const {number}
 */
const START_SIZE = 4;

/**
 * The number of cells used in the records array by a STOP event.
 * @const {number}
 */
const STOP_SIZE = 2;

/**
 * Stored reference to Performance instance provided by the Browser.
 * @const {Performance}
 */
const performance = typeof window === 'object' && window.performance;

/**
 * Callback handle called by Profiler for each frame it decodes from its
 * records.
 * @callback FrameCallback
 * @param {ProfilerFrame} frame
 */

/**
 * A set of information about a frame of execution that was recorded.
 */
class ProfilerFrame {
  /**
   * @param {number} depth Depth of the frame in the recorded stack.
   */
  constructor(depth) {
    /**
     * The numeric id of a record symbol like Runtime._step or
     * blockFunction.
     * @type {number}
     */
    this.id = -1;

    /**
     * The amount of time spent inside the recorded frame and any deeper
     * frames.
     * @type {number}
     */
    this.totalTime = 0;

    /**
     * The amount of time spent only inside this record frame. Not
     * including time in any deeper frames.
     * @type {number}
     */
    this.selfTime = 0;

    /**
     * An arbitrary argument for the recorded frame. For example a block
     * function might record its opcode as an argument.
     * @type {*}
     */
    this.arg = null;

    /**
     * The depth of the recorded frame. This can help compare recursive
     * funtions that are recorded. Each level of recursion with have a
     * different depth value.
     * @type {number}
     */
    this.depth = depth;

    /**
     * A summarized count of the number of calls to this frame.
     * @type {number}
     */
    this.count = 0;
  }
}
class Profiler {
  /**
   * @param {FrameCallback} onFrame a handle called for each recorded frame.
   * The passed frame value may not be stored as it'll be updated with later
   * frame information. Any information that is further stored by the handler
   * should make copies or reduce the information.
   */
  constructor() {
    let onFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
    /**
     * A series of START and STOP values followed by arguments. After
     * recording is complete the full set of records is reported back by
     * stepping through the series to connect the relative START and STOP
     * information.
     * @type {Array.<*>}
     */
    this.records = [];

    /**
     * An array of frames incremented on demand instead as part of start
     * and stop.
     * @type {Array.<ProfilerFrame>}
     */
    this.increments = [];

    /**
     * An array of profiler frames separated by counter argument. Generally
     * for Scratch these frames are separated by block function opcode.
     * This tracks each time an opcode is called.
     * @type {Array.<ProfilerFrame>}
     */
    this.counters = [];

    /**
     * A frame with no id or argument.
     * @type {ProfilerFrame}
     */
    this.nullFrame = new ProfilerFrame(-1);

    /**
     * A cache of ProfilerFrames to reuse when reporting the recorded
     * frames in records.
     * @type {Array.<ProfilerFrame>}
     */
    this._stack = [new ProfilerFrame(0)];

    /**
     * A callback handle called with each decoded frame when reporting back
     * all the recorded times.
     * @type {FrameCallback}
     */
    this.onFrame = onFrame;

    /**
     * A reference to the START record id constant.
     * @const {number}
     */
    this.START = START;

    /**
     * A reference to the STOP record id constant.
     * @const {number}
     */
    this.STOP = STOP;
  }

  /**
   * Start recording a frame of time for an id and optional argument.
   * @param {number} id The id returned by idByName for a name symbol like
   * Runtime._step.
   * @param {?*} arg An arbitrary argument value to store with the frame.
   */
  start(id, arg) {
    this.records.push(START, id, arg, performance.now());
  }

  /**
   * Stop the current frame.
   */
  stop() {
    this.records.push(STOP, performance.now());
  }

  /**
   * Increment the number of times this symbol is called.
   * @param {number} id The id returned by idByName for a name symbol.
   */
  increment(id) {
    if (!this.increments[id]) {
      this.increments[id] = new ProfilerFrame(-1);
      this.increments[id].id = id;
    }
    this.increments[id].count += 1;
  }

  /**
   * Find or create a ProfilerFrame-like object whose counter can be
   * incremented outside of the Profiler.
   * @param {number} id The id returned by idByName for a name symbol.
   * @param {*} arg The argument for a frame that identifies it in addition
   *   to the id.
   * @return {{count: number}} A ProfilerFrame-like whose count should be
   *   incremented for each call.
   */
  frame(id, arg) {
    for (let i = 0; i < this.counters.length; i++) {
      if (this.counters[i].id === id && this.counters[i].arg === arg) {
        return this.counters[i];
      }
    }
    const newCounter = new ProfilerFrame(-1);
    newCounter.id = id;
    newCounter.arg = arg;
    this.counters.push(newCounter);
    return newCounter;
  }

  /**
   * Decode records and report all frames to `this.onFrame`.
   */
  reportFrames() {
    const stack = this._stack;
    let depth = 1;

    // Step through the records and initialize Frame instances from the
    // START and STOP events. START and STOP events are separated by events
    // for deeper frames run by higher frames. Frames are stored on a stack
    // and reinitialized for each START event. When a stop event is reach
    // the Frame for the current depth has its final values stored and its
    // passed to the current onFrame callback. This way Frames are "pushed"
    // for each START event and "popped" for each STOP and handed to an
    // outside handle to any desired reduction of the collected data.
    for (let i = 0; i < this.records.length;) {
      if (this.records[i] === START) {
        if (depth >= stack.length) {
          stack.push(new ProfilerFrame(depth));
        }

        // Store id, arg, totalTime, and initialize selfTime.
        const frame = stack[depth++];
        frame.id = this.records[i + 1];
        frame.arg = this.records[i + 2];
        // totalTime is first set as the time recorded by this START
        // event. Once the STOP event is reached the stored start time
        // is subtracted from the recorded stop time. The resulting
        // difference is the actual totalTime, and replaces the start
        // time in frame.totalTime.
        //
        // totalTime is used this way as a convenient member to store a
        // value between the two events without needing additional
        // members on the Frame or in a shadow map.
        frame.totalTime = this.records[i + 3];
        // selfTime is decremented until we reach the STOP event for
        // this frame. totalTime will be added to it then to get the
        // time difference.
        frame.selfTime = 0;
        i += START_SIZE;
      } else if (this.records[i] === STOP) {
        const now = this.records[i + 1];
        const frame = stack[--depth];
        // totalTime is the difference between the start event time
        // stored in totalTime and the stop event time pulled from this
        // record.
        frame.totalTime = now - frame.totalTime;
        // selfTime is the difference of this frame's totalTime and the
        // sum of totalTime of deeper frames.
        frame.selfTime += frame.totalTime;

        // Remove this frames totalTime from the parent's selfTime.
        stack[depth - 1].selfTime -= frame.totalTime;

        // This frame occured once.
        frame.count = 1;
        this.onFrame(frame);
        i += STOP_SIZE;
      } else {
        this.records.length = 0;
        throw new Error('Unable to decode Profiler records.');
      }
    }
    for (let j = 0; j < this.increments.length; j++) {
      if (this.increments[j] && this.increments[j].count > 0) {
        this.onFrame(this.increments[j]);
        this.increments[j].count = 0;
      }
    }
    for (let k = 0; k < this.counters.length; k++) {
      if (this.counters[k].count > 0) {
        this.onFrame(this.counters[k]);
        this.counters[k].count = 0;
      }
    }
    this.records.length = 0;
  }

  /**
   * Lookup or create an id for a frame name.
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */
  idByName(name) {
    return Profiler.idByName(name);
  }

  /**
   * Reverse lookup the name from a given frame id.
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */
  nameById(id) {
    return Profiler.nameById(id);
  }

  /**
   * Lookup or create an id for a frame name.
   * @static
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */
  static idByName(name) {
    if (typeof profilerNames[name] !== 'number') {
      profilerNames[name] = nextId++;
    }
    return profilerNames[name];
  }

  /**
   * Reverse lookup the name from a given frame id.
   * @static
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */
  static nameById(id) {
    for (const name in profilerNames) {
      if (profilerNames[name] === id) {
        return name;
      }
    }
    return null;
  }

  /**
   * Profiler is only available on platforms with the Performance API.
   * @return {boolean} Can the Profiler run in this browser?
   */
  static available() {
    return typeof window === 'object' && typeof window.performance !== 'undefined';
  }
}

/**
 * A reference to the START record id constant.
 * @const {number}
 */
Profiler.START = START;

/**
 * A reference to the STOP record id constant.
 * @const {number}
 */
Profiler.STOP = STOP;
module.exports = Profiler;

/***/ }),

/***/ "./src/engine/runtime.js":
/*!*******************************!*\
  !*** ./src/engine/runtime.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const {
  OrderedMap
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
const uuid = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");
const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");
const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");
const Profiler = __webpack_require__(/*! ./profiler */ "./src/engine/profiler.js");
const Sequencer = __webpack_require__(/*! ./sequencer */ "./src/engine/sequencer.js");
const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");
const ScratchBlocksConstants = __webpack_require__(/*! ./scratch-blocks-constants */ "./src/engine/scratch-blocks-constants.js");
const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");
const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");
const StageLayering = __webpack_require__(/*! ./stage-layering */ "./src/engine/stage-layering.js");
const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");
const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");
const ScratchLinkWebSocket = __webpack_require__(/*! ../util/scratch-link-websocket */ "./src/util/scratch-link-websocket.js");
const fetchWithTimeout = __webpack_require__(/*! ../util/fetch-with-timeout */ "./src/util/fetch-with-timeout.js");

// Virtual I/O devices.
const Clock = __webpack_require__(/*! ../io/clock */ "./src/io/clock.js");
const Cloud = __webpack_require__(/*! ../io/cloud */ "./src/io/cloud.js");
const Keyboard = __webpack_require__(/*! ../io/keyboard */ "./src/io/keyboard.js");
const Mouse = __webpack_require__(/*! ../io/mouse */ "./src/io/mouse.js");
const MouseWheel = __webpack_require__(/*! ../io/mouseWheel */ "./src/io/mouseWheel.js");
const UserData = __webpack_require__(/*! ../io/userData */ "./src/io/userData.js");
const Video = __webpack_require__(/*! ../io/video */ "./src/io/video.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const defaultBlockPackages = {
  scratch3_control: __webpack_require__(/*! ../blocks/scratch3_control */ "./src/blocks/scratch3_control.js"),
  scratch3_event: __webpack_require__(/*! ../blocks/scratch3_event */ "./src/blocks/scratch3_event.js"),
  scratch3_looks: __webpack_require__(/*! ../blocks/scratch3_looks */ "./src/blocks/scratch3_looks.js"),
  scratch3_motion: __webpack_require__(/*! ../blocks/scratch3_motion */ "./src/blocks/scratch3_motion.js"),
  scratch3_operators: __webpack_require__(/*! ../blocks/scratch3_operators */ "./src/blocks/scratch3_operators.js"),
  scratch3_sound: __webpack_require__(/*! ../blocks/scratch3_sound */ "./src/blocks/scratch3_sound.js"),
  scratch3_sensing: __webpack_require__(/*! ../blocks/scratch3_sensing */ "./src/blocks/scratch3_sensing.js"),
  scratch3_data: __webpack_require__(/*! ../blocks/scratch3_data */ "./src/blocks/scratch3_data.js"),
  scratch3_procedures: __webpack_require__(/*! ../blocks/scratch3_procedures */ "./src/blocks/scratch3_procedures.js")
};
const defaultExtensionColors = ['#0FBD8C', '#0DA57A', '#0B8E69'];

/**
 * Information used for converting Scratch argument types into scratch-blocks data.
 * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}
 */
const ArgumentTypeMap = (() => {
  const map = {};
  map[ArgumentType.ANGLE] = {
    shadow: {
      type: 'math_angle',
      // We specify fieldNames here so that we can pick
      // create and populate a field with the defaultValue
      // specified in the extension.
      // When the `fieldName` property is not specified,
      // the <field></field> will be left out of the XML and
      // the scratch-blocks defaults for that field will be
      // used instead (e.g. default of 0 for number fields)
      fieldName: 'NUM'
    }
  };
  map[ArgumentType.COLOR] = {
    shadow: {
      type: 'colour_picker',
      fieldName: 'COLOUR'
    }
  };
  map[ArgumentType.NUMBER] = {
    shadow: {
      type: 'math_number',
      fieldName: 'NUM'
    }
  };
  map[ArgumentType.STRING] = {
    shadow: {
      type: 'text',
      fieldName: 'TEXT'
    }
  };
  map[ArgumentType.BOOLEAN] = {
    check: 'Boolean'
  };
  map[ArgumentType.MATRIX] = {
    shadow: {
      type: 'matrix',
      fieldName: 'MATRIX'
    }
  };
  map[ArgumentType.NOTE] = {
    shadow: {
      type: 'note',
      fieldName: 'NOTE'
    }
  };
  map[ArgumentType.IMAGE] = {
    // Inline images are weird because they're not actually "arguments".
    // They are more analagous to the label on a block.
    fieldType: 'field_image'
  };
  return map;
})();

/**
 * A pair of functions used to manage the cloud variable limit,
 * to be used when adding (or attempting to add) or removing a cloud variable.
 * @typedef {object} CloudDataManager
 * @property {function} canAddCloudVariable A function to call to check that
 * a cloud variable can be added.
 * @property {function} addCloudVariable A function to call to track a new
 * cloud variable on the runtime.
 * @property {function} removeCloudVariable A function to call when
 * removing an existing cloud variable.
 * @property {function} hasCloudVariables A function to call to check that
 * the runtime has any cloud variables.
 */

/**
 * Creates and manages cloud variable limit in a project,
 * and returns two functions to be used to add a new
 * cloud variable (while checking that it can be added)
 * and remove an existing cloud variable.
 * These are to be called whenever attempting to create or delete
 * a cloud variable.
 * @return {CloudDataManager} The functions to be used when adding or removing a
 * cloud variable.
 */
const cloudDataManager = () => {
  const limit = 10;
  let count = 0;
  const canAddCloudVariable = () => count < limit;
  const addCloudVariable = () => {
    count++;
  };
  const removeCloudVariable = () => {
    count--;
  };
  const hasCloudVariables = () => count > 0;
  return {
    canAddCloudVariable,
    addCloudVariable,
    removeCloudVariable,
    hasCloudVariables
  };
};

/**
 * Numeric ID for Runtime._step in Profiler instances.
 * @type {number}
 */
let stepProfilerId = -1;

/**
 * Numeric ID for Sequencer.stepThreads in Profiler instances.
 * @type {number}
 */
let stepThreadsProfilerId = -1;

/**
 * Numeric ID for RenderWebGL.draw in Profiler instances.
 * @type {number}
 */
let rendererDrawProfilerId = -1;

/**
 * Manages targets, scripts, and the sequencer.
 * @constructor
 */
class Runtime extends EventEmitter {
  constructor() {
    super();

    /**
     * Target management and storage.
     * @type {Array.<!Target>}
     */
    this.targets = [];

    /**
     * Targets in reverse order of execution. Shares its order with drawables.
     * @type {Array.<!Target>}
     */
    this.executableTargets = [];

    /**
     * A list of threads that are currently running in the VM.
     * Threads are added when execution starts and pruned when execution ends.
     * @type {Array.<Thread>}
     */
    this.threads = [];

    /** @type {!Sequencer} */
    this.sequencer = new Sequencer(this);

    /**
     * Storage container for flyout blocks.
     * These will execute on `_editingTarget.`
     * @type {!Blocks}
     */
    this.flyoutBlocks = new Blocks(this, true /* force no glow */);

    /**
     * Storage container for monitor blocks.
     * These will execute on a target maybe
     * @type {!Blocks}
     */
    this.monitorBlocks = new Blocks(this, true /* force no glow */);

    /**
     * Currently known editing target for the VM.
     * @type {?Target}
     */
    this._editingTarget = null;

    /**
     * Map to look up a block primitive's implementation function by its opcode.
     * This is a two-step lookup: package name first, then primitive name.
     * @type {Object.<string, Function>}
     */
    this._primitives = {};

    /**
     * Map to look up all block information by extended opcode.
     * @type {Array.<CategoryInfo>}
     * @private
     */
    this._blockInfo = [];

    /**
     * Map to look up hat blocks' metadata.
     * Keys are opcode for hat, values are metadata objects.
     * @type {Object.<string, Object>}
     */
    this._hats = {};

    /**
     * A list of script block IDs that were glowing during the previous frame.
     * @type {!Array.<!string>}
     */
    this._scriptGlowsPreviousFrame = [];

    /**
     * Number of non-monitor threads running during the previous frame.
     * @type {number}
     */
    this._nonMonitorThreadCount = 0;

    /**
     * All threads that finished running and were removed from this.threads
     * by behaviour in Sequencer.stepThreads.
     * @type {Array<Thread>}
     */
    this._lastStepDoneThreads = null;

    /**
     * Currently known number of clones, used to enforce clone limit.
     * @type {number}
     */
    this._cloneCounter = 0;

    /**
     * Flag to emit a targets update at the end of a step. When target data
     * changes, this flag is set to true.
     * @type {boolean}
     */
    this._refreshTargets = false;

    /**
     * Map to look up all monitor block information by opcode.
     * @type {object}
     * @private
     */
    this.monitorBlockInfo = {};

    /**
     * Ordered map of all monitors, which are MonitorReporter objects.
     */
    this._monitorState = OrderedMap({});

    /**
     * Monitor state from last tick
     */
    this._prevMonitorState = OrderedMap({});

    /**
     * Whether the project is in "turbo mode."
     * @type {Boolean}
     */
    this.turboMode = false;

    /**
     * Whether the project is in "compatibility mode" (30 TPS).
     * @type {Boolean}
     */
    this.compatibilityMode = false;

    /**
     * A reference to the current runtime stepping interval, set
     * by a `setInterval`.
     * @type {!number}
     */
    this._steppingInterval = null;

    /**
     * Current length of a step.
     * Changes as mode switches, and used by the sequencer to calculate
     * WORK_TIME.
     * @type {!number}
     */
    this.currentStepTime = null;

    // Set an intial value for this.currentMSecs
    this.updateCurrentMSecs();

    /**
     * Whether any primitive has requested a redraw.
     * Affects whether `Sequencer.stepThreads` will yield
     * after stepping each thread.
     * Reset on every frame.
     * @type {boolean}
     */
    this.redrawRequested = false;

    // Register all given block packages.
    this._registerBlockPackages();

    // Register and initialize "IO devices", containers for processing
    // I/O related data.
    /** @type {Object.<string, Object>} */
    this.ioDevices = {
      clock: new Clock(this),
      cloud: new Cloud(this),
      keyboard: new Keyboard(this),
      mouse: new Mouse(this),
      mouseWheel: new MouseWheel(this),
      userData: new UserData(),
      video: new Video(this)
    };

    /**
     * A list of extensions, used to manage hardware connection.
     */
    this.peripheralExtensions = {};

    /**
     * A runtime profiler that records timed events for later playback to
     * diagnose Scratch performance.
     * @type {Profiler}
     */
    this.profiler = null;
    const newCloudDataManager = cloudDataManager();

    /**
     * Check wether the runtime has any cloud data.
     * @type {function}
     * @return {boolean} Whether or not the runtime currently has any
     * cloud variables.
     */
    this.hasCloudData = newCloudDataManager.hasCloudVariables;

    /**
     * A function which checks whether a new cloud variable can be added
     * to the runtime.
     * @type {function}
     * @return {boolean} Whether or not a new cloud variable can be added
     * to the runtime.
     */
    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;

    /**
     * A function that tracks a new cloud variable in the runtime,
     * updating the cloud variable limit. Calling this function will
     * emit a cloud data update event if this is the first cloud variable
     * being added.
     * @type {function}
     */
    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);

    /**
     * A function which updates the runtime's cloud variable limit
     * when removing a cloud variable and emits a cloud update event
     * if the last of the cloud variables is being removed.
     * @type {function}
     */
    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);

    /**
     * A string representing the origin of the current project from outside of the
     * Scratch community, such as CSFirst.
     * @type {?string}
     */
    this.origin = null;
    this._initScratchLink();
    this.resetRunId();
  }

  /**
   * Width of the stage, in pixels.
   * @const {number}
   */
  static get STAGE_WIDTH() {
    return 480;
  }

  /**
   * Height of the stage, in pixels.
   * @const {number}
   */
  static get STAGE_HEIGHT() {
    return 360;
  }

  /**
   * Event name for glowing a script.
   * @const {string}
   */
  static get SCRIPT_GLOW_ON() {
    return 'SCRIPT_GLOW_ON';
  }

  /**
   * Event name for unglowing a script.
   * @const {string}
   */
  static get SCRIPT_GLOW_OFF() {
    return 'SCRIPT_GLOW_OFF';
  }

  /**
   * Event name for glowing a block.
   * @const {string}
   */
  static get BLOCK_GLOW_ON() {
    return 'BLOCK_GLOW_ON';
  }

  /**
   * Event name for unglowing a block.
   * @const {string}
   */
  static get BLOCK_GLOW_OFF() {
    return 'BLOCK_GLOW_OFF';
  }

  /**
   * Event name for a cloud data update
   * to this project.
   * @const {string}
   */
  static get HAS_CLOUD_DATA_UPDATE() {
    return 'HAS_CLOUD_DATA_UPDATE';
  }

  /**
   * Event name for turning on turbo mode.
   * @const {string}
   */
  static get TURBO_MODE_ON() {
    return 'TURBO_MODE_ON';
  }

  /**
   * Event name for turning off turbo mode.
   * @const {string}
   */
  static get TURBO_MODE_OFF() {
    return 'TURBO_MODE_OFF';
  }

  /**
   * Event name when the project is started (threads may not necessarily be
   * running).
   * @const {string}
   */
  static get PROJECT_START() {
    return 'PROJECT_START';
  }

  /**
   * Event name when threads start running.
   * Used by the UI to indicate running status.
   * @const {string}
   */
  static get PROJECT_RUN_START() {
    return 'PROJECT_RUN_START';
  }

  /**
   * Event name when threads stop running
   * Used by the UI to indicate not-running status.
   * @const {string}
   */
  static get PROJECT_RUN_STOP() {
    return 'PROJECT_RUN_STOP';
  }

  /**
   * Event name for project being stopped or restarted by the user.
   * Used by blocks that need to reset state.
   * @const {string}
   */
  static get PROJECT_STOP_ALL() {
    return 'PROJECT_STOP_ALL';
  }

  /**
   * Event name for target being stopped by a stop for target call.
   * Used by blocks that need to stop individual targets.
   * @const {string}
   */
  static get STOP_FOR_TARGET() {
    return 'STOP_FOR_TARGET';
  }

  /**
   * Event name for visual value report.
   * @const {string}
   */
  static get VISUAL_REPORT() {
    return 'VISUAL_REPORT';
  }

  /**
   * Event name for project loaded report.
   * @const {string}
   */
  static get PROJECT_LOADED() {
    return 'PROJECT_LOADED';
  }

  /**
   * Event name for report that a change was made that can be saved
   * @const {string}
   */
  static get PROJECT_CHANGED() {
    return 'PROJECT_CHANGED';
  }

  /**
   * Event name for report that a change was made to an extension in the toolbox.
   * @const {string}
   */
  static get TOOLBOX_EXTENSIONS_NEED_UPDATE() {
    return 'TOOLBOX_EXTENSIONS_NEED_UPDATE';
  }

  /**
   * Event name for targets update report.
   * @const {string}
   */
  static get TARGETS_UPDATE() {
    return 'TARGETS_UPDATE';
  }

  /**
   * Event name for monitors update.
   * @const {string}
   */
  static get MONITORS_UPDATE() {
    return 'MONITORS_UPDATE';
  }

  /**
   * Event name for block drag update.
   * @const {string}
   */
  static get BLOCK_DRAG_UPDATE() {
    return 'BLOCK_DRAG_UPDATE';
  }

  /**
   * Event name for block drag end.
   * @const {string}
   */
  static get BLOCK_DRAG_END() {
    return 'BLOCK_DRAG_END';
  }

  /**
   * Event name for reporting that an extension was added.
   * @const {string}
   */
  static get EXTENSION_ADDED() {
    return 'EXTENSION_ADDED';
  }

  /**
   * Event name for reporting that an extension as asked for a custom field to be added
   * @const {string}
   */
  static get EXTENSION_FIELD_ADDED() {
    return 'EXTENSION_FIELD_ADDED';
  }

  /**
   * Event name for updating the available set of peripheral devices.
   * This causes the peripheral connection modal to update a list of
   * available peripherals.
   * @const {string}
   */
  static get PERIPHERAL_LIST_UPDATE() {
    return 'PERIPHERAL_LIST_UPDATE';
  }

  /**
   * Event name for when the user picks a bluetooth device to connect to
   * via Companion Device Manager (CDM)
   * @const {string}
   */
  static get USER_PICKED_PERIPHERAL() {
    return 'USER_PICKED_PERIPHERAL';
  }

  /**
   * Event name for reporting that a peripheral has connected.
   * This causes the status button in the blocks menu to indicate 'connected'.
   * @const {string}
   */
  static get PERIPHERAL_CONNECTED() {
    return 'PERIPHERAL_CONNECTED';
  }

  /**
   * Event name for reporting that a peripheral has been intentionally disconnected.
   * This causes the status button in the blocks menu to indicate 'disconnected'.
   * @const {string}
   */
  static get PERIPHERAL_DISCONNECTED() {
    return 'PERIPHERAL_DISCONNECTED';
  }

  /**
   * Event name for reporting that a peripheral has encountered a request error.
   * This causes the peripheral connection modal to switch to an error state.
   * @const {string}
   */
  static get PERIPHERAL_REQUEST_ERROR() {
    return 'PERIPHERAL_REQUEST_ERROR';
  }

  /**
   * Event name for reporting that a peripheral connection has been lost.
   * This causes a 'peripheral connection lost' error alert to display.
   * @const {string}
   */
  static get PERIPHERAL_CONNECTION_LOST_ERROR() {
    return 'PERIPHERAL_CONNECTION_LOST_ERROR';
  }

  /**
   * Event name for reporting that a peripheral has not been discovered.
   * This causes the peripheral connection modal to show a timeout state.
   * @const {string}
   */
  static get PERIPHERAL_SCAN_TIMEOUT() {
    return 'PERIPHERAL_SCAN_TIMEOUT';
  }

  /**
   * Event name to indicate that the microphone is being used to stream audio.
   * @const {string}
   */
  static get MIC_LISTENING() {
    return 'MIC_LISTENING';
  }

  /**
   * Event name for reporting that blocksInfo was updated.
   * @const {string}
   */
  static get BLOCKSINFO_UPDATE() {
    return 'BLOCKSINFO_UPDATE';
  }

  /**
   * Event name when the runtime tick loop has been started.
   * @const {string}
   */
  static get RUNTIME_STARTED() {
    return 'RUNTIME_STARTED';
  }

  /**
   * Event name when the runtime dispose has been called.
   * @const {string}
   */
  static get RUNTIME_DISPOSED() {
    return 'RUNTIME_DISPOSED';
  }

  /**
   * Event name for reporting that a block was updated and needs to be rerendered.
   * @const {string}
   */
  static get BLOCKS_NEED_UPDATE() {
    return 'BLOCKS_NEED_UPDATE';
  }

  /**
   * How rapidly we try to step threads by default, in ms.
   */
  static get THREAD_STEP_INTERVAL() {
    return 1000 / 60;
  }

  /**
   * In compatibility mode, how rapidly we try to step threads, in ms.
   */
  static get THREAD_STEP_INTERVAL_COMPATIBILITY() {
    return 1000 / 30;
  }

  /**
   * How many clones can be created at a time.
   * @const {number}
   */
  static get MAX_CLONES() {
    return 300;
  }

  // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------

  // Helper function for initializing the addCloudVariable function
  _initializeAddCloudVariable(newCloudDataManager) {
    // The addCloudVariable function
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.addCloudVariable();
      if (!hadCloudVarsBefore && this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);
      }
    };
  }

  // Helper function for initializing the removeCloudVariable function
  _initializeRemoveCloudVariable(newCloudDataManager) {
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.removeCloudVariable();
      if (hadCloudVarsBefore && !this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
      }
    };
  }

  /**
   * Register default block packages with this runtime.
   * @todo Prefix opcodes with package name.
   * @private
   */
  _registerBlockPackages() {
    for (const packageName in defaultBlockPackages) {
      if (Object.prototype.hasOwnProperty.call(defaultBlockPackages, packageName)) {
        // @todo pass a different runtime depending on package privilege?
        const packageObject = new defaultBlockPackages[packageName](this);
        // Collect primitives from package.
        if (packageObject.getPrimitives) {
          const packagePrimitives = packageObject.getPrimitives();
          for (const op in packagePrimitives) {
            if (Object.prototype.hasOwnProperty.call(packagePrimitives, op)) {
              this._primitives[op] = packagePrimitives[op].bind(packageObject);
            }
          }
        }
        // Collect hat metadata from package.
        if (packageObject.getHats) {
          const packageHats = packageObject.getHats();
          for (const hatName in packageHats) {
            if (Object.prototype.hasOwnProperty.call(packageHats, hatName)) {
              this._hats[hatName] = packageHats[hatName];
            }
          }
        }
        // Collect monitored from package.
        if (packageObject.getMonitored) {
          this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());
        }
      }
    }
  }
  getMonitorState() {
    return this._monitorState;
  }

  /**
   * Generate an extension-specific menu ID.
   * @param {string} menuName - the name of the menu.
   * @param {string} extensionId - the ID of the extension hosting the menu.
   * @returns {string} - the constructed ID.
   * @private
   */
  _makeExtensionMenuId(menuName, extensionId) {
    return "".concat(extensionId, "_menu_").concat(xmlEscape(menuName));
  }

  /**
   * Create a context ("args") object for use with `formatMessage` on messages which might be target-specific.
   * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current
   * editing target or the stage.
   */
  makeMessageContextForTarget(target) {
    const context = {};
    target = target || this.getEditingTarget() || this.getTargetForStage();
    if (target) {
      context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;
    }
  }

  /**
   * Register the primitives provided by an extension.
   * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)
   * @private
   */
  _registerExtensionPrimitives(extensionInfo) {
    const categoryInfo = {
      id: extensionInfo.id,
      name: maybeFormatMessage(extensionInfo.name),
      showStatusButton: extensionInfo.showStatusButton,
      blockIconURI: extensionInfo.blockIconURI,
      menuIconURI: extensionInfo.menuIconURI
    };
    if (extensionInfo.color1) {
      categoryInfo.color1 = extensionInfo.color1;
      categoryInfo.color2 = extensionInfo.color2;
      categoryInfo.color3 = extensionInfo.color3;
    } else {
      categoryInfo.color1 = defaultExtensionColors[0];
      categoryInfo.color2 = defaultExtensionColors[1];
      categoryInfo.color3 = defaultExtensionColors[2];
    }
    this._blockInfo.push(categoryInfo);
    this._fillExtensionCategory(categoryInfo, extensionInfo);
    for (const fieldTypeName in categoryInfo.customFieldTypes) {
      if (Object.prototype.hasOwnProperty.call(extensionInfo.customFieldTypes, fieldTypeName)) {
        const fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName];

        // Emit events for custom field types from extension
        this.emit(Runtime.EXTENSION_FIELD_ADDED, {
          name: "field_".concat(fieldTypeInfo.extendedName),
          implementation: fieldTypeInfo.fieldImplementation
        });
      }
    }
    this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
  }

  /**
   * Reregister the primitives for an extension
   * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension
   * @private
   */
  _refreshExtensionPrimitives(extensionInfo) {
    const categoryInfo = this._blockInfo.find(info => info.id === extensionInfo.id);
    if (categoryInfo) {
      categoryInfo.name = maybeFormatMessage(extensionInfo.name);
      this._fillExtensionCategory(categoryInfo, extensionInfo);
      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    }
  }

  /**
   * Read extension information, convert menus, blocks and custom field types
   * and store the results in the provided category object.
   * @param {CategoryInfo} categoryInfo - the category to be filled
   * @param {ExtensionMetadata} extensionInfo - the extension metadata to read
   * @private
   */
  _fillExtensionCategory(categoryInfo, extensionInfo) {
    categoryInfo.blocks = [];
    categoryInfo.customFieldTypes = {};
    categoryInfo.menus = [];
    categoryInfo.menuInfo = {};
    for (const menuName in extensionInfo.menus) {
      if (Object.prototype.hasOwnProperty.call(extensionInfo.menus, menuName)) {
        const menuInfo = extensionInfo.menus[menuName];
        const convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);
        categoryInfo.menus.push(convertedMenu);
        categoryInfo.menuInfo[menuName] = menuInfo;
      }
    }
    for (const fieldTypeName in extensionInfo.customFieldTypes) {
      if (Object.prototype.hasOwnProperty.call(extensionInfo.customFieldTypes, fieldTypeName)) {
        const fieldType = extensionInfo.customFieldTypes[fieldTypeName];
        const fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);
        categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;
      }
    }
    for (const blockInfo of extensionInfo.blocks) {
      try {
        const convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);
        categoryInfo.blocks.push(convertedBlock);
        if (convertedBlock.json) {
          const opcode = convertedBlock.json.type;
          if (blockInfo.blockType !== BlockType.EVENT) {
            this._primitives[opcode] = convertedBlock.info.func;
          }
          if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {
            this._hats[opcode] = {
              edgeActivated: blockInfo.isEdgeActivated,
              restartExistingThreads: blockInfo.shouldRestartExistingThreads
            };
          }
        }
      } catch (e) {
        log.error('Error parsing block: ', {
          block: blockInfo,
          error: e
        });
      }
    }
  }

  /**
   * Convert the given extension menu items into the scratch-blocks style of list of pairs.
   * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.
   * @param {object} menuItems - an array of menu items or a function to retrieve such an array
   * @returns {object} - an array of 2 element arrays or the original input function
   * @private
   */
  _convertMenuItems(menuItems) {
    if (typeof menuItems !== 'function') {
      const extensionMessageContext = this.makeMessageContextForTarget();
      return menuItems.map(item => {
        const formattedItem = maybeFormatMessage(item, extensionMessageContext);
        switch (typeof formattedItem) {
          case 'string':
            return [formattedItem, formattedItem];
          case 'object':
            return [maybeFormatMessage(item.text, extensionMessageContext), item.value];
          default:
            throw new Error("Can't interpret menu item: ".concat(JSON.stringify(item)));
        }
      });
    }
    return menuItems;
  }

  /**
   * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.
   * @param {string} menuName - the name of the menu
   * @param {object} menuInfo - a description of this menu and its items
   * @property {*} items - an array of menu items or a function to retrieve such an array
   * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption
   * @private
   */
  _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {
    const menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);
    const menuItems = this._convertMenuItems(menuInfo.items);
    return {
      json: {
        message0: '%1',
        type: menuId,
        inputsInline: true,
        output: 'String',
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: menuInfo.acceptReporters ? ScratchBlocksConstants.OUTPUT_SHAPE_ROUND : ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE,
        args0: [{
          type: 'field_dropdown',
          name: menuName,
          options: menuItems
        }]
      }
    };
  }
  _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {
    const extendedName = "".concat(extensionId, "_").concat(fieldName);
    return {
      fieldName: fieldName,
      extendedName: extendedName,
      argumentTypeInfo: {
        shadow: {
          type: extendedName,
          fieldName: "field_".concat(extendedName)
        }
      },
      scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),
      fieldImplementation: fieldInfo.implementation
    };
  }

  /**
   * Build the scratch-blocks JSON needed for a fieldType.
   * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other
   * @param  {string} fieldName - The name of the field
   * @param {string} output - The output of the field
   * @param {number} outputShape - Shape of the field (from ScratchBlocksConstants)
   * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)
   * @returns {object} - Object to be inserted into scratch-blocks
   */
  _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {
    return {
      json: {
        type: fieldName,
        message0: '%1',
        inputsInline: true,
        output: output,
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: outputShape,
        args0: [{
          name: "field_".concat(fieldName),
          type: "field_".concat(fieldName)
        }]
      }
    };
  }

  /**
   * Convert ExtensionBlockMetadata into data ready for scratch-blocks.
   * @param {ExtensionBlockMetadata} blockInfo - the block info to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */
  _convertForScratchBlocks(blockInfo, categoryInfo) {
    if (blockInfo === '---') {
      return this._convertSeparatorForScratchBlocks(blockInfo);
    }
    if (blockInfo.blockType === BlockType.BUTTON) {
      return this._convertButtonForScratchBlocks(blockInfo);
    }
    return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);
  }

  /**
   * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */
  _convertBlockForScratchBlocks(blockInfo, categoryInfo) {
    const extendedOpcode = "".concat(categoryInfo.id, "_").concat(blockInfo.opcode);
    const blockJSON = {
      type: extendedOpcode,
      inputsInline: true,
      category: categoryInfo.name,
      colour: categoryInfo.color1,
      colourSecondary: categoryInfo.color2,
      colourTertiary: categoryInfo.color3
    };
    const context = {
      // TODO: store this somewhere so that we can map args appropriately after translation.
      // This maps an arg name to its relative position in the original (usually English) block text.
      // When displaying a block in another language we'll need to run a `replace` action similar to the one
      // below, but each `[ARG]` will need to be replaced with the number in this map.
      argsMap: {},
      blockJSON,
      categoryInfo,
      blockInfo,
      inputList: []
    };

    // If an icon for the extension exists, prepend it to each block, with a vertical separator.
    // We can overspecify an icon for each block, but if no icon exists on a block, fall back to
    // the category block icon.
    const iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;
    if (iconURI) {
      blockJSON.extensions = ['scratch_extension'];
      blockJSON.message0 = '%1 %2';
      const iconJSON = {
        type: 'field_image',
        src: iconURI,
        width: 40,
        height: 40
      };
      const separatorJSON = {
        type: 'field_vertical_separator'
      };
      blockJSON.args0 = [iconJSON, separatorJSON];
    }
    switch (blockInfo.blockType) {
      case BlockType.COMMAND:
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat
        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }
        break;
      case BlockType.REPORTER:
        blockJSON.output = 'String'; // TODO: distinguish number & string here?
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;
        break;
      case BlockType.BOOLEAN:
        blockJSON.output = 'Boolean';
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;
        break;
      case BlockType.HAT:
      case BlockType.EVENT:
        if (!Object.prototype.hasOwnProperty.call(blockInfo, 'isEdgeActivated')) {
          // if absent, this property defaults to true
          blockInfo.isEdgeActivated = true;
        }
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        break;
      case BlockType.CONDITIONAL:
      case BlockType.LOOP:
        blockInfo.branchCount = blockInfo.branchCount || 1;
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat
        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }
        break;
    }
    const blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];
    let inTextNum = 0; // text for the next block "arm" is blockText[inTextNum]
    let inBranchNum = 0; // how many branches have we placed into the JSON so far?
    let outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`
    const convertPlaceholders = this._convertPlaceholders.bind(this, context);
    const extensionMessageContext = this.makeMessageContextForTarget();

    // alternate between a block "arm" with text on it and an open slot for a substack
    while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {
      if (inTextNum < blockText.length) {
        context.outLineNum = outLineNum;
        const lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);
        const convertedText = lineText.replace(/\[(.+?)]/g, convertPlaceholders);
        if (blockJSON["message".concat(outLineNum)]) {
          blockJSON["message".concat(outLineNum)] += convertedText;
        } else {
          blockJSON["message".concat(outLineNum)] = convertedText;
        }
        ++inTextNum;
        ++outLineNum;
      }
      if (inBranchNum < blockInfo.branchCount) {
        blockJSON["message".concat(outLineNum)] = '%1';
        blockJSON["args".concat(outLineNum)] = [{
          type: 'input_statement',
          name: "SUBSTACK".concat(inBranchNum > 0 ? inBranchNum + 1 : '')
        }];
        ++inBranchNum;
        ++outLineNum;
      }
    }
    if (blockInfo.blockType === BlockType.REPORTER) {
      if (!blockInfo.disableMonitor && context.inputList.length === 0) {
        blockJSON.checkboxInFlyout = true;
      }
    } else if (blockInfo.blockType === BlockType.LOOP) {
      // Add icon to the bottom right of a loop block
      blockJSON["lastDummyAlign".concat(outLineNum)] = 'RIGHT';
      blockJSON["message".concat(outLineNum)] = '%1';
      blockJSON["args".concat(outLineNum)] = [{
        type: 'field_image',
        src: './static/blocks-media/repeat.svg',
        // TODO: use a constant or make this configurable?
        width: 24,
        height: 24,
        alt: '*',
        // TODO remove this since we don't use collapsed blocks in scratch
        flip_rtl: true
      }];
      ++outLineNum;
    }
    const mutation = blockInfo.isDynamic ? "<mutation blockInfo=\"".concat(xmlEscape(JSON.stringify(blockInfo)), "\"/>") : '';
    const inputs = context.inputList.join('');
    const blockXML = "<block type=\"".concat(extendedOpcode, "\">").concat(mutation).concat(inputs, "</block>");
    return {
      info: context.blockInfo,
      json: context.blockJSON,
      xml: blockXML
    };
  }

  /**
   * Generate a separator between blocks categories or sub-categories.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */
  _convertSeparatorForScratchBlocks(blockInfo) {
    return {
      info: blockInfo,
      xml: '<sep gap="36"/>'
    };
  }

  /**
   * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.
   * @param {ExtensionBlockMetadata} buttonInfo - the button to convert
   * @property {string} func - the callback name
   * @param {CategoryInfo} categoryInfo - the category for this button
   * @returns {ConvertedBlockInfo} - the converted & original button information
   * @private
   */
  _convertButtonForScratchBlocks(buttonInfo) {
    // for now we only support these pre-defined callbacks handled in scratch-blocks
    const supportedCallbackKeys = ['MAKE_A_LIST', 'MAKE_A_PROCEDURE', 'MAKE_A_VARIABLE'];
    if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {
      log.error("Custom button callbacks not supported yet: ".concat(buttonInfo.func));
    }
    const extensionMessageContext = this.makeMessageContextForTarget();
    const buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);
    return {
      info: buttonInfo,
      xml: "<button text=\"".concat(buttonText, "\" callbackKey=\"").concat(buttonInfo.func, "\"></button>")
    };
  }

  /**
   * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block "arguments".
   * @param {object} argInfo Metadata about the inline image as specified by the extension
   * @return {object} JSON blob for a scratch-blocks image field.
   * @private
   */
  _constructInlineImageJson(argInfo) {
    if (!argInfo.dataURI) {
      log.warn('Missing data URI in extension block with argument type IMAGE');
    }
    return {
      type: 'field_image',
      src: argInfo.dataURI || '',
      // TODO these probably shouldn't be hardcoded...?
      width: 24,
      height: 24,
      // Whether or not the inline image should be flipped horizontally
      // in RTL languages. Defaults to false, indicating that the
      // image will not be flipped.
      flip_rtl: argInfo.flipRTL || false
    };
  }

  /**
   * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback
   * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.
   * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.
   * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.
   * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.
   * @return {string} scratch-blocks placeholder for the argument: '%1'.
   * @private
   */
  _convertPlaceholders(context, match, placeholder) {
    // Sanitize the placeholder to ensure valid XML
    placeholder = placeholder.replace(/[<"&]/, '_');

    // Determine whether the argument type is one of the known standard field types
    const argInfo = context.blockInfo.arguments[placeholder] || {};
    let argTypeInfo = ArgumentTypeMap[argInfo.type] || {};

    // Field type not a standard field type, see if extension has registered custom field type
    if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {
      argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;
    }

    // Start to construct the scratch-blocks style JSON defining how the block should be
    // laid out
    let argJSON;

    // Most field types are inputs (slots on the block that can have other blocks plugged into them)
    // check if this is not one of those cases. E.g. an inline image on a block.
    if (argTypeInfo.fieldType === 'field_image') {
      argJSON = this._constructInlineImageJson(argInfo);
    } else {
      // Construct input value

      // Layout a block argument (e.g. an input slot on the block)
      argJSON = {
        type: 'input_value',
        name: placeholder
      };
      const defaultValue = typeof argInfo.defaultValue === 'undefined' ? '' : xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());
      if (argTypeInfo.check) {
        // Right now the only type of 'check' we have specifies that the
        // input slot on the block accepts Boolean reporters, so it should be
        // shaped like a hexagon
        argJSON.check = argTypeInfo.check;
      }
      let valueName;
      let shadowType;
      let fieldName;
      if (argInfo.menu) {
        const menuInfo = context.categoryInfo.menuInfo[argInfo.menu];
        if (menuInfo.acceptReporters) {
          valueName = placeholder;
          shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);
          fieldName = argInfo.menu;
        } else {
          argJSON.type = 'field_dropdown';
          argJSON.options = this._convertMenuItems(menuInfo.items);
          valueName = null;
          shadowType = null;
          fieldName = placeholder;
        }
      } else {
        valueName = placeholder;
        shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;
        fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;
      }

      // <value> is the ScratchBlocks name for a block input.
      if (valueName) {
        context.inputList.push("<value name=\"".concat(placeholder, "\">"));
      }

      // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.
      // Boolean inputs don't need to specify a shadow in the XML.
      if (shadowType) {
        context.inputList.push("<shadow type=\"".concat(shadowType, "\">"));
      }

      // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.
      // Leave out the field if defaultValue or fieldName are not specified
      if (defaultValue && fieldName) {
        context.inputList.push("<field name=\"".concat(fieldName, "\">").concat(defaultValue, "</field>"));
      }
      if (shadowType) {
        context.inputList.push('</shadow>');
      }
      if (valueName) {
        context.inputList.push('</value>');
      }
    }
    const argsName = "args".concat(context.outLineNum);
    const blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];
    if (argJSON) blockArgs.push(argJSON);
    const argNum = blockArgs.length;
    context.argsMap[placeholder] = argNum;
    return "%".concat(argNum);
  }

  /**
   * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.
   * @param {?Target} [target] - the active editing target (optional)
   * @property {string} id - the category / extension ID
   * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`
   */
  getBlocksXML(target) {
    return this._blockInfo.map(categoryInfo => {
      const {
        name,
        color1,
        color2
      } = categoryInfo;
      // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's
      // `hideFromPalette` and `filter` properties.
      const paletteBlocks = categoryInfo.blocks.filter(block => {
        let blockFilterIncludesTarget = true;
        // If an editing target is not passed, include all blocks
        // If the block info doesn't include a `filter` property, always include it
        if (target && block.info.filter) {
          blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);
        }
        // If the block info's `hideFromPalette` is true, then filter out this block
        return blockFilterIncludesTarget && !block.info.hideFromPalette;
      });
      const colorXML = "colour=\"".concat(color1, "\" secondaryColour=\"").concat(color2, "\"");

      // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,
      // the category menu will show its default colored circle.
      let menuIconURI = '';
      if (categoryInfo.menuIconURI) {
        menuIconURI = categoryInfo.menuIconURI;
      } else if (categoryInfo.blockIconURI) {
        menuIconURI = categoryInfo.blockIconURI;
      }
      const menuIconXML = menuIconURI ? "iconURI=\"".concat(menuIconURI, "\"") : '';
      let statusButtonXML = '';
      if (categoryInfo.showStatusButton) {
        statusButtonXML = 'showStatusButton="true"';
      }
      return {
        id: categoryInfo.id,
        xml: "<category name=\"".concat(name, "\" id=\"").concat(categoryInfo.id, "\" ").concat(statusButtonXML, " ").concat(colorXML, " ").concat(menuIconXML, ">").concat(paletteBlocks.map(block => block.xml).join(''), "</category>")
      };
    });
  }

  /**
   * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
   */
  getBlocksJSON() {
    return this._blockInfo.reduce((result, categoryInfo) => result.concat(categoryInfo.blocks.map(blockInfo => blockInfo.json)), []);
  }

  /**
   * One-time initialization for Scratch Link support.
   */
  _initScratchLink() {
    // Check that we're actually in a real browser, not Node.js or JSDOM, and we have a valid-looking origin.
    // note that `if (self?....)` will throw if `self` is undefined, so check for that first!
    if (typeof self !== 'undefined' && typeof document !== 'undefined' && document.getElementById && self.origin && self.origin !== 'null' &&
    // note this is a string comparison, not a null check
    self.navigator && self.navigator.userAgent && !(self.navigator.userAgent.includes('Node.js') || self.navigator.userAgent.includes('jsdom'))) {
      // Create a script tag for the Scratch Link browser extension, unless one already exists
      const scriptElement = document.getElementById('scratch-link-extension-script');
      if (!scriptElement) {
        const script = document.createElement('script');
        script.id = 'scratch-link-extension-script';
        document.body.appendChild(script);

        // Tell the browser extension to inject its script.
        // If the extension isn't present or isn't active, this will do nothing.
        self.postMessage('inject-scratch-link-script', self.origin);
      }
    }
  }

  /**
   * Get a scratch link socket.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The scratch link socket.
   */
  getScratchLinkSocket(type) {
    const factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;
    return factory(type);
  }

  /**
   * Configure how ScratchLink sockets are created. Factory must consume a "type" parameter
   * either BT or BLE.
   * @param {Function} factory The new factory for creating ScratchLink sockets.
   */
  configureScratchLinkSocketFactory(factory) {
    this._linkSocketFactory = factory;
  }

  /**
   * The default scratch link socket creator, using websockets to the installed device manager.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)
   */
  _defaultScratchLinkSocketFactory(type) {
    const Scratch = self.Scratch;
    const ScratchLinkSafariSocket = Scratch && Scratch.ScratchLinkSafariSocket;
    // detect this every time in case the user turns on the extension after loading the page
    const useSafariSocket = ScratchLinkSafariSocket && ScratchLinkSafariSocket.isSafariHelperCompatible();
    return useSafariSocket ? new ScratchLinkSafariSocket(type) : new ScratchLinkWebSocket(type);
  }

  /**
   * Register an extension that communications with a hardware peripheral by id,
   * to have access to it and its peripheral functions in the future.
   * @param {string} extensionId - the id of the extension.
   * @param {object} extension - the extension to register.
   */
  registerPeripheralExtension(extensionId, extension) {
    this.peripheralExtensions[extensionId] = extension;
  }

  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */
  scanForPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].scan();
    }
  }

  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */
  connectPeripheral(extensionId, peripheralId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].connect(peripheralId);
    }
  }

  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */
  disconnectPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].disconnect();
    }
  }

  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */
  getPeripheralIsConnected(extensionId) {
    let isConnected = false;
    if (this.peripheralExtensions[extensionId]) {
      isConnected = this.peripheralExtensions[extensionId].isConnected();
    }
    return isConnected;
  }

  /**
   * Emit an event to indicate that the microphone is being used to stream audio.
   * @param {boolean} listening - true if the microphone is currently listening.
   */
  emitMicListening(listening) {
    this.emit(Runtime.MIC_LISTENING, listening);
  }

  /**
   * Retrieve the function associated with the given opcode.
   * @param {!string} opcode The opcode to look up.
   * @return {Function} The function which implements the opcode.
   */
  getOpcodeFunction(opcode) {
    return this._primitives[opcode];
  }

  /**
   * Return whether an opcode represents a hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a hat.
   */
  getIsHat(opcode) {
    return Object.prototype.hasOwnProperty.call(this._hats, opcode);
  }

  /**
   * Return whether an opcode represents an edge-activated hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a edge-activated hat.
   */
  getIsEdgeActivatedHat(opcode) {
    return Object.prototype.hasOwnProperty.call(this._hats, opcode) && this._hats[opcode].edgeActivated;
  }

  /**
   * Attach the audio engine
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */
  attachAudioEngine(audioEngine) {
    this.audioEngine = audioEngine;
  }

  /**
   * Attach the renderer
   * @param {!RenderWebGL} renderer The renderer to attach
   */
  attachRenderer(renderer) {
    this.renderer = renderer;
    this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);
  }

  /**
   * Set the bitmap adapter for the VM/runtime, which converts scratch 2
   * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
   * @param {!function} bitmapAdapter The adapter to attach
   */
  attachV2BitmapAdapter(bitmapAdapter) {
    this.v2BitmapAdapter = bitmapAdapter;
  }

  /**
   * Attach the storage module
   * @param {!ScratchStorage} storage The storage module to attach
   */
  attachStorage(storage) {
    this.storage = storage;
    fetchWithTimeout.setFetch(storage.scratchFetch.scratchFetch);
    this.resetRunId();
  }

  // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------

  /**
   * Create a thread and push it to the list of threads.
   * @param {!string} id ID of block that starts the stack.
   * @param {!Target} target Target to run thread on.
   * @param {?object} opts optional arguments
   * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack
   * @param {?boolean} opts.updateMonitor true if the script should update a monitor value
   * @return {!Thread} The newly created thread.
   */
  _pushThread(id, target, opts) {
    const thread = new Thread(id);
    thread.target = target;
    thread.stackClick = Boolean(opts && opts.stackClick);
    thread.updateMonitor = Boolean(opts && opts.updateMonitor);
    thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;
    thread.pushStack(id);
    this.threads.push(thread);
    return thread;
  }

  /**
   * Stop a thread: stop running it immediately, and remove it from the thread list later.
   * @param {!Thread} thread Thread object to remove from actives
   */
  _stopThread(thread) {
    // Mark the thread for later removal
    thread.isKilled = true;
    // Inform sequencer to stop executing that thread.
    this.sequencer.retireThread(thread);
  }

  /**
   * Restart a thread in place, maintaining its position in the list of threads.
   * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
   * Test project: https://scratch.mit.edu/projects/130183108/
   * @param {!Thread} thread Thread object to restart.
   * @return {Thread} The restarted thread.
   */
  _restartThread(thread) {
    const newThread = new Thread(thread.topBlock);
    newThread.target = thread.target;
    newThread.stackClick = thread.stackClick;
    newThread.updateMonitor = thread.updateMonitor;
    newThread.blockContainer = thread.blockContainer;
    newThread.pushStack(thread.topBlock);
    const i = this.threads.indexOf(thread);
    if (i > -1) {
      this.threads[i] = newThread;
      return newThread;
    }
    this.threads.push(thread);
    return thread;
  }

  /**
   * Return whether a thread is currently active/running.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is active/running.
   */
  isActiveThread(thread) {
    return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;
  }

  /**
   * Return whether a thread is waiting for more information or done.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is waiting
   */
  isWaitingThread(thread) {
    return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);
  }

  /**
   * Toggle a script.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?object} opts optional arguments to toggle script
   * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
   * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
   *     determines whether we show a visual report when turning on the script.
   */
  toggleScript(topBlockId, opts) {
    opts = Object.assign({
      target: this._editingTarget,
      stackClick: false
    }, opts);
    // Remove any existing thread.
    for (let i = 0; i < this.threads.length; i++) {
      // Toggling a script that's already running turns it off
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {
        const blockContainer = opts.target.blocks;
        const opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));
        if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {
          // Allow edge activated hat thread stack click to coexist with
          // edge activated hat thread that runs every frame
          continue;
        }
        this._stopThread(this.threads[i]);
        return;
      }
    }
    // Otherwise add it.
    this._pushThread(topBlockId, opts.target, opts);
  }

  /**
   * Enqueue a script that when finished will update the monitor for the block.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
   */
  addMonitorScript(topBlockId, optTarget) {
    if (!optTarget) optTarget = this._editingTarget;
    for (let i = 0; i < this.threads.length; i++) {
      // Don't re-add the script if it's already running
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {
        return;
      }
    }
    // Otherwise add it.
    this._pushThread(topBlockId, optTarget, {
      updateMonitor: true
    });
  }

  /**
   * Run a function `f` for all scripts in a workspace.
   * `f` will be called with two parameters:
   *  - the top block ID of the script.
   *  - the target that owns the script.
   * @param {!Function} f Function to call for each script.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   */
  allScriptsDo(f, optTarget) {
    let targets = this.executableTargets;
    if (optTarget) {
      targets = [optTarget];
    }
    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = target.blocks.getScripts();
      for (let j = 0; j < scripts.length; j++) {
        const topBlockId = scripts[j];
        f(topBlockId, target);
      }
    }
  }
  allScriptsByOpcodeDo(opcode, f, optTarget) {
    let targets = this.executableTargets;
    if (optTarget) {
      targets = [optTarget];
    }
    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);
      for (let j = 0; j < scripts.length; j++) {
        f(scripts[j], target);
      }
    }
  }

  /**
   * Start all relevant hats.
   * @param {!string} requestedHatOpcode Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */
  startHats(requestedHatOpcode, optMatchFields, optTarget) {
    if (!Object.prototype.hasOwnProperty.call(this._hats, requestedHatOpcode)) {
      // No known hat with this opcode.
      return;
    }
    const instance = this;
    const newThreads = [];
    // Look up metadata for the relevant hat.
    const hatMeta = instance._hats[requestedHatOpcode];
    for (const opts in optMatchFields) {
      if (!Object.prototype.hasOwnProperty.call(optMatchFields, opts)) continue;
      optMatchFields[opts] = optMatchFields[opts].toUpperCase();
    }

    // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.
    this.allScriptsByOpcodeDo(requestedHatOpcode, (script, target) => {
      const {
        blockId: topBlockId,
        fieldsOfInputs: hatFields
      } = script;

      // Match any requested fields.
      // For example: ensures that broadcasts match.
      // This needs to happen before the block is evaluated
      // (i.e., before the predicate can be run) because "broadcast and wait"
      // needs to have a precise collection of started threads.
      for (const matchField in optMatchFields) {
        if (hatFields[matchField].value !== optMatchFields[matchField]) {
          // Field mismatch.
          return;
        }
      }
      if (hatMeta.restartExistingThreads) {
        // If `restartExistingThreads` is true, we should stop
        // any existing threads starting with the top block.
        for (let i = 0; i < this.threads.length; i++) {
          if (this.threads[i].target === target && this.threads[i].topBlock === topBlockId &&
          // stack click threads and hat threads can coexist
          !this.threads[i].stackClick) {
            newThreads.push(this._restartThread(this.threads[i]));
            return;
          }
        }
      } else {
        // If `restartExistingThreads` is false, we should
        // give up if any threads with the top block are running.
        for (let j = 0; j < this.threads.length; j++) {
          if (this.threads[j].target === target && this.threads[j].topBlock === topBlockId &&
          // stack click threads and hat threads can coexist
          !this.threads[j].stackClick && this.threads[j].status !== Thread.STATUS_DONE) {
            // Some thread is already running.
            return;
          }
        }
      }
      // Start the thread with this top block.
      newThreads.push(this._pushThread(topBlockId, target));
    }, optTarget);
    // For compatibility with Scratch 2, edge triggered hats need to be processed before
    // threads are stepped. See ScratchRuntime.as for original implementation
    newThreads.forEach(thread => {
      execute(this.sequencer, thread);
      thread.goToNextBlock();
    });
    return newThreads;
  }

  /**
   * Dispose all targets. Return to clean state.
   */
  dispose() {
    this.stopAll();
    // Deleting each target's variable's monitors.
    this.targets.forEach(target => {
      if (target.isOriginal) target.deleteMonitors();
    });
    this.targets.map(this.disposeTarget, this);
    this._monitorState = OrderedMap({});
    this.emit(Runtime.RUNTIME_DISPOSED);
    this.ioDevices.clock.resetProjectTimer();
    // @todo clear out extensions? turboMode? etc.

    // *********** Cloud *******************

    // If the runtime currently has cloud data,
    // emit a has cloud data update event resetting
    // it to false
    if (this.hasCloudData()) {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
    }
    this.ioDevices.cloud.clear();

    // Reset runtime cloud data info
    const newCloudDataManager = cloudDataManager();
    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }

  /**
   * Add a target to the runtime. This tracks the sprite pane
   * ordering of the target. The target still needs to be put
   * into the correct execution order after calling this function.
   * @param {Target} target target to add
   */
  addTarget(target) {
    this.targets.push(target);
    this.executableTargets.push(target);
  }

  /**
   * Move a target in the execution order by a relative amount.
   *
   * A positve number will make the target execute earlier. A negative number
   * will make the target execute later in the order.
   *
   * @param {Target} executableTarget target to move
   * @param {number} delta number of positions to move target by
   * @returns {number} new position in execution order
   */
  moveExecutable(executableTarget, delta) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    this.executableTargets.splice(oldIndex, 1);
    let newIndex = oldIndex + delta;
    if (newIndex > this.executableTargets.length) {
      newIndex = this.executableTargets.length;
    }
    if (newIndex <= 0) {
      if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {
        newIndex = 1;
      } else {
        newIndex = 0;
      }
    }
    this.executableTargets.splice(newIndex, 0, executableTarget);
    return newIndex;
  }

  /**
   * Set a target to execute at a specific position in the execution order.
   *
   * Infinity will set the target to execute first. 0 will set the target to
   * execute last (before the stage).
   *
   * @param {Target} executableTarget target to move
   * @param {number} newIndex position in execution order to place the target
   * @returns {number} new position in the execution order
   */
  setExecutablePosition(executableTarget, newIndex) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    return this.moveExecutable(executableTarget, newIndex - oldIndex);
  }

  /**
   * Remove a target from the execution set.
   * @param {Target} executableTarget target to remove
   */
  removeExecutable(executableTarget) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    if (oldIndex > -1) {
      this.executableTargets.splice(oldIndex, 1);
    }
  }

  /**
   * Dispose of a target.
   * @param {!Target} disposingTarget Target to dispose of.
   */
  disposeTarget(disposingTarget) {
    this.targets = this.targets.filter(target => {
      if (disposingTarget !== target) return true;
      // Allow target to do dispose actions.
      target.dispose();
      // Remove from list of targets.
      return false;
    });
  }

  /**
   * Stop any threads acting on the target.
   * @param {!Target} target Target to stop threads for.
   * @param {Thread=} optThreadException Optional thread to skip.
   */
  stopForTarget(target, optThreadException) {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException);

    // Stop any threads on the target.
    for (let i = 0; i < this.threads.length; i++) {
      if (this.threads[i] === optThreadException) {
        continue;
      }
      if (this.threads[i].target === target) {
        this._stopThread(this.threads[i]);
      }
    }
  }

  /**
   * Reset the Run ID. Call this any time the project logically starts, stops, or changes identity.
   */
  resetRunId() {
    if (!this.storage) {
      // see also: attachStorage
      return;
    }
    const newRunId = uuid.v1();
    this.storage.scratchFetch.setMetadata(this.storage.scratchFetch.RequestMetadata.RunId, newRunId);
  }

  /**
   * Start all threads that start with the green flag.
   */
  greenFlag() {
    this.stopAll();
    this.emit(Runtime.PROJECT_START);
    this.ioDevices.clock.resetProjectTimer();
    this.targets.forEach(target => target.clearEdgeActivatedValues());
    // Inform all targets of the green flag.
    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onGreenFlag();
    }
    this.startHats('event_whenflagclicked');
  }

  /**
   * Stop "everything."
   */
  stopAll() {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.PROJECT_STOP_ALL);

    // Dispose all clones.
    const newTargets = [];
    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onStopAll();
      if (Object.prototype.hasOwnProperty.call(this.targets[i], 'isOriginal') && !this.targets[i].isOriginal) {
        this.targets[i].dispose();
      } else {
        newTargets.push(this.targets[i]);
      }
    }
    this.targets = newTargets;
    // Dispose of the active thread.
    if (this.sequencer.activeThread !== null) {
      this._stopThread(this.sequencer.activeThread);
    }
    // Remove all remaining threads from executing in the next tick.
    this.threads = [];
    this.resetRunId();
  }

  /**
   * Repeatedly run `sequencer.stepThreads` and filter out
   * inactive threads after each iteration.
   */
  _step() {
    if (this.profiler !== null) {
      if (stepProfilerId === -1) {
        stepProfilerId = this.profiler.idByName('Runtime._step');
      }
      this.profiler.start(stepProfilerId);
    }

    // Clean up threads that were told to stop during or since the last step
    this.threads = this.threads.filter(thread => !thread.isKilled);

    // Find all edge-activated hats, and add them to threads to be evaluated.
    for (const hatType in this._hats) {
      if (!Object.prototype.hasOwnProperty.call(this._hats, hatType)) continue;
      const hat = this._hats[hatType];
      if (hat.edgeActivated) {
        this.startHats(hatType);
      }
    }
    this.redrawRequested = false;
    this._pushMonitors();
    if (this.profiler !== null) {
      if (stepThreadsProfilerId === -1) {
        stepThreadsProfilerId = this.profiler.idByName('Sequencer.stepThreads');
      }
      this.profiler.start(stepThreadsProfilerId);
    }
    const doneThreads = this.sequencer.stepThreads();
    if (this.profiler !== null) {
      this.profiler.stop();
    }
    this._updateGlows(doneThreads);
    // Add done threads so that even if a thread finishes within 1 frame, the green
    // flag will still indicate that a script ran.
    this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([...this.threads, ...doneThreads]));
    // Store threads that completed this iteration for testing and other
    // internal purposes.
    this._lastStepDoneThreads = doneThreads;
    if (this.renderer) {
      // @todo: Only render when this.redrawRequested or clones rendered.
      if (this.profiler !== null) {
        if (rendererDrawProfilerId === -1) {
          rendererDrawProfilerId = this.profiler.idByName('RenderWebGL.draw');
        }
        this.profiler.start(rendererDrawProfilerId);
      }
      this.renderer.draw();
      if (this.profiler !== null) {
        this.profiler.stop();
      }
    }
    if (this._refreshTargets) {
      this.emit(Runtime.TARGETS_UPDATE, false /* Don't emit project changed */);
      this._refreshTargets = false;
    }
    if (!this._prevMonitorState.equals(this._monitorState)) {
      this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
      this._prevMonitorState = this._monitorState;
    }
    if (this.profiler !== null) {
      this.profiler.stop();
      this.profiler.reportFrames();
    }
  }

  /**
   * Get the number of threads in the given array that are monitor threads (threads
   * that update monitor values, and don't count as running a script).
   * @param {!Array.<Thread>} threads The set of threads to look through.
   * @return {number} The number of monitor threads in threads.
   */
  _getMonitorThreadCount(threads) {
    let count = 0;
    threads.forEach(thread => {
      if (thread.updateMonitor) count++;
    });
    return count;
  }

  /**
   * Queue monitor blocks to sequencer to be run.
   */
  _pushMonitors() {
    this.monitorBlocks.runAllMonitored(this);
  }

  /**
   * Set the current editing target known by the runtime.
   * @param {!Target} editingTarget New editing target.
   */
  setEditingTarget(editingTarget) {
    const oldEditingTarget = this._editingTarget;
    this._editingTarget = editingTarget;
    // Script glows must be cleared.
    this._scriptGlowsPreviousFrame = [];
    this._updateGlows();
    if (oldEditingTarget !== this._editingTarget) {
      this.requestToolboxExtensionsUpdate();
    }
  }

  /**
   * Set whether we are in 30 TPS compatibility mode.
   * @param {boolean} compatibilityModeOn True iff in compatibility mode.
   */
  setCompatibilityMode(compatibilityModeOn) {
    this.compatibilityMode = compatibilityModeOn;
    if (this._steppingInterval) {
      clearInterval(this._steppingInterval);
      this._steppingInterval = null;
      this.start();
    }
  }

  /**
   * Emit glows/glow clears for scripts after a single tick.
   * Looks at `this.threads` and notices which have turned on/off new glows.
   * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
   */
  _updateGlows(optExtraThreads) {
    const searchThreads = [];
    searchThreads.push(...this.threads);
    if (optExtraThreads) {
      searchThreads.push(...optExtraThreads);
    }
    // Set of scripts that request a glow this frame.
    const requestedGlowsThisFrame = [];
    // Final set of scripts glowing during this frame.
    const finalScriptGlows = [];
    // Find all scripts that should be glowing.
    for (let i = 0; i < searchThreads.length; i++) {
      const thread = searchThreads[i];
      const target = thread.target;
      if (target === this._editingTarget) {
        const blockForThread = thread.blockGlowInFrame;
        if (thread.requestScriptGlowInFrame || thread.stackClick) {
          let script = target.blocks.getTopLevelScript(blockForThread);
          if (!script) {
            // Attempt to find in flyout blocks.
            script = this.flyoutBlocks.getTopLevelScript(blockForThread);
          }
          if (script) {
            requestedGlowsThisFrame.push(script);
          }
        }
      }
    }
    // Compare to previous frame.
    for (let j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {
      const previousFrameGlow = this._scriptGlowsPreviousFrame[j];
      if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {
        // Glow turned off.
        this.glowScript(previousFrameGlow, false);
      } else {
        // Still glowing.
        finalScriptGlows.push(previousFrameGlow);
      }
    }
    for (let k = 0; k < requestedGlowsThisFrame.length; k++) {
      const currentFrameGlow = requestedGlowsThisFrame[k];
      if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {
        // Glow turned on.
        this.glowScript(currentFrameGlow, true);
        finalScriptGlows.push(currentFrameGlow);
      }
    }
    this._scriptGlowsPreviousFrame = finalScriptGlows;
  }

  /**
   * Emit run start/stop after each tick. Emits when `this.threads.length` goes
   * between non-zero and zero
   *
   * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
   */
  _emitProjectRunStatus(nonMonitorThreadCount) {
    if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {
      this.emit(Runtime.PROJECT_RUN_START);
    }
    if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {
      this.emit(Runtime.PROJECT_RUN_STOP);
    }
    this._nonMonitorThreadCount = nonMonitorThreadCount;
  }

  /**
   * "Quiet" a script's glow: stop the VM from generating glow/unglow events
   * about that script. Use when a script has just been deleted, but we may
   * still be tracking glow data about it.
   * @param {!string} scriptBlockId Id of top-level block in script to quiet.
   */
  quietGlow(scriptBlockId) {
    const index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);
    if (index > -1) {
      this._scriptGlowsPreviousFrame.splice(index, 1);
    }
  }

  /**
   * Emit feedback for block glowing (used in the sequencer).
   * @param {?string} blockId ID for the block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */
  glowBlock(blockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.BLOCK_GLOW_ON, {
        id: blockId
      });
    } else {
      this.emit(Runtime.BLOCK_GLOW_OFF, {
        id: blockId
      });
    }
  }

  /**
   * Emit feedback for script glowing.
   * @param {?string} topBlockId ID for the top block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */
  glowScript(topBlockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.SCRIPT_GLOW_ON, {
        id: topBlockId
      });
    } else {
      this.emit(Runtime.SCRIPT_GLOW_OFF, {
        id: topBlockId
      });
    }
  }

  /**
   * Emit whether blocks are being dragged over gui
   * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise
   */
  emitBlockDragUpdate(areBlocksOverGui) {
    this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
  }

  /**
   * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace
   * @param {Array.<object>} blocks The set of blocks dragged to the GUI
   * @param {string} topBlockId The original id of the top block being dragged
   */
  emitBlockEndDrag(blocks, topBlockId) {
    this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
  }

  /**
   * Emit value for reporter to show in the blocks.
   * @param {string} blockId ID for the block.
   * @param {string} value Value to show associated with the block.
   */
  visualReport(blockId, value) {
    this.emit(Runtime.VISUAL_REPORT, {
      id: blockId,
      value: String(value)
    });
  }

  /**
   * Add a monitor to the state. If the monitor already exists in the state,
   * updates those properties that are defined in the given monitor record.
   * @param {!MonitorRecord} monitor Monitor to add.
   */
  requestAddMonitor(monitor) {
    const id = monitor.get('id');
    if (!this.requestUpdateMonitor(monitor)) {
      // update monitor if it exists in the state
      // if the monitor did not exist in the state, add it
      this._monitorState = this._monitorState.set(id, monitor);
    }
  }

  /**
   * Update a monitor in the state and report success/failure of update.
   * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite
   *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,
   *     the old monitor will keep its old value.
   * @return {boolean} true if monitor exists in the state and was updated, false if it did not exist.
   */
  requestUpdateMonitor(monitor) {
    const id = monitor.get('id');
    if (this._monitorState.has(id)) {
      this._monitorState =
      // Use mergeWith here to prevent undefined values from overwriting existing ones
      this._monitorState.set(id, this._monitorState.get(id).mergeWith((prev, next) => {
        if (typeof next === 'undefined' || next === null) {
          return prev;
        }
        return next;
      }, monitor));
      return true;
    }
    return false;
  }

  /**
   * Removes a monitor from the state. Does nothing if the monitor already does
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to remove.
   */
  requestRemoveMonitor(monitorId) {
    this._monitorState = this._monitorState.delete(monitorId);
  }

  /**
   * Hides a monitor and returns success/failure of action.
   * @param {!string} monitorId ID of the monitor to hide.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */
  requestHideMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', false]]));
  }

  /**
   * Shows a monitor and returns success/failure of action.
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to show.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */
  requestShowMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', true]]));
  }

  /**
   * Removes all monitors with the given target ID from the state. Does nothing if
   * the monitor already does not exist in the state.
   * @param {!string} targetId Remove all monitors with given target ID.
   */
  requestRemoveMonitorByTargetId(targetId) {
    this._monitorState = this._monitorState.filterNot(value => value.targetId === targetId);
  }

  /**
   * Get a target by its id.
   * @param {string} targetId Id of target to find.
   * @return {?Target} The target, if found.
   */
  getTargetById(targetId) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.id === targetId) {
        return target;
      }
    }
  }

  /**
   * Get the first original (non-clone-block-created) sprite given a name.
   * @param {string} spriteName Name of sprite to look for.
   * @return {?Target} Target representing a sprite of the given name.
   */
  getSpriteTargetByName(spriteName) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.isStage) {
        continue;
      }
      if (target.sprite && target.sprite.name === spriteName) {
        return target;
      }
    }
  }

  /**
   * Get a target by its drawable id.
   * @param {number} drawableID drawable id of target to find
   * @return {?Target} The target, if found
   */
  getTargetByDrawableId(drawableID) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.drawableID === drawableID) return target;
    }
  }

  /**
   * Update the clone counter to track how many clones are created.
   * @param {number} changeAmount How many clones have been created/destroyed.
   */
  changeCloneCounter(changeAmount) {
    this._cloneCounter += changeAmount;
  }

  /**
   * Return whether there are clones available.
   * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.
   */
  clonesAvailable() {
    return this._cloneCounter < Runtime.MAX_CLONES;
  }

  /**
   * Handle that the project has loaded in the Virtual Machine.
   */
  handleProjectLoaded() {
    this.emit(Runtime.PROJECT_LOADED);
    this.resetRunId();
  }

  /**
   * Report that the project has changed in a way that would affect serialization
   */
  emitProjectChanged() {
    this.emit(Runtime.PROJECT_CHANGED);
  }

  /**
   * Report that a new target has been created, possibly by cloning an existing target.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @fires Runtime#targetWasCreated
   */
  fireTargetWasCreated(newTarget, sourceTarget) {
    this.emit('targetWasCreated', newTarget, sourceTarget);
  }

  /**
   * Report that a clone target is being removed.
   * @param {Target} target - the target being removed
   * @fires Runtime#targetWasRemoved
   */
  fireTargetWasRemoved(target) {
    this.emit('targetWasRemoved', target);
  }

  /**
   * Get a target representing the Scratch stage, if one exists.
   * @return {?Target} The target, if found.
   */
  getTargetForStage() {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.isStage) {
        return target;
      }
    }
  }

  /**
   * Get the editing target.
   * @return {?Target} The editing target.
   */
  getEditingTarget() {
    return this._editingTarget;
  }
  getAllVarNamesOfType(varType) {
    let varNames = [];
    for (const target of this.targets) {
      const targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);
      varNames = varNames.concat(targetVarNames);
    }
    return varNames;
  }

  /**
   * Get the label or label function for an opcode
   * @param {string} extendedOpcode - the opcode you want a label for
   * @return {object} - object with label and category
   * @property {string} category - the category for this opcode
   * @property {Function} [labelFn] - function to generate the label for this opcode
   * @property {string} [label] - the label for this opcode if `labelFn` is absent
   */
  getLabelForOpcode(extendedOpcode) {
    const [category, opcode] = StringUtil.splitFirst(extendedOpcode, '_');
    if (!(category && opcode)) return;
    const categoryInfo = this._blockInfo.find(ci => ci.id === category);
    if (!categoryInfo) return;
    const block = categoryInfo.blocks.find(b => b.info.opcode === opcode);
    if (!block) return;

    // TODO: we may want to format the label in a locale-specific way.
    return {
      category: 'extension',
      // This assumes that all extensions have the same monitor color.
      label: "".concat(categoryInfo.name, ": ").concat(block.info.text)
    };
  }

  /**
   * Create a new global variable avoiding conflicts with other variable names.
   * @param {string} variableName The desired variable name for the new global variable.
   * This can be turned into a fresh name as necessary.
   * @param {string} optVarId An optional ID to use for the variable. A new one will be generated
   * if a falsey value for this parameter is provided.
   * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.
   * @return {Variable} The new variable that was created.
   */
  createNewGlobalVariable(variableName, optVarId, optVarType) {
    const varType = typeof optVarType === 'string' ? optVarType : Variable.SCALAR_TYPE;
    const allVariableNames = this.getAllVarNamesOfType(varType);
    const newName = StringUtil.unusedName(variableName, allVariableNames);
    const variable = new Variable(optVarId || uid(), newName, varType);
    const stage = this.getTargetForStage();
    stage.variables[variable.id] = variable;
    return variable;
  }

  /**
   * Tell the runtime to request a redraw.
   * Use after a clone/sprite has completed some visible operation on the stage.
   */
  requestRedraw() {
    this.redrawRequested = true;
  }

  /**
   * Emit a targets update at the end of the step if the provided target is
   * the original sprite
   * @param {!Target} target Target requesting the targets update
   */
  requestTargetsUpdate(target) {
    if (!target.isOriginal) return;
    this._refreshTargets = true;
  }

  /**
   * Emit an event that indicates that the blocks on the workspace need updating.
   */
  requestBlocksUpdate() {
    this.emit(Runtime.BLOCKS_NEED_UPDATE);
  }

  /**
   * Emit an event that indicates that the toolbox extension blocks need updating.
   */
  requestToolboxExtensionsUpdate() {
    this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);
  }

  /**
   * Set up timers to repeatedly step in a browser.
   */
  start() {
    // Do not start if we are already running
    if (this._steppingInterval) return;
    let interval = Runtime.THREAD_STEP_INTERVAL;
    if (this.compatibilityMode) {
      interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;
    }
    this.currentStepTime = interval;
    this._steppingInterval = setInterval(() => {
      this._step();
    }, interval);
    this.emit(Runtime.RUNTIME_STARTED);
  }

  /**
   * Quit the Runtime, clearing any handles which might keep the process alive.
   * Do not use the runtime after calling this method. This method is meant for test shutdown.
   */
  quit() {
    clearInterval(this._steppingInterval);
    this._steppingInterval = null;
  }

  /**
   * Turn on profiling.
   * @param {Profiler/FrameCallback} onFrame A callback handle passed a
   * profiling frame when the profiler reports its collected data.
   */
  enableProfiling(onFrame) {
    if (Profiler.available()) {
      this.profiler = new Profiler(onFrame);
    }
  }

  /**
   * Turn off profiling.
   */
  disableProfiling() {
    this.profiler = null;
  }

  /**
   * Update a millisecond timestamp value that is saved on the Runtime.
   * This value is helpful in certain instances for compatibility with Scratch 2,
   * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as
   */
  updateCurrentMSecs() {
    this.currentMSecs = Date.now();
  }
}

/**
 * Event fired after a new target has been created, possibly by cloning an existing target.
 *
 * @event Runtime#targetWasCreated
 * @param {Target} newTarget - the newly created target.
 * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
 */

module.exports = Runtime;

/***/ }),

/***/ "./src/engine/scratch-blocks-constants.js":
/*!************************************************!*\
  !*** ./src/engine/scratch-blocks-constants.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * These constants are copied from scratch-blocks/core/constants.js
 * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?
 * @readonly
 * @enum {int}
 */
const ScratchBlocksConstants = {
  /**
   * ENUM for output shape: hexagonal (booleans/predicates).
   * @const
   */
  OUTPUT_SHAPE_HEXAGONAL: 1,
  /**
   * ENUM for output shape: rounded (numbers).
   * @const
   */
  OUTPUT_SHAPE_ROUND: 2,
  /**
   * ENUM for output shape: squared (any/all values; strings).
   * @const
   */
  OUTPUT_SHAPE_SQUARE: 3
};
module.exports = ScratchBlocksConstants;

/***/ }),

/***/ "./src/engine/sequencer.js":
/*!*********************************!*\
  !*** ./src/engine/sequencer.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");
const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");

/**
 * Profiler frame name for stepping a single thread.
 * @const {string}
 */
const stepThreadProfilerFrame = 'Sequencer.stepThread';

/**
 * Profiler frame name for the inner loop of stepThreads.
 * @const {string}
 */
const stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';

/**
 * Profiler frame name for execute.
 * @const {string}
 */
const executeProfilerFrame = 'execute';

/**
 * Profiler frame ID for stepThreadProfilerFrame.
 * @type {number}
 */
let stepThreadProfilerId = -1;

/**
 * Profiler frame ID for stepThreadsInnerProfilerFrame.
 * @type {number}
 */
let stepThreadsInnerProfilerId = -1;

/**
 * Profiler frame ID for executeProfilerFrame.
 * @type {number}
 */
let executeProfilerId = -1;
class Sequencer {
  constructor(runtime) {
    /**
     * A utility timer for timing thread sequencing.
     * @type {!Timer}
     */
    this.timer = new Timer();

    /**
     * Reference to the runtime owning this sequencer.
     * @type {!Runtime}
     */
    this.runtime = runtime;
    this.activeThread = null;
  }

  /**
   * Time to run a warp-mode thread, in ms.
   * @type {number}
   */
  static get WARP_TIME() {
    return 500;
  }

  /**
   * Step through all threads in `this.runtime.threads`, running them in order.
   * @return {Array.<!Thread>} List of inactive threads after stepping.
   */
  stepThreads() {
    // Work time is 75% of the thread stepping interval.
    const WORK_TIME = 0.75 * this.runtime.currentStepTime;
    // For compatibility with Scatch 2, update the millisecond clock
    // on the Runtime once per step (see Interpreter.as in Scratch 2
    // for original use of `currentMSecs`)
    this.runtime.updateCurrentMSecs();
    // Start counting toward WORK_TIME.
    this.timer.start();
    // Count of active threads.
    let numActiveThreads = Infinity;
    // Whether `stepThreads` has run through a full single tick.
    let ranFirstTick = false;
    const doneThreads = [];
    // Conditions for continuing to stepping threads:
    // 1. We must have threads in the list, and some must be active.
    // 2. Time elapsed must be less than WORK_TIME.
    // 3. Either turbo mode, or no redraw has been requested by a primitive.
    while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {
      if (this.runtime.profiler !== null) {
        if (stepThreadsInnerProfilerId === -1) {
          stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);
        }
        this.runtime.profiler.start(stepThreadsInnerProfilerId);
      }
      numActiveThreads = 0;
      let stoppedThread = false;
      // Attempt to run each thread one time.
      const threads = this.runtime.threads;
      for (let i = 0; i < threads.length; i++) {
        const activeThread = this.activeThread = threads[i];
        // Check if the thread is done so it is not executed.
        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
          continue;
        }
        if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {
          // Clear single-tick yield from the last call of `stepThreads`.
          activeThread.status = Thread.STATUS_RUNNING;
        }
        if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {
          // Normal-mode thread: step.
          if (this.runtime.profiler !== null) {
            if (stepThreadProfilerId === -1) {
              stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);
            }

            // Increment the number of times stepThread is called.
            this.runtime.profiler.increment(stepThreadProfilerId);
          }
          this.stepThread(activeThread);
          activeThread.warpTimer = null;
          if (activeThread.isKilled) {
            i--; // if the thread is removed from the list (killed), do not increase index
          }
        }
        if (activeThread.status === Thread.STATUS_RUNNING) {
          numActiveThreads++;
        }
        // Check if the thread completed while it just stepped to make
        // sure we remove it before the next iteration of all threads.
        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
        }
      }
      // We successfully ticked once. Prevents running STATUS_YIELD_TICK
      // threads on the next tick.
      ranFirstTick = true;
      if (this.runtime.profiler !== null) {
        this.runtime.profiler.stop();
      }

      // Filter inactive threads from `this.runtime.threads`.
      if (stoppedThread) {
        let nextActiveThread = 0;
        for (let i = 0; i < this.runtime.threads.length; i++) {
          const thread = this.runtime.threads[i];
          if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {
            this.runtime.threads[nextActiveThread] = thread;
            nextActiveThread++;
          } else {
            doneThreads.push(thread);
          }
        }
        this.runtime.threads.length = nextActiveThread;
      }
    }
    this.activeThread = null;
    return doneThreads;
  }

  /**
   * Step the requested thread for as long as necessary.
   * @param {!Thread} thread Thread object to step.
   */
  stepThread(thread) {
    let currentBlockId = thread.peekStack();
    if (!currentBlockId) {
      // A "null block" - empty branch.
      thread.popStack();

      // Did the null follow a hat block?
      if (thread.stack.length === 0) {
        thread.status = Thread.STATUS_DONE;
        return;
      }
    }
    // Save the current block ID to notice if we did control flow.
    while (currentBlockId = thread.peekStack()) {
      let isWarpMode = thread.peekStackFrame().warpMode;
      if (isWarpMode && !thread.warpTimer) {
        // Initialize warp-mode timer if it hasn't been already.
        // This will start counting the thread toward `Sequencer.WARP_TIME`.
        thread.warpTimer = new Timer();
        thread.warpTimer.start();
      }
      // Execute the current block.
      if (this.runtime.profiler !== null) {
        if (executeProfilerId === -1) {
          executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);
        }

        // Increment the number of times execute is called.
        this.runtime.profiler.increment(executeProfilerId);
      }
      if (thread.target === null) {
        this.retireThread(thread);
      } else {
        execute(this, thread);
      }
      thread.blockGlowInFrame = currentBlockId;
      // If the thread has yielded or is waiting, yield to other threads.
      if (thread.status === Thread.STATUS_YIELD) {
        // Mark as running for next iteration.
        thread.status = Thread.STATUS_RUNNING;
        // In warp mode, yielded blocks are re-executed immediately.
        if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {
          continue;
        }
        return;
      } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {
        // A promise was returned by the primitive. Yield the thread
        // until the promise resolves. Promise resolution should reset
        // thread.status to Thread.STATUS_RUNNING.
        return;
      } else if (thread.status === Thread.STATUS_YIELD_TICK) {
        // stepThreads will reset the thread to Thread.STATUS_RUNNING
        return;
      }
      // If no control flow has happened, switch to next block.
      if (thread.peekStack() === currentBlockId) {
        thread.goToNextBlock();
      }
      // If no next block has been found at this point, look on the stack.
      while (!thread.peekStack()) {
        thread.popStack();
        if (thread.stack.length === 0) {
          // No more stack to run!
          thread.status = Thread.STATUS_DONE;
          return;
        }
        const stackFrame = thread.peekStackFrame();
        isWarpMode = stackFrame.warpMode;
        if (stackFrame.isLoop) {
          // The current level of the stack is marked as a loop.
          // Return to yield for the frame/tick in general.
          // Unless we're in warp mode - then only return if the
          // warp timer is up.
          if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
            // Don't do anything to the stack, since loops need
            // to be re-executed.
            return;
          }
          // Don't go to the next block for this level of the stack,
          // since loops need to be re-executed.
          continue;
        } else if (stackFrame.waitingReporter) {
          // This level of the stack was waiting for a value.
          // This means a reporter has just returned - so don't go
          // to the next block for this level of the stack.
          return;
        }
        // Get next block of existing block on the stack.
        thread.goToNextBlock();
      }
    }
  }

  /**
   * Step a thread into a block's branch.
   * @param {!Thread} thread Thread object to step to branch.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */
  stepToBranch(thread, branchNum, isLoop) {
    if (!branchNum) {
      branchNum = 1;
    }
    const currentBlockId = thread.peekStack();
    const branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);
    thread.peekStackFrame().isLoop = isLoop;
    if (branchId) {
      // Push branch ID to the thread's stack.
      thread.pushStack(branchId);
    } else {
      thread.pushStack(null);
    }
  }

  /**
   * Step a procedure.
   * @param {!Thread} thread Thread object to step to procedure.
   * @param {!string} procedureCode Procedure code of procedure to step to.
   */
  stepToProcedure(thread, procedureCode) {
    const definition = thread.target.blocks.getProcedureDefinition(procedureCode);
    if (!definition) {
      return;
    }
    // Check if the call is recursive.
    // If so, set the thread to yield after pushing.
    const isRecursive = thread.isRecursiveCall(procedureCode);
    // To step to a procedure, we put its definition on the stack.
    // Execution for the thread will proceed through the definition hat
    // and on to the main definition of the procedure.
    // When that set of blocks finishes executing, it will be popped
    // from the stack by the sequencer, returning control to the caller.
    thread.pushStack(definition);
    // In known warp-mode threads, only yield when time is up.
    if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
      thread.status = Thread.STATUS_YIELD;
    } else {
      // Look for warp-mode flag on definition, and set the thread
      // to warp-mode if needed.
      const definitionBlock = thread.target.blocks.getBlock(definition);
      const innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);
      let doWarp = false;
      if (innerBlock && innerBlock.mutation) {
        const warp = innerBlock.mutation.warp;
        if (typeof warp === 'boolean') {
          doWarp = warp;
        } else if (typeof warp === 'string') {
          doWarp = JSON.parse(warp);
        }
      }
      if (doWarp) {
        thread.peekStackFrame().warpMode = true;
      } else if (isRecursive) {
        // In normal-mode threads, yield any time we have a recursive call.
        thread.status = Thread.STATUS_YIELD;
      }
    }
  }

  /**
   * Retire a thread in the middle, without considering further blocks.
   * @param {!Thread} thread Thread object to retire.
   */
  retireThread(thread) {
    thread.stack = [];
    thread.stackFrame = [];
    thread.requestScriptGlowInFrame = false;
    thread.status = Thread.STATUS_DONE;
  }
}
module.exports = Sequencer;

/***/ }),

/***/ "./src/engine/stage-layering.js":
/*!**************************************!*\
  !*** ./src/engine/stage-layering.js ***!
  \**************************************/
/***/ ((module) => {

class StageLayering {
  static get BACKGROUND_LAYER() {
    return 'background';
  }
  static get VIDEO_LAYER() {
    return 'video';
  }
  static get PEN_LAYER() {
    return 'pen';
  }
  static get SPRITE_LAYER() {
    return 'sprite';
  }

  // Order of layer groups relative to each other,
  static get LAYER_GROUPS() {
    return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];
  }
}
module.exports = StageLayering;

/***/ }),

/***/ "./src/engine/target.js":
/*!******************************!*\
  !*** ./src/engine/target.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");

/**
 * @fileoverview
 * A Target is an abstract "code-running" object for the Scratch VM.
 * Examples include sprites/clones or potentially physical-world devices.
 */

class Target extends EventEmitter {
  /**
   * @param {Runtime} runtime Reference to the runtime.
   * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.
   * @constructor
   */
  constructor(runtime, blocks) {
    super();
    if (!blocks) {
      blocks = new Blocks(runtime);
    }

    /**
     * Reference to the runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * A unique ID for this target.
     * @type {string}
     */
    this.id = uid();
    /**
     * Blocks run as code for this target.
     * @type {!Blocks}
     */
    this.blocks = blocks;
    /**
     * Dictionary of variables and their values for this target.
     * Key is the variable id.
     * @type {Object.<string,*>}
     */
    this.variables = {};
    /**
     * Dictionary of comments for this target.
     * Key is the comment id.
     * @type {Object.<string,*>}
     */
    this.comments = {};
    /**
     * Dictionary of custom state for this target.
     * This can be used to store target-specific custom state for blocks which need it.
     * TODO: do we want to persist this in SB3 files?
     * @type {Object.<string,*>}
     */
    this._customState = {};

    /**
     * Currently known values for edge-activated hats.
     * Keys are block ID for the hat; values are the currently known values.
     * @type {Object.<string, *>}
     */
    this._edgeActivatedHatValues = {};
  }

  /**
   * Called when the project receives a "green flag."
   * @abstract
   */
  onGreenFlag() {}

  /**
   * Return a human-readable name for this target.
   * Target implementations should override this.
   * @abstract
   * @returns {string} Human-readable name for the target.
   */
  getName() {
    return this.id;
  }

  /**
   * Update an edge-activated hat block value.
   * @param {!string} blockId ID of hat to store value for.
   * @param {*} newValue Value to store for edge-activated hat.
   * @return {*} The old value for the edge-activated hat.
   */
  updateEdgeActivatedValue(blockId, newValue) {
    const oldValue = this._edgeActivatedHatValues[blockId];
    this._edgeActivatedHatValues[blockId] = newValue;
    return oldValue;
  }
  hasEdgeActivatedValue(blockId) {
    return Object.prototype.hasOwnProperty.call(this._edgeActivatedHatValues, blockId);
  }

  /**
   * Clear all edge-activaed hat values.
   */
  clearEdgeActivatedValues() {
    this._edgeActivatedHatValues = {};
  }

  /**
   * Look up a variable object, first by id, and then by name if the id is not found.
   * Create a new variable if both lookups fail.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */
  lookupOrCreateVariable(id, name) {
    let variable = this.lookupVariableById(id);
    if (variable) return variable;
    variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);
    if (variable) return variable;

    // No variable with this name exists - create it locally.
    const newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
    this.variables[id] = newVariable;
    return newVariable;
  }

  /**
   * Look up a broadcast message object with the given id and return it
   * if it exists.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */
  lookupBroadcastMsg(id, name) {
    let broadcastMsg;
    if (id) {
      broadcastMsg = this.lookupVariableById(id);
    } else if (name) {
      broadcastMsg = this.lookupBroadcastByInputValue(name);
    } else {
      log.error('Cannot find broadcast message if neither id nor name are provided.');
    }
    if (broadcastMsg) {
      if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {
        log.error("Found broadcast message with id: ".concat(id, ", but") + "its name, ".concat(broadcastMsg.name, " did not match expected name ").concat(name, "."));
      }
      if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
        log.error("Found variable with id: ".concat(id, ", but its type ").concat(broadcastMsg.type) + "did not match expected type ".concat(Variable.BROADCAST_MESSAGE_TYPE));
      }
      return broadcastMsg;
    }
  }

  /**
   * Look up a broadcast message with the given name and return the variable
   * if it exists. Does not create a new broadcast message variable if
   * it doesn't exist.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */
  lookupBroadcastByInputValue(name) {
    const vars = this.variables;
    for (const propName in vars) {
      if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {
        return vars[propName];
      }
    }
  }

  /**
   * Look up a variable object.
   * Search begins for local variables; then look for globals.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */
  lookupVariableById(id) {
    // If we have a local copy, return it.
    if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
      return this.variables[id];
    }
    // If the stage has a global copy, return it.
    if (this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();
      if (stage && Object.prototype.hasOwnProperty.call(stage.variables, id)) {
        return stage.variables[id];
      }
    }
  }

  /**
   * Look up a variable object by its name and variable type.
   * Search begins with local variables; then global variables if a local one
   * was not found.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
   * @param {?bool} skipStage Optional flag to skip checking the stage
   * @return {?Variable} Variable object if found, or null if not.
   */
  lookupVariableByNameAndType(name, type, skipStage) {
    if (typeof name !== 'string') return;
    if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;
    for (const varId in this.variables) {
      const currVar = this.variables[varId];
      if (currVar.name === name && currVar.type === type) {
        return currVar;
      }
    }
    if (!skipStage && this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();
      if (stage) {
        for (const varId in stage.variables) {
          const currVar = stage.variables[varId];
          if (currVar.name === name && currVar.type === type) {
            return currVar;
          }
        }
      }
    }
    return null;
  }

  /**
  * Look up a list object for this target, and create it if one doesn't exist.
  * Search begins for local lists; then look for globals.
  * @param {!string} id Id of the list.
  * @param {!string} name Name of the list.
  * @return {!Varible} Variable object representing the found/created list.
   */
  lookupOrCreateList(id, name) {
    let list = this.lookupVariableById(id);
    if (list) return list;
    list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);
    if (list) return list;

    // No variable with this name exists - create it locally.
    const newList = new Variable(id, name, Variable.LIST_TYPE, false);
    this.variables[id] = newList;
    return newList;
  }

  /**
   * Creates a variable with the given id and name and adds it to the
   * dictionary of variables.
   * @param {string} id Id of variable
   * @param {string} name Name of variable.
   * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
   * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
   * Additional checks are made that the variable can be created as a cloud variable.
   */
  createVariable(id, name, type, isCloud) {
    if (!Object.prototype.hasOwnProperty.call(this.variables, id)) {
      const newVariable = new Variable(id, name, type, false);
      if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {
        newVariable.isCloud = true;
        this.runtime.addCloudVariable();
        this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);
      }
      this.variables[id] = newVariable;
    }
  }

  /**
   * Creates a comment with the given properties.
   * @param {string} id Id of the comment.
   * @param {string} blockId Optional id of the block the comment is attached
   * to if it is a block comment.
   * @param {string} text The text the comment contains.
   * @param {number} x The x coordinate of the comment on the workspace.
   * @param {number} y The y coordinate of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size
   * @param {number} height The height of the comment when it is full size
   * @param {boolean} minimized Whether the comment is minimized.
   */
  createComment(id, blockId, text, x, y, width, height, minimized) {
    if (!Object.prototype.hasOwnProperty.call(this.comments, id)) {
      const newComment = new Comment(id, text, x, y, width, height, minimized);
      if (blockId) {
        newComment.blockId = blockId;
        const blockWithComment = this.blocks.getBlock(blockId);
        if (blockWithComment) {
          blockWithComment.comment = id;
        } else {
          log.warn("Could not find block with id ".concat(blockId, " associated with commentId: ").concat(id));
        }
      }
      this.comments[id] = newComment;
    }
  }

  /**
   * Renames the variable with the given id to newName.
   * @param {string} id Id of variable to rename.
   * @param {string} newName New name for the variable.
   */
  renameVariable(id, newName) {
    if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
      const variable = this.variables[id];
      if (variable.id === id) {
        const oldName = variable.name;
        variable.name = newName;
        if (this.runtime) {
          if (variable.isCloud && this.isStage) {
            this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);
          }
          if (variable.type === Variable.SCALAR_TYPE) {
            // sensing__of may be referencing to this variable.
            // Change the reference.
            let blockUpdated = false;
            this.runtime.targets.forEach(t => {
              blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, this.isStage ? '_stage_' : this.getName()) || blockUpdated;
            });
            // Request workspace change only if sensing_of blocks were actually updated.
            if (blockUpdated) this.runtime.requestBlocksUpdate();
          }
          const blocks = this.runtime.monitorBlocks;
          blocks.changeBlock({
            id: id,
            element: 'field',
            name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',
            value: id
          }, this.runtime);
          const monitorBlock = blocks.getBlock(variable.id);
          if (monitorBlock) {
            this.runtime.requestUpdateMonitor(Map({
              id: id,
              params: blocks._getBlockParams(monitorBlock)
            }));
          }
        }
      }
    }
  }

  /**
   * Removes the variable with the given id from the dictionary of variables.
   * @param {string} id Id of variable to delete.
   */
  deleteVariable(id) {
    if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
      // Get info about the variable before deleting it
      const deletedVariableName = this.variables[id].name;
      const deletedVariableWasCloud = this.variables[id].isCloud;
      delete this.variables[id];
      if (this.runtime) {
        if (deletedVariableWasCloud && this.isStage) {
          this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);
          this.runtime.removeCloudVariable();
        }
        this.runtime.monitorBlocks.deleteBlock(id);
        this.runtime.requestRemoveMonitor(id);
      }
    }
  }

  /**
   * Remove this target's monitors from the runtime state and remove the
   * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
   * NOTE: This does not delete any of the stage monitors like backdrop name.
   */
  deleteMonitors() {
    this.runtime.requestRemoveMonitorByTargetId(this.id);
    let targetSpecificMonitorBlockIds;
    if (this.isStage) {
      // This only deletes global variables and not other stage monitors like backdrop number.
      targetSpecificMonitorBlockIds = Object.keys(this.variables);
    } else {
      targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(key => this.runtime.monitorBlocks._blocks[key].targetId === this.id);
    }
    for (const blockId of targetSpecificMonitorBlockIds) {
      this.runtime.monitorBlocks.deleteBlock(blockId);
    }
  }

  /**
   * Create a clone of the variable with the given id from the dictionary of
   * this target's variables.
   * @param {string} id Id of variable to duplicate.
   * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
   * for the duplicate variable. This is necessary when cloning a sprite, for example.
   * @return {?Variable} The duplicated variable, or null if
   * the original variable was not found.
   */
  duplicateVariable(id, optKeepOriginalId) {
    if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
      const originalVariable = this.variables[id];
      const newVariable = new Variable(optKeepOriginalId ? id : null,
      // conditionally keep original id or generate a new one
      originalVariable.name, originalVariable.type, originalVariable.isCloud);
      if (newVariable.type === Variable.LIST_TYPE) {
        newVariable.value = originalVariable.value.slice(0);
      } else {
        newVariable.value = originalVariable.value;
      }
      return newVariable;
    }
    return null;
  }

  /**
   * Duplicate the dictionary of this target's variables as part of duplicating.
   * this target or making a clone.
   * @param {object=} optBlocks Optional block container for the target being duplicated.
   * If provided, new variables will be generated with new UIDs and any variable references
   * in this blocks container will be updated to refer to the corresponding new IDs.
   * @return {object} The duplicated dictionary of variables
   */
  duplicateVariables(optBlocks) {
    let allVarRefs;
    if (optBlocks) {
      allVarRefs = optBlocks.getAllVariableAndListReferences();
    }
    return Object.keys(this.variables).reduce((accum, varId) => {
      const newVariable = this.duplicateVariable(varId, !optBlocks);
      accum[newVariable.id] = newVariable;
      if (optBlocks && allVarRefs) {
        const currVarRefs = allVarRefs[varId];
        if (currVarRefs) {
          this.mergeVariables(varId, newVariable.id, currVarRefs);
        }
      }
      return accum;
    }, {});
  }

  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   * @abstract
   */
  postSpriteInfo() {}

  /**
   * Retrieve custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to retrieve.
   * @returns {*} the associated state, if any was found.
   */
  getCustomState(stateId) {
    return this._customState[stateId];
  }

  /**
   * Store custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to store on this target.
   * @param {*} newValue - the state value to store.
   */
  setCustomState(stateId, newValue) {
    this._customState[stateId] = newValue;
  }

  /**
   * Call to destroy a target.
   * @abstract
   */
  dispose() {
    this._customState = {};
    if (this.runtime) {
      this.runtime.removeExecutable(this);
    }
  }

  // Variable Conflict Resolution Helpers

  /**
   * Get the names of all the variables of the given type that are in scope for this target.
   * For targets that are not the stage, this includes any target-specific
   * variables as well as any stage variables unless the skipStage flag is true.
   * For the stage, this is all stage variables.
   * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
   * @param {?bool} skipStage Optional flag to skip the stage.
   * @return {Array<string>} A list of variable names
   */
  getAllVariableNamesInScopeByType(type, skipStage) {
    if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;
    const targetVariables = Object.values(this.variables).filter(v => v.type === type).map(variable => variable.name);
    if (skipStage || this.isStage || !this.runtime) {
      return targetVariables;
    }
    const stage = this.runtime.getTargetForStage();
    const stageVariables = stage.getAllVariableNamesInScopeByType(type);
    return targetVariables.concat(stageVariables);
  }

  /**
   * Merge variable references with another variable.
   * @param {string} idToBeMerged ID of the variable whose references need to be updated
   * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
   * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.
   * Defaults to all the blocks in this target.
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */
  mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {
    const referencesToChange = optReferencesToUpdate ||
    // TODO should there be a separate helper function that traverses the blocks
    // for all references for a given ID instead of doing the below..?
    this.blocks.getAllVariableAndListReferences()[idToBeMerged];
    VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);
  }

  /**
   * Share a local variable (and given references for that variable) to the stage.
   * @param {string} varId The ID of the variable to share.
   * @param {Array<object>} varRefs The list of variable references being shared,
   * that reference the given variable ID. The names and IDs of these variable
   * references will be updated to refer to the new (or pre-existing) global variable.
   */
  shareLocalVariableToStage(varId, varRefs) {
    if (!this.runtime) return;
    const variable = this.variables[varId];
    if (!variable) {
      log.warn("Cannot share a local variable to the stage if it's not local.");
      return;
    }
    const stage = this.runtime.getTargetForStage();
    // If a local var is being shared with the stage,
    // sharing will make the variable global, resulting in a conflict
    // with the existing local variable. Preemptively Resolve this conflict
    // by renaming the new global variable.

    // First check if we've already done the local to global transition for this
    // variable. If we have, merge it with the global variable we've already created.
    const varIdForStage = "StageVarFromLocal_".concat(varId);
    let stageVar = stage.lookupVariableById(varIdForStage);
    // If a global var doesn't already exist, create a new one with a fresh name.
    // Use the ID we created above so that we can lookup this new variable in the
    // future if we decide to share this same variable again.
    if (!stageVar) {
      const varName = variable.name;
      const varType = variable.type;
      const newStageName = "Stage: ".concat(varName);
      stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);
    }
    // Update all variable references to use the new name and ID
    this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);
  }

  /**
   * Share a local variable with a sprite, merging with one of the same name and
   * type if it already exists on the sprite, or create a new one.
   * @param {string} varId Id of the variable to share
   * @param {Target} sprite The sprite to share the variable with
   * @param {Array<object>} varRefs A list of all the variable references currently being shared.
   */
  shareLocalVariableToSprite(varId, sprite, varRefs) {
    if (!this.runtime) return;
    if (this.isStage) return;
    const variable = this.variables[varId];
    if (!variable) {
      log.warn("Tried to call 'shareLocalVariableToSprite' with a non-local variable.");
      return;
    }
    const varName = variable.name;
    const varType = variable.type;
    // Check if the receiving sprite already has a variable of the same name and type
    // and use the existing variable, otherwise create a new one.
    const existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);
    let newVarId;
    if (existingLocalVar) {
      newVarId = existingLocalVar.id;
    } else {
      const newVar = new Variable(null, varName, varType);
      newVarId = newVar.id;
      sprite.variables[newVarId] = newVar;
    }

    // Merge with the local variable on the new sprite.
    this.mergeVariables(varId, newVarId, varRefs);
  }

  /**
   * Given a list of variable referencing fields, shares those variables with
   * the target with the provided id, resolving any variable conflicts that arise
   * using the following rules:
   *
   * If this target is the stage, exit. There are no conflicts that arise
   * from sharing variables from the stage to another sprite. The variables
   * already exist globally, so no further action is needed.
   *
   * If a variable being referenced is a global variable, do nothing. The
   * global variable already exists so no further action is needed.
   *
   * If a variable being referenced is local, and
   * 1) The receiving target is a sprite:
   * create a new local variable or merge with an existing local variable
   * of the same name and type. Update all the referencing fields
   * for the original variable to reference the new variable.
   * 2) The receiving target is the stage:
   * Create a new global variable with a fresh name and update all the referencing
   * fields to reference the new variable.
   *
   * @param {Array<object>} blocks The blocks containing
   * potential conflicting references to variables.
   * @param {Target} receivingTarget The target receiving the variables
   */
  resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {
    if (this.isStage) return;

    // Get all the variable references in the given list of blocks
    const allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks);

    // For all the variables being referenced, check for which ones are local
    // to this target, and resolve conflicts based on whether the receiving target
    // is a sprite (with a conflicting local variable) or whether it is
    // the stage (which cannot have local variables)
    for (const varId in allVarListRefs) {
      const currVar = this.variables[varId];
      if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.

      // Get the list of references for the current variable id
      const currVarListRefs = allVarListRefs[varId];
      if (receivingTarget.isStage) {
        this.shareLocalVariableToStage(varId, currVarListRefs);
      } else {
        this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);
      }
    }
  }

  /**
   * Fixes up variable references in this target avoiding conflicts with
   * pre-existing variables in the same scope.
   * This is used when uploading this target as a new sprite into an existing
   * project, where the new sprite may contain references
   * to variable names that already exist as global variables in the project
   * (and thus are in scope for variable references in the given sprite).
   *
   * If this target has a block that references an existing global variable and that
   * variable *does not* exist in this target (e.g. it was a global variable in the
   * project the sprite was originally exported from), merge the variables. This entails
   * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
   *
   * If this target has a block that references an existing global variable and that
   * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
   * then the local variable is renamed to distinguish itself from the pre-existing variable.
   * All blocks that reference the local variable will be updated to use the new name.
   */
  // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...
  fixUpVariableReferences() {
    if (!this.runtime) return; // There's no runtime context to conflict with
    if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)
    const stage = this.runtime.getTargetForStage();
    if (!stage || !stage.variables) return;
    const renameConflictingLocalVar = (id, name, type) => {
      const conflict = stage.lookupVariableByNameAndType(name, type);
      if (conflict) {
        const newName = StringUtil.unusedName("".concat(this.getName(), ": ").concat(name), this.getAllVariableNamesInScopeByType(type));
        this.renameVariable(id, newName);
        return newName;
      }
      return null;
    };
    const allReferences = this.blocks.getAllVariableAndListReferences();
    const unreferencedLocalVarIds = [];
    if (Object.keys(this.variables).length > 0) {
      for (const localVarId in this.variables) {
        if (!Object.prototype.hasOwnProperty.call(this.variables, localVarId)) continue;
        if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);
      }
    }
    const conflictIdsToReplace = Object.create(null);
    const conflictNamesToReplace = Object.create(null);

    // Cache the list of all variable names by type so that we don't need to
    // re-calculate this in every iteration of the following loop.
    const varNamesByType = {};
    const allVarNames = type => {
      const namesOfType = varNamesByType[type];
      if (namesOfType) return namesOfType;
      varNamesByType[type] = this.runtime.getAllVarNamesOfType(type);
      return varNamesByType[type];
    };
    for (const varId in allReferences) {
      // We don't care about which var ref we get, they should all have the same var info
      const varRef = allReferences[varId][0];
      const varName = varRef.referencingField.value;
      const varType = varRef.type;
      if (this.lookupVariableById(varId)) {
        // Found a variable with the id in either the target or the stage,
        // figure out which one.
        if (Object.prototype.hasOwnProperty.call(this.variables, varId)) {
          // If the target has the variable, then check whether the stage
          // has one with the same name and type. If it does, then rename
          // this target specific variable so that there is a distinction.
          const newVarName = renameConflictingLocalVar(varId, varName, varType);
          if (newVarName) {
            // We are not calling this.blocks.updateBlocksAfterVarRename
            // here because it will search through all the blocks. We already
            // have access to all the references for this var id.
            allReferences[varId].map(ref => {
              ref.referencingField.value = newVarName;
              return ref;
            });
          }
        }
      } else {
        // We didn't find the referenced variable id anywhere,
        // Treat it as a reference to a global variable (from the original
        // project this sprite was exported from).
        // Check for whether a global variable of the same name and type exists,
        // and if so, track it to merge with the existing global in a second pass of the blocks.
        const existingVar = stage.lookupVariableByNameAndType(varName, varType);
        if (existingVar) {
          if (!conflictIdsToReplace[varId]) {
            conflictIdsToReplace[varId] = existingVar.id;
          }
        } else {
          // A global variable with the same name did not already exist,
          // create a new one such that it does not conflict with any
          // names of local variables of the same type.
          const allNames = allVarNames(varType);
          const freshName = StringUtil.unusedName(varName, allNames);
          stage.createVariable(varId, freshName, varType);
          if (!conflictNamesToReplace[varId]) {
            conflictNamesToReplace[varId] = freshName;
          }
        }
      }
    }
    // Rename any local variables that were missed above because they aren't
    // referenced by any blocks
    for (const id in unreferencedLocalVarIds) {
      const varId = unreferencedLocalVarIds[id];
      const name = this.variables[varId].name;
      const type = this.variables[varId].type;
      renameConflictingLocalVar(varId, name, type);
    }
    // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has
    // blocks referencing some variable that the sprite does not own, and this
    // variable conflicts with a global var)
    // In this case, we want to merge the new variable referenes with the
    // existing global variable
    for (const conflictId in conflictIdsToReplace) {
      const existingId = conflictIdsToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      this.mergeVariables(conflictId, existingId, referencesToUpdate);
    }

    // Handle global var conflicts existing local vars (e.g a sprite is uploaded,
    // and has blocks referencing some variable that the sprite does not own, and this
    // variable conflcits with another sprite's local var).
    // In this case, we want to go through the variable references and update
    // the name of the variable in that reference.
    for (const conflictId in conflictNamesToReplace) {
      const newName = conflictNamesToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      referencesToUpdate.map(ref => {
        ref.referencingField.value = newName;
        return ref;
      });
    }
  }
}
module.exports = Target;

/***/ }),

/***/ "./src/engine/thread.js":
/*!******************************!*\
  !*** ./src/engine/thread.js ***!
  \******************************/
/***/ ((module) => {

/**
 * Recycle bin for empty stackFrame objects
 * @type Array<_StackFrame>
 */
const _stackFrameFreeList = [];

/**
 * A frame used for each level of the stack. A general purpose
 * place to store a bunch of execution context and parameters
 * @param {boolean} warpMode Whether this level of the stack is warping
 * @constructor
 * @private
 */
class _StackFrame {
  constructor(warpMode) {
    /**
     * Whether this level of the stack is a loop.
     * @type {boolean}
     */
    this.isLoop = false;

    /**
     * Whether this level is in warp mode.  Is set by some legacy blocks and
     * "turbo mode"
     * @type {boolean}
     */
    this.warpMode = warpMode;

    /**
     * Reported value from just executed block.
     * @type {Any}
     */
    this.justReported = null;

    /**
     * The active block that is waiting on a promise.
     * @type {string}
     */
    this.reporting = '';

    /**
     * Persists reported inputs during async block.
     * @type {Object}
     */
    this.reported = null;

    /**
     * Name of waiting reporter.
     * @type {string}
     */
    this.waitingReporter = null;

    /**
     * Procedure parameters.
     * @type {Object}
     */
    this.params = null;

    /**
     * A context passed to block implementations.
     * @type {Object}
     */
    this.executionContext = null;
  }

  /**
   * Reset all properties of the frame to pristine null and false states.
   * Used to recycle.
   * @return {_StackFrame} this
   */
  reset() {
    this.isLoop = false;
    this.warpMode = false;
    this.justReported = null;
    this.reported = null;
    this.waitingReporter = null;
    this.params = null;
    this.executionContext = null;
    return this;
  }

  /**
   * Reuse an active stack frame in the stack.
   * @param {?boolean} warpMode defaults to current warpMode
   * @returns {_StackFrame} this
   */
  reuse() {
    let warpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.warpMode;
    this.reset();
    this.warpMode = Boolean(warpMode);
    return this;
  }

  /**
   * Create or recycle a stack frame object.
   * @param {boolean} warpMode Enable warpMode on this frame.
   * @returns {_StackFrame} The clean stack frame with correct warpMode setting.
   */
  static create(warpMode) {
    const stackFrame = _stackFrameFreeList.pop();
    if (typeof stackFrame !== 'undefined') {
      stackFrame.warpMode = Boolean(warpMode);
      return stackFrame;
    }
    return new _StackFrame(warpMode);
  }

  /**
   * Put a stack frame object into the recycle bin for reuse.
   * @param {_StackFrame} stackFrame The frame to reset and recycle.
   */
  static release(stackFrame) {
    if (typeof stackFrame !== 'undefined') {
      _stackFrameFreeList.push(stackFrame.reset());
    }
  }
}

/**
 * A thread is a running stack context and all the metadata needed.
 * @param {?string} firstBlock First block to execute in the thread.
 * @constructor
 */
class Thread {
  constructor(firstBlock) {
    /**
     * ID of top block of the thread
     * @type {!string}
     */
    this.topBlock = firstBlock;

    /**
     * Stack for the thread. When the sequencer enters a control structure,
     * the block is pushed onto the stack so we know where to exit.
     * @type {Array.<string>}
     */
    this.stack = [];

    /**
     * Stack frames for the thread. Store metadata for the executing blocks.
     * @type {Array.<_StackFrame>}
     */
    this.stackFrames = [];

    /**
     * Status of the thread, one of three states (below)
     * @type {number}
     */
    this.status = 0; /* Thread.STATUS_RUNNING */

    /**
     * Whether the thread is killed in the middle of execution.
     * @type {boolean}
     */
    this.isKilled = false;

    /**
     * Target of this thread.
     * @type {?Target}
     */
    this.target = null;

    /**
     * The Blocks this thread will execute.
     * @type {Blocks}
     */
    this.blockContainer = null;

    /**
     * Whether the thread requests its script to glow during this frame.
     * @type {boolean}
     */
    this.requestScriptGlowInFrame = false;

    /**
     * Which block ID should glow during this frame, if any.
     * @type {?string}
     */
    this.blockGlowInFrame = null;

    /**
     * A timer for when the thread enters warp mode.
     * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
     * @type {?Timer}
     */
    this.warpTimer = null;
    this.justReported = null;
  }

  /**
   * Thread status for initialized or running thread.
   * This is the default state for a thread - execution should run normally,
   * stepping from block to block.
   * @const
   */
  static get STATUS_RUNNING() {
    return 0;
  }

  /**
   * Threads are in this state when a primitive is waiting on a promise;
   * execution is paused until the promise changes thread status.
   * @const
   */
  static get STATUS_PROMISE_WAIT() {
    return 1;
  }

  /**
   * Thread status for yield.
   * @const
   */
  static get STATUS_YIELD() {
    return 2;
  }

  /**
   * Thread status for a single-tick yield. This will be cleared when the
   * thread is resumed.
   * @const
   */
  static get STATUS_YIELD_TICK() {
    return 3;
  }

  /**
   * Thread status for a finished/done thread.
   * Thread is in this state when there are no more blocks to execute.
   * @const
   */
  static get STATUS_DONE() {
    return 4;
  }

  /**
   * Push stack and update stack frames appropriately.
   * @param {string} blockId Block ID to push to stack.
   */
  pushStack(blockId) {
    this.stack.push(blockId);
    // Push an empty stack frame, if we need one.
    // Might not, if we just popped the stack.
    if (this.stack.length > this.stackFrames.length) {
      const parent = this.stackFrames[this.stackFrames.length - 1];
      this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));
    }
  }

  /**
   * Reset the stack frame for use by the next block.
   * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
   * @param {string} blockId Block ID to push to stack.
   */
  reuseStackForNextBlock(blockId) {
    this.stack[this.stack.length - 1] = blockId;
    this.stackFrames[this.stackFrames.length - 1].reuse();
  }

  /**
   * Pop last block on the stack and its stack frame.
   * @return {string} Block ID popped from the stack.
   */
  popStack() {
    _StackFrame.release(this.stackFrames.pop());
    return this.stack.pop();
  }

  /**
   * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
   */
  stopThisScript() {
    let blockID = this.peekStack();
    while (blockID !== null) {
      const block = this.target.blocks.getBlock(blockID);
      if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {
        break;
      }
      this.popStack();
      blockID = this.peekStack();
    }
    if (this.stack.length === 0) {
      // Clean up!
      this.requestScriptGlowInFrame = false;
      this.status = Thread.STATUS_DONE;
    }
  }

  /**
   * Get top stack item.
   * @return {?string} Block ID on top of stack.
   */
  peekStack() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  }

  /**
   * Get top stack frame.
   * @return {?object} Last stack frame stored on this thread.
   */
  peekStackFrame() {
    return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;
  }

  /**
   * Get stack frame above the current top.
   * @return {?object} Second to last stack frame stored on this thread.
   */
  peekParentStackFrame() {
    return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;
  }

  /**
   * Push a reported value to the parent of the current stack frame.
   * @param {*} value Reported value to push.
   */
  pushReportedValue(value) {
    this.justReported = typeof value === 'undefined' ? null : value;
  }

  /**
   * Initialize procedure parameters on this stack frame.
   */
  initParams() {
    const stackFrame = this.peekStackFrame();
    if (stackFrame.params === null) {
      stackFrame.params = {};
    }
  }

  /**
   * Add a parameter to the stack frame.
   * Use when calling a procedure with parameter values.
   * @param {!string} paramName Name of parameter.
   * @param {*} value Value to set for parameter.
   */
  pushParam(paramName, value) {
    const stackFrame = this.peekStackFrame();
    stackFrame.params[paramName] = value;
  }

  /**
   * Get a parameter at the lowest possible level of the stack.
   * @param {!string} paramName Name of parameter.
   * @return {*} value Value for parameter.
   */
  getParam(paramName) {
    for (let i = this.stackFrames.length - 1; i >= 0; i--) {
      const frame = this.stackFrames[i];
      if (frame.params === null) {
        continue;
      }
      if (Object.prototype.hasOwnProperty.call(frame.params, paramName)) {
        return frame.params[paramName];
      }
      return null;
    }
    return null;
  }

  /**
   * Whether the current execution of a thread is at the top of the stack.
   * @return {boolean} True if execution is at top of the stack.
   */
  atStackTop() {
    return this.peekStack() === this.topBlock;
  }

  /**
   * Switch the thread to the next block at the current level of the stack.
   * For example, this is used in a standard sequence of blocks,
   * where execution proceeds from one block to the next.
   */
  goToNextBlock() {
    const nextBlockId = this.target.blocks.getNextBlock(this.peekStack());
    this.reuseStackForNextBlock(nextBlockId);
  }

  /**
   * Attempt to determine whether a procedure call is recursive,
   * by examining the stack.
   * @param {!string} procedureCode Procedure code of procedure being called.
   * @return {boolean} True if the call appears recursive.
   */
  isRecursiveCall(procedureCode) {
    let callCount = 5; // Max number of enclosing procedure calls to examine.
    const sp = this.stack.length - 1;
    for (let i = sp - 1; i >= 0; i--) {
      const block = this.target.blocks.getBlock(this.stack[i]);
      if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {
        return true;
      }
      if (--callCount < 0) return false;
    }
    return false;
  }
}
module.exports = Thread;

/***/ }),

/***/ "./src/engine/variable.js":
/*!********************************!*\
  !*** ./src/engine/variable.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * Object representing a Scratch variable.
 */

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");
class Variable {
  /**
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable, one of '' or 'list'
   * @param {boolean} isCloud Whether the variable is stored in the cloud.
   * @constructor
   */
  constructor(id, name, type, isCloud) {
    this.id = id || uid();
    this.name = name;
    this.type = type;
    this.isCloud = isCloud;
    switch (this.type) {
      case Variable.SCALAR_TYPE:
        this.value = 0;
        break;
      case Variable.LIST_TYPE:
        this.value = [];
        break;
      case Variable.BROADCAST_MESSAGE_TYPE:
        this.value = this.name;
        break;
      default:
        throw new Error("Invalid variable type: ".concat(this.type));
    }
  }
  toXML(isLocal) {
    isLocal = isLocal === true;
    return "<variable type=\"".concat(this.type, "\" id=\"").concat(this.id, "\" islocal=\"").concat(isLocal, "\" iscloud=\"").concat(this.isCloud, "\">").concat(xmlEscape(this.name), "</variable>");
  }

  /**
   * Type representation for scalar variables.
   * This is currently represented as ''
   * for compatibility with blockly.
   * @const {string}
   */
  static get SCALAR_TYPE() {
    return '';
  }

  /**
   * Type representation for list variables.
   * @const {string}
   */
  static get LIST_TYPE() {
    return 'list';
  }

  /**
   * Type representation for list variables.
   * @const {string}
   */
  static get BROADCAST_MESSAGE_TYPE() {
    return 'broadcast_msg';
  }
}
module.exports = Variable;

/***/ }),

/***/ "./src/extension-support/argument-type.js":
/*!************************************************!*\
  !*** ./src/extension-support/argument-type.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Block argument types
 * @enum {string}
 */
const ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
module.exports = ArgumentType;

/***/ }),

/***/ "./src/extension-support/block-type.js":
/*!*********************************************!*\
  !*** ./src/extension-support/block-type.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Types of block
 * @enum {string}
 */
const BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
module.exports = BlockType;

/***/ }),

/***/ "./src/extension-support/extension-manager.js":
/*!****************************************************!*\
  !*** ./src/extension-support/extension-manager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const dispatch = __webpack_require__(/*! ../dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");
const BlockType = __webpack_require__(/*! ./block-type */ "./src/extension-support/block-type.js");

// These extensions are currently built into the VM repository but should not be loaded at startup.
// TODO: move these out into a separate repository?
// TODO: change extension spec so that library info, including extension ID, can be collected through static methods

const builtinExtensions = {
  // This is an example that isn't loaded with the other core blocks,
  // but serves as a reference for loading core blocks as extensions.
  coreExample: () => __webpack_require__(/*! ../blocks/scratch3_core_example */ "./src/blocks/scratch3_core_example.js"),
  // These are the non-core built-in extensions.
  pen: () => __webpack_require__(/*! ../extensions/scratch3_pen */ "./src/extensions/scratch3_pen/index.js"),
  wedo2: () => __webpack_require__(/*! ../extensions/scratch3_wedo2 */ "./src/extensions/scratch3_wedo2/index.js"),
  music: () => __webpack_require__(/*! ../extensions/scratch3_music */ "./src/extensions/scratch3_music/index.js"),
  microbit: () => __webpack_require__(/*! ../extensions/scratch3_microbit */ "./src/extensions/scratch3_microbit/index.js"),
  text2speech: () => __webpack_require__(/*! ../extensions/scratch3_text2speech */ "./src/extensions/scratch3_text2speech/index.js"),
  translate: () => __webpack_require__(/*! ../extensions/scratch3_translate */ "./src/extensions/scratch3_translate/index.js"),
  videoSensing: () => __webpack_require__(/*! ../extensions/scratch3_video_sensing */ "./src/extensions/scratch3_video_sensing/index.js"),
  ev3: () => __webpack_require__(/*! ../extensions/scratch3_ev3 */ "./src/extensions/scratch3_ev3/index.js"),
  makeymakey: () => __webpack_require__(/*! ../extensions/scratch3_makeymakey */ "./src/extensions/scratch3_makeymakey/index.js"),
  boost: () => __webpack_require__(/*! ../extensions/scratch3_boost */ "./src/extensions/scratch3_boost/index.js"),
  gdxfor: () => __webpack_require__(/*! ../extensions/scratch3_gdx_for */ "./src/extensions/scratch3_gdx_for/index.js")
};

/**
 * @typedef {object} ArgumentInfo - Information about an extension block argument
 * @property {ArgumentType} type - the type of value this argument can take
 * @property {*|undefined} default - the default value of this argument (default: blank)
 */

/**
 * @typedef {object} ConvertedBlockInfo - Raw extension block data paired with processed data ready for scratch-blocks
 * @property {ExtensionBlockMetadata} info - the raw block info
 * @property {object} json - the scratch-blocks JSON definition for this block
 * @property {string} xml - the scratch-blocks XML definition for this block
 */

/**
 * @typedef {object} CategoryInfo - Information about a block category
 * @property {string} id - the unique ID of this category
 * @property {string} name - the human-readable name of this category
 * @property {string|undefined} blockIconURI - optional URI for the block icon image
 * @property {string} color1 - the primary color for this category, in '#rrggbb' format
 * @property {string} color2 - the secondary color for this category, in '#rrggbb' format
 * @property {string} color3 - the tertiary color for this category, in '#rrggbb' format
 * @property {Array.<ConvertedBlockInfo>} blocks - the blocks, separators, etc. in this category
 * @property {Array.<object>} menus - the menus provided by this category
 */

/**
 * @typedef {object} PendingExtensionWorker - Information about an extension worker still initializing
 * @property {string} extensionURL - the URL of the extension to be loaded by this worker
 * @property {Function} resolve - function to call on successful worker startup
 * @property {Function} reject - function to call on failed worker startup
 */

class ExtensionManager {
  constructor(runtime) {
    /**
     * The ID number to provide to the next extension worker.
     * @type {int}
     */
    this.nextExtensionWorker = 0;

    /**
     * FIFO queue of extensions which have been requested but not yet loaded in a worker,
     * along with promise resolution functions to call once the worker is ready or failed.
     *
     * @type {Array.<PendingExtensionWorker>}
     */
    this.pendingExtensions = [];

    /**
     * Map of worker ID to workers which have been allocated but have not yet finished initialization.
     * @type {Array.<PendingExtensionWorker>}
     */
    this.pendingWorkers = [];

    /**
     * Map of loaded extension URLs/IDs (equivalent for built-in extensions) to service name.
     * @type {Map.<string,string>}
     * @private
     */
    this._loadedExtensions = new Map();

    /**
     * Keep a reference to the runtime so we can construct internal extension objects.
     * TODO: remove this in favor of extensions accessing the runtime as a service.
     * @type {Runtime}
     */
    this.runtime = runtime;
    dispatch.setService('extensions', this).catch(e => {
      log.error("ExtensionManager was unable to register extension service: ".concat(JSON.stringify(e)));
    });
  }

  /**
   * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
   * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
   * `loadExtensionURL` if you need to wait until the extension is truly ready.
   * @param {string} extensionID - the ID of the extension.
   * @returns {boolean} - true if loaded, false otherwise.
   */
  isExtensionLoaded(extensionID) {
    return this._loadedExtensions.has(extensionID);
  }

  /**
   * Synchronously load an internal extension (core or non-core) by ID. This call will
   * fail if the provided id is not does not match an internal extension.
   * @param {string} extensionId - the ID of an internal extension
   */
  loadExtensionIdSync(extensionId) {
    if (!Object.prototype.hasOwnProperty.call(builtinExtensions, extensionId)) {
      log.warn("Could not find extension ".concat(extensionId, " in the built in extensions."));
      return;
    }

    /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
    if (this.isExtensionLoaded(extensionId)) {
      const message = "Rejecting attempt to load a second extension with ID ".concat(extensionId);
      log.warn(message);
      return;
    }
    const extension = builtinExtensions[extensionId]();
    const extensionInstance = new extension(this.runtime);
    const serviceName = this._registerInternalExtension(extensionInstance);
    this._loadedExtensions.set(extensionId, serviceName);
  }

  /**
   * Load an extension by URL or internal extension ID
   * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
   * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
   */
  loadExtensionURL(extensionURL) {
    if (Object.prototype.hasOwnProperty.call(builtinExtensions, extensionURL)) {
      /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
      if (this.isExtensionLoaded(extensionURL)) {
        const message = "Rejecting attempt to load a second extension with ID ".concat(extensionURL);
        log.warn(message);
        return Promise.resolve();
      }
      const extension = builtinExtensions[extensionURL]();
      const extensionInstance = new extension(this.runtime);
      const serviceName = this._registerInternalExtension(extensionInstance);
      this._loadedExtensions.set(extensionURL, serviceName);
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      // If we `require` this at the global level it breaks non-webpack targets, including tests
      const worker = new Worker('./extension-worker.js');
      this.pendingExtensions.push({
        extensionURL,
        resolve,
        reject
      });
      dispatch.addWorker(worker);
    });
  }

  /**
   * Regenerate blockinfo for any loaded extensions
   * @returns {Promise} resolved once all the extensions have been reinitialized
   */
  refreshBlocks() {
    const allPromises = Array.from(this._loadedExtensions.values()).map(serviceName => dispatch.call(serviceName, 'getInfo').then(info => {
      info = this._prepareExtensionInfo(serviceName, info);
      dispatch.call('runtime', '_refreshExtensionPrimitives', info);
    }).catch(e => {
      log.error("Failed to refresh built-in extension primitives: ".concat(JSON.stringify(e)));
    }));
    return Promise.all(allPromises);
  }
  allocateWorker() {
    const id = this.nextExtensionWorker++;
    const workerInfo = this.pendingExtensions.shift();
    this.pendingWorkers[id] = workerInfo;
    return [id, workerInfo.extensionURL];
  }

  /**
   * Synchronously collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */
  registerExtensionServiceSync(serviceName) {
    const info = dispatch.callSync(serviceName, 'getInfo');
    this._registerExtensionInfo(serviceName, info);
  }

  /**
   * Collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */
  registerExtensionService(serviceName) {
    dispatch.call(serviceName, 'getInfo').then(info => {
      this._registerExtensionInfo(serviceName, info);
    });
  }

  /**
   * Called by an extension worker to indicate that the worker has finished initialization.
   * @param {int} id - the worker ID.
   * @param {*?} e - the error encountered during initialization, if any.
   */
  onWorkerInit(id, e) {
    const workerInfo = this.pendingWorkers[id];
    delete this.pendingWorkers[id];
    if (e) {
      workerInfo.reject(e);
    } else {
      workerInfo.resolve(id);
    }
  }

  /**
   * Register an internal (non-Worker) extension object
   * @param {object} extensionObject - the extension object to register
   * @returns {string} The name of the registered extension service
   */
  _registerInternalExtension(extensionObject) {
    const extensionInfo = extensionObject.getInfo();
    const fakeWorkerId = this.nextExtensionWorker++;
    const serviceName = "extension_".concat(fakeWorkerId, "_").concat(extensionInfo.id);
    dispatch.setServiceSync(serviceName, extensionObject);
    dispatch.callSync('extensions', 'registerExtensionServiceSync', serviceName);
    return serviceName;
  }

  /**
   * Sanitize extension info then register its primitives with the VM.
   * @param {string} serviceName - the name of the service hosting the extension
   * @param {ExtensionInfo} extensionInfo - the extension's metadata
   * @private
   */
  _registerExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
    dispatch.call('runtime', '_registerExtensionPrimitives', extensionInfo).catch(e => {
      log.error("Failed to register primitives for extension on service ".concat(serviceName, ":"), e);
    });
  }

  /**
   * Modify the provided text as necessary to ensure that it may be used as an attribute value in valid XML.
   * @param {string} text - the text to be sanitized
   * @returns {string} - the sanitized text
   * @private
   */
  _sanitizeID(text) {
    return text.toString().replace(/[<"&]/, '_');
  }

  /**
   * Apply minor cleanup and defaults for optional extension fields.
   * TODO: make the ID unique in cases where two copies of the same extension are loaded.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionInfo} extensionInfo - the extension info to be sanitized
   * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
   * @private
   */
  _prepareExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = Object.assign({}, extensionInfo);
    if (!/^[a-z0-9]+$/i.test(extensionInfo.id)) {
      throw new Error('Invalid extension id');
    }
    extensionInfo.name = extensionInfo.name || extensionInfo.id;
    extensionInfo.blocks = extensionInfo.blocks || [];
    extensionInfo.targetTypes = extensionInfo.targetTypes || [];
    extensionInfo.blocks = extensionInfo.blocks.reduce((results, blockInfo) => {
      try {
        let result;
        switch (blockInfo) {
          case '---':
            // separator
            result = '---';
            break;
          default:
            // an ExtensionBlockMetadata object
            result = this._prepareBlockInfo(serviceName, blockInfo);
            break;
        }
        results.push(result);
      } catch (e) {
        // TODO: more meaningful error reporting
        log.error("Error processing block: ".concat(e.message, ", Block:\n").concat(JSON.stringify(blockInfo)));
      }
      return results;
    }, []);
    extensionInfo.menus = extensionInfo.menus || {};
    extensionInfo.menus = this._prepareMenuInfo(serviceName, extensionInfo.menus);
    return extensionInfo;
  }

  /**
   * Prepare extension menus. e.g. setup binding for dynamic menu functions.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {Array.<MenuInfo>} menus - the menu defined by the extension.
   * @returns {Array.<MenuInfo>} - a menuInfo object with all preprocessing done.
   * @private
   */
  _prepareMenuInfo(serviceName, menus) {
    const menuNames = Object.getOwnPropertyNames(menus);
    for (let i = 0; i < menuNames.length; i++) {
      const menuName = menuNames[i];
      let menuInfo = menus[menuName];

      // If the menu description is in short form (items only) then normalize it to general form: an object with
      // its items listed in an `items` property.
      if (!menuInfo.items) {
        menuInfo = {
          items: menuInfo
        };
        menus[menuName] = menuInfo;
      }
      // If `items` is a string, it should be the name of a function in the extension object. Calling the
      // function should return an array of items to populate the menu when it is opened.
      if (typeof menuInfo.items === 'string') {
        const menuItemFunctionName = menuInfo.items;
        const serviceObject = dispatch.services[serviceName];
        // Bind the function here so we can pass a simple item generation function to Scratch Blocks later.
        menuInfo.items = this._getExtensionMenuItems.bind(this, serviceObject, menuItemFunctionName);
      }
    }
    return menus;
  }

  /**
   * Fetch the items for a particular extension menu, providing the target ID for context.
   * @param {object} extensionObject - the extension object providing the menu.
   * @param {string} menuItemFunctionName - the name of the menu function to call.
   * @returns {Array} menu items ready for scratch-blocks.
   * @private
   */
  _getExtensionMenuItems(extensionObject, menuItemFunctionName) {
    // Fetch the items appropriate for the target currently being edited. This assumes that menus only
    // collect items when opened by the user while editing a particular target.
    const editingTarget = this.runtime.getEditingTarget() || this.runtime.getTargetForStage();
    const editingTargetID = editingTarget ? editingTarget.id : null;
    const extensionMessageContext = this.runtime.makeMessageContextForTarget(editingTarget);

    // TODO: Fix this to use dispatch.call when extensions are running in workers.
    const menuFunc = extensionObject[menuItemFunctionName];
    const menuItems = menuFunc.call(extensionObject, editingTargetID).map(item => {
      item = maybeFormatMessage(item, extensionMessageContext);
      switch (typeof item) {
        case 'object':
          return [maybeFormatMessage(item.text, extensionMessageContext), item.value];
        case 'string':
          return [item, item];
        default:
          return item;
      }
    });
    if (!menuItems || menuItems.length < 1) {
      throw new Error("Extension menu returned no items: ".concat(menuItemFunctionName));
    }
    return menuItems;
  }

  /**
   * Apply defaults for optional block fields.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionBlockMetadata} blockInfo - the block info from the extension
   * @returns {ExtensionBlockMetadata} - a new block info object which has values for all relevant optional fields.
   * @private
   */
  _prepareBlockInfo(serviceName, blockInfo) {
    blockInfo = Object.assign({}, {
      blockType: BlockType.COMMAND,
      terminal: false,
      blockAllThreads: false,
      arguments: {}
    }, blockInfo);
    blockInfo.opcode = blockInfo.opcode && this._sanitizeID(blockInfo.opcode);
    blockInfo.text = blockInfo.text || blockInfo.opcode;
    switch (blockInfo.blockType) {
      case BlockType.EVENT:
        if (blockInfo.func) {
          log.warn("Ignoring function \"".concat(blockInfo.func, "\" for event block ").concat(blockInfo.opcode));
        }
        break;
      case BlockType.BUTTON:
        if (blockInfo.opcode) {
          log.warn("Ignoring opcode \"".concat(blockInfo.opcode, "\" for button with text: ").concat(blockInfo.text));
        }
        break;
      default:
        {
          if (!blockInfo.opcode) {
            throw new Error('Missing opcode for block');
          }
          const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
          const getBlockInfo = blockInfo.isDynamic ? args => args && args.mutation && args.mutation.blockInfo : () => blockInfo;
          const callBlockFunc = (() => {
            if (dispatch._isRemoteService(serviceName)) {
              return (args, util, realBlockInfo) => dispatch.call(serviceName, funcName, args, util, realBlockInfo);
            }

            // avoid promise latency if we can call direct
            const serviceObject = dispatch.services[serviceName];
            if (!serviceObject[funcName]) {
              // The function might show up later as a dynamic property of the service object
              log.warn("Could not find extension block function called ".concat(funcName));
            }
            return (args, util, realBlockInfo) => serviceObject[funcName](args, util, realBlockInfo);
          })();
          blockInfo.func = (args, util) => {
            const realBlockInfo = getBlockInfo(args);
            // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?
            return callBlockFunc(args, util, realBlockInfo);
          };
          break;
        }
    }
    return blockInfo;
  }
}
module.exports = ExtensionManager;

/***/ }),

/***/ "./src/extension-support/target-type.js":
/*!**********************************************!*\
  !*** ./src/extension-support/target-type.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Default types of Target supported by the VM
 * @enum {string}
 */
const TargetType = {
  /**
   * Rendered target which can move, change costumes, etc.
   */
  SPRITE: 'sprite',
  /**
   * Rendered target which cannot move but can change backdrops
   */
  STAGE: 'stage'
};
module.exports = TargetType;

/***/ }),

/***/ "./src/extensions/scratch3_boost/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_boost/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");
const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

/**
 * The LEGO Wireless Protocol documentation used to create this extension can be found at:
 * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html
 */

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==';

/**
 * Boost BLE UUIDs.
 * @enum {string}
 */
const BoostBLE = {
  service: '00001623-1212-efde-1623-785feabcd123',
  characteristic: '00001624-1212-efde-1623-785feabcd123',
  sendInterval: 100,
  sendRateMax: 20
};

/**
 * Boost Motor Max Power Add. Defines how much more power than the target speed
 * the motors may supply to reach the target speed faster.
 * Lower number == softer, slower reached target speed.
 * Higher number == harder, faster reached target speed.
 * @constant {number}
 */
const BoostMotorMaxPowerAdd = 10;

/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */
const BoostPingInterval = 5000;

/**
 * The number of continuous samples the color-sensor will evaluate color from.
 * @type {number}
 */
const BoostColorSampleSize = 5;

/**
 * Enum for Boost sensor and actuator types.
 * @readonly
 * @enum {number}
 */
const BoostIO = {
  MOTOR_WEDO: 0x01,
  MOTOR_SYSTEM: 0x02,
  BUTTON: 0x05,
  LIGHT: 0x08,
  VOLTAGE: 0x14,
  CURRENT: 0x15,
  PIEZO: 0x16,
  LED: 0x17,
  TILT_EXTERNAL: 0x22,
  MOTION_SENSOR: 0x23,
  COLOR: 0x25,
  MOTOREXT: 0x26,
  MOTORINT: 0x27,
  TILT: 0x28
};

/**
 * Enum for ids for various output command feedback types on the Boost.
 * @readonly
 * @enum {number}
 */
const BoostPortFeedback = {
  IN_PROGRESS: 0x01,
  COMPLETED: 0x02,
  DISCARDED: 0x04,
  IDLE: 0x08,
  BUSY_OR_FULL: 0x10
};

/**
 * Enum for physical Boost Ports
 * @readonly
 * @enum {number}
 */

const BoostPort10000223OrOlder = {
  A: 55,
  B: 56,
  C: 1,
  D: 2
};
const BoostPort10000224OrNewer = {
  A: 0,
  B: 1,
  C: 2,
  D: 3
};

// Set default port mapping to support the newer firmware
let BoostPort = BoostPort10000224OrNewer;

/**
 * Ids for each color sensor value used by the extension.
 * @readonly
 * @enum {string}
 */
const BoostColor = {
  ANY: 'any',
  NONE: 'none',
  RED: 'red',
  BLUE: 'blue',
  GREEN: 'green',
  YELLOW: 'yellow',
  WHITE: 'white',
  BLACK: 'black'
};

/**
 * Enum for indices for each color sensed by the Boost vision sensor.
 * @readonly
 * @enum {number}
 */
const BoostColorIndex = {
  [BoostColor.NONE]: 255,
  [BoostColor.RED]: 9,
  [BoostColor.BLUE]: 3,
  [BoostColor.GREEN]: 5,
  [BoostColor.YELLOW]: 7,
  [BoostColor.WHITE]: 10,
  [BoostColor.BLACK]: 0
};

/**
 * Enum for Message Types
 * @readonly
 * @enum {number}
 */
const BoostMessage = {
  HUB_PROPERTIES: 0x01,
  HUB_ACTIONS: 0x02,
  HUB_ALERTS: 0x03,
  HUB_ATTACHED_IO: 0x04,
  ERROR: 0x05,
  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,
  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,
  PORT_INFORMATION: 0x43,
  PORT_MODEINFORMATION: 0x44,
  PORT_VALUE: 0x45,
  PORT_VALUE_COMBINED: 0x46,
  PORT_INPUT_FORMAT: 0x47,
  PORT_INPUT_FORMAT_COMBINED: 0x48,
  OUTPUT: 0x81,
  PORT_FEEDBACK: 0x82
};

/**
 * Enum for Hub Property Types
 * @readonly
 * @enum {number}
 */

const BoostHubProperty = {
  ADVERTISEMENT_NAME: 0x01,
  BUTTON: 0x02,
  FW_VERSION: 0x03,
  HW_VERSION: 0x04,
  RSSI: 0x05,
  BATTERY_VOLTAGE: 0x06,
  BATTERY_TYPE: 0x07,
  MANUFACTURER_NAME: 0x08,
  RADIO_FW_VERSION: 0x09,
  LEGO_WP_VERSION: 0x0A,
  SYSTEM_TYPE_ID: 0x0B,
  HW_NETWORK_ID: 0x0C,
  PRIMARY_MAC: 0x0D,
  SECONDARY_MAC: 0x0E,
  HW_NETWORK_FAMILY: 0x0F
};

/**
 * Enum for Hub Property Operations
 * @readonly
 * @enum {number}
 */

const BoostHubPropertyOperation = {
  SET: 0x01,
  ENABLE_UPDATES: 0x02,
  DISABLE_UPDATES: 0x03,
  RESET: 0x04,
  REQUEST_UPDATE: 0x05,
  UPDATE: 0x06
};

/**
 * Enum for Motor Subcommands (for 0x81)
 * @readonly
 * @enum {number}
 */
const BoostOutputSubCommand = {
  START_POWER: 0x01,
  START_POWER_PAIR: 0x02,
  SET_ACC_TIME: 0x05,
  SET_DEC_TIME: 0x06,
  START_SPEED: 0x07,
  START_SPEED_PAIR: 0x08,
  START_SPEED_FOR_TIME: 0x09,
  START_SPEED_FOR_TIME_PAIR: 0x0A,
  START_SPEED_FOR_DEGREES: 0x0B,
  START_SPEED_FOR_DEGREES_PAIR: 0x0C,
  GO_TO_ABS_POSITION: 0x0D,
  GO_TO_ABS_POSITION_PAIR: 0x0E,
  PRESET_ENCODER: 0x14,
  WRITE_DIRECT_MODE_DATA: 0x51
};

/**
 * Enum for Startup/Completion information for an output command.
 * Startup and completion bytes must be OR'ed to be combined to a single byte.
 * @readonly
 * @enum {number}
 */
const BoostOutputExecution = {
  // Startup information
  BUFFER_IF_NECESSARY: 0x00,
  EXECUTE_IMMEDIATELY: 0x10,
  // Completion information
  NO_ACTION: 0x00,
  COMMAND_FEEDBACK: 0x01
};

/**
 * Enum for Boost Motor end states
 * @readonly
 * @enum {number}
 */
const BoostMotorEndState = {
  FLOAT: 0,
  HOLD: 126,
  BRAKE: 127
};

/**
 * Enum for Boost Motor acceleration/deceleration profiles
 * @readyonly
 * @enum {number}
 */
const BoostMotorProfile = {
  DO_NOT_USE: 0x00,
  ACCELERATION: 0x01,
  DECELERATION: 0x02
};

/**
 * Enum for when Boost IO's are attached/detached
 * @readonly
 * @enum {number}
 */
const BoostIOEvent = {
  ATTACHED: 0x01,
  DETACHED: 0x00,
  ATTACHED_VIRTUAL: 0x02
};

/**
 * Enum for selected sensor modes.
 * @enum {number}
 */
const BoostMode = {
  TILT: 0,
  // angle (pitch/yaw)
  LED: 1,
  // Set LED to accept RGB values
  COLOR: 0,
  // Read indexed colors from Vision Sensor
  MOTOR_SENSOR: 2,
  // Set motors to report their position
  UNKNOWN: 0 // Anything else will use the default mode (mode 0)
};

/**
 * Enum for Boost motor states.
 * @param {number}
 */
const BoostMotorState = {
  OFF: 0,
  ON_FOREVER: 1,
  ON_FOR_TIME: 2,
  ON_FOR_ROTATION: 3
};

/**
 * Helper function for converting a JavaScript number to an INT32-number
 * @param {number} number - a number
 * @return {array} - a 4-byte array of Int8-values representing an INT32-number
 */
const numberToInt32Array = function numberToInt32Array(number) {
  const buffer = new ArrayBuffer(4);
  const dataview = new DataView(buffer);
  dataview.setInt32(0, number);
  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];
};

/**
 * Helper function for converting a regular array to a Little Endian INT32-value
 * @param {Array} array - an array containing UInt8-values
 * @return {number} - a number
 */
const int32ArrayToNumber = function int32ArrayToNumber(array) {
  const i = Uint8Array.from(array);
  const d = new DataView(i.buffer);
  return d.getInt32(0, true);
};

/**
 * Manage power, direction, position, and timers for one Boost motor.
 */
class BoostMotor {
  /**
   * Construct a Boost Motor instance.
   * @param {Boost} parent - the Boost peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The Boost peripheral which owns this motor.
     * @type {Boost}
     * @private
     */
    this._parent = parent;

    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */
    this._index = index;

    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */
    this._direction = 1;

    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */
    this._power = 50;

    /**
     * This motor's current relative position
     * @type {number}
     * @private
     */
    this._position = 0;

    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */
    this._status = BoostMotorState.OFF;

    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */
    this._pendingDurationTimeoutId = null;

    /**
     * The starting time for the pending duration timeout.
     * @type {number}
     * @private
     */
    this._pendingDurationTimeoutStartTime = null;

    /**
     * The delay/duration of the pending duration timeout.
     * @type {number}
     * @private
     */
    this._pendingDurationTimeoutDelay = null;

    /**
     * The target position of a turn-based command.
     * @type {number}
     * @private
     */
    this._pendingRotationDestination = null;

    /**
     * If the motor has been turned on run for a specific rotation, this is the function
     * that will be called once Scratch VM gets a notification from the Move Hub.
     * @type {Object}
     * @private
     */
    this._pendingRotationPromise = null;
    this.turnOff = this.turnOff.bind(this);
  }

  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */
  get direction() {
    return this._direction;
  }

  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */
  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }

  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */
  get power() {
    return this._power;
  }

  /**
   * @param {int} value - this motor's new power level, in the range [10,100].
   */
  set power(value) {
    /**
     * Scale the motor power to a range between 10 and 100,
     * to make sure the motors will run with something built onto them.
     */
    if (value === 0) {
      this._power = 0;
    } else {
      this._power = MathUtil.scale(value, 1, 100, 10, 100);
    }
  }

  /**
   * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]
   */
  get position() {
    return this._position;
  }

  /**
   * @param {int} value - set this motor's current position.
   */
  set position(value) {
    this._position = value;
  }

  /**
   * @return {BoostMotorState} - the motor's current state.
   */
  get status() {
    return this._status;
  }

  /**
   * @param {BoostMotorState} value - set this motor's state.
   */
  set status(value) {
    this._clearRotationState();
    this._clearDurationTimeout();
    this._status = value;
  }

  /**
   * @return {number} - time, in milliseconds, of when the pending duration timeout began.
   */
  get pendingDurationTimeoutStartTime() {
    return this._pendingDurationTimeoutStartTime;
  }

  /**
   * @return {number} - delay, in milliseconds, of the pending duration timeout.
   */
  get pendingDurationTimeoutDelay() {
    return this._pendingDurationTimeoutDelay;
  }

  /**
   * @return {number} - target position, in degrees, of the pending rotation.
   */
  get pendingRotationDestination() {
    return this._pendingRotationDestination;
  }

  /**
   * @return {Promise} - the Promise function for the pending rotation.
   */
  get pendingRotationPromise() {
    return this._pendingRotationPromise;
  }

  /**
   * @param {function} func - function to resolve pending rotation Promise
   */
  set pendingRotationPromise(func) {
    this._pendingRotationPromise = func;
  }

  /**
   * Turn this motor on indefinitely
   * @private
   */
  _turnOn() {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);
    this._parent.send(BoostBLE.characteristic, cmd);
  }

  /**
   * Turn this motor on indefinitely
   */
  turnOnForever() {
    this.status = BoostMotorState.ON_FOREVER;
    this._turnOn();
  }

  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */
  turnOnFor(milliseconds) {
    milliseconds = Math.max(0, milliseconds);
    this.status = BoostMotorState.ON_FOR_TIME;
    this._turnOn();
    this._setNewDurationTimeout(this.turnOff, milliseconds);
  }

  /**
   * Turn this motor on for a specific rotation in degrees.
   * @param {number} degrees - run the motor for this amount of degrees.
   * @param {number} direction - rotate in this direction
   */
  turnOnForDegrees(degrees, direction) {
    degrees = Math.max(0, degrees);
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [...numberToInt32Array(degrees), this.power * this.direction * direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]);
    this.status = BoostMotorState.ON_FOR_ROTATION;
    this._pendingRotationDestination = this.position + degrees * this.direction * direction;
    this._parent.send(BoostBLE.characteristic, cmd);
  }

  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */
  turnOff() {
    let useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);
    this.status = BoostMotorState.OFF;
    this._parent.send(BoostBLE.characteristic, cmd, useLimiter);
  }

  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */
  _clearDurationTimeout() {
    if (this._pendingDurationTimeoutId !== null) {
      clearTimeout(this._pendingDurationTimeoutId);
      this._pendingDurationTimeoutId = null;
      this._pendingDurationTimeoutStartTime = null;
      this._pendingDurationTimeoutDelay = null;
    }
  }

  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */
  _setNewDurationTimeout(callback, delay) {
    this._clearDurationTimeout();
    const timeoutID = setTimeout(() => {
      if (this._pendingDurationTimeoutId === timeoutID) {
        this._pendingDurationTimeoutId = null;
        this._pendingDurationTimeoutStartTime = null;
        this._pendingDurationTimeoutDelay = null;
      }
      callback();
    }, delay);
    this._pendingDurationTimeoutId = timeoutID;
    this._pendingDurationTimeoutStartTime = Date.now();
    this._pendingDurationTimeoutDelay = delay;
  }

  /**
   * Clear the motor states related to rotation-based commands, if any.
   * Safe to call even when there is no pending promise function.
   * @private
   */
  _clearRotationState() {
    if (this._pendingRotationPromise !== null) {
      this._pendingRotationPromise();
      this._pendingRotationPromise = null;
    }
    this._pendingRotationDestination = null;
  }
}

/**
 * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.
 */
class Boost {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;

    /**
     * A list of the ids of the physical or virtual sensors.
     * @type {string[]}
     * @private
     */
    this._ports = [];

    /**
     * A list of motors registered by the Boost hardware.
     * @type {BoostMotor[]}
     * @private
     */
    this._motors = [];

    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };

    /**
     * An array of values from the Boost Vision Sensor.
     * @type {Array}
     * @private
     */
    this._colorSamples = [];

    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */
    this._ble = null;
    this._runtime.registerPeripheralExtension(extensionId, this);

    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */
    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);

    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */
    this._pingDeviceId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pingDevice = this._pingDevice.bind(this);
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */
  get tiltX() {
    return this._sensors.tiltX;
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */
  get tiltY() {
    return this._sensors.tiltY;
  }

  /**
   * @return {number} - the latest color value received from the vision sensor.
   */
  get color() {
    return this._sensors.color;
  }

  /**
   * @return {number} - the previous color value received from the vision sensor.
   */
  get previousColor() {
    return this._sensors.previousColor;
  }

  /**
   * Look up the color id for an index received from the vision sensor.
   * @param {number} index - the color index to look up.
   * @return {BoostColor} the color id for this index.
   */
  boostColorForIndex(index) {
    const colorForIndex = Object.keys(BoostColorIndex).find(key => BoostColorIndex[key] === index);
    return colorForIndex || BoostColor.NONE;
  }

  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the index of the desired motor.
   * @return {BoostMotor} - the BoostMotor instance, if any, at that index.
   */
  motor(index) {
    return this._motors[index];
  }

  /**
   * Stop all the motors that are currently running.
   */
  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }

  /**
   * Set the Boost peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */
  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];
    const cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED, ...rgb]);
    return this.send(BoostBLE.characteristic, cmd);
  }

  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */
  setLEDMode() {
    const cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);
    return this.send(BoostBLE.characteristic, cmd);
  }

  /**
   * Stop the motors on the Boost peripheral.
   */
  stopAll() {
    if (!this.isConnected()) return;
    this.stopAllMotors();
  }

  /**
   * Called by the runtime when user wants to scan for a Boost peripheral.
   */
  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BoostBLE.service],
        manufacturerData: {
          0x0397: {
            dataPrefix: [0x00, 0x40],
            mask: [0x00, 0xFF]
          }
        }
      }],
      optionalServices: []
    }, this._onConnect, this.reset);
  }

  /**
   * Called by the runtime when user wants to connect to a certain Boost peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */
  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }

  /**
   * Disconnects from the current BLE socket and resets state.
   */
  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this.reset();
  }

  /**
   * Reset all the state and timeout/interval ids.
   */
  reset() {
    this._ports = [];
    this._motors = [];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };
    if (this._pingDeviceId) {
      window.clearInterval(this._pingDeviceId);
      this._pingDeviceId = null;
    }
  }

  /**
   * Called by the runtime to detect whether the Boost peripheral is connected.
   * @return {boolean} - the connected state.
   */
  isConnected() {
    let connected = false;
    if (this._ble) {
      connected = this._ble.isConnected();
    }
    return connected;
  }

  /**
   * Write a message to the Boost peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */
  send(uuid, message) {
    let useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!this.isConnected()) return Promise.resolve();
    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }
    return this._ble.write(BoostBLE.service, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');
  }

  /**
   * Generate a Boost 'Output Command' in the byte array format
   * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).
   *
   * Payload is accepted as an array since these vary across different subcommands.
   *
   * @param  {number} portID - the port (Connect ID) to send a command to.
   * @param  {number} execution - Byte containing startup/completion information
   * @param  {number} subCommand - the id of the subcommand byte.
   * @param  {array}  payload    - the list of bytes to send as subcommand payload
   * @return {array}            - a generated output command.
   */
  generateOutputCommand(portID, execution, subCommand, payload) {
    const hubID = 0x00;
    const command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand, ...payload];
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }

  /**
   * Generate a Boost 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the Boost that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  portID           - the port (Connect ID) to send a command to.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */
  generateInputCommand(portID, mode, delta, enableNotifications) {
    const command = [0x00,
    // Hub ID
    BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }

  /**
   * Starts reading data from peripheral after BLE has connected.
   * @private
   */
  _onConnect() {
    this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);
    this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval);

    // Send a request for firmware version.
    setTimeout(() => {
      const command = [0x00,
      // Hub ID
      BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];
      command.unshift(command.length + 1);
      this.send(BoostBLE.characteristic, command, false);
    }, 500);
  }

  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */
  _onMessage(base64) {
    const data = Base64Util.base64ToUint8Array(base64);

    /**
     * First three bytes are the common header:
     * 0: Length of message
     * 1: Hub ID (always 0x00 at the moment, unused)
     * 2: Message Type
     * 3: Port ID
     * We base our switch-case on Message Type
     */

    const messageType = data[2];
    const portID = data[3];
    switch (messageType) {
      case BoostMessage.HUB_PROPERTIES:
        {
          const property = data[3];
          switch (property) {
            case BoostHubProperty.FW_VERSION:
              {
                // Establish firmware version 1.0.00.0224 as a 32-bit signed integer (little endian)
                const fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);
                const fwHub = int32ArrayToNumber(data.slice(5, data.length));
                if (fwHub < fwVersion10000224) {
                  BoostPort = BoostPort10000223OrOlder;
                  log.info('Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.');
                } else {
                  BoostPort = BoostPort10000224OrNewer;
                }
                break;
              }
          }
          break;
        }
      case BoostMessage.HUB_ATTACHED_IO:
        {
          // IO Attach/Detach events
          const event = data[4];
          const typeId = data[5];
          switch (event) {
            case BoostIOEvent.ATTACHED:
              this._registerSensorOrMotor(portID, typeId);
              break;
            case BoostIOEvent.DETACHED:
              this._clearPort(portID);
              break;
            case BoostIOEvent.ATTACHED_VIRTUAL:
            default:
          }
          break;
        }
      case BoostMessage.PORT_VALUE:
        {
          const type = this._ports[portID];
          switch (type) {
            case BoostIO.TILT:
              this._sensors.tiltX = data[4];
              this._sensors.tiltY = data[5];
              break;
            case BoostIO.COLOR:
              this._colorSamples.unshift(data[4]);
              if (this._colorSamples.length > BoostColorSampleSize) {
                this._colorSamples.pop();
                if (this._colorSamples.every((v, i, arr) => v === arr[0])) {
                  this._sensors.previousColor = this._sensors.color;
                  this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);
                } else {
                  this._sensors.color = BoostColor.NONE;
                }
              } else {
                this._sensors.color = BoostColor.NONE;
              }
              break;
            case BoostIO.MOTOREXT:
            case BoostIO.MOTORINT:
              this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));
              break;
            case BoostIO.CURRENT:
            case BoostIO.VOLTAGE:
            case BoostIO.LED:
              break;
            default:
              log.warn("Unknown sensor value! Type: ".concat(type));
          }
          break;
        }
      case BoostMessage.PORT_FEEDBACK:
        {
          const feedback = data[4];
          const motor = this.motor(portID);
          if (motor) {
            // Makes sure that commands resolve both when they actually complete and when they fail
            const isBusy = feedback & BoostPortFeedback.IN_PROGRESS;
            const commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);
            if (!isBusy && commandCompleted) {
              if (motor.status === BoostMotorState.ON_FOR_ROTATION) {
                motor.status = BoostMotorState.OFF;
              }
            }
          }
          break;
        }
      case BoostMessage.ERROR:
        log.warn("Error reported by hub: ".concat(data));
        break;
    }
  }

  /**
   * Ping the Boost hub. If the Boost hub has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   * @private
   */
  _pingDevice() {
    this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);
  }

  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} portID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */
  _registerSensorOrMotor(portID, type) {
    // Record which port is connected to what type of device
    this._ports[portID] = type;

    // Record motor port
    if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {
      this._motors[portID] = new BoostMotor(this, portID);
    }

    // Set input format for tilt or distance sensor
    let mode = null;
    let delta = 1;
    switch (type) {
      case BoostIO.MOTORINT:
      case BoostIO.MOTOREXT:
        mode = BoostMode.MOTOR_SENSOR;
        break;
      case BoostIO.COLOR:
        mode = BoostMode.COLOR;
        delta = 0;
        break;
      case BoostIO.LED:
        mode = BoostMode.LED;
        /**
         * Sets the LED to blue to give an indication on the hub
         * that it has connected successfully.
         */
        this.setLEDMode();
        this.setLED(0x0000FF);
        break;
      case BoostIO.TILT:
        mode = BoostMode.TILT;
        break;
      default:
        mode = BoostMode.UNKNOWN;
    }
    const cmd = this.generateInputCommand(portID, mode, delta, true // Receive feedback
    );
    this.send(BoostBLE.characteristic, cmd);
  }

  /**
   * Clear the sensors or motors present on the ports.
   * @param {number} portID - the port to clear.
   * @private
   */
  _clearPort(portID) {
    const type = this._ports[portID];
    if (type === BoostIO.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }
    if (type === BoostIO.COLOR) {
      this._sensors.color = BoostColor.NONE;
    }
    this._ports[portID] = 'none';
    this._motors[portID] = null;
  }
}

/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */
const BoostMotorLabel = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  AB: 'AB',
  ALL: 'ABCD'
};

/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */
const BoostMotorDirection = {
  FORWARD: 'this way',
  BACKWARD: 'that way',
  REVERSE: 'reverse'
};

/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */
const BoostTiltDirection = {
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};

/**
 * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.
 */
class Scratch3BoostBlocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'boost';
  }

  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */
  static get TILT_THRESHOLD() {
    return 15;
  }

  /**
   * Construct a set of Boost blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    // Create a new Boost peripheral instance
    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: Scratch3BoostBlocks.EXTENSION_ID,
      name: 'BOOST',
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorOnFor',
        text: formatMessage({
          id: 'boost.motorOnFor',
          default: 'turn motor [MOTOR_ID] for [DURATION] seconds',
          description: 'turn a motor on for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOnForRotation',
        text: formatMessage({
          id: 'boost.motorOnForRotation',
          default: 'turn motor [MOTOR_ID] for [ROTATION] rotations',
          description: 'turn a motor on for rotation'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          ROTATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOn',
        text: formatMessage({
          id: 'boost.motorOn',
          default: 'turn motor [MOTOR_ID] on',
          description: 'turn a motor on indefinitely'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'motorOff',
        text: formatMessage({
          id: 'boost.motorOff',
          default: 'turn motor [MOTOR_ID] off',
          description: 'turn a motor off'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'setMotorPower',
        text: formatMessage({
          id: 'boost.setMotorPower',
          default: 'set motor [MOTOR_ID] speed to [POWER] %',
          description: 'set the motor\'s speed without turning it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.ALL
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'setMotorDirection',
        text: formatMessage({
          id: 'boost.setMotorDirection',
          default: 'set motor [MOTOR_ID] direction [MOTOR_DIRECTION]',
          description: 'set the motor\'s turn direction without turning it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_DIRECTION',
            defaultValue: BoostMotorDirection.FORWARD
          }
        }
      }, {
        opcode: 'getMotorPosition',
        text: formatMessage({
          id: 'boost.getMotorPosition',
          default: 'motor [MOTOR_REPORTER_ID] position',
          description: 'the position returned by the motor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          MOTOR_REPORTER_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_REPORTER_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'whenColor',
        text: formatMessage({
          id: 'boost.whenColor',
          default: 'when [COLOR] brick seen',
          description: 'check for when color'
        }),
        blockType: BlockType.HAT,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: 'COLOR',
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: 'seeingColor',
        text: formatMessage({
          id: 'boost.seeingColor',
          default: 'seeing [COLOR] brick?',
          description: 'is the color sensor seeing a certain color?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: 'COLOR',
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'boost.whenTilted',
          default: 'when tilted [TILT_DIRECTION_ANY]',
          description: 'check when tilted in a certain direction'
        }),
        func: 'isTilted',
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: BoostTiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'boost.getTiltAngle',
          default: 'tilt angle [TILT_DIRECTION]',
          description: 'the angle returned by the tilt sensor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION',
            defaultValue: BoostTiltDirection.UP
          }
        }
      }, {
        opcode: 'setLightHue',
        text: formatMessage({
          id: 'boost.setLightHue',
          default: 'set light color to [HUE]',
          description: 'set the LED color'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: 'A',
            value: BoostMotorLabel.A
          }, {
            text: 'B',
            value: BoostMotorLabel.B
          }, {
            text: 'C',
            value: BoostMotorLabel.C
          }, {
            text: 'D',
            value: BoostMotorLabel.D
          }, {
            text: 'AB',
            value: BoostMotorLabel.AB
          }, {
            text: 'ABCD',
            value: BoostMotorLabel.ALL
          }]
        },
        MOTOR_REPORTER_ID: {
          acceptReporters: true,
          items: [{
            text: 'A',
            value: BoostMotorLabel.A
          }, {
            text: 'B',
            value: BoostMotorLabel.B
          }, {
            text: 'C',
            value: BoostMotorLabel.C
          }, {
            text: 'D',
            value: BoostMotorLabel.D
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.motorDirection.forward',
              default: 'this way',
              description: 'label for forward element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: 'boost.motorDirection.backward',
              default: 'that way',
              description: 'label for backward element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: 'boost.motorDirection.reverse',
              default: 'reverse',
              description: 'label for reverse element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.tiltDirection.up',
              default: 'up',
              description: 'label for up element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.down',
              default: 'down',
              description: 'label for down element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.left',
              default: 'left',
              description: 'label for left element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.right',
              default: 'right',
              description: 'label for right element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.tiltDirection.up',
              default: 'up'
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.down',
              default: 'down'
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.left',
              default: 'left'
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.right',
              default: 'right'
            }),
            value: BoostTiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.any',
              default: 'any',
              description: 'label for any element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.ANY
          }]
        },
        COLOR: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.color.red',
              default: 'red',
              description: 'the color red'
            }),
            value: BoostColor.RED
          }, {
            text: formatMessage({
              id: 'boost.color.blue',
              default: 'blue',
              description: 'the color blue'
            }),
            value: BoostColor.BLUE
          }, {
            text: formatMessage({
              id: 'boost.color.green',
              default: 'green',
              description: 'the color green'
            }),
            value: BoostColor.GREEN
          }, {
            text: formatMessage({
              id: 'boost.color.yellow',
              default: 'yellow',
              description: 'the color yellow'
            }),
            value: BoostColor.YELLOW
          }, {
            text: formatMessage({
              id: 'boost.color.white',
              default: 'white',
              desription: 'the color white'
            }),
            value: BoostColor.WHITE
          }, {
            text: formatMessage({
              id: 'boost.color.black',
              default: 'black',
              description: 'the color black'
            }),
            value: BoostColor.BLACK
          }, {
            text: formatMessage({
              id: 'boost.color.any',
              default: 'any color',
              description: 'any color'
            }),
            value: BoostColor.ANY
          }]
        }
      }
    };
  }

  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */
  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);
        if (motor) motor.turnOnFor(durationMS);
      });

      // Run for some time even when no motor is connected
      setTimeout(resolve, durationMS);
    });
  }

  /**
   * Turn specified motor(s) on for a specified rotation in full rotations.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} ROTATION - the amount of full rotations to turn the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */
  motorOnForRotation(args) {
    // TODO: cast args.MOTOR_ID?
    let degrees = Cast.toNumber(args.ROTATION) * 360;
    // TODO: Clamps to 100 rotations. Consider changing.
    const sign = Math.sign(degrees);
    degrees = Math.abs(MathUtil.clamp(degrees, -360000, 360000));
    const motors = [];
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      motors.push(motorIndex);
    });

    /**
     * Checks that the motors given in args.MOTOR_ID exist,
     * and maps a promise for each of the motor-commands to an array.
     */
    const promises = motors.map(portID => {
      const motor = this._peripheral.motor(portID);
      if (motor) {
        // to avoid a hanging block if power is 0, return an immediately resolving promise.
        if (motor.power === 0) return Promise.resolve();
        return new Promise(resolve => {
          motor.turnOnForDegrees(degrees, sign);
          motor.pendingRotationPromise = resolve;
        });
      }
      return null;
    });
    /**
     * Make sure all promises are resolved, i.e. all motor-commands have completed.
     * To prevent the block from returning a value, an empty function is added to the .then
     */
    return Promise.all(promises).then(() => {});
  }

  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */
  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) motor.turnOnForever();
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */
  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) motor.turnOff();
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

  /**
   * Set the power level of the specified motor(s).
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */
  setMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);
        switch (motor.status) {
          case BoostMotorState.ON_FOREVER:
            motor.turnOnForever();
            break;
          case BoostMotorState.ON_FOR_TIME:
            motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
            break;
        }
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */
  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case BoostMotorDirection.FORWARD:
            motor.direction = 1;
            break;
          case BoostMotorDirection.BACKWARD:
            motor.direction = -1;
            break;
          case BoostMotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;
          default:
            log.warn("Unknown motor direction in setMotorDirection: ".concat(args.DIRECTION));
            break;
        }
        // keep the motor on if it's running, and update the pending timeout if needed
        if (motor) {
          switch (motor.status) {
            case BoostMotorState.ON_FOREVER:
              motor.turnOnForever();
              break;
            case BoostMotorState.ON_FOR_TIME:
              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
              break;
          }
        }
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

  /**
   * @param {object} args - the block's arguments.
   * @return {number} - returns the motor's position.
   */
  getMotorPosition(args) {
    let portID = null;
    switch (args.MOTOR_REPORTER_ID) {
      case BoostMotorLabel.A:
        portID = BoostPort.A;
        break;
      case BoostMotorLabel.B:
        portID = BoostPort.B;
        break;
      case BoostMotorLabel.C:
        portID = BoostPort.C;
        break;
      case BoostMotorLabel.D:
        portID = BoostPort.D;
        break;
      default:
        log.warn('Asked for a motor position that doesnt exist!');
        return false;
    }
    if (portID !== null && this._peripheral.motor(portID)) {
      let val = this._peripheral.motor(portID).position;
      // Boost motor A position direction is reversed by design
      // so we have to reverse the position here
      if (portID === BoostPort.A) {
        val *= -1;
      }
      return MathUtil.wrapClamp(val, 0, 360);
    }
    return 0;
  }

  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */
  _forEachMotor(motorID, callback) {
    let motors;
    switch (motorID) {
      case BoostMotorLabel.A:
        motors = [BoostPort.A];
        break;
      case BoostMotorLabel.B:
        motors = [BoostPort.B];
        break;
      case BoostMotorLabel.C:
        motors = [BoostPort.C];
        break;
      case BoostMotorLabel.D:
        motors = [BoostPort.D];
        break;
      case BoostMotorLabel.AB:
        motors = [BoostPort.A, BoostPort.B];
        break;
      case BoostMotorLabel.ALL:
        motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];
        break;
      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }
    for (const index of motors) {
      callback(index);
    }
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }

  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */
  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */
  _isTilted(direction) {
    switch (direction) {
      case BoostTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;
      default:
        return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;
    }
  }

  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */
  _getTiltAngle(direction) {
    switch (direction) {
      case BoostTiltDirection.UP:
        return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;
      case BoostTiltDirection.DOWN:
        return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;
      case BoostTiltDirection.LEFT:
        return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;
      case BoostTiltDirection.RIGHT:
        return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;
      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }

  /**
   * Edge-triggering hat function, for when the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */
  whenColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      // For "any" color, return true if the color is not "none", and
      // the color is different from the previous color detected. This
      // allows the hat to trigger when the color changes from one color
      // to another.
      return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;
    }
    return args.COLOR === this._peripheral.color;
  }

  /**
   * A boolean reporter function, for whether the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */
  seeingColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      return this._peripheral.color !== BoostColor.NONE;
    }
    return args.COLOR === this._peripheral.color;
  }

  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */
  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Cast.toNumber(args.HUE);
    inputHue = MathUtil.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = color.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);
    this._peripheral._led = inputHue;
    this._peripheral.setLED(rgbDecimal);
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
}
module.exports = Scratch3BoostBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_ev3/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_ev3/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const uid = __webpack_require__(/*! ../../util/uid */ "./src/util/uid.js");
const BT = __webpack_require__(/*! ../../io/bt */ "./src/io/bt.js");
const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUwLjIgKDU1MDQ3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5ldjMtYmxvY2staWNvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJldjMtYmxvY2staWNvbiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImV2MyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS41MDAwMDAsIDMuNTAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgeD0iMC41IiB5PSIzLjU5IiB3aWR0aD0iMjgiIGhlaWdodD0iMjUuODEiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRTZFN0U4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMC41IiB3aWR0aD0iMjQiIGhlaWdodD0iMzIiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRkZGRkZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMTQuNSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjEzIj48L3JlY3Q+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC41LDEwLjUgTDE0LjUsMTQuNSIgaWQ9IlNoYXBlIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNFNkU3RTgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PC9wYXRoPgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIGZpbGw9IiM0MTQ3NTciIHg9IjQuNSIgeT0iMi41IiB3aWR0aD0iMjAiIGhlaWdodD0iMTAiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB4PSIxMy41IiB5PSIyMC4xMyIgd2lkdGg9IjIiIGhlaWdodD0iMiIgcng9IjAuNSI+PC9yZWN0PgogICAgICAgICAgICA8cGF0aCBkPSJNOS4wNiwyMC4xMyBMMTAuNTYsMjAuMTMgQzEwLjgzNjE0MjQsMjAuMTMgMTEuMDYsMjAuMzUzODU3NiAxMS4wNiwyMC42MyBMMTEuMDYsMjEuNjMgQzExLjA2LDIxLjkwNjE0MjQgMTAuODM2MTQyNCwyMi4xMyAxMC41NiwyMi4xMyBMOS4wNiwyMi4xMyBDOC41MDc3MTUyNSwyMi4xMyA4LjA2LDIxLjY4MjI4NDcgOC4wNiwyMS4xMyBDOC4wNiwyMC41Nzc3MTUzIDguNTA3NzE1MjUsMjAuMTMgOS4wNiwyMC4xMyBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTguOTEsMjAuMTMgTDIwLjQyLDIwLjEzIEMyMC42OTYxNDI0LDIwLjEzIDIwLjkyLDIwLjM1Mzg1NzYgMjAuOTIsMjAuNjMgTDIwLjkyLDIxLjYzIEMyMC45MiwyMS45MDYxNDI0IDIwLjY5NjE0MjQsMjIuMTMgMjAuNDIsMjIuMTMgTDE4LjkyLDIyLjEzIEMxOC4zNjc3MTUzLDIyLjEzIDE3LjkyLDIxLjY4MjI4NDcgMTcuOTIsMjEuMTMgQzE3LjkxOTk3MjYsMjAuNTgxNTk3IDE4LjM2MTYyNDUsMjAuMTM1NDg0IDE4LjkxLDIwLjEzIFoiIGlkPSJTaGFwZSIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOS40MjAwMDAsIDIxLjEzMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTE5LjQyMDAwMCwgLTIxLjEzMDAwMCkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjIzLDE3LjUgTDUsMTcuNSBDNC43MjM4NTc2MywxNy41IDQuNSwxNy4yNzYxNDI0IDQuNSwxNyBMNC41LDE0LjUgTDEwLjUsMTQuNSBMOC42NSwxNy4yOCBDOC41NTQ2Njk2MSwxNy40MTc5MDgyIDguMzk3NjUwMDYsMTcuNTAwMTU2NiA4LjIzLDE3LjUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE4LjE1LDE4Ljg1IEwxNy42NSwxOS4zNSBDMTcuNTUyMzQxNiwxOS40NDQwNzU2IDE3LjQ5ODAzMzksMTkuNTc0NDE0MiAxNy41LDE5LjcxIEwxNy41LDIwIEMxNy41LDIwLjI3NjE0MjQgMTcuMjc2MTQyNCwyMC41IDE3LDIwLjUgTDE2LjUsMjAuNSBDMTYuMjIzODU3NiwyMC41IDE2LDIwLjI3NjE0MjQgMTYsMjAgQzE2LDE5LjcyMzg1NzYgMTUuNzc2MTQyNCwxOS41IDE1LjUsMTkuNSBMMTMuNSwxOS41IEMxMy4yMjM4NTc2LDE5LjUgMTMsMTkuNzIzODU3NiAxMywyMCBDMTMsMjAuMjc2MTQyNCAxMi43NzYxNDI0LDIwLjUgMTIuNSwyMC41IEwxMiwyMC41IEMxMS43MjM4NTc2LDIwLjUgMTEuNSwyMC4yNzYxNDI0IDExLjUsMjAgTDExLjUsMTkuNzEgQzExLjUwMTk2NjEsMTkuNTc0NDE0MiAxMS40NDc2NTg0LDE5LjQ0NDA3NTYgMTEuMzUsMTkuMzUgTDEwLjg1LDE4Ljg1IEMxMC42NTgyMTY3LDE4LjY1MjE4NjMgMTAuNjU4MjE2NywxOC4zMzc4MTM3IDEwLjg1LDE4LjE0IEwxMi4zNiwxNi42NSBDMTIuNDUwMjgwMywxNi41NTI4NjE3IDEyLjU3NzM5NjEsMTYuNDk4MzgzNSAxMi43MSwxNi41IEwxNi4yOSwxNi41IEMxNi40MjI2MDM5LDE2LjQ5ODM4MzUgMTYuNTQ5NzE5NywxNi41NTI4NjE3IDE2LjY0LDE2LjY1IEwxOC4xNSwxOC4xNCBDMTguMzQxNzgzMywxOC4zMzc4MTM3IDE4LjM0MTc4MzMsMTguNjUyMTg2MyAxOC4xNSwxOC44NSBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTAuODUsMjMuNDUgTDExLjM1LDIyLjk1IEMxMS40NDc2NTg0LDIyLjg1NTkyNDQgMTEuNTAxOTY2MSwyMi43MjU1ODU4IDExLjUsMjIuNTkgTDExLjUsMjIuMyBDMTEuNSwyMi4wMjM4NTc2IDExLjcyMzg1NzYsMjEuOCAxMiwyMS44IEwxMi41LDIxLjggQzEyLjc3NjE0MjQsMjEuOCAxMywyMi4wMjM4NTc2IDEzLDIyLjMgQzEzLDIyLjU3NjE0MjQgMTMuMjIzODU3NiwyMi44IDEzLjUsMjIuOCBMMTUuNSwyMi44IEMxNS43NzYxNDI0LDIyLjggMTYsMjIuNTc2MTQyNCAxNiwyMi4zIEMxNiwyMi4wMjM4NTc2IDE2LjIyMzg1NzYsMjEuOCAxNi41LDIxLjggTDE3LDIxLjggQzE3LjI3NjE0MjQsMjEuOCAxNy41LDIyLjAyMzg1NzYgMTcuNSwyMi4zIEwxNy41LDIyLjU5IEMxNy40OTgwMzM5LDIyLjcyNTU4NTggMTcuNTUyMzQxNiwyMi44NTU5MjQ0IDE3LjY1LDIyLjk1IEwxOC4xNSwyMy40NSBDMTguMzQwNTcxNCwyMy42NDQ0MjE4IDE4LjM0MDU3MTQsMjMuOTU1NTc4MiAxOC4xNSwyNC4xNSBMMTYuNjQsMjUuNjUgQzE2LjU0OTcxOTcsMjUuNzQ3MTM4MyAxNi40MjI2MDM5LDI1LjgwMTYxNjUgMTYuMjksMjUuOCBMMTIuNzEsMjUuOCBDMTIuNTc3Mzk2MSwyNS44MDE2MTY1IDEyLjQ1MDI4MDMsMjUuNzQ3MTM4MyAxMi4zNiwyNS42NSBMMTAuODUsMjQuMTUgQzEwLjY1OTQyODYsMjMuOTU1NTc4MiAxMC42NTk0Mjg2LDIzLjY0NDQyMTggMTAuODUsMjMuNDUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTIxLjUsMjcuNSBMMjYuNSwyNy41IEwyNi41LDMxLjUgQzI2LjUsMzIuMDUyMjg0NyAyNi4wNTIyODQ3LDMyLjUgMjUuNSwzMi41IEwyMS41LDMyLjUgTDIxLjUsMjcuNSBaIiBpZD0iU2hhcGUiIHN0cm9rZT0iI0NDNEMyMyIgZmlsbD0iI0YxNUEyOSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=';

/**
 * String with Ev3 expected pairing pin.
 * @readonly
 */
const Ev3PairingPin = '1234';

/**
 * A maximum number of BT message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */
const BTSendRateMax = 40;

/**
 * Enum for Ev3 parameter encodings of various argument and return values.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 9, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 *
 * The format for these values is:
 * 0xxxxxxx for Short Format
 * 1ttt-bbb for Long Format
 *
 * @readonly
 * @enum {number}
 */
const Ev3Encoding = {
  ONE_BYTE: 0x81,
  // = 0b1000-001, "1 byte to follow"
  TWO_BYTES: 0x82,
  // = 0b1000-010, "2 bytes to follow"
  FOUR_BYTES: 0x83,
  // = 0b1000-011, "4 bytes to follow"
  GLOBAL_VARIABLE_ONE_BYTE: 0xE1,
  // = 0b1110-001, "1 byte to follow"
  GLOBAL_CONSTANT_INDEX_0: 0x20,
  // = 0b00100000
  GLOBAL_VARIABLE_INDEX_0: 0x60 // = 0b01100000
};

/**
 * Enum for Ev3 direct command types.
 * Found in the 'EV3 Communication Developer Kit', section 4, page 24, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */
const Ev3Command = {
  DIRECT_COMMAND_REPLY: 0x00,
  DIRECT_COMMAND_NO_REPLY: 0x80,
  DIRECT_REPLY: 0x02
};

/**
 * Enum for Ev3 commands opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section 4, page 10, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */
const Ev3Opcode = {
  OPOUTPUT_STEP_SPEED: 0xAE,
  OPOUTPUT_TIME_SPEED: 0xAF,
  OPOUTPUT_STOP: 0xA3,
  OPOUTPUT_RESET: 0xA2,
  OPOUTPUT_STEP_SYNC: 0xB0,
  OPOUTPUT_TIME_SYNC: 0xB1,
  OPOUTPUT_GET_COUNT: 0xB3,
  OPSOUND: 0x94,
  OPSOUND_CMD_TONE: 1,
  OPSOUND_CMD_STOP: 0,
  OPINPUT_DEVICE_LIST: 0x98,
  OPINPUT_READSI: 0x9D
};

/**
 * Enum for Ev3 values used as arguments to various opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 10-onwards, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */
const Ev3Args = {
  LAYER: 0,
  // always 0, chained EV3s not supported
  COAST: 0,
  BRAKE: 1,
  RAMP: 50,
  // time in milliseconds
  DO_NOT_CHANGE_TYPE: 0,
  MAX_DEVICES: 32 // 'Normally 32' from pg. 46
};

/**
 * Enum for Ev3 device type numbers.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {string}
 */
const Ev3Device = {
  29: 'color',
  30: 'ultrasonic',
  32: 'gyro',
  16: 'touch',
  8: 'mediumMotor',
  7: 'largeMotor',
  126: 'none',
  125: 'none'
};

/**
 * Enum for Ev3 device modes.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */
const Ev3Mode = {
  touch: 0,
  // touch
  color: 1,
  // ambient
  ultrasonic: 1,
  // inch
  none: 0
};

/**
 * Enum for Ev3 device labels used in the Scratch blocks/UI.
 * @readonly
 * @enum {string}
 */
const Ev3Label = {
  touch: 'button',
  color: 'brightness',
  ultrasonic: 'distance'
};

/**
 * Manage power, direction, and timers for one EV3 motor.
 */
class EV3Motor {
  /**
   * Construct a EV3 Motor instance, which could be of type 'largeMotor' or
   * 'mediumMotor'.
   *
   * @param {EV3} parent - the EV3 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   * @param {string} type - the type of motor (i.e. 'largeMotor' or 'mediumMotor').
   */
  constructor(parent, index, type) {
    /**
     * The EV3 peripheral which owns this motor.
     * @type {EV3}
     * @private
     */
    this._parent = parent;

    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */
    this._index = index;

    /**
     * The type of EV3 motor this could be: 'largeMotor' or 'mediumMotor'.
     * @type {string}
     * @private
     */
    this._type = type;

    /**
     * This motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
     * @type {number}
     * @private
     */
    this._direction = 1;

    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */
    this._power = 50;

    /**
     * This motor's current position, in the range [0,360].
     * @type {number}
     * @private
     */
    this._position = 0;

    /**
     * An ID for the current coast command, to help override multiple coast
     * commands sent in succession.
     * @type {number}
     * @private
     */
    this._commandID = null;

    /**
     * A delay, in milliseconds, to add to coasting, to make sure that a brake
     * first takes effect if one was sent.
     * @type {number}
     * @private
     */
    this._coastDelay = 1000;
  }

  /**
   * @return {string} - this motor's type: 'largeMotor' or 'mediumMotor'
   */
  get type() {
    return this._type;
  }

  /**
   * @param {string} value - this motor's new type: 'largeMotor' or 'mediumMotor'
   */
  set type(value) {
    this._type = value;
  }

  /**
   * @return {int} - this motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
   */
  get direction() {
    return this._direction;
  }

  /**
   * @param {int} value - this motor's new direction: 1 for "clockwise" or -1 for "counterclockwise"
   */
  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }

  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */
  get power() {
    return this._power;
  }

  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */
  set power(value) {
    this._power = value;
  }

  /**
   * @return {int} - this motor's current position, in the range [-inf,inf].
   */
  get position() {
    return this._position;
  }

  /**
   * @param {int} array - this motor's new position, in the range [0,360].
   */
  set position(array) {
    // tachoValue from Paula
    let value = array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;
    if (value > 0x7fffffff) {
      value = value - 0x100000000;
    }
    this._position = value;
  }

  /**
   * Turn this motor on for a specific duration.
   * Found in the 'EV3 Firmware Developer Kit', page 56, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Opcode arguments:
   * (Data8) LAYER  Specify chain layer number [0 - 3]
   * (Data8) NOS  Output bit field [0x00  0x0F]
   * (Data8) SPEED  Power level, [-100  100]
   * (Data32) STEP1  Time in milliseconds for ramp up
   * (Data32) STEP2  Time in milliseconds for continues run
   * (Data32) STEP3  Time in milliseconds for ramp down
   * (Data8) BRAKE - Specify break level [0: Float, 1: Break]
   *
   * @param {number} milliseconds - run the motor for this long.
   */
  turnOnFor(milliseconds) {
    if (this._power === 0) return;
    const port = this._portMask(this._index);
    let n = milliseconds;
    let speed = this._power * this._direction;
    const ramp = Ev3Args.RAMP;
    let byteCommand = [];
    byteCommand[0] = Ev3Opcode.OPOUTPUT_TIME_SPEED;

    // If speed is less than zero, make it positive and multiply the input
    // value by -1
    if (speed < 0) {
      speed = -1 * speed;
      n = -1 * n;
    }
    // If the input value is less than 0
    const dir = n < 0 ? 0x100 - speed : speed; // step negative or positive
    n = Math.abs(n);
    // Setup motor run duration and ramping behavior
    let rampup = ramp;
    let rampdown = ramp;
    let run = n - ramp * 2;
    if (run < 0) {
      rampup = Math.floor(n / 2);
      run = 0;
      rampdown = n - rampup;
    }
    // Generate motor command values
    const runcmd = this._runValues(run);
    byteCommand = byteCommand.concat([Ev3Args.LAYER, port, Ev3Encoding.ONE_BYTE, dir & 0xff, Ev3Encoding.ONE_BYTE, rampup]).concat(runcmd.concat([Ev3Encoding.ONE_BYTE, rampdown, Ev3Args.BRAKE]));
    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, byteCommand);
    this._parent.send(cmd);
    this.coastAfter(milliseconds);
  }

  /**
   * Set the motor to coast after a specified amount of time.
   * @param {number} time - the time in milliseconds.
   */
  coastAfter(time) {
    if (this._power === 0) return;

    // Set the motor command id to check before starting coast
    const commandId = uid();
    this._commandID = commandId;

    // Send coast message
    setTimeout(() => {
      // Do not send coast if another motor command changed the command id.
      if (this._commandID === commandId) {
        this.coast();
        this._commandID = null;
      }
    }, time + this._coastDelay); // add a delay so the brake takes effect
  }

  /**
   * Set the motor to coast.
   */
  coast() {
    if (this._power === 0) return;
    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPOUTPUT_STOP, Ev3Args.LAYER, this._portMask(this._index),
    // port output bit field
    Ev3Args.COAST]);
    this._parent.send(cmd, false); // don't use rate limiter to ensure motor stops
  }

  /**
   * Generate motor run values for a given input.
   * @param  {number} run - run input.
   * @return {array} - run values as a byte array.
   */
  _runValues(run) {
    // If run duration is less than max 16-bit integer
    if (run < 0x7fff) {
      return [Ev3Encoding.TWO_BYTES, run & 0xff, run >> 8 & 0xff];
    }

    // Run forever
    return [Ev3Encoding.FOUR_BYTES, run & 0xff, run >> 8 & 0xff, run >> 16 & 0xff, run >> 24 & 0xff];
  }

  /**
   * Return a port value for the EV3 that is in the format for 'output bit field'
   * as 1/2/4/8, generally needed for motor ports, instead of the typical 0/1/2/3.
   * The documentation in the 'EV3 Firmware Developer Kit' for motor port arguments
   * is sometimes mistaken, but we believe motor ports are mostly addressed this way.
   * @param {number} port - the port number to convert to an 'output bit field'.
   * @return {number} - the converted port number.
   */
  _portMask(port) {
    return Math.pow(2, port);
  }
}
class EV3 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;

    /**
     * A list of the names of the sensors connected in ports 1,2,3,4.
     * @type {string[]}
     * @private
     */
    this._sensorPorts = [];

    /**
     * A list of the names of the motors connected in ports A,B,C,D.
     * @type {string[]}
     * @private
     */
    this._motorPorts = [];

    /**
     * The state of all sensor values.
     * @type {string[]}
     * @private
     */
    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };

    /**
     * The motors which this EV3 could possibly have connected.
     * @type {string[]}
     * @private
     */
    this._motors = [null, null, null, null];

    /**
     * The polling interval, in milliseconds.
     * @type {number}
     * @private
     */
    this._pollingInterval = 150;

    /**
     * The polling interval ID.
     * @type {number}
     * @private
     */
    this._pollingIntervalID = null;

    /**
     * The counter keeping track of polling cycles.
     * @type {string[]}
     * @private
     */
    this._pollingCounter = 0;

    /**
     * The Bluetooth socket connection for reading/writing peripheral data.
     * @type {BT}
     * @private
     */
    this._bt = null;
    this._runtime.registerPeripheralExtension(extensionId, this);

    /**
     * A rate limiter utility, to help limit the rate at which we send BT messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */
    this._rateLimiter = new RateLimiter(BTSendRateMax);
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pollValues = this._pollValues.bind(this);
  }
  get distance() {
    let value = this._sensors.distance > 100 ? 100 : this._sensors.distance;
    value = value < 0 ? 0 : value;
    value = Math.round(100 * value) / 100;
    return value;
  }
  get brightness() {
    return this._sensors.brightness;
  }

  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {EV3Motor} - the EV3Motor instance, if any, at that index.
   */
  motor(index) {
    return this._motors[index];
  }
  isButtonPressed(port) {
    return this._sensors.buttons[port] === 1;
  }
  beep(freq, time) {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_TONE, Ev3Encoding.ONE_BYTE, 2, Ev3Encoding.TWO_BYTES, freq, freq >> 8, Ev3Encoding.TWO_BYTES, time, time >> 8]);
    this.send(cmd);
  }
  stopAll() {
    this.stopAllMotors();
    this.stopSound();
  }
  stopSound() {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_STOP]);
    this.send(cmd, false); // don't use rate limiter to ensure sound stops
  }
  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        motor.coast();
      }
    });
  }

  /**
   * Called by the runtime when user wants to scan for an EV3 peripheral.
   */
  scan() {
    if (this._bt) {
      this._bt.disconnect();
    }
    this._bt = new BT(this._runtime, this._extensionId, {
      majorDeviceClass: 8,
      minorDeviceClass: 1
    }, this._onConnect, this.reset, this._onMessage);
  }

  /**
   * Called by the runtime when user wants to connect to a certain EV3 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */
  connect(id) {
    if (this._bt) {
      this._bt.connectPeripheral(id, Ev3PairingPin);
    }
  }

  /**
   * Called by the runtime when user wants to disconnect from the EV3 peripheral.
   */
  disconnect() {
    if (this._bt) {
      this._bt.disconnect();
    }
    this.reset();
  }

  /**
   * Reset all the state and timeout/interval ids.
   */
  reset() {
    this._sensorPorts = [];
    this._motorPorts = [];
    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    this._motors = [null, null, null, null];
    if (this._pollingIntervalID) {
      window.clearInterval(this._pollingIntervalID);
      this._pollingIntervalID = null;
    }
  }

  /**
   * Called by the runtime to detect whether the EV3 peripheral is connected.
   * @return {boolean} - the connected state.
   */
  isConnected() {
    let connected = false;
    if (this._bt) {
      connected = this._bt.isConnected();
    }
    return connected;
  }

  /**
   * Send a message to the peripheral BT socket.
   * @param {Uint8Array} message - the message to send.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the send operation.
   */
  send(message) {
    let useLimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!this.isConnected()) return Promise.resolve();
    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }
    return this._bt.sendMessage({
      message: Base64Util.uint8ArrayToBase64(message),
      encoding: 'base64'
    });
  }

  /**
   * Genrates direct commands that are sent to the EV3 as a single or compounded byte arrays.
   * See 'EV3 Communication Developer Kit', section 4, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Direct commands are one of two types:
   * DIRECT_COMMAND_NO_REPLY = a direct command where no reply is expected
   * DIRECT_COMMAND_REPLY = a direct command where a reply is expected, and the
   * number and length of returned values needs to be specified.
   *
   * The direct command byte array sent takes the following format:
   * Byte 0 - 1: Command size, Little Endian. Command size not including these 2 bytes
   * Byte 2 - 3: Message counter, Little Endian. Forth running counter
   * Byte 4:     Command type. Either DIRECT_COMMAND_REPLY or DIRECT_COMMAND_NO_REPLY
   * Byte 5 - 6: Reservation (allocation) of global and local variables using a compressed format
   *             (globals reserved in byte 5 and the 2 lsb of byte 6, locals reserved in the upper
   *             6 bits of byte 6)  see documentation for more details.
   * Byte 7 - n: Byte codes as a single command or compound commands (I.e. more commands composed
   *             as a small program)
   *
   * @param {number} type - the direct command type.
   * @param {string} byteCommands - a compound array of EV3 Opcode + arguments.
   * @param {number} allocation - the allocation of global and local vars needed for replies.
   * @return {array} - generated complete command byte array, with header and compounded commands.
   */
  generateCommand(type, byteCommands) {
    let allocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // Header (Bytes 0 - 6)
    let command = [];
    command[2] = 0; // Message counter unused for now
    command[3] = 0; // Message counter unused for now
    command[4] = type;
    command[5] = allocation & 0xFF;
    command[6] = allocation >> 8 && 0xFF;

    // Bytecodes (Bytes 7 - n)
    command = command.concat(byteCommands);

    // Calculate command length minus first two header bytes
    const len = command.length - 2;
    command[0] = len & 0xFF;
    command[1] = len >> 8 && 0xFF;
    return command;
  }

  /**
   * When the EV3 peripheral connects, start polling for sensor and motor values.
   * @private
   */
  _onConnect() {
    this._pollingIntervalID = window.setInterval(this._pollValues, this._pollingInterval);
  }

  /**
   * Poll the EV3 for sensor and motor input values, based on the list of
   * known connected sensors and motors. This is sent as many compound commands
   * in a direct command, with a reply expected.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 46, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for a list of polling/input device commands and their arguments.
   *
   * @private
   */
  _pollValues() {
    if (!this.isConnected()) {
      window.clearInterval(this._pollingIntervalID);
      return;
    }
    const cmds = []; // compound command
    let allocation = 0;
    let sensorCount = 0;

    // Reset the list of devices every 20 counts
    if (this._pollingCounter % 20 === 0) {
      // GET DEVICE LIST
      cmds[0] = Ev3Opcode.OPINPUT_DEVICE_LIST;
      cmds[1] = Ev3Encoding.ONE_BYTE;
      cmds[2] = Ev3Args.MAX_DEVICES;
      cmds[3] = Ev3Encoding.GLOBAL_VARIABLE_INDEX_0;
      cmds[4] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
      cmds[5] = Ev3Encoding.GLOBAL_CONSTANT_INDEX_0;

      // Command and payload lengths
      allocation = 33;
      this._updateDevices = true;
    } else {
      // GET SENSOR VALUES FOR CONNECTED SENSORS
      let index = 0;
      for (let i = 0; i < 4; i++) {
        if (this._sensorPorts[i] !== 'none') {
          cmds[index + 0] = Ev3Opcode.OPINPUT_READSI;
          cmds[index + 1] = Ev3Args.LAYER;
          cmds[index + 2] = i; // PORT
          cmds[index + 3] = Ev3Args.DO_NOT_CHANGE_TYPE;
          cmds[index + 4] = Ev3Mode[this._sensorPorts[i]];
          cmds[index + 5] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
          cmds[index + 6] = sensorCount * 4; // GLOBAL INDEX
          index += 7;
        }
        sensorCount++;
      }

      // GET MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT
      for (let i = 0; i < 4; i++) {
        cmds[index + 0] = Ev3Opcode.OPOUTPUT_GET_COUNT;
        cmds[index + 1] = Ev3Args.LAYER;
        cmds[index + 2] = i; // PORT (incorrectly specified as 'Output bit field' in LEGO docs)
        cmds[index + 3] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
        cmds[index + 4] = sensorCount * 4; // GLOBAL INDEX
        index += 5;
        sensorCount++;
      }

      // Command and payload lengths
      allocation = sensorCount * 4;
    }
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_REPLY, cmds, allocation);
    this.send(cmd);
    this._pollingCounter++;
  }

  /**
   * Message handler for incoming EV3 reply messages, either a list of connected
   * devices (sensors and motors) or the values of the connected sensors and motors.
   *
   * See 'EV3 Communication Developer Kit', section 4.1, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for more details on direct reply formats.
   *
   * The direct reply byte array sent takes the following format:
   * Byte 0  1: Reply size, Little Endian. Reply size not including these 2 bytes
   * Byte 2  3: Message counter, Little Endian. Equals the Direct Command
   * Byte 4:     Reply type. Either DIRECT_REPLY or DIRECT_REPLY_ERROR
   * Byte 5 - n: Resonse buffer. I.e. the content of the by the Command reserved global variables.
   *             I.e. if the command reserved 64 bytes, these bytes will be placed in the reply
   *             packet as the bytes 5 to 68.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 56 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for direct response buffer formats for various commands.
   *
   * @param {object} params - incoming message parameters
   * @private
   */
  _onMessage(params) {
    const message = params.message;
    const data = Base64Util.base64ToUint8Array(message);
    if (data[4] !== Ev3Command.DIRECT_REPLY) {
      return;
    }
    if (this._updateDevices) {
      // PARSE DEVICE LIST
      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 5]];
        // if returned device type is null, use 'none'
        this._sensorPorts[i] = deviceType ? deviceType : 'none';
      }
      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 21]];
        // if returned device type is null, use 'none'
        this._motorPorts[i] = deviceType ? deviceType : 'none';
      }
      for (let m = 0; m < 4; m++) {
        const type = this._motorPorts[m];
        if (type !== 'none' && !this._motors[m]) {
          // add new motor if don't already have one
          this._motors[m] = new EV3Motor(this, m, type);
        }
        if (type === 'none' && this._motors[m]) {
          // clear old motor
          this._motors[m] = null;
        }
      }
      this._updateDevices = false;

      // eslint-disable-next-line no-undefined
    } else if (!this._sensorPorts.includes(undefined) && !this._motorPorts.includes(undefined)) {
      // PARSE SENSOR VALUES
      let offset = 5; // start reading sensor values at byte 5
      for (let i = 0; i < 4; i++) {
        // array 2 float
        const buffer = new Uint8Array([data[offset], data[offset + 1], data[offset + 2], data[offset + 3]]).buffer;
        const view = new DataView(buffer);
        const value = view.getFloat32(0, true);
        if (Ev3Label[this._sensorPorts[i]] === 'button') {
          // Read a button value per port
          this._sensors.buttons[i] = value ? value : 0;
        } else if (Ev3Label[this._sensorPorts[i]]) {
          // if valid
          // Read brightness / distance values and set to 0 if null
          this._sensors[Ev3Label[this._sensorPorts[i]]] = value ? value : 0;
        }
        offset += 4;
      }

      // PARSE MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT
      for (let i = 0; i < 4; i++) {
        const positionArray = [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];
        if (this._motors[i]) {
          this._motors[i].position = positionArray;
        }
        offset += 4;
      }
    }
  }
}

/**
 * Enum for motor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */
const Ev3MotorMenu = ['A', 'B', 'C', 'D'];

/**
 * Enum for sensor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */
const Ev3SensorMenu = ['1', '2', '3', '4'];
class Scratch3Ev3Blocks {
  /**
   * The ID of the extension.
   * @return {string} the id
   */
  static get EXTENSION_ID() {
    return 'ev3';
  }

  /**
   * Creates a new instance of the EV3 extension.
   * @param  {object} runtime VM runtime
   * @constructor
   */
  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    // Create a new EV3 peripheral instance
    this._peripheral = new EV3(this.runtime, Scratch3Ev3Blocks.EXTENSION_ID);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);
  }

  /**
   * Define the EV3 extension.
   * @return {object} Extension description.
   */
  getInfo() {
    return {
      id: Scratch3Ev3Blocks.EXTENSION_ID,
      name: 'LEGO EV3',
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorTurnClockwise',
        text: formatMessage({
          id: 'ev3.motorTurnClockwise',
          default: 'motor [PORT] turn this way for [TIME] seconds',
          description: 'turn a motor clockwise for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorTurnCounterClockwise',
        text: formatMessage({
          id: 'ev3.motorTurnCounterClockwise',
          default: 'motor [PORT] turn that way for [TIME] seconds',
          description: 'turn a motor counter-clockwise for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorSetPower',
        text: formatMessage({
          id: 'ev3.motorSetPower',
          default: 'motor [PORT] set power [POWER] %',
          description: 'set a motor\'s power to some value'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'getMotorPosition',
        text: formatMessage({
          id: 'ev3.getMotorPosition',
          default: 'motor [PORT] position',
          description: 'get the measured degrees a motor has turned'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'whenButtonPressed',
        text: formatMessage({
          id: 'ev3.whenButtonPressed',
          default: 'when button [PORT] pressed',
          description: 'when a button connected to a port is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'sensorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'whenDistanceLessThan',
        text: formatMessage({
          id: 'ev3.whenDistanceLessThan',
          default: 'when distance < [DISTANCE]',
          description: 'when the value measured by the distance sensor is less than some value'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 5
          }
        }
      }, {
        opcode: 'whenBrightnessLessThan',
        text: formatMessage({
          id: 'ev3.whenBrightnessLessThan',
          default: 'when brightness < [DISTANCE]',
          description: 'when value measured by brightness sensor is less than some value'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'buttonPressed',
        text: formatMessage({
          id: 'ev3.buttonPressed',
          default: 'button [PORT] pressed?',
          description: 'is a button on some port pressed?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'sensorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'getDistance',
        text: formatMessage({
          id: 'ev3.getDistance',
          default: 'distance',
          description: 'gets measured distance'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getBrightness',
        text: formatMessage({
          id: 'ev3.getBrightness',
          default: 'brightness',
          description: 'gets measured brightness'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'beep',
        text: formatMessage({
          id: 'ev3.beepNote',
          default: 'beep note [NOTE] for [TIME] secs',
          description: 'play some note on EV3 for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        }
      }],
      menus: {
        motorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3MotorMenu)
        },
        sensorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3SensorMenu)
        }
      }
    };
  }
  motorTurnClockwise(args) {
    const port = Cast.toNumber(args.PORT);
    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);
        if (motor) {
          motor.direction = 1;
          motor.turnOnFor(time);
        }
      });

      // Run for some time even when no motor is connected
      setTimeout(resolve, time);
    });
  }
  motorTurnCounterClockwise(args) {
    const port = Cast.toNumber(args.PORT);
    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);
        if (motor) {
          motor.direction = -1;
          motor.turnOnFor(time);
        }
      });

      // Run for some time even when no motor is connected
      setTimeout(resolve, time);
    });
  }
  motorSetPower(args) {
    const port = Cast.toNumber(args.PORT);
    const power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);
    this._forEachMotor(port, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        motor.power = power;
      }
    });
  }
  getMotorPosition(args) {
    const port = Cast.toNumber(args.PORT);
    if (![0, 1, 2, 3].includes(port)) {
      return;
    }
    const motor = this._peripheral.motor(port);
    let position = 0;
    if (motor) {
      position = MathUtil.wrapClamp(motor.position, 0, 360);
    }
    return position;
  }
  whenButtonPressed(args) {
    const port = Cast.toNumber(args.PORT);
    if (![0, 1, 2, 3].includes(port)) {
      return;
    }
    return this._peripheral.isButtonPressed(port);
  }
  whenDistanceLessThan(args) {
    const distance = MathUtil.clamp(Cast.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.distance < distance;
  }
  whenBrightnessLessThan(args) {
    const brightness = MathUtil.clamp(Cast.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.brightness < brightness;
  }
  buttonPressed(args) {
    const port = Cast.toNumber(args.PORT);
    if (![0, 1, 2, 3].includes(port)) {
      return;
    }
    return this._peripheral.isButtonPressed(port);
  }
  getDistance() {
    return this._peripheral.distance;
  }
  getBrightness() {
    return this._peripheral.brightness;
  }
  _playNoteForPicker(note, category) {
    if (category !== this.getInfo().name) return;
    this.beep({
      NOTE: note,
      TIME: 0.25
    });
  }
  beep(args) {
    const note = MathUtil.clamp(Cast.toNumber(args.NOTE), 47, 99); // valid EV3 sounds
    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 3000);
    if (time === 0) {
      return; // don't send a beep time of 0
    }
    return new Promise(resolve => {
      // https://en.wikipedia.org/wiki/MIDI_tuning_standard#Frequency_values
      const freq = Math.pow(2, (note - 69 + 12) / 12) * 440;
      this._peripheral.beep(freq, time);

      // Run for some time even when no piezo is connected.
      setTimeout(resolve, time);
    });
  }

  /**
   * Call a callback for each motor indexed by the provided motor ID.
   *
   * Note: This way of looping through motors is currently unnecessary, but could be
   * useful if an 'all motors' option is added in the future (see WeDo2 extension).
   *
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */
  _forEachMotor(motorID, callback) {
    let motors;
    switch (motorID) {
      case 0:
        motors = [0];
        break;
      case 1:
        motors = [1];
        break;
      case 2:
        motors = [2];
        break;
      case 3:
        motors = [3];
        break;
      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }
    for (const index of motors) {
      callback(index);
    }
  }

  /**
   * Formats menus into a format suitable for block menus, and loading previously
   * saved projects:
   * [
   *   {
   *    text: label,
   *    value: index
   *   },
   *   {
   *    text: label,
   *    value: index
   *   },
   *   etc...
   * ]
   *
   * @param {array} menu - a menu to format.
   * @return {object} - a formatted menu as an object.
   * @private
   */
  _formatMenu(menu) {
    const m = [];
    for (let i = 0; i < menu.length; i++) {
      const obj = {};
      obj.text = menu[i];
      obj.value = i.toString();
      m.push(obj);
    }
    return m;
  }
}
module.exports = Scratch3Ev3Blocks;

/***/ }),

/***/ "./src/extensions/scratch3_gdx_for/index.js":
/*!**************************************************!*\
  !*** ./src/extensions/scratch3_gdx_for/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
const godirect = __webpack_require__(/*! @vernier/godirect */ "./node_modules/@vernier/godirect/dist/godirect.min.cjs.js");
const ScratchLinkDeviceAdapter = __webpack_require__(/*! ./scratch-link-device-adapter */ "./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js");

/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAABGdBTUEAALGPC/xhBQAACCNJREFUeAHtnGtsFFUUgM+dfXbbbbcWaKHSFgrlkWgkJCb6A4kmJfiHIBYBpcFfRg1GEkmEVAvhFYw/TExMxGoICAECiZEIIUQCiiT4gh+KILRQCi2ENIV2t/ue6zl3u2Upu4XuzO4csCe587iPmXO/OWfunTszV4ABWfflQU+0p+9bTcLzEmS5gUPlvagAcVMXcMpnK1u+evW8QLYKaNkWpHKxnt6dQsqFjxo80p10Jt1vx7t30n62Ys+2IJUTUpDlqUNomgYutwsjhZFD5r6slBAOhUHX9YTe6D1GTmrIAhFeBZ2c4JFCpBiggmwlBR7pTGLUewxZYBIUWV7yqgb7g8lotuukt5ihqyELHCSEbusk931ExMxbjSkWSNxEyr3vysxZLFHWnDuT0CtFV6OKmmOBRrV4hMubZoGmMZA6lHTfgsLeHnBEIiCxUY86XRDw+sBfOgZ0m820U5lxIFYAncF+GNvVDo5QaLBu1ClyYTyF4tvd8lZltQgXFA6mW73BxoVt0ShUXG2VCp4QQdDEFqez4Bm7p7gaO0of422r3x4Ji/KrbdIexu4SE2FjgWO6OkCLx6gt6gxOiNV92tiY+ni1Ye1nu7dpQfk35ikru9EBN6unsEDIwgLJPQv8dwCfT3WPt+iFIfAUqM3vL7vpjmuz0KX1gkAfOMN33dxKkjwA9vsTDIS8uubdBZcyAWlqWtohQbRSuru/L1O2vMazAGiLxRKVFqDgDEdAaHCN0kU8Ply2vKWxABhzJZ5ipC6qHlRzfJxVz99S49GdYQEw7PYkuAmokZJ6fumlQUqiNpVSQ56i9JnyHMsCYMRdADGHk0ZyHM1b976XicH0rXtWYR57FPNSGQ7CAiCBCJQ8oXhI0FdmBiPfVnl9ZZmz5DmFDcA+HwIUOEYMcjL2+e57PbBp04HxONI4ifIEKC8TYQMwhs+7IU+hwBFOYQvB5qF8grbwJnRfQXnIhbkIG4AExF+ScE00w0X3AZLwisrDyH1JH1YAA8UlIG029FRZsu6TPfVJiIltWYIjMTLgLUlGs1izeRYmGtS383t9wnu7G2J6fH/Tln2LNUdExGLxvZSOQ1qCS/+P9CFhBZAUuj12PHgCvRJHZ7w4EnhYjya6hXGHQ2Jaxj4ilbVC2AFEUNBVXSdKb3WC29+rmISKiqFn7ARBadyEHUACFHM64VZlDTdWafVh1Yik1ZB5JEsLJGaVtosw37ld4TscWQHX4+oRWO1zWrAEWCR6oMnTCEXijmI1234MVvsPgV+WcmKndGHpwlNtZwbhkZYEkuI4CkuAXfpk0HGAPym0TXEchaUL39Br4JvQeljk+lwxOxBeCRQ3UrFHI+AMBsEV6gcnhlwIS4BU0RORV1V42EqnwnLgSyo3AsM3eA9bPOt8bAEOV6NUWGRZ9FYvHSx6R0pfYgkMmk2DCH1+Z7KwB5gKazjLGgpLgUOAuRZWALnDSncxLAOYCmskbqjhe02h5d6y0sFKF5cXgI8LrLwB9PTeGew6POwNnptlpYOVLi4nFjjuWts957rnBk8tomoZ+bjhPcqOcCcnAG34EaTqOjxmsNKxzQnAkX5wronsOry6zIn66ThljLNcg+W1a2Gi55+MCg6XcKl3NuxrbxouS87TLAcY1V0QV5+8jLyuEekeeSGTS1gOcM/lZpOrlN/DsRzOyi8CY2fLuwUum/wR1BT+ZUzrDKUv9D4LB9rXZEjNTfRjZYFS5r86ebfA3W0bcmMKFh01/5fMoorm6rSjAA2SNc2F8dvmQVWCgdy8fxg8gcEN0pWez80QUyyQFAqn/N9mhmK5PAYN7adecCPnMsUCCZ7U8ari4IGb87wJeKFDA/MlmHXBDVkgTR1CV4/gaThKzBoeKYpuSzqSrqSzEiFuJDayWxqyQJp3RUhYSKfWUSEz5iDIrhrZl8I5b37JvrTBT3wdpd43cOqT/WiJhq6ikQpkW5a8BxuS/X219uXZHoPKmdMUGdEgpWzTll3Kr95Z8VJK7N3NL7b/qHY2rnmdjd6G7oF3q/b/3RoFaPDajwIcBWiQgMHioxZoEKChfqDBc2csnmxtM2ZglMDKArFvduhBbLDv9sOD8oymA0xBCHVtl6+c7ey6Ibdt+3ox7WOoxMCmD4i68PrZkBQaEDUe1tnVqSyyfl79+vr6evz1C2jKogkYWEEc0JnViiZRqKuoqJiZtEJcn0GIsykewzhW2jJVZjzBamxsfK79ase/5MoXL106TnEDwfq36qgIF6HGjKyqFsNkDGMwUNxEDEmIHQTxyNGjH1AchvumBcC4vAuXVpiA+TDYMFDXiiZFoN+SrmMI7tixo/v3337diNtQUzNpPq1RChIra5ccAFKDUEwYLra2fnXu3PmtA0gojqbaVUNl23ft+pPiPW73U7RGYdGH5QCQYCg93C73075S34I5c+ZQa0s/B1Njou51tVVVatJAXcrED3Q4EI5plgsHgAQiSiRCoRD9ECeam9fPo32UJzFQYwJLlix9mdZ9fb1naY2iyiQ2rVtyAEi199Pi5M8/tdB62vRpzceOH3+toaHBh61w2clTp96sqq5ehUnxw0eO7KA8KKpMYtO6JZcOKTUeNRhsp0+ffmtilYI1VLf4+Qvn1784d+5ezEfW144hMR05blglpDgHSbqxt6Wl5Y8ZM6afKq8oL7LZHd54PH7H7w+cOPj9dx8uXbLk+ICynbhm4cJDr7LVMKmhoP5dphaWoFGrHMTAQrgBJCjkFdQHpPntqCUmiWCge14PBsvdFnUYlP8AMAKfKIKmYukAAAAASUVORK5CYII=';

/**
 * Icon png to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const menuIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAABGdBTUEAALGPC/xhBQAAA9dJREFUWAnNmE2IFEcUgF/9dE/v7LoaM9kkK4JBRA0EFBIPRm85hBAvEXHXwyo5eFE87GFcReMkObgJiQnkkJzEg9n8HIJixKNe1IMKihgiCbviwV11V3d0d3pmuqsqr5ppcEnb3TNVggVFVVe9eu+r97qqq4tASqp8/fsboQgmU0TMugi571K29bPy9ovPU8Sf16HbpQj3EkYFBcJcr5Am2nZfs94AIWVfqMQeHNwhICUBZ4ypUIA/X2sbIm2AW8AJK0lkEP6TJpfqwXgg4QxmF/fB7Gtvxk1G5ZKHU1CqTgPJoSUXYJYeohSUJu+qrqdVUGh2/pVX4VFffx77WaqBZkrkEFj271+qWH0sXcU3FBzyQe/Mg7B//LbKMTRTxNiDbsMHHjTJlyM7HEJIBHXs2KXFj+oTNSdoQOCYLS5jD9IwBMm5H8NplwwPb/QV4yEIcycaAza9IuA76B38fuz1OF5RXUkmHCdu6rg0BpSMgV/sAe7DdzGFrvvdi0D3mSZjQA0wt7REQsY+iWF0XbfFzyal8SLRxuteD+Du4h4Z/flbqaBHibAQtZmQtcZaAZSMwtTylaR/4vaw1ju5YhWG10pwwAqghmp2FeHO2+t11WqyM80W0m7vAOhsM1kD7CGz8L57Jsq6bitZC/GcWgLf1H6KuHT92cTDAFy/BgXMXm0OCpgV50Bo9kK3BqiBboabQMMU/WoL5im4jToeq/AIgXsiRx5KKCjcwPEsiAv/BQMu9EwyDHXd/3kqCOSzDk6t5/YglQKKeJwq+PNRmJI8kwSTaj1HZy5AhSHqnXkIvU9mMUwEw4Q5wTM57LUtkg8QPw/cdcBJ+PhvKJ0Gj80nGq6JXrg6/XFiX97GXIBpyqTieKpKViOl+WEhWXMaUavvvdIZ8Giy5+Lh3bwKm/t+Be3JazMfxc1tldY26rastiHcsQevTG9pw0znovkAcRWHzSDKnZtaOJLSfMFLB5RqtRBS4LbCurqLCy0YPkU3C0IIPEimMqR2ei7ZX2+KQdRi/WahNT/GmfOD4Vyzhx/66pcjp85dUvcmp6J8+txldXh07PPskdkS+V6EbD0vTOKlB0x9B/O6BS8ULly9PgE6x4kDPR/XX5pyYKj8xcCucsUmkNUQE0JvKKm2VioVK5HRE7UKOHbi6B94RzP+93jtpC0vWgXUF0hr3ipuw8uadwd3jXxoA9IK4Pah8t6BneV9GgjD28Svw1mlxFobgFbeFTz13cKbth93fDryp2CEq0a4hTA+aAPQ/ESJFDdvXLzzzrqNjlTqOP6uDeFf0uhvJ0ZP2QD8D6ZzU6u8YIbBAAAAAElFTkSuQmCC';

/**
 * Enum for Vernier godirect protocol.
 * @readonly
 * @enum {string}
 */
const BLEUUID = {
  service: 'd91714ef-28b9-4f91-ba16-f0d9a604f112',
  commandChar: 'f4bf14a6-c7d5-4b6d-8aa8-df1a7c83adcb',
  responseChar: 'b41e6675-a329-40e0-aa01-44d2f444babe'
};

/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */
const BLETimeout = 4500;

/**
 * A string to report to the BLE socket when the GdxFor has stopped receiving data.
 * @type {string}
 */
const BLEDataStoppedError = 'Force and Acceleration extension stopped receiving data';

/**
 * Sensor ID numbers for the GDX-FOR.
 */
const GDXFOR_SENSOR = {
  FORCE: 1,
  ACCELERATION_X: 2,
  ACCELERATION_Y: 3,
  ACCELERATION_Z: 4,
  SPIN_SPEED_X: 5,
  SPIN_SPEED_Y: 6,
  SPIN_SPEED_Z: 7
};

/**
 * The update rate, in milliseconds, for sensor data input from the peripheral.
 */
const GDXFOR_UPDATE_RATE = 80;

/**
 * Threshold for pushing and pulling force, for the whenForcePushedOrPulled hat block.
 * @type {number}
 */
const FORCE_THRESHOLD = 5;

/**
 * Threshold for acceleration magnitude, for the "shaken" gesture.
 * @type {number}
 */
const SHAKEN_THRESHOLD = 30;

/**
 * Threshold for acceleration magnitude, to check if we are facing up.
 * @type {number}
 */
const FACING_THRESHOLD = 9;

/**
 * An offset for the facing threshold, used to check that we are no longer facing up.
 * @type {number}
 */
const FACING_THRESHOLD_OFFSET = 5;

/**
 * Threshold for acceleration magnitude, below which we are in freefall.
 * @type {number}
 */
const FREEFALL_THRESHOLD = 0.5;

/**
 * Factor used to account for influence of rotation during freefall.
 * @type {number}
 */
const FREEFALL_ROTATION_FACTOR = 0.3;

/**
 * Threshold in degrees for reporting that the sensor is tilted.
 * @type {number}
 */
const TILT_THRESHOLD = 15;

/**
 * Acceleration due to gravity, in m/s^2.
 * @type {number}
 */
const GRAVITY = 9.8;

/**
 * Manage communication with a GDX-FOR peripheral over a Scratch Link client socket.
 */
class GdxFor {
  /**
   * Construct a GDX-FOR communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */
    this._ble = null;

    /**
     * An @vernier/godirect Device
     * @type {Device}
     * @private
     */
    this._device = null;
    this._runtime.registerPeripheralExtension(extensionId, this);

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;

    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */
    this._sensors = {
      force: 0,
      accelerationX: 0,
      accelerationY: 0,
      accelerationZ: 0,
      spinSpeedX: 0,
      spinSpeedY: 0,
      spinSpeedZ: 0
    };

    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */
    this._timeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
  }

  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */
  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        namePrefix: 'GDX-FOR'
      }],
      optionalServices: [BLEUUID.service]
    }, this._onConnect, this.reset);
  }

  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */
  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }

  /**
   * Called by the runtime when a user exits the connection popup.
   * Disconnect from the GDX FOR.
   */
  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this.reset();
  }

  /**
   * Reset all the state and timeout/interval ids.
   */
  reset() {
    this._sensors = {
      force: 0,
      accelerationX: 0,
      accelerationY: 0,
      accelerationZ: 0,
      spinSpeedX: 0,
      spinSpeedY: 0,
      spinSpeedZ: 0
    };
    if (this._timeoutID) {
      window.clearInterval(this._timeoutID);
      this._timeoutID = null;
    }
  }

  /**
   * Return true if connected to the goforce device.
   * @return {boolean} - whether the goforce is connected.
   */
  isConnected() {
    let connected = false;
    if (this._ble) {
      connected = this._ble.isConnected();
    }
    return connected;
  }

  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */
  _onConnect() {
    const adapter = new ScratchLinkDeviceAdapter(this._ble, BLEUUID);
    godirect.createDevice(adapter, {
      open: true,
      startMeasurements: false
    }).then(device => {
      // Setup device
      this._device = device;
      this._device.keepValues = false; // todo: possibly remove after updating Vernier godirect module

      // Enable sensors
      this._device.sensors.forEach(sensor => {
        sensor.setEnabled(true);
      });

      // Set sensor value-update behavior
      this._device.on('measurements-started', () => {
        const enabledSensors = this._device.sensors.filter(s => s.enabled);
        enabledSensors.forEach(sensor => {
          sensor.on('value-changed', s => {
            this._onSensorValueChanged(s);
          });
        });
        this._timeoutID = window.setInterval(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
      });

      // Start device
      this._device.start(GDXFOR_UPDATE_RATE);
    });
  }

  /**
   * Handler for sensor value changes from the goforce device.
   * @param {object} sensor - goforce device sensor whose value has changed
   * @private
   */
  _onSensorValueChanged(sensor) {
    switch (sensor.number) {
      case GDXFOR_SENSOR.FORCE:
        // Normalize the force, which can be measured between -50 and 50 N,
        // to be a value between -100 and 100.
        this._sensors.force = MathUtil.clamp(sensor.value * 2, -100, 100);
        break;
      case GDXFOR_SENSOR.ACCELERATION_X:
        this._sensors.accelerationX = sensor.value;
        break;
      case GDXFOR_SENSOR.ACCELERATION_Y:
        this._sensors.accelerationY = sensor.value;
        break;
      case GDXFOR_SENSOR.ACCELERATION_Z:
        this._sensors.accelerationZ = sensor.value;
        break;
      case GDXFOR_SENSOR.SPIN_SPEED_X:
        this._sensors.spinSpeedX = this._spinSpeedFromGyro(sensor.value);
        break;
      case GDXFOR_SENSOR.SPIN_SPEED_Y:
        this._sensors.spinSpeedY = this._spinSpeedFromGyro(sensor.value);
        break;
      case GDXFOR_SENSOR.SPIN_SPEED_Z:
        this._sensors.spinSpeedZ = this._spinSpeedFromGyro(sensor.value);
        break;
    }
    // cancel disconnect timeout and start a new one
    window.clearInterval(this._timeoutID);
    this._timeoutID = window.setInterval(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  _spinSpeedFromGyro(val) {
    const framesPerSec = 1000 / this._runtime.currentStepTime;
    val = MathUtil.radToDeg(val);
    val = val / framesPerSec; // convert to from degrees per sec to degrees per frame
    val = val * -1;
    return val;
  }
  getForce() {
    return this._sensors.force;
  }
  getTiltFrontBack() {
    let back = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const x = this.getAccelerationX();
    const y = this.getAccelerationY();
    const z = this.getAccelerationZ();

    // Compute the yz unit vector
    const y2 = y * y;
    const z2 = z * z;
    let value = y2 + z2;
    value = Math.sqrt(value);

    // For sufficiently small zy vector values we are essentially at 90 degrees.
    // The following snaps to 90 and avoids divide-by-zero errors.
    // The snap factor was derived through observation -- just enough to
    // still allow single degree steps up to 90 (..., 87, 88, 89, 90).
    if (value < 0.35) {
      value = x < 0 ? 90 : -90;
    } else {
      value = x / value;
      value = Math.atan(value);
      value = MathUtil.radToDeg(value) * -1;
    }

    // Back is the inverse of front
    if (back) value *= -1;
    return value;
  }
  getTiltLeftRight() {
    let right = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const x = this.getAccelerationX();
    const y = this.getAccelerationY();
    const z = this.getAccelerationZ();

    // Compute the yz unit vector
    const x2 = x * x;
    const z2 = z * z;
    let value = x2 + z2;
    value = Math.sqrt(value);

    // For sufficiently small zy vector values we are essentially at 90 degrees.
    // The following snaps to 90 and avoids divide-by-zero errors.
    // The snap factor was derived through observation -- just enough to
    // still allow single degree steps up to 90 (..., 87, 88, 89, 90).
    if (value < 0.35) {
      value = y < 0 ? 90 : -90;
    } else {
      value = y / value;
      value = Math.atan(value);
      value = MathUtil.radToDeg(value) * -1;
    }

    // Right is the inverse of left
    if (right) value *= -1;
    return value;
  }
  getAccelerationX() {
    return this._sensors.accelerationX;
  }
  getAccelerationY() {
    return this._sensors.accelerationY;
  }
  getAccelerationZ() {
    return this._sensors.accelerationZ;
  }
  getSpinSpeedX() {
    return this._sensors.spinSpeedX;
  }
  getSpinSpeedY() {
    return this._sensors.spinSpeedY;
  }
  getSpinSpeedZ() {
    return this._sensors.spinSpeedZ;
  }
}

/**
 * Enum for pushed and pulled menu options.
 * @readonly
 * @enum {string}
 */
const PushPullValues = {
  PUSHED: 'pushed',
  PULLED: 'pulled'
};

/**
 * Enum for motion gesture menu options.
 * @readonly
 * @enum {string}
 */
const GestureValues = {
  SHAKEN: 'shaken',
  STARTED_FALLING: 'started falling',
  TURNED_FACE_UP: 'turned face up',
  TURNED_FACE_DOWN: 'turned face down'
};

/**
 * Enum for tilt axis menu options.
 * @readonly
 * @enum {string}
 */
const TiltAxisValues = {
  FRONT: 'front',
  BACK: 'back',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};

/**
 * Enum for axis menu options.
 * @readonly
 * @enum {string}
 */
const AxisValues = {
  X: 'x',
  Y: 'y',
  Z: 'z'
};

/**
 * Scratch 3.0 blocks to interact with a GDX-FOR peripheral.
 */
class Scratch3GdxForBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return 'Force and Acceleration';
  }

  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'gdxfor';
  }
  get AXIS_MENU() {
    return [{
      text: 'x',
      value: AxisValues.X
    }, {
      text: 'y',
      value: AxisValues.Y
    }, {
      text: 'z',
      value: AxisValues.Z
    }];
  }
  get TILT_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.front',
        default: 'front',
        description: 'label for front element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.FRONT
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.back',
        default: 'back',
        description: 'label for back element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.BACK
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.left',
        default: 'left',
        description: 'label for left element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.LEFT
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.right',
        default: 'right',
        description: 'label for right element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.RIGHT
    }];
  }
  get TILT_MENU_ANY() {
    return [...this.TILT_MENU, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.any',
        default: 'any',
        description: 'label for any direction element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.ANY
    }];
  }
  get PUSH_PULL_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.pushed',
        default: 'pushed',
        description: 'the force sensor was pushed inward'
      }),
      value: PushPullValues.PUSHED
    }, {
      text: formatMessage({
        id: 'gdxfor.pulled',
        default: 'pulled',
        description: 'the force sensor was pulled outward'
      }),
      value: PushPullValues.PULLED
    }];
  }
  get GESTURE_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.shaken',
        default: 'shaken',
        description: 'the sensor was shaken'
      }),
      value: GestureValues.SHAKEN
    }, {
      text: formatMessage({
        id: 'gdxfor.startedFalling',
        default: 'started falling',
        description: 'the sensor started free falling'
      }),
      value: GestureValues.STARTED_FALLING
    }, {
      text: formatMessage({
        id: 'gdxfor.turnedFaceUp',
        default: 'turned face up',
        description: 'the sensor was turned to face up'
      }),
      value: GestureValues.TURNED_FACE_UP
    }, {
      text: formatMessage({
        id: 'gdxfor.turnedFaceDown',
        default: 'turned face down',
        description: 'the sensor was turned to face down'
      }),
      value: GestureValues.TURNED_FACE_DOWN
    }];
  }

  /**
   * Construct a set of GDX-FOR blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    // Create a new GdxFor peripheral instance
    this._peripheral = new GdxFor(this.runtime, Scratch3GdxForBlocks.EXTENSION_ID);
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: Scratch3GdxForBlocks.EXTENSION_ID,
      name: Scratch3GdxForBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'whenGesture',
        text: formatMessage({
          id: 'gdxfor.whenGesture',
          default: 'when [GESTURE]',
          description: 'when the sensor detects a gesture'
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: 'gestureOptions',
            defaultValue: GestureValues.SHAKEN
          }
        }
      }, {
        opcode: 'whenForcePushedOrPulled',
        text: formatMessage({
          id: 'gdxfor.whenForcePushedOrPulled',
          default: 'when force sensor [PUSH_PULL]',
          description: 'when the force sensor is pushed or pulled'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PUSH_PULL: {
            type: ArgumentType.STRING,
            menu: 'pushPullOptions',
            defaultValue: PushPullValues.PUSHED
          }
        }
      }, {
        opcode: 'getForce',
        text: formatMessage({
          id: 'gdxfor.getForce',
          default: 'force',
          description: 'gets force'
        }),
        blockType: BlockType.REPORTER
      }, '---', {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'gdxfor.whenTilted',
          default: 'when tilted [TILT]',
          description: 'when the sensor detects tilt'
        }),
        blockType: BlockType.HAT,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltAnyOptions',
            defaultValue: TiltAxisValues.ANY
          }
        }
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'gdxfor.isTilted',
          default: 'tilted [TILT]?',
          description: 'is the device tilted?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltAnyOptions',
            defaultValue: TiltAxisValues.ANY
          }
        }
      }, {
        opcode: 'getTilt',
        text: formatMessage({
          id: 'gdxfor.getTilt',
          default: 'tilt angle [TILT]',
          description: 'gets tilt'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltOptions',
            defaultValue: TiltAxisValues.FRONT
          }
        }
      }, '---', {
        opcode: 'isFreeFalling',
        text: formatMessage({
          id: 'gdxfor.isFreeFalling',
          default: 'falling?',
          description: 'is the device in free fall?'
        }),
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'getSpinSpeed',
        text: formatMessage({
          id: 'gdxfor.getSpin',
          default: 'spin speed [DIRECTION]',
          description: 'gets spin speed'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'axisOptions',
            defaultValue: AxisValues.Z
          }
        }
      }, {
        opcode: 'getAcceleration',
        text: formatMessage({
          id: 'gdxfor.getAcceleration',
          default: 'acceleration [DIRECTION]',
          description: 'gets acceleration'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'axisOptions',
            defaultValue: AxisValues.X
          }
        }
      }],
      menus: {
        pushPullOptions: {
          acceptReporters: true,
          items: this.PUSH_PULL_MENU
        },
        gestureOptions: {
          acceptReporters: true,
          items: this.GESTURE_MENU
        },
        axisOptions: {
          acceptReporters: true,
          items: this.AXIS_MENU
        },
        tiltOptions: {
          acceptReporters: true,
          items: this.TILT_MENU
        },
        tiltAnyOptions: {
          acceptReporters: true,
          items: this.TILT_MENU_ANY
        }
      }
    };
  }
  whenForcePushedOrPulled(args) {
    switch (args.PUSH_PULL) {
      case PushPullValues.PUSHED:
        return this._peripheral.getForce() < FORCE_THRESHOLD * -1;
      case PushPullValues.PULLED:
        return this._peripheral.getForce() > FORCE_THRESHOLD;
      default:
        log.warn("unknown push/pull value in whenForcePushedOrPulled: ".concat(args.PUSH_PULL));
        return false;
    }
  }
  getForce() {
    return Math.round(this._peripheral.getForce());
  }
  whenGesture(args) {
    switch (args.GESTURE) {
      case GestureValues.SHAKEN:
        return this.gestureMagnitude() > SHAKEN_THRESHOLD;
      case GestureValues.STARTED_FALLING:
        return this.isFreeFalling();
      case GestureValues.TURNED_FACE_UP:
        return this._isFacing(GestureValues.TURNED_FACE_UP);
      case GestureValues.TURNED_FACE_DOWN:
        return this._isFacing(GestureValues.TURNED_FACE_DOWN);
      default:
        log.warn("unknown gesture value in whenGesture: ".concat(args.GESTURE));
        return false;
    }
  }
  _isFacing(direction) {
    if (typeof this._facingUp === 'undefined') {
      this._facingUp = false;
    }
    if (typeof this._facingDown === 'undefined') {
      this._facingDown = false;
    }

    // If the sensor is already facing up or down, reduce the threshold.
    // This prevents small fluctations in acceleration while it is being
    // turned from causing the hat block to trigger multiple times.
    let threshold = FACING_THRESHOLD;
    if (this._facingUp || this._facingDown) {
      threshold -= FACING_THRESHOLD_OFFSET;
    }
    this._facingUp = this._peripheral.getAccelerationZ() > threshold;
    this._facingDown = this._peripheral.getAccelerationZ() < threshold * -1;
    switch (direction) {
      case GestureValues.TURNED_FACE_UP:
        return this._facingUp;
      case GestureValues.TURNED_FACE_DOWN:
        return this._facingDown;
      default:
        return false;
    }
  }
  whenTilted(args) {
    return this._isTilted(args.TILT);
  }
  isTilted(args) {
    return this._isTilted(args.TILT);
  }
  getTilt(args) {
    return this._getTiltAngle(args.TILT);
  }
  _isTilted(direction) {
    switch (direction) {
      case TiltAxisValues.ANY:
        return this._getTiltAngle(TiltAxisValues.FRONT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.BACK) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.LEFT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.RIGHT) > TILT_THRESHOLD;
      default:
        return this._getTiltAngle(direction) > TILT_THRESHOLD;
    }
  }
  _getTiltAngle(direction) {
    // Tilt values are calculated using acceleration due to gravity,
    // so we need to return 0 when the peripheral is not connected.
    if (!this._peripheral.isConnected()) {
      return 0;
    }
    switch (direction) {
      case TiltAxisValues.FRONT:
        return Math.round(this._peripheral.getTiltFrontBack(true));
      case TiltAxisValues.BACK:
        return Math.round(this._peripheral.getTiltFrontBack(false));
      case TiltAxisValues.LEFT:
        return Math.round(this._peripheral.getTiltLeftRight(true));
      case TiltAxisValues.RIGHT:
        return Math.round(this._peripheral.getTiltLeftRight(false));
      default:
        log.warn("Unknown direction in getTilt: ".concat(direction));
    }
  }
  getSpinSpeed(args) {
    switch (args.DIRECTION) {
      case AxisValues.X:
        return Math.round(this._peripheral.getSpinSpeedX());
      case AxisValues.Y:
        return Math.round(this._peripheral.getSpinSpeedY());
      case AxisValues.Z:
        return Math.round(this._peripheral.getSpinSpeedZ());
      default:
        log.warn("Unknown direction in getSpinSpeed: ".concat(args.DIRECTION));
    }
  }
  getAcceleration(args) {
    switch (args.DIRECTION) {
      case AxisValues.X:
        return Math.round(this._peripheral.getAccelerationX());
      case AxisValues.Y:
        return Math.round(this._peripheral.getAccelerationY());
      case AxisValues.Z:
        return Math.round(this._peripheral.getAccelerationZ());
      default:
        log.warn("Unknown direction in getAcceleration: ".concat(args.DIRECTION));
    }
  }

  /**
   * @param {number} x - x axis vector
   * @param {number} y - y axis vector
   * @param {number} z - z axis vector
   * @return {number} - the magnitude of a three dimension vector.
   */
  magnitude(x, y, z) {
    return Math.sqrt(x * x + y * y + z * z);
  }
  accelMagnitude() {
    return this.magnitude(this._peripheral.getAccelerationX(), this._peripheral.getAccelerationY(), this._peripheral.getAccelerationZ());
  }
  gestureMagnitude() {
    return this.accelMagnitude() - GRAVITY;
  }
  spinMagnitude() {
    return this.magnitude(this._peripheral.getSpinSpeedX(), this._peripheral.getSpinSpeedY(), this._peripheral.getSpinSpeedZ());
  }
  isFreeFalling() {
    // When the peripheral is not connected, the acceleration magnitude
    // is 0 instead of ~9.8, which ends up calculating as a positive
    // free fall; so we need to return 'false' here to prevent returning 'true'.
    if (!this._peripheral.isConnected()) {
      return false;
    }
    const accelMag = this.accelMagnitude();
    const spinMag = this.spinMagnitude();

    // We want to account for rotation during freefall,
    // so we tack on a an estimated "rotational effect"
    // The FREEFALL_ROTATION_FACTOR const is used to both scale the
    // gyro measurements and convert them to radians/second.
    // So, we compare our accel magnitude against:
    // FREEFALL_THRESHOLD + (some_scaled_magnitude_of_rotation).
    const ffThresh = FREEFALL_THRESHOLD + FREEFALL_ROTATION_FACTOR * spinMag;
    return accelMag < ffThresh;
  }
}
module.exports = Scratch3GdxForBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js":
/*!************************************************************************!*\
  !*** ./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");

/**
 * Adapter class
 */
class ScratchLinkDeviceAdapter {
  constructor(socket, _ref) {
    let {
      service,
      commandChar,
      responseChar
    } = _ref;
    this.socket = socket;
    this._service = service;
    this._commandChar = commandChar;
    this._responseChar = responseChar;
    this._onResponse = this._onResponse.bind(this);
    this._deviceOnResponse = null;
  }
  get godirectAdapter() {
    return true;
  }
  writeCommand(commandBuffer) {
    const data = Base64Util.uint8ArrayToBase64(commandBuffer);
    return this.socket.write(this._service, this._commandChar, data, 'base64');
  }
  setup(_ref2) {
    let {
      onResponse
    } = _ref2;
    this._deviceOnResponse = onResponse;
    return this.socket.startNotifications(this._service, this._responseChar, this._onResponse);

    // TODO:
    // How do we find out from scratch link if communication closes?
  }
  _onResponse(base64) {
    const array = Base64Util.base64ToUint8Array(base64);
    const response = new DataView(array.buffer);
    return this._deviceOnResponse(response);
  }
}
module.exports = ScratchLinkDeviceAdapter;

/***/ }),

/***/ "./src/extensions/scratch3_makeymakey/index.js":
/*!*****************************************************!*\
  !*** ./src/extensions/scratch3_makeymakey/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHN0eWxlPi5zdDJ7ZmlsbDpyZWR9LnN0M3tmaWxsOiNlMGUwZTB9LnN0NHtmaWxsOm5vbmU7c3Ryb2tlOiM2NjY7c3Ryb2tlLXdpZHRoOi41O3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PHBhdGggZD0iTTM1IDI4SDVhMSAxIDAgMCAxLTEtMVYxMmMwLS42LjQtMSAxLTFoMzBjLjUgMCAxIC40IDEgMXYxNWMwIC41LS41IDEtMSAxeiIgZmlsbD0iI2ZmZiIgaWQ9IkxheWVyXzYiLz48ZyBpZD0iTGF5ZXJfNCI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQgMjVoMzJ2Mi43SDR6TTEzIDI0aC0yLjJhMSAxIDAgMCAxLTEtMXYtOS43YzAtLjYuNC0xIDEtMUgxM2MuNiAwIDEgLjQgMSAxVjIzYzAgLjYtLjUgMS0xIDF6Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTYuMSAxOS4zdi0yLjJjMC0uNS40LTEgMS0xaDkuN2MuNSAwIDEgLjUgMSAxdjIuMmMwIC41LS41IDEtMSAxSDcuMWExIDEgMCAwIDEtMS0xeiIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIzLjQiLz48Y2lyY2xlIGNsYXNzPSJzdDIiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMy40Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQuMiAyN2gzMS45di43SDQuMnoiLz48L2c+PGcgaWQ9IkxheWVyXzUiPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIyLjMiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMi4zIi8+PHBhdGggY2xhc3M9InN0MyIgZD0iTTEyLjUgMjIuOWgtMS4yYy0uMyAwLS41LS4yLS41LS41VjE0YzAtLjMuMi0uNS41LS41aDEuMmMuMyAwIC41LjIuNS41djguNGMwIC4zLS4yLjUtLjUuNXoiLz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNNy4yIDE4Ljd2LTEuMmMwLS4zLjItLjUuNS0uNWg4LjRjLjMgMCAuNS4yLjUuNXYxLjJjMCAuMy0uMi41LS41LjVINy43Yy0uMyAwLS41LS4yLS41LS41ek00IDI2aDMydjJINHoiLz48L2c+PGcgaWQ9IkxheWVyXzMiPjxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik0zNS4yIDI3LjlINC44YTEgMSAwIDAgMS0xLTFWMTIuMWMwLS42LjUtMSAxLTFoMzAuNWMuNSAwIDEgLjQgMSAxVjI3YTEgMSAwIDAgMS0xLjEuOXoiLz48cGF0aCBjbGFzcz0ic3Q0IiBkPSJNMzUuMiAyNy45SDQuOGExIDEgMCAwIDEtMS0xVjEyLjFjMC0uNi41LTEgMS0xaDMwLjVjLjUgMCAxIC40IDEgMVYyN2ExIDEgMCAwIDEtMS4xLjl6Ii8+PC9nPjwvc3ZnPg==';

/**
 * Length of the buffer to store key presses for the "when keys pressed in order" hat
 * @type {number}
 */
const KEY_BUFFER_LENGTH = 100;

/**
 * Timeout in milliseconds to reset the completed flag for a sequence.
 * @type {number}
 */
const SEQUENCE_HAT_TIMEOUT = 100;

/**
 * An id for the space key on a keyboard.
 */
const KEY_ID_SPACE = 'SPACE';

/**
 * An id for the left arrow key on a keyboard.
 */
const KEY_ID_LEFT = 'LEFT';

/**
 * An id for the right arrow key on a keyboard.
 */
const KEY_ID_RIGHT = 'RIGHT';

/**
 * An id for the up arrow key on a keyboard.
 */
const KEY_ID_UP = 'UP';

/**
 * An id for the down arrow key on a keyboard.
 */
const KEY_ID_DOWN = 'DOWN';

/**
 * Names used by keyboard io for keys used in scratch.
 * @enum {string}
 */
const SCRATCH_KEY_NAME = {
  [KEY_ID_SPACE]: 'space',
  [KEY_ID_LEFT]: 'left arrow',
  [KEY_ID_UP]: 'up arrow',
  [KEY_ID_RIGHT]: 'right arrow',
  [KEY_ID_DOWN]: 'down arrow'
};

/**
 * Class for the makey makey blocks in Scratch 3.0
 * @constructor
 */
class Scratch3MakeyMakeyBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * A toggle that alternates true and false each frame, so that an
     * edge-triggered hat can trigger on every other frame.
     * @type {boolean}
     */
    this.frameToggle = false;

    // Set an interval that toggles the frameToggle every frame.
    setInterval(() => {
      this.frameToggle = !this.frameToggle;
    }, this.runtime.currentStepTime);
    this.keyPressed = this.keyPressed.bind(this);
    this.runtime.on('KEY_PRESSED', this.keyPressed);
    this._clearkeyPressBuffer = this._clearkeyPressBuffer.bind(this);
    this.runtime.on('PROJECT_STOP_ALL', this._clearkeyPressBuffer);

    /*
     * An object containing a set of sequence objects.
     * These are the key sequences currently being detected by the "when
     * keys pressed in order" hat block. Each sequence is keyed by its
     * string representation (the sequence's value in the menu, which is a
     * string of KEY_IDs separated by spaces). Each sequence object
     * has an array property (an array of KEY_IDs) and a boolean
     * completed property that is true when the sequence has just been
     * pressed.
     * @type {object}
     */
    this.sequences = {};

    /*
     * An array of the key codes of recently pressed keys.
     * @type {array}
     */
    this.keyPressBuffer = [];
  }

  /*
  * Localized short-form names of the space bar and arrow keys, for use in the
  * displayed menu items of the "when keys pressed in order" block.
  * @type {object}
  */
  get KEY_TEXT_SHORT() {
    return {
      [KEY_ID_SPACE]: formatMessage({
        id: 'makeymakey.spaceKey',
        default: 'space',
        description: 'The space key on a computer keyboard.'
      }),
      [KEY_ID_LEFT]: formatMessage({
        id: 'makeymakey.leftArrowShort',
        default: 'left',
        description: 'Short name for the left arrow key on a computer keyboard.'
      }),
      [KEY_ID_UP]: formatMessage({
        id: 'makeymakey.upArrowShort',
        default: 'up',
        description: 'Short name for the up arrow key on a computer keyboard.'
      }),
      [KEY_ID_RIGHT]: formatMessage({
        id: 'makeymakey.rightArrowShort',
        default: 'right',
        description: 'Short name for the right arrow key on a computer keyboard.'
      }),
      [KEY_ID_DOWN]: formatMessage({
        id: 'makeymakey.downArrowShort',
        default: 'down',
        description: 'Short name for the down arrow key on a computer keyboard.'
      })
    };
  }

  /*
   * An array of strings of KEY_IDs representing the default set of
   * key sequences for use by the "when keys pressed in order" block.
   * @type {array}
   */
  get DEFAULT_SEQUENCES() {
    return ["".concat(KEY_ID_LEFT, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_RIGHT, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_RIGHT, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_DOWN), "".concat(KEY_ID_DOWN, " ").concat(KEY_ID_UP), "".concat(KEY_ID_UP, " ").concat(KEY_ID_RIGHT, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_LEFT, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_DOWN, " ") + "".concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT, " ").concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT)];
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: 'makeymakey',
      name: 'Makey Makey',
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'whenMakeyKeyPressed',
        text: formatMessage({
          id: 'makeymakey.whenKeyPressed',
          default: 'when [KEY] key pressed',
          description: 'when a keyboard key is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          KEY: {
            type: ArgumentType.STRING,
            menu: 'KEY',
            defaultValue: KEY_ID_SPACE
          }
        }
      }, {
        opcode: 'whenCodePressed',
        text: formatMessage({
          id: 'makeymakey.whenKeysPressedInOrder',
          default: 'when [SEQUENCE] pressed in order',
          description: 'when a sequence of keyboard keys is pressed in a specific order'
        }),
        blockType: BlockType.HAT,
        arguments: {
          SEQUENCE: {
            type: ArgumentType.STRING,
            menu: 'SEQUENCE',
            defaultValue: this.DEFAULT_SEQUENCES[0]
          }
        }
      }],
      menus: {
        KEY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'makeymakey.spaceKey',
              default: 'space',
              description: 'The space key on a computer keyboard.'
            }),
            value: KEY_ID_SPACE
          }, {
            text: formatMessage({
              id: 'makeymakey.upArrow',
              default: 'up arrow',
              description: 'The up arrow key on a computer keyboard.'
            }),
            value: KEY_ID_UP
          }, {
            text: formatMessage({
              id: 'makeymakey.downArrow',
              default: 'down arrow',
              description: 'The down arrow key on a computer keyboard.'
            }),
            value: KEY_ID_DOWN
          }, {
            text: formatMessage({
              id: 'makeymakey.rightArrow',
              default: 'right arrow',
              description: 'The right arrow key on a computer keyboard.'
            }),
            value: KEY_ID_RIGHT
          }, {
            text: formatMessage({
              id: 'makeymakey.leftArrow',
              default: 'left arrow',
              description: 'The left arrow key on a computer keyboard.'
            }),
            value: KEY_ID_LEFT
          }, {
            text: 'w',
            value: 'w'
          }, {
            text: 'a',
            value: 'a'
          }, {
            text: 's',
            value: 's'
          }, {
            text: 'd',
            value: 'd'
          }, {
            text: 'f',
            value: 'f'
          }, {
            text: 'g',
            value: 'g'
          }]
        },
        SEQUENCE: {
          acceptReporters: true,
          items: this.buildSequenceMenu(this.DEFAULT_SEQUENCES)
        }
      }
    };
  }

  /*
   * Build the menu of key sequences.
   * @param {array} sequencesArray an array of strings of KEY_IDs.
   * @returns {array} an array of objects with text and value properties.
   */
  buildSequenceMenu(sequencesArray) {
    return sequencesArray.map(str => this.getMenuItemForSequenceString(str));
  }

  /*
   * Create a menu item for a sequence string.
   * @param {string} sequenceString a string of KEY_IDs.
   * @return {object} an object with text and value properties.
   */
  getMenuItemForSequenceString(sequenceString) {
    let sequenceArray = sequenceString.split(' ');
    sequenceArray = sequenceArray.map(str => this.KEY_TEXT_SHORT[str]);
    return {
      text: sequenceArray.join(' '),
      value: sequenceString
    };
  }

  /*
   * Check whether a keyboard key is currently pressed.
   * Also, toggle the results of the test on alternate frames, so that the
   * hat block fires repeatedly.
   * @param {object} args - the block arguments.
   * @property {number} KEY - a key code.
   * @param {object} util - utility object provided by the runtime.
   */
  whenMakeyKeyPressed(args, util) {
    let key = args.KEY;
    // Convert the key arg, if it is a KEY_ID, to the key name used by
    // the Keyboard io module.
    if (SCRATCH_KEY_NAME[args.KEY]) {
      key = SCRATCH_KEY_NAME[args.KEY];
    }
    const isDown = util.ioQuery('keyboard', 'getKeyIsDown', [key]);
    return isDown && this.frameToggle;
  }

  /*
   * A function called on the KEY_PRESSED event, to update the key press
   * buffer and check if any of the key sequences have been completed.
   * @param {string} key A scratch key name.
   */
  keyPressed(key) {
    // Store only the first word of the Scratch key name, so that e.g. when
    // "left arrow" is pressed, we store "LEFT", which matches KEY_ID_LEFT
    key = key.split(' ')[0];
    key = key.toUpperCase();
    this.keyPressBuffer.push(key);
    // Keep the buffer under the length limit
    if (this.keyPressBuffer.length > KEY_BUFFER_LENGTH) {
      this.keyPressBuffer.shift();
    }
    // Check the buffer for each sequence in use
    for (const str in this.sequences) {
      const arr = this.sequences[str].array;
      // Bail out if we don't have enough presses for this sequence
      if (this.keyPressBuffer.length < arr.length) {
        continue;
      }
      let missFlag = false;
      // Slice the buffer to the length of the sequence we're checking
      const bufferSegment = this.keyPressBuffer.slice(-1 * arr.length);
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== bufferSegment[i]) {
          missFlag = true;
        }
      }
      // If the miss flag is false, the sequence matched the buffer
      if (!missFlag) {
        this.sequences[str].completed = true;
        // Clear the completed flag after a timeout. This is necessary because
        // the hat is edge-triggered (not event triggered). Multiple hats
        // may be checking the same sequence, so this timeout gives them enough
        // time to all trigger before resetting the flag.
        setTimeout(() => {
          this.sequences[str].completed = false;
        }, SEQUENCE_HAT_TIMEOUT);
      }
    }
  }

  /**
   * Clear the key press buffer.
   */
  _clearkeyPressBuffer() {
    this.keyPressBuffer = [];
  }

  /*
   * Add a key sequence to the set currently being checked on each key press.
   * @param {string} sequenceString a string of space-separated KEY_IDs.
   * @param {array} sequenceArray an array of KEY_IDs.
   */
  addSequence(sequenceString, sequenceArray) {
    // If we already have this sequence string, return.
    if (Object.prototype.hasOwnProperty.call(this.sequences, sequenceString)) {
      return;
    }
    this.sequences[sequenceString] = {
      array: sequenceArray,
      completed: false
    };
  }

  /*
   * Check whether a key sequence was recently completed.
   * @param {object} args The block arguments.
   * @property {number} SEQUENCE A string of KEY_IDs.
   */
  whenCodePressed(args) {
    const sequenceString = Cast.toString(args.SEQUENCE).toUpperCase();
    const sequenceArray = sequenceString.split(' ');
    if (sequenceArray.length < 2) {
      return;
    }
    this.addSequence(sequenceString, sequenceArray);
    return this.sequences[sequenceString].completed;
  }
}
module.exports = Scratch3MakeyMakeyBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_microbit/index.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_microbit/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
const cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");

/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAKcElEQVR42u2cfXAU9RnHv7u3L3d7l9yR5PIGXO7MkQKaYiCUWqJhFGvRMk4JZXSc8aXVaSmiYlthVHQEW99FxiIdrVY6teiMdoa+ICqhIqgQAsjwMgYDOQKXl7uY17u9293b3f5x5JKYe8+FJGSfvzbP/n77e/azz+95nt9v90KoqgpN0hdSQ6AB1ABqADWAmmgANYAaQA2gJhpADeBEE2q8GPLaWzu/CslyiY4k9dOn5uijtXGd7+jWkaReVpT3Hrhv6d0awEFC07rgD+ZeYYnXprhwigUAvjj0zbjxQCLebozT7iDzK1ZUWCru2K7L//6MVC8ue45Blz8n6rlQ815QtuohOlXiEdy/AUqPa6y59Mkh6Q1345GNja6m7pHEQKNl3t0704EXat4L6fSOmOeEI1vHKzwAyNJR9MPFpRUPOu0ONm2A0xatWaTLm5WfDrzvAppA8AbiG03fC8CQNkDKZK2YrPAuRrhpifJERsuYywveJc7CqcIDMAyeLm82dEXzw39I/qjXkpr3QuW9lxfAdOABGAKPslWDnbsy7Jl8BxTeM3SqmO0gaA5U6c3jymup0YSn9JyLee67wpTfBQAQjmyF3HFqiJcRtDECjy5dAmbmcgQPvjjxl3Lx4IVjnD/5cE1zkWtyP34VBGcdKLJnLgc9cznk1kMXFdzEn8KJ4KUqqsSHvcxWDf7j1UM8UPr6/YgHhhX8xAaYaXgAIB7fBnbuSrBzV8aNgarEQ/z6/YkLcDTg9V9XlXjQtuqoU1TpcUHlvZDOfDiuyh5qPMCLrJ1bDw3EuUtx81N/BH3pjQBJQ2HMF5V6iKfeRchVm9kkMtrwxmSdobeA9daBde8GwVlBcFYofS1Jw0vaAy9HeJHQwBUPzIBvGxDc92Rmp/BowJs10wkAONfsBs8HAAAltqngOAO8HZ3o6OiMqcvLy4E1Lwc8H8C5ZndMXdLJa/qNacNLCDBw/O8nFUNWxp/64+tWAwBefe1tHKg7CgC4/9d3ori4EHv3HcDrb26PqVt2602ovvaHaGlpw+8ffSamLqXYmya8jG8mpFy6iGLkWLh4HAwG4+r6j4VBfaPpLgU8IMGO9MLqW2pYQ9aQokuR5dgXIwCC1CUcNMj3hpdvLAdSF54EYpCHooRA0Swomo2pC0kCQpIAkqTA6LmYupgxL0X7m78+aG10NXVkpIwxsAwWXncDCESHLkohfPbpbiT6ZFPPZQ9fC0e58Wi6wTDj6UbT/rQAyiERS2pW4Kc3LQDLRO8miCEAKj7d83FcTxyLJJJJ+9MCqKoq9HomMrgkSThxsgEcZ8AMpwMkSYJlKDA0DVUFiHGWRDJp/4jXwqIo4uFHnkZXdw8AYGbZFXhs3WqQJDkhkkim7E8KoMlkxKbnn8DBunrwUli3e8/+yOAA0HjmHDq7upGXm5PUoDUr7hmWRB5Zt3FYwoime+vtd/H6G9uGJIxouniSyP6H7v8FystnY80jGzIA0MihsMAKu20aTp3JzFb6WCWRuDUvHwByw8cOhw2FBVaYjNzIAba1e3Hfb9aiq7MTNStuBwAsvr4KO3d9GnmKztIS5EyxTJiVSDT7p04tipx/9MnnYc7ORlu7NzMxsK3di5AkDHgGw2DTC+uHBeGJshJJZL/fxyMQEDKbRAiCQDAoQhBDYBkKNE2j4uqrhpUBoiSBIMZfEhkN+1NeiWSqEB2rlUg69md0JRIQRHy86z8jXsqNVRLJlP0jqgNJXXgAgjbCcONmCHUvQ+44NWG2s/rtH5Mt/ciToo0wLH4JBGO6LLazRiJk2vBYy4gHHw/bWSN+LZBKEhkMjzn/CaSiKgQOvJDyFB7L7axUJWNJZDA8IhQA1boPin7KZbMSGfUYyFx9b3hXg/cCsoBA2Z0AoYOaxlcC4+mdyCUDKBzanLFBJ3USyaRMuiSSKZmUSSSTMimTCABUlblRU9kAZ0E39p+eii21c+EL0jHbOwu6sfaWgyjND//U4oP6MmzZnfi79XT7mfQSNi7bh0JzOLG19XBY/89r49pYVebGqhuOosDsh1+gsWV3BXYdd2Q+BlaVuXFv9bHgkSbzk+vfcVRyjHhi47J9cftsXLYf7T36Ix8cLHlo6ydlv6qpPI2qssRZcuOy/Wjp4k5s+2zG+offKqtcUt6kJtNv7S0H0RtkvEufXTB/6bML5je2Wy7UVDbEbF9o9mPDsv2oP5v75vbPS26rP5u3fdXiozDppcwDrKlswOlWy9E//DX09Mt/azh8zzNM1RybF86C7pheVGD240CDeX3NWtfml94Rt+0+Mf3Lm8qbEnpfgdmPs+3G9+564vTT//pM/GrHYduWRP0AYOEMN/5S61xT92Vtfd2XtfWb/vu91fHALyxzw9tnkB/cTD5w+2Ou9375HHtfa7exM5mxRpKFaafdQQKgAcDERs98/foLHrXdaXfoABi8vczhWO2/28/TRR5z2h00gKymNl1ton79oigq6bQ7dE67Q+ew9mb1h4FYYwVESgLAXLSRa+3mWpIdK+UYuPiq89f8+XfT/+ftZQ4vLm9ZmUyfdcsv1M2fWfRaUCK8i8vdK1u6ktuAWPWTsztm24o/cnnYHUsrWzd1+fVJ9XtqxbG3XzFdNcPTawjcueibpxK1t+X26f/9R8a953jub4typOvm2b1XnvUmv8JKWMZcaZffX3XDERRP8cGaFRjWxtPLoZvXY4oxgPBNEsgxBhCUKEzL6Ru+JydS8Ak0giKFgESDJFQoKmCgQzAwIfQEWETzmoBIwd2VNaStu8uEHGO4Buz06zHHFv0dRkefAZ1+PQx0KNK2eIoPLCUj2zDc275qzgcBFWv+cf3IyxgTK2KOzQufEM5kfpGF12eGPSf8DXN+No/87HDWiwYYALw+M6ym8AscAxO++X7xCTRM7EDQzht0Da8v/NWo1dQDAxNCocUXs+303IGHdaptOmYXnh/SLlZbV+fwnwJm6UXEm/ojqgM/PFmJQ81OPHfrtqT7bN23BE8seTflYLvz5DwYGQHLKz5Puo/XZ8aLtT+D1dSDuxbsGQIymmz48DbwIguOESJOcce8XaO3oVpZ8k3Em5KVVAAMFnuOB9as1MbimCBunn04vBmR40ls29Wfgxf1KMn1gBdY+MXUCvK4ANvPndpLzrLzALjBN2VPwrDBksgLYkn1jBMp90nVY2++8vAw3RlPeLNYVZSPAEgjKWP6ZCn4lF+gMdnE08spQb73RQB9aXtgo6tJcNodf8rWz3L//Br340UW3sExEkXrFFKSSUVHqkRfkJZ8QSZk5gS6hw9H+GyDQAclSs41BVmSUIn+toAKIUTJskKoQUknCxKlkISKb/sM0NMyyVAhXW+AlYosfgOgQlUJVadTSUWBKoQoudvPioPbenq5oIUTaRUqenhWKi3oyVIUqKpKREoLggDhF6hQb4CV9LRM9rctMPN6glChp2SdTqeSskwoAECSKnG61fzFR/XsGu+FhmONriYl7TImsjoYKJyZSeB8CoBQo6spqU8TCO1fgE7gDVUNoCYaQA2gBlADqAHURAOoAdQAagA10QCOgfwfNp/hXbfBMCAAAAAASUVORK5CYII=';

/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/scratchfoundation/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */
const BLECommand = {
  CMD_PIN_CONFIG: 0x80,
  CMD_DISPLAY_TEXT: 0x81,
  CMD_DISPLAY_LED: 0x82
};

/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */
const BLETimeout = 4500;

/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */
const BLESendInterval = 100;

/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */
const BLEDataStoppedError = 'micro:bit extension stopped receiving data';

/**
 * Enum for micro:bit protocol.
 * https://github.com/scratchfoundation/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {string}
 */
const BLEUUID = {
  service: 0xf005,
  rxChar: '5261da01-fa7e-42ab-850b-7c80220097cc',
  txChar: '5261da02-fa7e-42ab-850b-7c80220097cc'
};

/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */
class MicroBit {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */
    this._ble = null;
    this._runtime.registerPeripheralExtension(extensionId, this);

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;

    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      buttonA: 0,
      buttonB: 0,
      touchPins: [0, 0, 0],
      gestureState: 0,
      ledMatrixState: new Uint8Array(5)
    };

    /**
     * The most recently received value for each gesture.
     * @type {Object.<string, Object>}
     * @private
     */
    this._gestures = {
      moving: false,
      move: {
        active: false,
        timeout: false
      },
      shake: {
        active: false,
        timeout: false
      },
      jump: {
        active: false,
        timeout: false
      }
    };

    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */
    this._timeoutID = null;

    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */
    this._busy = false;

    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */
    this._busyTimeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
  }

  /**
   * @param {string} text - the text to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */
  displayText(text) {
    const output = new Uint8Array(text.length);
    for (let i = 0; i < text.length; i++) {
      output[i] = text.charCodeAt(i);
    }
    return this.send(BLECommand.CMD_DISPLAY_TEXT, output);
  }

  /**
   * @param {Uint8Array} matrix - the matrix to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */
  displayMatrix(matrix) {
    return this.send(BLECommand.CMD_DISPLAY_LED, matrix);
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */
  get tiltX() {
    return this._sensors.tiltX;
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */
  get tiltY() {
    return this._sensors.tiltY;
  }

  /**
   * @return {boolean} - the latest value received for the A button.
   */
  get buttonA() {
    return this._sensors.buttonA;
  }

  /**
   * @return {boolean} - the latest value received for the B button.
   */
  get buttonB() {
    return this._sensors.buttonB;
  }

  /**
   * @return {number} - the latest value received for the motion gesture states.
   */
  get gestureState() {
    return this._sensors.gestureState;
  }

  /**
   * @return {Uint8Array} - the current state of the 5x5 LED matrix.
   */
  get ledMatrixState() {
    return this._sensors.ledMatrixState;
  }

  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */
  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEUUID.service]
      }]
    }, this._onConnect, this.reset);
  }

  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */
  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }

  /**
   * Disconnect from the micro:bit.
   */
  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this.reset();
  }

  /**
   * Reset all the state and timeout/interval ids.
   */
  reset() {
    if (this._timeoutID) {
      window.clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }

  /**
   * Return true if connected to the micro:bit.
   * @return {boolean} - whether the micro:bit is connected.
   */
  isConnected() {
    let connected = false;
    if (this._ble) {
      connected = this._ble.isConnected();
    }
    return connected;
  }

  /**
   * Send a message to the peripheral BLE socket.
   * @param {number} command - the BLE command hex.
   * @param {Uint8Array} message - the message to write
   */
  send(command, message) {
    if (!this.isConnected()) return;
    if (this._busy) return;

    // Set a busy flag so that while we are sending a message and waiting for
    // the response, additional messages are ignored.
    this._busy = true;

    // Set a timeout after which to reset the busy flag. This is used in case
    // a BLE message was sent for which we never received a response, because
    // e.g. the peripheral was turned off after the message was sent. We reset
    // the busy flag after a while so that it is possible to try again later.
    this._busyTimeoutID = window.setTimeout(() => {
      this._busy = false;
    }, 5000);
    const output = new Uint8Array(message.length + 1);
    output[0] = command; // attach command to beginning of message
    for (let i = 0; i < message.length; i++) {
      output[i + 1] = message[i];
    }
    const data = Base64Util.uint8ArrayToBase64(output);
    this._ble.write(BLEUUID.service, BLEUUID.txChar, data, 'base64', true).then(() => {
      this._busy = false;
      window.clearTimeout(this._busyTimeoutID);
    });
  }

  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */
  _onConnect() {
    this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);
    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }

  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */
  _onMessage(base64) {
    // parse data
    const data = Base64Util.base64ToUint8Array(base64);
    this._sensors.tiltX = data[1] | data[0] << 8;
    if (this._sensors.tiltX > 1 << 15) this._sensors.tiltX -= 1 << 16;
    this._sensors.tiltY = data[3] | data[2] << 8;
    if (this._sensors.tiltY > 1 << 15) this._sensors.tiltY -= 1 << 16;
    this._sensors.buttonA = data[4];
    this._sensors.buttonB = data[5];
    this._sensors.touchPins[0] = data[6];
    this._sensors.touchPins[1] = data[7];
    this._sensors.touchPins[2] = data[8];
    this._sensors.gestureState = data[9];

    // cancel disconnect timeout and start a new one
    window.clearTimeout(this._timeoutID);
    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }

  /**
   * @param {number} pin - the pin to check touch state.
   * @return {number} - the latest value received for the touch pin states.
   * @private
   */
  _checkPinState(pin) {
    return this._sensors.touchPins[pin];
  }
}

/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */
const MicroBitTiltDirection = {
  FRONT: 'front',
  BACK: 'back',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};

/**
 * Enum for micro:bit gestures.
 * @readonly
 * @enum {string}
 */
const MicroBitGestures = {
  MOVED: 'moved',
  SHAKEN: 'shaken',
  JUMPED: 'jumped'
};

/**
 * Enum for micro:bit buttons.
 * @readonly
 * @enum {string}
 */
const MicroBitButtons = {
  A: 'A',
  B: 'B',
  ANY: 'any'
};

/**
 * Enum for micro:bit pin states.
 * @readonly
 * @enum {string}
 */
const MicroBitPinState = {
  ON: 'on',
  OFF: 'off'
};

/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */
class Scratch3MicroBitBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return 'micro:bit';
  }

  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'microbit';
  }

  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */
  static get TILT_THRESHOLD() {
    return 15;
  }

  /**
   * @return {array} - text and values for each buttons menu element
   */
  get BUTTONS_MENU() {
    return [{
      text: 'A',
      value: MicroBitButtons.A
    }, {
      text: 'B',
      value: MicroBitButtons.B
    }, {
      text: formatMessage({
        id: 'microbit.buttonsMenu.any',
        default: 'any',
        description: 'label for "any" element in button picker for micro:bit extension'
      }),
      value: MicroBitButtons.ANY
    }];
  }

  /**
   * @return {array} - text and values for each gestures menu element
   */
  get GESTURES_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.gesturesMenu.moved',
        default: 'moved',
        description: 'label for moved gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.MOVED
    }, {
      text: formatMessage({
        id: 'microbit.gesturesMenu.shaken',
        default: 'shaken',
        description: 'label for shaken gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.SHAKEN
    }, {
      text: formatMessage({
        id: 'microbit.gesturesMenu.jumped',
        default: 'jumped',
        description: 'label for jumped gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.JUMPED
    }];
  }

  /**
   * @return {array} - text and values for each pin state menu element
   */
  get PIN_STATE_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.pinStateMenu.on',
        default: 'on',
        description: 'label for on element in pin state picker for micro:bit extension'
      }),
      value: MicroBitPinState.ON
    }, {
      text: formatMessage({
        id: 'microbit.pinStateMenu.off',
        default: 'off',
        description: 'label for off element in pin state picker for micro:bit extension'
      }),
      value: MicroBitPinState.OFF
    }];
  }

  /**
   * @return {array} - text and values for each tilt direction menu element
   */
  get TILT_DIRECTION_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.front',
        default: 'front',
        description: 'label for front element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.FRONT
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.back',
        default: 'back',
        description: 'label for back element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.BACK
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.left',
        default: 'left',
        description: 'label for left element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.LEFT
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.right',
        default: 'right',
        description: 'label for right element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.RIGHT
    }];
  }

  /**
   * @return {array} - text and values for each tilt direction (plus "any") menu element
   */
  get TILT_DIRECTION_ANY_MENU() {
    return [...this.TILT_DIRECTION_MENU, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.any',
        default: 'any',
        description: 'label for any direction element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.ANY
    }];
  }

  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    // Create a new MicroBit peripheral instance
    this._peripheral = new MicroBit(this.runtime, Scratch3MicroBitBlocks.EXTENSION_ID);
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: Scratch3MicroBitBlocks.EXTENSION_ID,
      name: Scratch3MicroBitBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'whenButtonPressed',
        text: formatMessage({
          id: 'microbit.whenButtonPressed',
          default: 'when [BTN] button pressed',
          description: 'when the selected button on the micro:bit is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: 'buttons',
            defaultValue: MicroBitButtons.A
          }
        }
      }, {
        opcode: 'isButtonPressed',
        text: formatMessage({
          id: 'microbit.isButtonPressed',
          default: '[BTN] button pressed?',
          description: 'is the selected button on the micro:bit pressed?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: 'buttons',
            defaultValue: MicroBitButtons.A
          }
        }
      }, '---', {
        opcode: 'whenGesture',
        text: formatMessage({
          id: 'microbit.whenGesture',
          default: 'when [GESTURE]',
          description: 'when the selected gesture is detected by the micro:bit'
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: 'gestures',
            defaultValue: MicroBitGestures.MOVED
          }
        }
      }, '---', {
        opcode: 'displaySymbol',
        text: formatMessage({
          id: 'microbit.displaySymbol',
          default: 'display [MATRIX]',
          description: 'display a pattern on the micro:bit display'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MATRIX: {
            type: ArgumentType.MATRIX,
            defaultValue: '0101010101100010101000100'
          }
        }
      }, {
        opcode: 'displayText',
        text: formatMessage({
          id: 'microbit.displayText',
          default: 'display text [TEXT]',
          description: 'display text on the micro:bit display'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'microbit.defaultTextToDisplay',
              default: 'Hello!',
              description: "default text to display.\n                                IMPORTANT - the micro:bit only supports letters a-z, A-Z.\n                                Please substitute a default word in your language\n                                that can be written with those characters,\n                                substitute non-accented characters or leave it as \"Hello!\".\n                                Check the micro:bit site documentation for details"
            })
          }
        }
      }, {
        opcode: 'displayClear',
        text: formatMessage({
          id: 'microbit.clearDisplay',
          default: 'clear display',
          description: 'display nothing on the micro:bit display'
        }),
        blockType: BlockType.COMMAND
      }, '---', {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'microbit.whenTilted',
          default: 'when tilted [DIRECTION]',
          description: 'when the micro:bit is tilted in a direction'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirectionAny',
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'microbit.isTilted',
          default: 'tilted [DIRECTION]?',
          description: 'is the micro:bit is tilted in a direction?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirectionAny',
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'microbit.tiltAngle',
          default: 'tilt angle [DIRECTION]',
          description: 'how much the micro:bit is tilted in a direction'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirection',
            defaultValue: MicroBitTiltDirection.FRONT
          }
        }
      }, '---', {
        opcode: 'whenPinConnected',
        text: formatMessage({
          id: 'microbit.whenPinConnected',
          default: 'when pin [PIN] connected',
          description: 'when the pin detects a connection to Earth/Ground'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PIN: {
            type: ArgumentType.STRING,
            menu: 'touchPins',
            defaultValue: '0'
          }
        }
      }],
      menus: {
        buttons: {
          acceptReporters: true,
          items: this.BUTTONS_MENU
        },
        gestures: {
          acceptReporters: true,
          items: this.GESTURES_MENU
        },
        pinState: {
          acceptReporters: true,
          items: this.PIN_STATE_MENU
        },
        tiltDirection: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_MENU
        },
        tiltDirectionAny: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_ANY_MENU
        },
        touchPins: {
          acceptReporters: true,
          items: ['0', '1', '2']
        }
      }
    };
  }

  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */
  whenButtonPressed(args) {
    if (args.BTN === 'any') {
      return this._peripheral.buttonA | this._peripheral.buttonB;
    } else if (args.BTN === 'A') {
      return this._peripheral.buttonA;
    } else if (args.BTN === 'B') {
      return this._peripheral.buttonB;
    }
    return false;
  }

  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */
  isButtonPressed(args) {
    if (args.BTN === 'any') {
      return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;
    } else if (args.BTN === 'A') {
      return this._peripheral.buttonA !== 0;
    } else if (args.BTN === 'B') {
      return this._peripheral.buttonB !== 0;
    }
    return false;
  }

  /**
   * Test whether the micro:bit is moving
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the micro:bit is moving.
   */
  whenGesture(args) {
    const gesture = cast.toString(args.GESTURE);
    if (gesture === 'moved') {
      return this._peripheral.gestureState >> 2 & 1;
    } else if (gesture === 'shaken') {
      return this._peripheral.gestureState & 1;
    } else if (gesture === 'jumped') {
      return this._peripheral.gestureState >> 1 & 1;
    }
    return false;
  }

  /**
   * Display a predefined symbol on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after a tick.
   */
  displaySymbol(args) {
    const symbol = cast.toString(args.MATRIX).replace(/\s/g, '');
    const reducer = (accumulator, c, index) => {
      const value = c === '0' ? accumulator : accumulator + Math.pow(2, index);
      return value;
    };
    const hex = symbol.split('').reduce(reducer, 0);
    if (hex !== null) {
      this._peripheral.ledMatrixState[0] = hex & 0x1F;
      this._peripheral.ledMatrixState[1] = hex >> 5 & 0x1F;
      this._peripheral.ledMatrixState[2] = hex >> 10 & 0x1F;
      this._peripheral.ledMatrixState[3] = hex >> 15 & 0x1F;
      this._peripheral.ledMatrixState[4] = hex >> 20 & 0x1F;
      this._peripheral.displayMatrix(this._peripheral.ledMatrixState);
    }
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Display text on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after the text is done printing.
   * Note the limit is 19 characters
   * The print time is calculated by multiplying the number of horizontal pixels
   * by the default scroll delay of 120ms.
   * The number of horizontal pixels = 6px for each character in the string,
   * 1px before the string, and 5px after the string.
   */
  displayText(args) {
    const text = String(args.TEXT).substring(0, 19);
    if (text.length > 0) this._peripheral.displayText(text);
    const yieldDelay = 120 * (6 * text.length + 6);
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, yieldDelay);
    });
  }

  /**
   * Turn all 5x5 matrix LEDs off.
   * @return {Promise} - a Promise that resolves after a tick.
   */
  displayClear() {
    for (let i = 0; i < 5; i++) {
      this._peripheral.ledMatrixState[i] = 0;
    }
    this._peripheral.displayMatrix(this._peripheral.ledMatrixState);
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  whenTilted(args) {
    return this._isTilted(args.DIRECTION);
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  isTilted(args) {
    return this._isTilted(args.DIRECTION);
  }

  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   */
  getTiltAngle(args) {
    return this._getTiltAngle(args.DIRECTION);
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */
  _isTilted(direction) {
    switch (direction) {
      case MicroBitTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;
      default:
        return this._getTiltAngle(direction) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;
    }
  }

  /**
   * @param {TiltDirection} direction - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */
  _getTiltAngle(direction) {
    switch (direction) {
      case MicroBitTiltDirection.FRONT:
        return Math.round(this._peripheral.tiltY / -10);
      case MicroBitTiltDirection.BACK:
        return Math.round(this._peripheral.tiltY / 10);
      case MicroBitTiltDirection.LEFT:
        return Math.round(this._peripheral.tiltX / -10);
      case MicroBitTiltDirection.RIGHT:
        return Math.round(this._peripheral.tiltX / 10);
      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }

  /**
   * @param {object} args - the block's arguments.
   * @return {boolean} - the touch pin state.
   * @private
   */
  whenPinConnected(args) {
    const pin = parseInt(args.PIN, 10);
    if (isNaN(pin)) return;
    if (pin < 0 || pin > 2) return false;
    return this._peripheral._checkPinState(pin);
  }
}
module.exports = Scratch3MicroBitBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_music/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_music/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const Timer = __webpack_require__(/*! ../../util/timer */ "./src/util/timer.js");

/**
 * The instrument and drum sounds, loaded as static assets.
 * @type {object}
 */
let assetData = {};
try {
  assetData = __webpack_require__(/*! ./manifest */ "./src/extensions/scratch3_music/manifest.js");
} catch (e) {
  // Non-webpack environment, don't worry about assets.
}

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=';

/**
 * Icon svg to be displayed in the category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2LjA5IDEyLjkzN2MuMjI4IDEuMTQxLS44MzMgMi4wNjMtMi4zNzMgMi4wNjMtMS41MzUgMC0yLjk2Mi0uOTIyLTMuMTg2LTIuMDYzLS4yMy0xLjE0Mi44MzMtMi4wNjggMi4zNzItMi4wNjguMzIzIDAgLjY0MS4wNDIuOTQ1LjExN2EzLjUgMy41IDAgMCAxIC40NjguMTUxYy40MzUtLjAxLS4wNTItMS4xNDctLjkxNy02LjExNC0xLjA2Ny02LjE1MiAxLjUzLS45MzUgNC4zODQtMS4zNzcgMi44NTQtLjQ0Mi4wMzggMi40MS0xLjgyNSAxLjkyMi0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc3LjEzMiA3LjM3ek03LjQ2IDguNTYzYy0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc2LjEzIDcuMzdDNy44MTYgMTcuMDczIDYuNzU0IDE4IDUuMjIgMThjLTEuNTM1IDAtMi45NjEtLjkyNi0zLjE5LTIuMDY4LS4yMjQtMS4xNDIuODM3LTIuMDY3IDIuMzc1LTIuMDY3LjUwMSAwIC45ODcuMDk4IDEuNDI3LjI3Mi40MTItLjAyOC0uMDc0LTEuMTg5LS45My02LjExNEMzLjgzNCAxLjg3IDYuNDMgNy4wODcgOS4yODIgNi42NDZjMi44NTQtLjQ0Ny4wMzggMi40MS0xLjgyMyAxLjkxN3oiIGZpbGw9IiM1NzVFNzUiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==';

/**
 * Class for the music-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */
class Scratch3MusicBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * The number of drum and instrument sounds currently being played simultaneously.
     * @type {number}
     * @private
     */
    this._concurrencyCounter = 0;

    /**
     * An array of sound players, one for each drum sound.
     * @type {Array}
     * @private
     */
    this._drumPlayers = [];

    /**
     * An array of arrays of sound players. Each instrument has one or more audio players.
     * @type {Array[]}
     * @private
     */
    this._instrumentPlayerArrays = [];

    /**
     * An array of arrays of sound players. Each instrument mya have an audio player for each playable note.
     * @type {Array[]}
     * @private
     */
    this._instrumentPlayerNoteArrays = [];

    /**
     * An array of audio bufferSourceNodes. Each time you play an instrument or drum sound,
     * a bufferSourceNode is created. We keep references to them to make sure their onended
     * events can fire.
     * @type {Array}
     * @private
     */
    this._bufferSources = [];
    this._loadAllSounds();
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this.runtime.on('targetWasCreated', this._onTargetCreated);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);
  }

  /**
   * Decode the full set of drum and instrument sounds, and store the audio buffers in arrays.
   */
  _loadAllSounds() {
    const loadingPromises = [];
    this.DRUM_INFO.forEach((drumInfo, index) => {
      const filePath = "drums/".concat(drumInfo.fileName);
      const promise = this._storeSound(filePath, index, this._drumPlayers);
      loadingPromises.push(promise);
    });
    this.INSTRUMENT_INFO.forEach((instrumentInfo, instrumentIndex) => {
      this._instrumentPlayerArrays[instrumentIndex] = [];
      this._instrumentPlayerNoteArrays[instrumentIndex] = [];
      instrumentInfo.samples.forEach((sample, noteIndex) => {
        const filePath = "instruments/".concat(instrumentInfo.dirName, "/").concat(sample);
        const promise = this._storeSound(filePath, noteIndex, this._instrumentPlayerArrays[instrumentIndex]);
        loadingPromises.push(promise);
      });
    });
    Promise.all(loadingPromises).then(() => {
      // @TODO: Update the extension status indicator.
    });
  }

  /**
   * Decode a sound and store the player in an array.
   * @param {string} filePath - the audio file name.
   * @param {number} index - the index at which to store the audio player.
   * @param {array} playerArray - the array of players in which to store it.
   * @return {Promise} - a promise which will resolve once the sound has been stored.
   */
  _storeSound(filePath, index, playerArray) {
    const fullPath = "".concat(filePath, ".mp3");
    if (!assetData[fullPath]) return;

    // The sound player has already been downloaded via the manifest file required above.
    const soundBuffer = assetData[fullPath];
    return this._decodeSound(soundBuffer).then(player => {
      playerArray[index] = player;
    });
  }

  /**
   * Decode a sound and return a promise with the audio buffer.
   * @param  {ArrayBuffer} soundBuffer - a buffer containing the encoded audio.
   * @return {Promise} - a promise which will resolve once the sound has decoded.
   */
  _decodeSound(soundBuffer) {
    const engine = this.runtime.audioEngine;
    if (!engine) {
      return Promise.reject(new Error('No Audio Context Detected'));
    }

    // Check for newer promise-based API
    return engine.decodeSoundPlayer({
      data: {
        buffer: soundBuffer
      }
    });
  }

  /**
   * Create data for a menu in scratch-blocks format, consisting of an array of objects with text and
   * value properties. The text is a translated string, and the value is one-indexed.
   * @param  {object[]} info - An array of info objects each having a name property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */
  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = String(index + 1);
      return obj;
    });
  }

  /**
   * An array of info about each drum.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the drums menu.
   * @param {string} fileName - the name of the audio file containing the drum sound.
   */
  get DRUM_INFO() {
    return [{
      name: formatMessage({
        id: 'music.drumSnare',
        default: '(1) Snare Drum',
        description: 'Sound of snare drum as used in a standard drum kit'
      }),
      fileName: '1-snare'
    }, {
      name: formatMessage({
        id: 'music.drumBass',
        default: '(2) Bass Drum',
        description: 'Sound of bass drum as used in a standard drum kit'
      }),
      fileName: '2-bass-drum'
    }, {
      name: formatMessage({
        id: 'music.drumSideStick',
        default: '(3) Side Stick',
        description: 'Sound of a drum stick hitting the side of a drum (usually the snare)'
      }),
      fileName: '3-side-stick'
    }, {
      name: formatMessage({
        id: 'music.drumCrashCymbal',
        default: '(4) Crash Cymbal',
        description: 'Sound of a drum stick hitting a crash cymbal'
      }),
      fileName: '4-crash-cymbal'
    }, {
      name: formatMessage({
        id: 'music.drumOpenHiHat',
        default: '(5) Open Hi-Hat',
        description: 'Sound of a drum stick hitting a hi-hat while open'
      }),
      fileName: '5-open-hi-hat'
    }, {
      name: formatMessage({
        id: 'music.drumClosedHiHat',
        default: '(6) Closed Hi-Hat',
        description: 'Sound of a drum stick hitting a hi-hat while closed'
      }),
      fileName: '6-closed-hi-hat'
    }, {
      name: formatMessage({
        id: 'music.drumTambourine',
        default: '(7) Tambourine',
        description: 'Sound of a tambourine being struck'
      }),
      fileName: '7-tambourine'
    }, {
      name: formatMessage({
        id: 'music.drumHandClap',
        default: '(8) Hand Clap',
        description: 'Sound of two hands clapping together'
      }),
      fileName: '8-hand-clap'
    }, {
      name: formatMessage({
        id: 'music.drumClaves',
        default: '(9) Claves',
        description: 'Sound of claves being struck together'
      }),
      fileName: '9-claves'
    }, {
      name: formatMessage({
        id: 'music.drumWoodBlock',
        default: '(10) Wood Block',
        description: 'Sound of a wood block being struck'
      }),
      fileName: '10-wood-block'
    }, {
      name: formatMessage({
        id: 'music.drumCowbell',
        default: '(11) Cowbell',
        description: 'Sound of a cowbell being struck'
      }),
      fileName: '11-cowbell'
    }, {
      name: formatMessage({
        id: 'music.drumTriangle',
        default: '(12) Triangle',
        description: 'Sound of a triangle (instrument) being struck'
      }),
      fileName: '12-triangle'
    }, {
      name: formatMessage({
        id: 'music.drumBongo',
        default: '(13) Bongo',
        description: 'Sound of a bongo being struck'
      }),
      fileName: '13-bongo'
    }, {
      name: formatMessage({
        id: 'music.drumConga',
        default: '(14) Conga',
        description: 'Sound of a conga being struck'
      }),
      fileName: '14-conga'
    }, {
      name: formatMessage({
        id: 'music.drumCabasa',
        default: '(15) Cabasa',
        description: 'Sound of a cabasa being shaken'
      }),
      fileName: '15-cabasa'
    }, {
      name: formatMessage({
        id: 'music.drumGuiro',
        default: '(16) Guiro',
        description: 'Sound of a guiro being played'
      }),
      fileName: '16-guiro'
    }, {
      name: formatMessage({
        id: 'music.drumVibraslap',
        default: '(17) Vibraslap',
        description: 'Sound of a Vibraslap being played'
      }),
      fileName: '17-vibraslap'
    }, {
      name: formatMessage({
        id: 'music.drumCuica',
        default: '(18) Cuica',
        description: 'Sound of a cuica being played'
      }),
      fileName: '18-cuica'
    }];
  }

  /**
   * An array of info about each instrument.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the instruments menu.
   * @param {string} dirName - the name of the directory containing audio samples for this instrument.
   * @param {number} [releaseTime] - an optional duration for the release portion of each note.
   * @param {number[]} samples - an array of numbers representing the MIDI note number for each
   *                           sampled sound used to play this instrument.
   */
  get INSTRUMENT_INFO() {
    return [{
      name: formatMessage({
        id: 'music.instrumentPiano',
        default: '(1) Piano',
        description: 'Sound of a piano'
      }),
      dirName: '1-piano',
      releaseTime: 0.5,
      samples: [24, 36, 48, 60, 72, 84, 96, 108]
    }, {
      name: formatMessage({
        id: 'music.instrumentElectricPiano',
        default: '(2) Electric Piano',
        description: 'Sound of an electric piano'
      }),
      dirName: '2-electric-piano',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentOrgan',
        default: '(3) Organ',
        description: 'Sound of an organ'
      }),
      dirName: '3-organ',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentGuitar',
        default: '(4) Guitar',
        description: 'Sound of an accoustic guitar'
      }),
      dirName: '4-guitar',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentElectricGuitar',
        default: '(5) Electric Guitar',
        description: 'Sound of an electric guitar'
      }),
      dirName: '5-electric-guitar',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentBass',
        default: '(6) Bass',
        description: 'Sound of an accoustic upright bass'
      }),
      dirName: '6-bass',
      releaseTime: 0.25,
      samples: [36, 48]
    }, {
      name: formatMessage({
        id: 'music.instrumentPizzicato',
        default: '(7) Pizzicato',
        description: 'Sound of a string instrument (e.g. violin) being plucked'
      }),
      dirName: '7-pizzicato',
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentCello',
        default: '(8) Cello',
        description: 'Sound of a cello being played with a bow'
      }),
      dirName: '8-cello',
      releaseTime: 0.1,
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentTrombone',
        default: '(9) Trombone',
        description: 'Sound of a trombone being played'
      }),
      dirName: '9-trombone',
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentClarinet',
        default: '(10) Clarinet',
        description: 'Sound of a clarinet being played'
      }),
      dirName: '10-clarinet',
      samples: [48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSaxophone',
        default: '(11) Saxophone',
        description: 'Sound of a saxophone being played'
      }),
      dirName: '11-saxophone',
      samples: [36, 60, 84]
    }, {
      name: formatMessage({
        id: 'music.instrumentFlute',
        default: '(12) Flute',
        description: 'Sound of a flute being played'
      }),
      dirName: '12-flute',
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentWoodenFlute',
        default: '(13) Wooden Flute',
        description: 'Sound of a wooden flute being played'
      }),
      dirName: '13-wooden-flute',
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentBassoon',
        default: '(14) Bassoon',
        description: 'Sound of a bassoon being played'
      }),
      dirName: '14-bassoon',
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentChoir',
        default: '(15) Choir',
        description: 'Sound of a choir singing'
      }),
      dirName: '15-choir',
      releaseTime: 0.25,
      samples: [48, 60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentVibraphone',
        default: '(16) Vibraphone',
        description: 'Sound of a vibraphone being struck'
      }),
      dirName: '16-vibraphone',
      releaseTime: 0.5,
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentMusicBox',
        default: '(17) Music Box',
        description: 'Sound of a music box playing'
      }),
      dirName: '17-music-box',
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSteelDrum',
        default: '(18) Steel Drum',
        description: 'Sound of a steel drum being struck'
      }),
      dirName: '18-steel-drum',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentMarimba',
        default: '(19) Marimba',
        description: 'Sound of a marimba being struck'
      }),
      dirName: '19-marimba',
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSynthLead',
        default: '(20) Synth Lead',
        description: 'Sound of a "lead" synthesizer being played'
      }),
      dirName: '20-synth-lead',
      releaseTime: 0.1,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSynthPad',
        default: '(21) Synth Pad',
        description: 'Sound of a "pad" synthesizer being played'
      }),
      dirName: '21-synth-pad',
      releaseTime: 0.25,
      samples: [60]
    }];
  }

  /**
   * An array that is a mapping from MIDI instrument numbers to Scratch instrument numbers.
   * @type {number[]}
   */
  get MIDI_INSTRUMENTS() {
    return [
    // Acoustic Grand, Bright Acoustic, Electric Grand, Honky-Tonk
    1, 1, 1, 1,
    // Electric Piano 1, Electric Piano 2, Harpsichord, Clavinet
    2, 2, 4, 4,
    // Celesta, Glockenspiel, Music Box, Vibraphone
    17, 17, 17, 16,
    // Marimba, Xylophone, Tubular Bells, Dulcimer
    19, 16, 17, 17,
    // Drawbar Organ, Percussive Organ, Rock Organ, Church Organ
    3, 3, 3, 3,
    // Reed Organ, Accordion, Harmonica, Tango Accordion
    3, 3, 3, 3,
    // Nylon String Guitar, Steel String Guitar, Electric Jazz Guitar, Electric Clean Guitar
    4, 4, 5, 5,
    // Electric Muted Guitar, Overdriven Guitar,Distortion Guitar, Guitar Harmonics
    5, 5, 5, 5,
    // Acoustic Bass, Electric Bass (finger), Electric Bass (pick), Fretless Bass
    6, 6, 6, 6,
    // Slap Bass 1, Slap Bass 2, Synth Bass 1, Synth Bass 2
    6, 6, 6, 6,
    // Violin, Viola, Cello, Contrabass
    8, 8, 8, 8,
    // Tremolo Strings, Pizzicato Strings, Orchestral Strings, Timpani
    8, 7, 8, 19,
    // String Ensemble 1, String Ensemble 2, SynthStrings 1, SynthStrings 2
    8, 8, 8, 8,
    // Choir Aahs, Voice Oohs, Synth Voice, Orchestra Hit
    15, 15, 15, 19,
    // Trumpet, Trombone, Tuba, Muted Trumpet
    9, 9, 9, 9,
    // French Horn, Brass Section, SynthBrass 1, SynthBrass 2
    9, 9, 9, 9,
    // Soprano Sax, Alto Sax, Tenor Sax, Baritone Sax
    11, 11, 11, 11,
    // Oboe, English Horn, Bassoon, Clarinet
    14, 14, 14, 10,
    // Piccolo, Flute, Recorder, Pan Flute
    12, 12, 13, 13,
    // Blown Bottle, Shakuhachi, Whistle, Ocarina
    13, 13, 12, 12,
    // Lead 1 (square), Lead 2 (sawtooth), Lead 3 (calliope), Lead 4 (chiff)
    20, 20, 20, 20,
    // Lead 5 (charang), Lead 6 (voice), Lead 7 (fifths), Lead 8 (bass+lead)
    20, 20, 20, 20,
    // Pad 1 (new age), Pad 2 (warm), Pad 3 (polysynth), Pad 4 (choir)
    21, 21, 21, 21,
    // Pad 5 (bowed), Pad 6 (metallic), Pad 7 (halo), Pad 8 (sweep)
    21, 21, 21, 21,
    // FX 1 (rain), FX 2 (soundtrack), FX 3 (crystal), FX 4 (atmosphere)
    21, 21, 21, 21,
    // FX 5 (brightness), FX 6 (goblins), FX 7 (echoes), FX 8 (sci-fi)
    21, 21, 21, 21,
    // Sitar, Banjo, Shamisen, Koto
    4, 4, 4, 4,
    // Kalimba, Bagpipe, Fiddle, Shanai
    17, 14, 8, 10,
    // Tinkle Bell, Agogo, Steel Drums, Woodblock
    17, 17, 18, 19,
    // Taiko Drum, Melodic Tom, Synth Drum, Reverse Cymbal
    1, 1, 1, 1,
    // Guitar Fret Noise, Breath Noise, Seashore, Bird Tweet
    21, 21, 21, 21,
    // Telephone Ring, Helicopter, Applause, Gunshot
    21, 21, 21, 21];
  }

  /**
   * An array that is a mapping from MIDI drum numbers in range (35..81) to Scratch drum numbers.
   * It's in the format [drumNum, pitch, decay].
   * The pitch and decay properties are not currently being used.
   * @type {Array[]}
   */
  get MIDI_DRUMS() {
    return [[1, -4],
    // "BassDrum" in 2.0, "Bass Drum" in 3.0 (which was "Tom" in 2.0)
    [1, 0],
    // Same as just above
    [2, 0], [0, 0], [7, 0], [0, 2], [1, -6, 4], [5, 0], [1, -3, 3.2], [5, 0],
    // "HiHatPedal" in 2.0, "Closed Hi-Hat" in 3.0
    [1, 0, 3], [4, -8], [1, 4, 3], [1, 7, 2.7], [3, -8], [1, 10, 2.7], [4, -2], [3, -11], [4, 2], [6, 0], [3, 0, 3.5], [10, 0], [3, -8, 3.5], [16, -6], [4, 2], [12, 2], [12, 0], [13, 0, 0.2], [13, 0, 2], [13, -5, 2], [12, 12], [12, 5], [10, 19], [10, 12], [14, 0], [14, 0],
    // "Maracas" in 2.0, "Cabasa" in 3.0 (TODO: pitch up?)
    [17, 12], [17, 5], [15, 0],
    // "GuiroShort" in 2.0, "Guiro" in 3.0 (which was "GuiroLong" in 2.0) (TODO: decay?)
    [15, 0], [8, 0], [9, 0], [9, -4], [17, -5], [17, 0], [11, -6, 1], [11, -6, 3]];
  }

  /**
   * The key to load & store a target's music-related state.
   * @type {string}
   */
  static get STATE_KEY() {
    return 'Scratch.music';
  }

  /**
   * The default music-related state, to be used when a target has no existing music state.
   * @type {MusicState}
   */
  static get DEFAULT_MUSIC_STATE() {
    return {
      currentInstrument: 0
    };
  }

  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */
  static get MIDI_NOTE_RANGE() {
    return {
      min: 0,
      max: 130
    };
  }

  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */
  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }

  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */
  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }

  /**
   * The maximum number of sounds to allow to play simultaneously.
   * @type {number}
   */
  static get CONCURRENCY_LIMIT() {
    return 30;
  }

  /**
   * @param {Target} target - collect music state for this target.
   * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.
   * @private
   */
  _getMusicState(target) {
    let musicState = target.getCustomState(Scratch3MusicBlocks.STATE_KEY);
    if (!musicState) {
      musicState = Clone.simple(Scratch3MusicBlocks.DEFAULT_MUSIC_STATE);
      target.setCustomState(Scratch3MusicBlocks.STATE_KEY, musicState);
    }
    return musicState;
  }

  /**
   * When a music-playing Target is cloned, clone the music state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */
  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const musicState = sourceTarget.getCustomState(Scratch3MusicBlocks.STATE_KEY);
      if (musicState) {
        newTarget.setCustomState(Scratch3MusicBlocks.STATE_KEY, Clone.simple(musicState));
      }
    }
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: 'music',
      name: formatMessage({
        id: 'music.categoryName',
        default: 'Music',
        description: 'Label for the Music extension category'
      }),
      menuIconURI: menuIconURI,
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'playDrumForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.playDrumForBeats',
          default: 'play drum [DRUM] for [BEATS] beats',
          description: 'play drum sample for a number of beats'
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: 'DRUM',
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'midiPlayDrumForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.midiPlayDrumForBeats',
          default: 'play drum [DRUM] for [BEATS] beats',
          description: 'play drum sample for a number of beats according to a mapping of MIDI codes'
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: 'DRUM',
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'restForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.restForBeats',
          default: 'rest for [BEATS] beats',
          description: 'rest (play no sound) for a number of beats'
        }),
        arguments: {
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'playNoteForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.playNoteForBeats',
          default: 'play note [NOTE] for [BEATS] beats',
          description: 'play a note for a number of beats'
        }),
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'setInstrument',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.setInstrument',
          default: 'set instrument to [INSTRUMENT]',
          description: 'set the instrument (e.g. piano, guitar, trombone) for notes played'
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            menu: 'INSTRUMENT',
            defaultValue: 1
          }
        }
      }, {
        opcode: 'midiSetInstrument',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.midiSetInstrument',
          default: 'set instrument to [INSTRUMENT]',
          description: 'set the instrument for notes played according to a mapping of MIDI codes'
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'setTempo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.setTempo',
          default: 'set tempo to [TEMPO]',
          description: 'set tempo (speed) for notes, drums, and rests played'
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 60
          }
        }
      }, {
        opcode: 'changeTempo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.changeTempo',
          default: 'change tempo by [TEMPO]',
          description: 'change tempo (speed) for notes, drums, and rests played'
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 20
          }
        }
      }, {
        opcode: 'getTempo',
        text: formatMessage({
          id: 'music.getTempo',
          default: 'tempo',
          description: 'get the current tempo (speed) for notes, drums, and rests played'
        }),
        blockType: BlockType.REPORTER
      }],
      menus: {
        DRUM: {
          acceptReporters: true,
          items: this._buildMenu(this.DRUM_INFO)
        },
        INSTRUMENT: {
          acceptReporters: true,
          items: this._buildMenu(this.INSTRUMENT_INFO)
        }
      }
    };
  }

  /**
   * Play a drum sound for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} DRUM - the number of the drum to play.
   * @property {number} BEATS - the duration in beats of the drum sound.
   */
  playDrumForBeats(args, util) {
    this._playDrumForBeats(args.DRUM, args.BEATS, util);
  }

  /**
   * Play a drum sound for some number of beats according to the range of "MIDI" drum codes supported.
   * This block is implemented for compatibility with old Scratch projects that use the
   * 'drum:duration:elapsed:from:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */
  midiPlayDrumForBeats(args, util) {
    let drumNum = Cast.toNumber(args.DRUM);
    drumNum = Math.round(drumNum);
    const midiDescription = this.MIDI_DRUMS[drumNum - 35];
    if (midiDescription) {
      drumNum = midiDescription[0];
    } else {
      drumNum = 2; // Default instrument used in Scratch 2.0
    }
    drumNum += 1; // drumNum input to _playDrumForBeats is one-indexed
    this._playDrumForBeats(drumNum, args.BEATS, util);
  }

  /**
   * Internal code to play a drum sound for some number of beats.
   * @param {number} drumNum - the drum number.
   * @param {beats} beats - the duration in beats to pause after playing the sound.
   * @param {object} util - utility object provided by the runtime.
   */
  _playDrumForBeats(drumNum, beats, util) {
    if (this._stackTimerNeedsInit(util)) {
      drumNum = Cast.toNumber(drumNum);
      drumNum = Math.round(drumNum);
      drumNum -= 1; // drums are one-indexed
      drumNum = MathUtil.wrapClamp(drumNum, 0, this.DRUM_INFO.length - 1);
      beats = Cast.toNumber(beats);
      beats = this._clampBeats(beats);
      this._playDrumNum(util, drumNum);
      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }

  /**
   * Play a drum sound using its 0-indexed number.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} drumNum - the number of the drum to play.
   * @private
   */
  _playDrumNum(util, drumNum) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return;
    // If we're playing too many sounds, do not play the drum sound.
    if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
      return;
    }
    const player = this._drumPlayers[drumNum];
    if (typeof player === 'undefined') return;
    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    }
    const engine = util.runtime.audioEngine;
    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    volumeGain.connect(engine.getInputNode());
    this._concurrencyCounter++;
    player.once('stop', () => {
      this._concurrencyCounter--;
    });
    player.play();
    // Connect the player to the gain node.
    player.connect({
      getInputNode() {
        return volumeGain;
      }
    });
  }

  /**
   * Rest for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} BEATS - the duration in beats of the rest.
   */
  restForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let beats = Cast.toNumber(args.BEATS);
      beats = this._clampBeats(beats);
      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }

  /**
   * Play a note using the current musical instrument for some number of beats.
   * This function processes the arguments, and handles the timing of the block's execution.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.
   * @property {number} BEATS - the duration in beats of the note.
   */
  playNoteForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let note = Cast.toNumber(args.NOTE);
      note = MathUtil.clamp(note, Scratch3MusicBlocks.MIDI_NOTE_RANGE.min, Scratch3MusicBlocks.MIDI_NOTE_RANGE.max);
      let beats = Cast.toNumber(args.BEATS);
      beats = this._clampBeats(beats);
      // If the duration is 0, do not play the note. In Scratch 2.0, "play drum for 0 beats" plays the drum,
      // but "play note for 0 beats" is silent.
      if (beats === 0) return;
      const durationSec = this._beatsToSec(beats);
      this._playNote(util, note, durationSec);
      this._startStackTimer(util, durationSec);
    } else {
      this._checkStackTimer(util);
    }
  }
  _playNoteForPicker(noteNum, category) {
    if (category !== this.getInfo().name) return;
    const util = {
      runtime: this.runtime,
      target: this.runtime.getEditingTarget()
    };
    this._playNote(util, noteNum, 0.25);
  }

  /**
   * Play a note using the current instrument for a duration in seconds.
   * This function actually plays the sound, and handles the timing of the sound, including the
   * "release" portion of the sound, which continues briefly after the block execution has finished.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.
   * @param {number} durationSec - the duration in seconds to play the note.
   * @private
   */
  _playNote(util, note, durationSec) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return;

    // If we're playing too many sounds, do not play the note.
    if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
      return;
    }

    // Determine which of the audio samples for this instrument to play
    const musicState = this._getMusicState(util.target);
    const inst = musicState.currentInstrument;
    const instrumentInfo = this.INSTRUMENT_INFO[inst];
    const sampleArray = instrumentInfo.samples;
    const sampleIndex = this._selectSampleIndexForNote(note, sampleArray);

    // If the audio sample has not loaded yet, bail out
    if (typeof this._instrumentPlayerArrays[inst] === 'undefined') return;
    if (typeof this._instrumentPlayerArrays[inst][sampleIndex] === 'undefined') return;

    // Fetch the sound player to play the note.
    const engine = util.runtime.audioEngine;
    if (!this._instrumentPlayerNoteArrays[inst][note]) {
      this._instrumentPlayerNoteArrays[inst][note] = this._instrumentPlayerArrays[inst][sampleIndex].take();
    }
    const player = this._instrumentPlayerNoteArrays[inst][note];
    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    }

    // Set its pitch.
    const sampleNote = sampleArray[sampleIndex];
    const notePitchInterval = this._ratioForPitchInterval(note - sampleNote);

    // Create gain nodes for this note's volume and release, and chain them
    // to the output.
    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    const releaseGain = context.createGain();
    volumeGain.connect(releaseGain);
    releaseGain.connect(engine.getInputNode());

    // Schedule the release of the note, ramping its gain down to zero,
    // and then stopping the sound.
    let releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;
    if (typeof releaseDuration === 'undefined') {
      releaseDuration = 0.01;
    }
    const releaseStart = context.currentTime + durationSec;
    const releaseEnd = releaseStart + releaseDuration;
    releaseGain.gain.setValueAtTime(1, releaseStart);
    releaseGain.gain.linearRampToValueAtTime(0.0001, releaseEnd);
    this._concurrencyCounter++;
    player.once('stop', () => {
      this._concurrencyCounter--;
    });

    // Start playing the note
    player.play();
    // Connect the player to the gain node.
    player.connect({
      getInputNode() {
        return volumeGain;
      }
    });
    // Set playback now after play creates the outputNode.
    player.outputNode.playbackRate.value = notePitchInterval;
    // Schedule playback to stop.
    player.outputNode.stop(releaseEnd);
  }

  /**
   * The samples array for each instrument is the set of pitches of the available audio samples.
   * This function selects the best one to use to play a given input note, and returns its index
   * in the samples array.
   * @param  {number} note - the input note to select a sample for.
   * @param  {number[]} samples - an array of the pitches of the available samples.
   * @return {index} the index of the selected sample in the samples array.
   * @private
   */
  _selectSampleIndexForNote(note, samples) {
    // Step backwards through the array of samples, i.e. in descending pitch, in order to find
    // the sample that is the closest one below (or matching) the pitch of the input note.
    for (let i = samples.length - 1; i >= 0; i--) {
      if (note >= samples[i]) {
        return i;
      }
    }
    return 0;
  }

  /**
   * Calcuate the frequency ratio for a given musical interval.
   * @param  {number} interval - the pitch interval to convert.
   * @return {number} a ratio corresponding to the input interval.
   * @private
   */
  _ratioForPitchInterval(interval) {
    return Math.pow(2, interval / 12);
  }

  /**
   * Clamp a duration in beats to the allowed min and max duration.
   * @param  {number} beats - a duration in beats.
   * @return {number} - the clamped duration.
   * @private
   */
  _clampBeats(beats) {
    return MathUtil.clamp(beats, Scratch3MusicBlocks.BEAT_RANGE.min, Scratch3MusicBlocks.BEAT_RANGE.max);
  }

  /**
   * Convert a number of beats to a number of seconds, using the current tempo.
   * @param  {number} beats - number of beats to convert to secs.
   * @return {number} seconds - number of seconds `beats` will last.
   * @private
   */
  _beatsToSec(beats) {
    return 60 / this.getTempo() * beats;
  }

  /**
   * Check if the stack timer needs initialization.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - true if the stack timer needs to be initialized.
   * @private
   */
  _stackTimerNeedsInit(util) {
    return !util.stackFrame.timer;
  }

  /**
   * Start the stack timer and the yield the thread if necessary.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} duration - a duration in seconds to set the timer for.
   * @private
   */
  _startStackTimer(util, duration) {
    util.stackFrame.timer = new Timer();
    util.stackFrame.timer.start();
    util.stackFrame.duration = duration;
    util.yield();
  }

  /**
   * Check the stack timer, and if its time is not up yet, yield the thread.
   * @param {object} util - utility object provided by the runtime.
   * @private
   */
  _checkStackTimer(util) {
    const timeElapsed = util.stackFrame.timer.timeElapsed();
    if (timeElapsed < util.stackFrame.duration * 1000) {
      util.yield();
    }
  }

  /**
   * Select an instrument for playing notes.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the number of the instrument to select.
   */
  setInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, false);
  }

  /**
   * Select an instrument for playing notes according to a mapping of MIDI codes to Scratch instrument numbers.
   * This block is implemented for compatibility with old Scratch projects that use the 'midiInstrument:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the MIDI number of the instrument to select.
   */
  midiSetInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, true);
  }

  /**
   * Internal code to select an instrument for playing notes. If mapMidi is true, set the instrument according to
   * the MIDI to Scratch instrument mapping.
   * @param {number} instNum - the instrument number.
   * @param {object} util - utility object provided by the runtime.
   * @param {boolean} mapMidi - whether or not instNum is a MIDI instrument number.
   */
  _setInstrument(instNum, util, mapMidi) {
    const musicState = this._getMusicState(util.target);
    instNum = Cast.toNumber(instNum);
    instNum = Math.round(instNum);
    instNum -= 1; // instruments are one-indexed
    if (mapMidi) {
      instNum = (this.MIDI_INSTRUMENTS[instNum] || 0) - 1;
    }
    instNum = MathUtil.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);
    musicState.currentInstrument = instNum;
  }

  /**
   * Set the current tempo to a new value.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the tempo, in beats per minute.
   */
  setTempo(args) {
    const tempo = Cast.toNumber(args.TEMPO);
    this._updateTempo(tempo);
  }

  /**
   * Change the current tempo by some amount.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the amount to change the tempo, in beats per minute.
   */
  changeTempo(args) {
    const change = Cast.toNumber(args.TEMPO);
    const tempo = change + this.getTempo();
    this._updateTempo(tempo);
  }

  /**
   * Update the current tempo, clamping it to the min and max allowable range.
   * @param {number} tempo - the tempo to set, in beats per minute.
   * @private
   */
  _updateTempo(tempo) {
    tempo = MathUtil.clamp(tempo, Scratch3MusicBlocks.TEMPO_RANGE.min, Scratch3MusicBlocks.TEMPO_RANGE.max);
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      stage.tempo = tempo;
    }
  }

  /**
   * Get the current tempo.
   * @return {number} - the current tempo, in beats per minute.
   */
  getTempo() {
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      return stage.tempo;
    }
    return 60;
  }
}
module.exports = Scratch3MusicBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_music/manifest.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_music/manifest.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  'drums/1-snare.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/1-snare.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/1-snare.mp3"),
  'drums/2-bass-drum.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/2-bass-drum.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3"),
  'drums/3-side-stick.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/3-side-stick.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3"),
  'drums/4-crash-cymbal.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/4-crash-cymbal.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3"),
  'drums/5-open-hi-hat.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/5-open-hi-hat.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3"),
  'drums/6-closed-hi-hat.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/6-closed-hi-hat.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3"),
  'drums/7-tambourine.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/7-tambourine.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3"),
  'drums/8-hand-clap.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/8-hand-clap.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3"),
  'drums/9-claves.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/9-claves.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/9-claves.mp3"),
  'drums/10-wood-block.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/10-wood-block.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3"),
  'drums/11-cowbell.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/11-cowbell.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3"),
  'drums/12-triangle.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/12-triangle.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/12-triangle.mp3"),
  'drums/13-bongo.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/13-bongo.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/13-bongo.mp3"),
  'drums/14-conga.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/14-conga.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/14-conga.mp3"),
  'drums/15-cabasa.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/15-cabasa.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3"),
  'drums/16-guiro.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/16-guiro.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/16-guiro.mp3"),
  'drums/17-vibraslap.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/17-vibraslap.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3"),
  'drums/18-cuica.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/drums/18-cuica.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/18-cuica.mp3"),
  'instruments/1-piano/24.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/24.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3"),
  'instruments/1-piano/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3"),
  'instruments/1-piano/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3"),
  'instruments/1-piano/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3"),
  'instruments/1-piano/72.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/72.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3"),
  'instruments/1-piano/84.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/84.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3"),
  'instruments/1-piano/96.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/96.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3"),
  'instruments/1-piano/108.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/1-piano/108.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3"),
  'instruments/2-electric-piano/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/2-electric-piano/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3"),
  'instruments/3-organ/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/3-organ/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3"),
  'instruments/4-guitar/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/4-guitar/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3"),
  'instruments/5-electric-guitar/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/5-electric-guitar/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3"),
  'instruments/6-bass/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/6-bass/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3"),
  'instruments/6-bass/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/6-bass/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3"),
  'instruments/7-pizzicato/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/7-pizzicato/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3"),
  'instruments/8-cello/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/8-cello/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3"),
  'instruments/8-cello/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/8-cello/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3"),
  'instruments/8-cello/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/8-cello/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3"),
  'instruments/9-trombone/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/9-trombone/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3"),
  'instruments/9-trombone/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/9-trombone/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3"),
  'instruments/9-trombone/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/9-trombone/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3"),
  'instruments/10-clarinet/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/10-clarinet/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3"),
  'instruments/10-clarinet/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/10-clarinet/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3"),
  'instruments/11-saxophone/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/11-saxophone/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3"),
  'instruments/11-saxophone/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/11-saxophone/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3"),
  'instruments/11-saxophone/84.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/11-saxophone/84.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3"),
  'instruments/12-flute/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/12-flute/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3"),
  'instruments/12-flute/72.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/12-flute/72.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3"),
  'instruments/13-wooden-flute/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/13-wooden-flute/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3"),
  'instruments/13-wooden-flute/72.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/13-wooden-flute/72.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3"),
  'instruments/14-bassoon/36.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/14-bassoon/36.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3"),
  'instruments/14-bassoon/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/14-bassoon/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3"),
  'instruments/14-bassoon/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/14-bassoon/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3"),
  'instruments/15-choir/48.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/15-choir/48.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3"),
  'instruments/15-choir/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/15-choir/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3"),
  'instruments/15-choir/72.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/15-choir/72.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3"),
  'instruments/16-vibraphone/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/16-vibraphone/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3"),
  'instruments/16-vibraphone/72.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/16-vibraphone/72.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3"),
  'instruments/17-music-box/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/17-music-box/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3"),
  'instruments/18-steel-drum/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/18-steel-drum/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3"),
  'instruments/19-marimba/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/19-marimba/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3"),
  'instruments/20-synth-lead/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/20-synth-lead/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3"),
  'instruments/21-synth-pad/60.mp3': __webpack_require__(/*! !arraybuffer-loader!./assets/instruments/21-synth-pad/60.mp3 */ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3")
};

/***/ }),

/***/ "./src/extensions/scratch3_pen/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_pen/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const TargetType = __webpack_require__(/*! ../../extension-support/target-type */ "./src/extension-support/target-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");
const Color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const RenderedTarget = __webpack_require__(/*! ../../sprites/rendered-target */ "./src/sprites/rendered-target.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
const StageLayering = __webpack_require__(/*! ../../engine/stage-layering */ "./src/engine/stage-layering.js");

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==';

/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */
const ColorParam = {
  COLOR: 'color',
  SATURATION: 'saturation',
  BRIGHTNESS: 'brightness',
  TRANSPARENCY: 'transparency'
};

/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */
class Scratch3PenBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * The ID of the renderer Drawable corresponding to the pen layer.
     * @type {int}
     * @private
     */
    this._penDrawableId = -1;

    /**
     * The ID of the renderer Skin corresponding to the pen layer.
     * @type {int}
     * @private
     */
    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on('targetWasCreated', this._onTargetCreated);
    runtime.on('RUNTIME_DISPOSED', this.clear.bind(this));
  }

  /**
   * The default pen state, to be used when a target has no existing pen state.
   * @type {PenState}
   */
  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // Used only for legacy `change shade by` blocks
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }

  /**
   * The minimum and maximum allowed pen size.
   * The maximum is twice the diagonal of the stage, so that even an
   * off-stage sprite can fill it.
   * @type {{min: number, max: number}}
   */
  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1200
    };
  }

  /**
   * The key to load & store a target's pen-related state.
   * @type {string}
   */
  static get STATE_KEY() {
    return 'Scratch.pen';
  }

  /**
   * Clamp a pen size value to the range allowed by the pen.
   * @param {number} requestedSize - the requested pen size.
   * @returns {number} the clamped size.
   * @private
   */
  _clampPenSize(requestedSize) {
    return MathUtil.clamp(requestedSize, Scratch3PenBlocks.PEN_SIZE_RANGE.min, Scratch3PenBlocks.PEN_SIZE_RANGE.max);
  }

  /**
   * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
   * the pen Skin doesn't yet exist, create it.
   * @returns {int} the Skin ID of the pen layer, or -1 on failure.
   * @private
   */
  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableSkinId(this._penDrawableId, this._penSkinId);
    }
    return this._penSkinId;
  }

  /**
   * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
   * @private
   */
  _getPenState(target) {
    let penState = target.getCustomState(Scratch3PenBlocks.STATE_KEY);
    if (!penState) {
      penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);
      target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);
    }
    return penState;
  }

  /**
   * When a pen-using Target is cloned, clone the pen state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */
  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);
      if (penState) {
        newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));
        if (penState.penDown) {
          newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
      }
    }
  }

  /**
   * Handle a target which has moved. This only fires when the pen is down.
   * @param {RenderedTarget} target - the target which has moved.
   * @param {number} oldX - the previous X position.
   * @param {number} oldY - the previous Y position.
   * @param {boolean} isForce - whether the movement was forced.
   * @private
   */
  _onTargetMoved(target, oldX, oldY, isForce) {
    // Only move the pen if the movement isn't forced (ie. dragged).
    if (!isForce) {
      const penSkinId = this._getPenLayerID();
      if (penSkinId >= 0) {
        const penState = this._getPenState(target);
        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }

  /**
   * Wrap a color input into the range (0,100).
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */
  _wrapColor(value) {
    return MathUtil.wrapClamp(value, 0, 100);
  }

  /**
   * Initialize color parameters menu with localized strings
   * @returns {array} of the localized text and values for each menu element
   * @private
   */
  _initColorParam() {
    return [{
      text: formatMessage({
        id: 'pen.colorMenu.color',
        default: 'color',
        description: 'label for color element in color picker for pen extension'
      }),
      value: ColorParam.COLOR
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.saturation',
        default: 'saturation',
        description: 'label for saturation element in color picker for pen extension'
      }),
      value: ColorParam.SATURATION
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.brightness',
        default: 'brightness',
        description: 'label for brightness element in color picker for pen extension'
      }),
      value: ColorParam.BRIGHTNESS
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.transparency',
        default: 'transparency',
        description: 'label for transparency element in color picker for pen extension'
      }),
      value: ColorParam.TRANSPARENCY
    }];
  }

  /**
   * Clamp a pen color parameter to the range (0,100).
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */
  _clampColorParam(value) {
    return MathUtil.clamp(value, 0, 100);
  }

  /**
   * Convert an alpha value to a pen transparency value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} alpha - the input alpha value.
   * @returns {number} the transparency value.
   * @private
   */
  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }

  /**
   * Convert a pen transparency value to an alpha value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} transparency - the input transparency value.
   * @returns {number} the alpha value.
   * @private
   */
  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: 'pen',
      name: formatMessage({
        id: 'pen.categoryName',
        default: 'Pen',
        description: 'Label for the pen extension category'
      }),
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'clear',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.clear',
          default: 'erase all',
          description: 'erase all pen trails and stamps'
        })
      }, {
        opcode: 'stamp',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.stamp',
          default: 'stamp',
          description: 'render current costume on the background'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'penDown',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.penDown',
          default: 'pen down',
          description: 'start leaving a trail when the sprite moves'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'penUp',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.penUp',
          default: 'pen up',
          description: 'stop leaving a trail behind the sprite'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenColorToColor',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setColor',
          default: 'set pen color to [COLOR]',
          description: 'set the pen color to a particular (RGB) value'
        }),
        arguments: {
          COLOR: {
            type: ArgumentType.COLOR
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'changePenColorParamBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeColorParam',
          default: 'change pen [COLOR_PARAM] by [VALUE]',
          description: 'change the state of a pen color parameter'
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: 'colorParam',
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenColorParamTo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setColorParam',
          default: 'set pen [COLOR_PARAM] to [VALUE]',
          description: 'set the state for a pen color parameter e.g. saturation'
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: 'colorParam',
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'changePenSizeBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeSize',
          default: 'change pen size by [SIZE]',
          description: 'change the diameter of the trail left by a sprite'
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenSizeTo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setSize',
          default: 'set pen size to [SIZE]',
          description: 'set the diameter of a trail left by a sprite'
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      }, /* Legacy blocks, should not be shown in flyout */
      {
        opcode: 'setPenShadeToNumber',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setShade',
          default: 'set pen shade to [SHADE]',
          description: 'legacy pen blocks - set pen shade'
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'changePenShadeBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeShade',
          default: 'change pen shade by [SHADE]',
          description: 'legacy pen blocks - change pen shade'
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'setPenHueToNumber',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setHue',
          default: 'set pen color to [HUE]',
          description: 'legacy pen blocks - set pen color to number'
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'changePenHueBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeHue',
          default: 'change pen color by [HUE]',
          description: 'legacy pen blocks - change pen color'
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }],
      menus: {
        colorParam: {
          acceptReporters: true,
          items: this._initColorParam()
        }
      }
    };
  }

  /**
   * The pen "clear" block clears the pen layer's contents.
   */
  clear() {
    const penSkinId = this._getPenLayerID();
    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }

  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */
  stamp(args, util) {
    const penSkinId = this._getPenLayerID();
    if (penSkinId >= 0) {
      const target = util.target;
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }

  /**
   * The pen "pen down" block causes the target to leave pen trails on future motion.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */
  penDown(args, util) {
    const target = util.target;
    const penState = this._getPenState(target);
    if (!penState.penDown) {
      penState.penDown = true;
      target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
    const penSkinId = this._getPenLayerID();
    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }

  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */
  penUp(args, util) {
    const target = util.target;
    const penState = this._getPenState(target);
    if (penState.penDown) {
      penState.penDown = false;
      target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
  }

  /**
   * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
   * The transparency is reset to 0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
   * @param {object} util - utility object provided by the runtime.
   */
  setPenColorToColor(args, util) {
    const penState = this._getPenState(util.target);
    const rgb = Cast.toRgbColorObject(args.COLOR);
    const hsv = Color.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;
    if (Object.prototype.hasOwnProperty.call(rgb, 'a')) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    }

    // Set the legacy "shade" value the same way scratch 2 did.
    penState._shade = penState.brightness / 2;
    this._updatePenColor(penState);
  }

  /**
   * Update the cached color from the color, saturation, brightness and transparency values
   * in the provided PenState object.
   * @param {PenState} penState - the pen state to update.
   * @private
   */
  _updatePenColor(penState) {
    const rgb = Color.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }

  /**
   * Set or change a single color parameter on the pen state, and update the pen color.
   * @param {ColorParam} param - the name of the color parameter to set or change.
   * @param {number} value - the value to set or change the param by.
   * @param {PenState} penState - the pen state to update.
   * @param {boolean} change - if true change param by value, if false set param to value.
   * @private
   */
  _setOrChangeColorParam(param, value, penState, change) {
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;
      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;
      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;
      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;
      default:
        log.warn("Tried to set or change unknown color parameter: ".concat(param));
    }
    this._updatePenColor(penState);
  }

  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */
  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);
    this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);
  }

  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */
  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);
    this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);
  }

  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */
  changePenSizeBy(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;
    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Cast.toNumber(args.SIZE));
  }

  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */
  setPenSizeTo(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;
    penAttributes.diameter = this._clampPenSize(Cast.toNumber(args.SIZE));
  }

  /* LEGACY OPCODES */
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */
  setPenHueToNumber(args, util) {
    const penState = this._getPenState(util.target);
    const hueValue = Cast.toNumber(args.HUE);
    const colorValue = hueValue / 2;
    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);
    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);
    this._legacyUpdatePenColor(penState);
  }

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */
  changePenHueBy(args, util) {
    const penState = this._getPenState(util.target);
    const hueChange = Cast.toNumber(args.HUE);
    const colorChange = hueChange / 2;
    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);
    this._legacyUpdatePenColor(penState);
  }

  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */
  setPenShadeToNumber(args, util) {
    const penState = this._getPenState(util.target);
    let newShade = Cast.toNumber(args.SHADE);

    // Wrap clamp the new shade value the way scratch 2 did.
    newShade = newShade % 200;
    if (newShade < 0) newShade += 200;

    // And store the shade that was used to compute this new color for later use.
    penState._shade = newShade;
    this._legacyUpdatePenColor(penState);
  }

  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */
  changePenShadeBy(args, util) {
    const penState = this._getPenState(util.target);
    const shadeChange = Cast.toNumber(args.SHADE);
    this.setPenShadeToNumber({
      SHADE: penState._shade + shadeChange
    }, util);
  }

  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */
  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Color.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;
    if (shade < 50) {
      rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);
    }

    // Update the pen state according to new color
    const hsv = Color.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;
    this._updatePenColor(penState);
  }
}
module.exports = Scratch3PenBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_text2speech/index.js":
/*!******************************************************!*\
  !*** ./src/extensions/scratch3_text2speech/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");
const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
const {
  fetchWithTimeout
} = __webpack_require__(/*! ../../util/fetch-with-timeout */ "./src/util/fetch-with-timeout.js");

/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLU1lbnU8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9UZXh0LXRvLVNwZWVjaC1NZW51IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuMDAwMDAwLCAyLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc1LDguODM0NjcxNzMgQzUuNzUsOC4zMjY5NjM0NCA1LjAwMzAwNzI3LDguMDQyMjEzNzEgNC41NTYyODAxMiw4LjQ0NDE0OTk5IEwzLjIwNjI4MDEyLDkuNTI1MzU3MDIgQzIuNjk2NzMzNzgsOS45MzM0NDk2OCAyLjAzNzQ4Njc1LDEwLjE2NTg3ODggMS4zNSwxMC4xNjU4Nzg4IEwxLjE1LDEwLjE2NTg3ODggQzAuNjMyNTk2MTY1LDEwLjE2NTg3ODggMC4yNSwxMC41MTA2MDAyIDAuMjUsMTAuOTUyMDM1NSBMMC4yNSwxMy4wNjkzOTkzIEMwLjI1LDEzLjUxMDgzNDYgMC42MzI1OTYxNjUsMTMuODU1NTU2IDEuMTUsMTMuODU1NTU2IEwxLjM1LDEzLjg1NTU1NiBDMi4wNzg3Nzg0MSwxMy44NTU1NTYgMi43MjY4NjE2MSwxNC4wNjY3NjM2IDMuMjU5ODYwNDksMTQuNDk5IEw0LjU1OTIwMTQ3LDE1LjU3OTY2MDggQzUuMDEzMDkyNzYsMTUuOTU0NTM5NiA1Ljc1LDE1LjY3MzYzNDQgNS43NSwxNS4xNDE3MTI4IEw1Ljc1LDguODM0NjcxNzMgWiIgaWQ9InNwZWFrZXIiIHN0cm9rZS1vcGFjaXR5PSIwLjE1IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBmaWxsPSIjNEQ0RDREIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMC43MDQ4MzEzLDggQzkuNzkwNjc0NjgsOS4xMzExNDg0NyA4LjMwNjYxODQsOS43MTQyODU3MSA3LjgzMzMzMzMzLDkuNzE0Mjg1NzEgQzcuODMzMzMzMzMsOS43MTQyODU3MSA3LjUsOS43MTQyODU3MSA3LjUsOS4zODA5NTIzOCBDNy41LDkuMDg1MjI2ODQgOC4wNjIyMDE2OCw4LjkwMTk0MTY0IDguMTg5MDYwNjcsNy41Njc1NDA1OCBDNi44ODk5Njk5MSw2LjkwNjc5MDA1IDYsNS41NTczMjY4MyA2LDQgQzYsMS43OTA4NjEgNy43OTA4NjEsNC4wNTgxMjI1MWUtMTYgMTAsMCBMMTIsMCBDMTQuMjA5MTM5LC00LjA1ODEyMjUxZS0xNiAxNiwxLjc5MDg2MSAxNiw0IEMxNiw2LjIwOTEzOSAxNC4yMDkxMzksOCAxMiw4IEwxMC43MDQ4MzEzLDggWiIgaWQ9InNwZWVjaCIgZmlsbD0iIzBFQkQ4QyI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLUJsb2NrPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkV4dGVuc2lvbnMvU29mdHdhcmUvVGV4dC10by1TcGVlY2gtQmxvY2siIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1vcGFjaXR5PSIwLjE1Ij4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQuMDAwMDAwLCA0LjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjUsMTcuNjY5MzQzNSBDMTEuNSwxNi42NTM5MjY5IDEwLjAwNjAxNDUsMTYuMDg0NDI3NCA5LjExMjU2MDI0LDE2Ljg4ODMgTDYuNDEyNTYwMjQsMTkuMDUwNzE0IEM1LjM5MzQ2NzU1LDE5Ljg2Njg5OTQgNC4wNzQ5NzM1MSwyMC4zMzE3NTc1IDIuNywyMC4zMzE3NTc1IEwyLjMsMjAuMzMxNzU3NSBDMS4yNjUxOTIzMywyMC4zMzE3NTc1IDAuNSwyMS4wMjEyMDAzIDAuNSwyMS45MDQwNzEgTDAuNSwyNi4xMzg3OTg2IEMwLjUsMjcuMDIxNjY5MyAxLjI2NTE5MjMzLDI3LjcxMTExMiAyLjMsMjcuNzExMTEyIEwyLjcsMjcuNzExMTEyIEM0LjE1NzU1NjgyLDI3LjcxMTExMiA1LjQ1MzcyMzIyLDI4LjEzMzUyNzEgNi41MTk3MjA5OCwyOC45OTggTDkuMTE4NDAyOTMsMzEuMTU5MzIxNiBDMTAuMDI2MTg1NSwzMS45MDkwNzkzIDExLjUsMzEuMzQ3MjY4OSAxMS41LDMwLjI4MzQyNTUgTDExLjUsMTcuNjY5MzQzNSBaIiBpZD0ic3BlYWtlciIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMjEuNjQzNjA2NiwxNi41IEMxOS45NzcwMDk5LDE4LjQzNzAyMzQgMTcuMTA1MDI3NSwxOS45Mjg1NzE0IDE1LjY2NjY2NjcsMTkuOTI4NTcxNCBDMTUuNTEyNjM5NywxOS45Mjg1NzE0IDE1LjMxNjYyOTIsMTkuODk1OTAzIDE1LjEwOTcyNjUsMTkuNzkyNDUxNyBDMTQuNzM3NjAzOSwxOS42MDYzOTA0IDE0LjUsMTkuMjQ5OTg0NiAxNC41LDE4Ljc2MTkwNDggQzE0LjUsMTguNjU2ODA0MSAxNC41MTcwNTU1LDE4LjU1NDUwNzYgMTQuNTQ5NDQ2NywxOC40NTQwODQ0IEMxNC42MjU3NTQ1LDE4LjIxNzUwNjMgMTUuMTczNTcyMSwxNy40Njc1MzEgMTUuMjc3MjA3MSwxNy4yODA5ODgxIEMxNS41NDYzNTI2LDE2Ljc5NjUyNjEgMTUuNzM5MDI1LDE2LjIwNjM1NjEgMTUuODQzMjg5MSwxNS40MTYwMDM0IEMxMy4xODk3MDA1LDEzLjkyNjgzNjkgMTEuNSwxMS4xMTM5NjY4IDExLjUsOCBDMTEuNSwzLjMwNTU3OTYzIDE1LjMwNTU3OTYsLTAuNSAyMCwtMC41IEwyNCwtMC41IEMyOC42OTQ0MjA0LC0wLjUgMzIuNSwzLjMwNTU3OTYzIDMyLjUsOCBDMzIuNSwxMi42OTQ0MjA0IDI4LjY5NDQyMDQsMTYuNSAyNCwxNi41IEwyMS42NDM2MDY2LDE2LjUgWiIgaWQ9InNwZWVjaCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';

/**
 * The url of the synthesis server.
 * @type {string}
 */
const SERVER_HOST = 'https://synthesis-service.scratch.mit.edu';

/**
 * How long to wait in ms before timing out requests to synthesis server.
 * @type {int}
 */
const SERVER_TIMEOUT = 10000; // 10 seconds

/**
 * Volume for playback of speech sounds, as a percentage.
 * @type {number}
 */
const SPEECH_VOLUME = 250;

/**
 * An id for one of the voices.
 */
const ALTO_ID = 'ALTO';

/**
 * An id for one of the voices.
 */
const TENOR_ID = 'TENOR';

/**
 * An id for one of the voices.
 */
const SQUEAK_ID = 'SQUEAK';

/**
 * An id for one of the voices.
 */
const GIANT_ID = 'GIANT';

/**
 * An id for one of the voices.
 */
const KITTEN_ID = 'KITTEN';

/**
 * Playback rate for the tenor voice, for cases where we have only a female gender voice.
 */
const FEMALE_TENOR_RATE = 0.89; // -2 semitones

/**
 * Playback rate for the giant voice, for cases where we have only a female gender voice.
 */
const FEMALE_GIANT_RATE = 0.79; // -4 semitones

/**
 * Language ids. The value for each language id is a valid Scratch locale.
 */
const ARABIC_ID = 'ar';
const CHINESE_ID = 'zh-cn';
const DANISH_ID = 'da';
const DUTCH_ID = 'nl';
const ENGLISH_ID = 'en';
const FRENCH_ID = 'fr';
const GERMAN_ID = 'de';
const HINDI_ID = 'hi';
const ICELANDIC_ID = 'is';
const ITALIAN_ID = 'it';
const JAPANESE_ID = 'ja';
const KOREAN_ID = 'ko';
const NORWEGIAN_ID = 'nb';
const POLISH_ID = 'pl';
const PORTUGUESE_BR_ID = 'pt-br';
const PORTUGUESE_ID = 'pt';
const ROMANIAN_ID = 'ro';
const RUSSIAN_ID = 'ru';
const SPANISH_ID = 'es';
const SPANISH_419_ID = 'es-419';
const SWEDISH_ID = 'sv';
const TURKISH_ID = 'tr';
const WELSH_ID = 'cy';

/**
 * Class for the text2speech blocks.
 * @constructor
 */
class Scratch3Text2SpeechBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * Map of soundPlayers by sound id.
     * @type {Map<string, SoundPlayer>}
     */
    this._soundPlayers = new Map();
    this._stopAllSpeech = this._stopAllSpeech.bind(this);
    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this._stopAllSpeech);
    }
    this._onTargetCreated = this._onTargetCreated.bind(this);
    if (this.runtime) {
      runtime.on('targetWasCreated', this._onTargetCreated);
    }

    /**
     * A list of all Scratch locales that are supported by the extension.
     * @type {Array}
     */
    this._supportedLocales = this._getSupportedLocales();
  }

  /**
   * An object with info for each voice.
   */
  get VOICE_INFO() {
    return {
      [ALTO_ID]: {
        name: formatMessage({
          id: 'text2speech.alto',
          default: 'alto',
          description: 'Name for a voice with ambiguous gender.'
        }),
        gender: 'female',
        playbackRate: 1
      },
      [TENOR_ID]: {
        name: formatMessage({
          id: 'text2speech.tenor',
          default: 'tenor',
          description: 'Name for a voice with ambiguous gender.'
        }),
        gender: 'male',
        playbackRate: 1
      },
      [SQUEAK_ID]: {
        name: formatMessage({
          id: 'text2speech.squeak',
          default: 'squeak',
          description: 'Name for a funny voice with a high pitch.'
        }),
        gender: 'female',
        playbackRate: 1.19 // +3 semitones
      },
      [GIANT_ID]: {
        name: formatMessage({
          id: 'text2speech.giant',
          default: 'giant',
          description: 'Name for a funny voice with a low pitch.'
        }),
        gender: 'male',
        playbackRate: 0.84 // -3 semitones
      },
      [KITTEN_ID]: {
        name: formatMessage({
          id: 'text2speech.kitten',
          default: 'kitten',
          description: 'A baby cat.'
        }),
        gender: 'female',
        playbackRate: 1.41 // +6 semitones
      }
    };
  }

  /**
   * An object with information for each language.
   *
   * A note on the different sets of locales referred to in this extension:
   *
   * SCRATCH LOCALE
   *      Set by the editor, and used to store the language state in the project.
   *      Listed in l10n: https://github.com/scratchfoundation/scratch-l10n/blob/master/src/supported-locales.js
   * SUPPORTED LOCALE
   *      A Scratch locale that has a corresponding extension locale.
   * EXTENSION LOCALE
   *      A locale corresponding to one of the available spoken languages
   *      in the extension. There can be multiple supported locales for a single
   *      extension locale. For example, for both written versions of chinese,
   *      zh-cn and zh-tw, we use a single spoken language (Mandarin). So there
   *      are two supported locales, with a single extension locale.
   * SPEECH SYNTH LOCALE
   *      A different locale code system, used by our speech synthesis service.
   *      Each extension locale has a speech synth locale.
   */
  get LANGUAGE_INFO() {
    return {
      [ARABIC_ID]: {
        name: 'Arabic',
        locales: ['ar'],
        speechSynthLocale: 'arb',
        singleGender: true
      },
      [CHINESE_ID]: {
        name: 'Chinese (Mandarin)',
        locales: ['zh-cn', 'zh-tw'],
        speechSynthLocale: 'cmn-CN',
        singleGender: true
      },
      [DANISH_ID]: {
        name: 'Danish',
        locales: ['da'],
        speechSynthLocale: 'da-DK'
      },
      [DUTCH_ID]: {
        name: 'Dutch',
        locales: ['nl'],
        speechSynthLocale: 'nl-NL'
      },
      [ENGLISH_ID]: {
        name: 'English',
        locales: ['en'],
        speechSynthLocale: 'en-US'
      },
      [FRENCH_ID]: {
        name: 'French',
        locales: ['fr'],
        speechSynthLocale: 'fr-FR'
      },
      [GERMAN_ID]: {
        name: 'German',
        locales: ['de'],
        speechSynthLocale: 'de-DE'
      },
      [HINDI_ID]: {
        name: 'Hindi',
        locales: ['hi'],
        speechSynthLocale: 'hi-IN',
        singleGender: true
      },
      [ICELANDIC_ID]: {
        name: 'Icelandic',
        locales: ['is'],
        speechSynthLocale: 'is-IS'
      },
      [ITALIAN_ID]: {
        name: 'Italian',
        locales: ['it'],
        speechSynthLocale: 'it-IT'
      },
      [JAPANESE_ID]: {
        name: 'Japanese',
        locales: ['ja', 'ja-hira'],
        speechSynthLocale: 'ja-JP'
      },
      [KOREAN_ID]: {
        name: 'Korean',
        locales: ['ko'],
        speechSynthLocale: 'ko-KR',
        singleGender: true
      },
      [NORWEGIAN_ID]: {
        name: 'Norwegian',
        locales: ['nb', 'nn'],
        speechSynthLocale: 'nb-NO',
        singleGender: true
      },
      [POLISH_ID]: {
        name: 'Polish',
        locales: ['pl'],
        speechSynthLocale: 'pl-PL'
      },
      [PORTUGUESE_BR_ID]: {
        name: 'Portuguese (Brazilian)',
        locales: ['pt-br'],
        speechSynthLocale: 'pt-BR'
      },
      [PORTUGUESE_ID]: {
        name: 'Portuguese (European)',
        locales: ['pt'],
        speechSynthLocale: 'pt-PT'
      },
      [ROMANIAN_ID]: {
        name: 'Romanian',
        locales: ['ro'],
        speechSynthLocale: 'ro-RO',
        singleGender: true
      },
      [RUSSIAN_ID]: {
        name: 'Russian',
        locales: ['ru'],
        speechSynthLocale: 'ru-RU'
      },
      [SPANISH_ID]: {
        name: 'Spanish (European)',
        locales: ['es'],
        speechSynthLocale: 'es-ES'
      },
      [SPANISH_419_ID]: {
        name: 'Spanish (Latin American)',
        locales: ['es-419'],
        speechSynthLocale: 'es-US'
      },
      [SWEDISH_ID]: {
        name: 'Swedish',
        locales: ['sv'],
        speechSynthLocale: 'sv-SE',
        singleGender: true
      },
      [TURKISH_ID]: {
        name: 'Turkish',
        locales: ['tr'],
        speechSynthLocale: 'tr-TR',
        singleGender: true
      },
      [WELSH_ID]: {
        name: 'Welsh',
        locales: ['cy'],
        speechSynthLocale: 'cy-GB',
        singleGender: true
      }
    };
  }

  /**
   * The key to load & store a target's text2speech state.
   * @return {string} The key.
   */
  static get STATE_KEY() {
    return 'Scratch.text2speech';
  }

  /**
   * The default state, to be used when a target has no existing state.
   * @type {Text2SpeechState}
   */
  static get DEFAULT_TEXT2SPEECH_STATE() {
    return {
      voiceId: ALTO_ID
    };
  }

  /**
   * A default language to use for speech synthesis.
   * @type {string}
   */
  get DEFAULT_LANGUAGE() {
    return ENGLISH_ID;
  }

  /**
   * @param {Target} target - collect  state for this target.
   * @returns {Text2SpeechState} the mutable state associated with that target. This will be created if necessary.
   * @private
   */
  _getState(target) {
    let state = target.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);
    if (!state) {
      state = Clone.simple(Scratch3Text2SpeechBlocks.DEFAULT_TEXT2SPEECH_STATE);
      target.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, state);
    }
    return state;
  }

  /**
   * When a Target is cloned, clone the state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */
  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const state = sourceTarget.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);
      if (state) {
        newTarget.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, Clone.simple(state));
      }
    }
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    // Only localize the default input to the "speak" block if we are in a
    // supported language.
    let defaultTextToSpeak = 'hello';
    if (this.isSupportedLanguage(this.getEditorLanguage())) {
      defaultTextToSpeak = formatMessage({
        id: 'text2speech.defaultTextToSpeak',
        default: 'hello',
        description: 'hello: the default text to speak'
      });
    }
    return {
      id: 'text2speech',
      name: formatMessage({
        id: 'text2speech.categoryName',
        default: 'Text to Speech',
        description: 'Name of the Text to Speech extension.'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: 'speakAndWait',
        text: formatMessage({
          id: 'text2speech.speakAndWaitBlock',
          default: 'speak [WORDS]',
          description: 'Speak some words.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: defaultTextToSpeak
          }
        }
      }, {
        opcode: 'setVoice',
        text: formatMessage({
          id: 'text2speech.setVoiceBlock',
          default: 'set voice to [VOICE]',
          description: 'Set the voice for speech synthesis.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          VOICE: {
            type: ArgumentType.STRING,
            menu: 'voices',
            defaultValue: ALTO_ID
          }
        }
      }, {
        opcode: 'setLanguage',
        text: formatMessage({
          id: 'text2speech.setLanguageBlock',
          default: 'set language to [LANGUAGE]',
          description: 'Set the language for speech synthesis.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: 'languages',
            defaultValue: this.getCurrentLanguage()
          }
        }
      }],
      menus: {
        voices: {
          acceptReporters: true,
          items: this.getVoiceMenu()
        },
        languages: {
          acceptReporters: true,
          items: this.getLanguageMenu()
        }
      }
    };
  }

  /**
   * Get the language code currently set in the editor, or fall back to the
   * browser locale.
   * @return {string} a Scratch locale code.
   */
  getEditorLanguage() {
    const locale = formatMessage.setup().locale || navigator.language || navigator.userLanguage || this.DEFAULT_LANGUAGE;
    return locale.toLowerCase();
  }

  /**
   * Get the language code currently set for the extension.
   * @returns {string} a Scratch locale code.
   */
  getCurrentLanguage() {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return this.DEFAULT_LANGUAGE;
    // If no language has been set, set it to the editor locale (or default).
    if (!stage.textToSpeechLanguage) {
      this.setCurrentLanguage(this.getEditorLanguage());
    }
    return stage.textToSpeechLanguage;
  }

  /**
   * Set the language code for the extension.
   * It is stored in the stage so it can be saved and loaded with the project.
   * @param {string} locale a locale code.
   */
  setCurrentLanguage(locale) {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return;
    if (this.isSupportedLanguage(locale)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(locale);
    }

    // Support language names dropped onto the menu via reporter block
    // such as a variable containing a language name (in any language),
    // or the translate extension's language reporter.
    const localeForDroppedName = languageNames.nameMap[locale.toLowerCase()];
    if (localeForDroppedName && this.isSupportedLanguage(localeForDroppedName)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(localeForDroppedName);
    }

    // If the language is null, set it to the default language.
    // This can occur e.g. if the extension was loaded with the editor
    // set to a language that is not in the list.
    if (!stage.textToSpeechLanguage) {
      stage.textToSpeechLanguage = this.DEFAULT_LANGUAGE;
    }
  }

  /**
   * Get the extension locale for a supported locale, or null.
   * @param {string} locale a locale code.
   * @returns {?string} a locale supported by the extension.
   */
  _getExtensionLocaleForSupportedLocale(locale) {
    for (const lang in this.LANGUAGE_INFO) {
      if (this.LANGUAGE_INFO[lang].locales.includes(locale)) {
        return lang;
      }
    }
    log.error("cannot find extension locale for locale ".concat(locale));
  }

  /**
   * Get the locale code used by the speech synthesis server corresponding to
   * the current language code set for the extension.
   * @returns {string} a speech synthesis locale.
   */
  _getSpeechSynthLocale() {
    let speechSynthLocale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;
    if (this.LANGUAGE_INFO[this.getCurrentLanguage()]) {
      speechSynthLocale = this.LANGUAGE_INFO[this.getCurrentLanguage()].speechSynthLocale;
    }
    return speechSynthLocale;
  }

  /**
   * Get an array of the locales supported by this extension.
   * @returns {Array} An array of locale strings.
   */
  _getSupportedLocales() {
    return Object.keys(this.LANGUAGE_INFO).reduce((acc, lang) => acc.concat(this.LANGUAGE_INFO[lang].locales), []);
  }

  /**
   * Check if a Scratch language code is in the list of supported languages for the
   * speech synthesis service.
   * @param {string} languageCode the language code to check.
   * @returns {boolean} true if the language code is supported.
   */
  isSupportedLanguage(languageCode) {
    return this._supportedLocales.includes(languageCode);
  }

  /**
   * Get the menu of voices for the "set voice" block.
   * @return {array} the text and value for each menu item.
   */
  getVoiceMenu() {
    return Object.keys(this.VOICE_INFO).map(voiceId => ({
      text: this.VOICE_INFO[voiceId].name,
      value: voiceId
    }));
  }

  /**
   * Get the localized menu of languages for the "set language" block.
   * For each language:
   *   if there is a custom translated spoken language name, use that;
   *   otherwise use the translation in the languageNames menuMap;
   *   otherwise fall back to the untranslated name in LANGUAGE_INFO.
   * @return {array} the text and value for each menu item.
   */
  getLanguageMenu() {
    const editorLanguage = this.getEditorLanguage();
    // Get the array of localized language names
    const localizedNameMap = {};
    let nameArray = languageNames.menuMap[editorLanguage];
    if (nameArray) {
      // Also get any localized names of spoken languages
      let spokenNameArray = [];
      if (languageNames.spokenLanguages) {
        spokenNameArray = languageNames.spokenLanguages[editorLanguage];
        nameArray = nameArray.concat(spokenNameArray);
      }
      // Create a map of language code to localized name
      // The localized spoken language names have been concatenated onto
      // the end of the name array, so the result of the forEach below is
      // when there is both a written language name (e.g. 'Chinese
      // (simplified)') and a spoken language name (e.g. 'Chinese
      // (Mandarin)', we always use the spoken version.
      nameArray.forEach(lang => {
        localizedNameMap[lang.code] = lang.name;
      });
    }
    return Object.keys(this.LANGUAGE_INFO).map(key => {
      let name = this.LANGUAGE_INFO[key].name;
      const localizedName = localizedNameMap[key];
      if (localizedName) {
        name = localizedName;
      }
      // Uppercase the first character of the name
      name = name.charAt(0).toUpperCase() + name.slice(1);
      return {
        text: name,
        value: key
      };
    });
  }

  /**
   * Set the voice for speech synthesis for this sprite.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   */
  setVoice(args, util) {
    const state = this._getState(util.target);
    let voice = args.VOICE;

    // If the arg is a dropped number, treat it as a voice index
    let voiceNum = parseInt(voice, 10);
    if (!isNaN(voiceNum)) {
      voiceNum -= 1; // Treat dropped args as one-indexed
      voiceNum = MathUtil.wrapClamp(voiceNum, 0, Object.keys(this.VOICE_INFO).length - 1);
      voice = Object.keys(this.VOICE_INFO)[voiceNum];
    }

    // Only set the voice if the arg is a valid voice id.
    if (Object.keys(this.VOICE_INFO).includes(voice)) {
      state.voiceId = voice;
    }
  }

  /**
   * Set the language for speech synthesis.
   * @param  {object} args Block arguments
   */
  setLanguage(args) {
    this.setCurrentLanguage(args.LANGUAGE);
  }

  /**
   * Stop all currently playing speech sounds.
   */
  _stopAllSpeech() {
    this._soundPlayers.forEach(player => {
      player.stop();
    });
  }

  /**
   * Convert the provided text into a sound file and then play the file.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   * @return {Promise} A promise that resolves after playing the sound
   */
  speakAndWait(args, util) {
    // Cast input to string
    let words = Cast.toString(args.WORDS);
    let locale = this._getSpeechSynthLocale();
    const state = this._getState(util.target);
    let gender = this.VOICE_INFO[state.voiceId].gender;
    let playbackRate = this.VOICE_INFO[state.voiceId].playbackRate;

    // Special case for voices where the synthesis service only provides a
    // single gender voice. In that case, always request the female voice,
    // and set special playback rates for the tenor and giant voices.
    if (this.LANGUAGE_INFO[this.getCurrentLanguage()].singleGender) {
      gender = 'female';
      if (state.voiceId === TENOR_ID) {
        playbackRate = FEMALE_TENOR_RATE;
      }
      if (state.voiceId === GIANT_ID) {
        playbackRate = FEMALE_GIANT_RATE;
      }
    }
    if (state.voiceId === KITTEN_ID) {
      words = words.replace(/\S+/g, 'meow');
      locale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;
    }

    // Build up URL
    let path = "".concat(SERVER_HOST, "/synth");
    path += "?locale=".concat(locale);
    path += "&gender=".concat(gender);
    path += "&text=".concat(encodeURIComponent(words.substring(0, 128)));

    // Perform HTTP request to get audio file
    return fetchWithTimeout(path, {}, SERVER_TIMEOUT).then(res => {
      if (res.status !== 200) {
        throw new Error("HTTP ".concat(res.status, " error reaching translation service"));
      }
      return res.arrayBuffer();
    }).then(buffer => {
      // Play the sound
      const sound = {
        data: {
          buffer
        }
      };
      return this.runtime.audioEngine.decodeSoundPlayer(sound);
    }).then(soundPlayer => {
      this._soundPlayers.set(soundPlayer.id, soundPlayer);
      soundPlayer.setPlaybackRate(playbackRate);

      // Increase the volume
      const engine = this.runtime.audioEngine;
      const chain = engine.createEffectChain();
      chain.set('volume', SPEECH_VOLUME);
      soundPlayer.connect(chain);
      soundPlayer.play();
      return new Promise(resolve => {
        soundPlayer.on('stop', () => {
          this._soundPlayers.delete(soundPlayer.id);
          resolve();
        });
      });
    }).catch(err => {
      log.warn(err);
    });
  }
}
module.exports = Scratch3Text2SpeechBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_translate/index.js":
/*!****************************************************!*\
  !*** ./src/extensions/scratch3_translate/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
const {
  fetchWithTimeout
} = __webpack_require__(/*! ../../util/fetch-with-timeout */ "./src/util/fetch-with-timeout.js");
const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const menuIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGAklEQVRYhe1YbUxTVxh+rh02o0KtkOEgKA4U4yeRWCdgxDoxCnH6h22iqSz76aasZlnijzkTBlvS4TJ/LGaJsmiyESe4hAVJvMJGxwQhLKECcRWkpWNZERs6Ctb2Lm97C/fe3n6Jyfzhk5y09z3nPPe57znnPe85DMdxeJ6x6LlW90LgM8BLchR1dXUZeXl5b3Ect+ppXsEwzHBfX98PVVVVY0GbmjW2AdgpaFYP4JxTZ+iLyCVdJFeuXNmdn59fn56enrFkyRIsWhSfk30+H1wuF+x2+1hPT4++oqLiJi/wEoA8AJslXSqdOsOlmARWV1dnlpeXd2ZnZ2fEK0xOqMViGWtoaNh++vRpa9CuZo1ZAJokQlc5dYYROR6RCq1WW56WlhZV3H0H8O9sZIHEQVzEKbTzQooBPBCYz4TlET4oFIosGtZoOHUN+Ph61GYgLuIU2tSscSmAYwAeCcx6NWs8o2aNxVKOkEUi9R55qv428Ng7b3viA/6eAs7dmrctVgD6bYBKGZ6LB4mrk7F/whcmokApfh8BWu6G2mc8ADsktuWmAbtzozGiLUJdu9QQVSC98JUkYNgBfPsboH4Z+GhPoK62FZiaAU7sCrTZmB5VHM3BPjVrrARwUVL1B4CD0vYxLVV68YFNQIICcLrn7SROtTjwEbGIE4iksFIpEVfs1BkeSdvGFUsObAz8Gm8CNTcC/49q42EIEbkLwKfhxCGWIRZC/zrQ/ifgcAWMK5YB+zc8nUBeZFuUORmfQIp/PsHGM/04YMta5oPT6cTs7Cw8Ho+oj9vtzmloaCgPZQtApVI96ejo6K2trR3lOM4nrRftJCzLfq3T6Y7LCfvuNtDL7wepfKgkTz6ZdeHdzePYlq30xz2lUintHhH0UbQ12my2+oKCguMcx7mE7aOHmWHgsxvzzzQP3ysMxMfzt2bxKmNHyZblSE5OjktYEImJidBoNFCr1frOzs5khmHe4Thubp8SCVQoFBwNUUJCwpyNwsfyZGBDOvB2fuCZQAH56KYJKJUpTy1OCOJYvXr1ocbGxjIAPwarRKvYZrNdn5iYEHV8LRW4cBj4oHheXBDT09PPRFwQxKXRaIQpmVjgkSNHfrFardcmJydjIqSMRehtOfzjmMTZmm/8hf5HAnF5vV7RVicSyHGcR6vVHh4YGPjKYrFMkTelq5JAH0B1MzMzUT+iu6cfdwfv+wv9jxchgZomaEFBwcmcnJxVY2NjXQqFQlQ/Pj6O/v7+s2az+U2Hw9Ec7X3tHXfm/v/c2hG3wLCruLm5+VBGRoY2mJGQJ0nc4ODgqZKSkjqKWSzL7olEPjJqx4PRv5CaqvE/OxyTflvWitj3xbBbnUql2kRxjYTRcA4MDHR1d3frguJiIW//NeC9/SVF2LplvcgWK8J6sKWl5UuVSrXO4/HYHj58+FNZWVkLx3HT8Rz0u3vN/t8Ho3aRaH3FgYULrKmpodT8jeBzvDcQ3T1m/5D6RXX0zNmn3TP+uq356xcmkE/NTwLoc+oMTXGpA3CnN7Bi99Hw5s8PL4mlulgFys5BXlwbn4I3qlnjsXgFBr22f+8OrFub7S/79u4Q1cWCEA8KxAmPhRfVrBFy51cK1nJnj+/rvwix0eqVswu5pJDzoPTMKhSZJzQolUoLZSLPCsRFnEI6OYE7I7xPdGYoKiq6YLVaByllWiiIg7iIM5rAYBouBB2yq5w6g+iATWGnqampZGhoqItiJSUP4YrcR9CQUh31JQ7iIk5hm7AXmPxdip5/dNIUCnduYBgm8fLly9tzc3NLwzlSqVTuW7NmzVphQkubwL179+xdXV3HKisrTVJxiJKwnuGHVM2XNjVrPCh3h8IT3+SLLKqrq+tKS0uvrly5UksJKvjsJSkpKd3r9TrkxCGSBxHwIoWXc7zAIOiIOOLUGULOsNHAMIzSZDJ9npmZeSIlJcWfTdPQm0ym8zqd7n257hGPnXxYyePv8py8mVb40ji1+UGZUmFh4Yetra1bzGbzteHh4SlKQNxu961wff7XS3Sau/w0c4VLQF7c8i8IAP4DcHKth/4Ur7MAAAAASUVORK5CYII=';

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAN+UlEQVR4Ae1ce2xT1xn/Tkhq4hqHJKRLDAlQGI+GUfFc14HaLmxuGd0ab93GgK6Vmm01y9BUsaU0RfyRFTakaRHq3So6jVapWEUxa9dRuU8x6IAGCoO6wa1KXiSQOE9jkjivO/2u7yWOuff6XvvekFb5SUdx7ON7v/vz9zrnO+cwnudpAokjZYK75DBBYJKYIDBJTBCYJCYITBJfOgIZYzbGWA5jLJ8xNm/z5s334a/4P1omYyzNsPt9WdIYxhiUId/j8azPz89fY7VaF6ampjqi+4TD4Qvd3d0f7t+/fx/HcTVE1M7z/EBS99VDoCikTWzWMdTgYSLqIaIQGs/zwzKyOaqrq1+aOnVqUUZGBqWnp5PFYqG0tDQaHh6mvr4+GhwcpFAoJLSenp4P9+7dW8Zx3Fme5zsTFSxVa0eovtPpnL1ly5YfzJgxw2WxWBYketNEAO25dOmSp7Ky8iBjrFbmoW12u70oOzubMjMzR32QkpJCVqtVeG2322lgYIACgcDK0tLS1+6+++4yxpiH5/krCQkGDYzXiCi3qqrKXVNTE7x48SLf0dHB9/X18WMF3Av3xL0hA2SBTNFyE9E8v9/PX758WbNUuCa+4/F4ymKvp7XF1UDGWK7H43m0sLBwZ05Ozg2/7lgApoiGe3d2dk5ZsWLFcx6Px84Y2xelOcHW1taXiOiRcDgsaJ2gljab0GDKscD1Jk2ahHd3ejwePOtenufb9TySKoEw26qqKhfIy83NFdT/ZiP6oauqqoKMsf2iObeuXr26vKKiwpOVlTXFbrfb8/LyFubk5KyBu1H68aVnGh4e3uZ2u08yxo7pCixKqgrX4XQ6l8JkoOrjDZAJskFGyBolt0UMcGhgJ19yP2rm3dDQwJ85c+akXlNWI9B++PDh38PvjFdANsgIWVUfksheUVHxfZDY3d0t+zT9/f2CP3S73feJWYZFC4FqJmxDtJ06daphRnuiluhrDqJbLcZcD7JBRiJ6Dj5Qrg9jDHfLhlm3tbUdslgsj8i5IvhI+MpNmzaVLlq0yCN+9wMiCvA8H1KSQY1AK3yHFP6ThfcTouePEaVNItrzI6LbpiR/TcgmplOyQmLE4XQ6C3fv3v0y+iEQIbggjZELKiB2+vTpxXl5ecUIRD6fr/nQoUNuxtjbPM/3yN1DLREWPsNNjUBNC9HgMFEKI2q5asglo2VTeo7sioqKP6anpwtBZObMmZSfny9LHokRG5+jn8PhoFtuucVRXFzMQdmVZPiyTyakIblGBqE3/QKZIBLDQafTmavUT/NIRA3XwkSlB4jaFD3FCPqHiJ5+Xb3PNBvRnoeN85UYyiUCmDHg9XoVn8wQDTxRR9RxjQjxLl4DgfH64Fq4pgEY6OjoONTe3q6bRPTH9zBmFsfgsjBEA4vmE/kuE30eiPzfN0B0WYyJGelEWQpx6FJXhNC0FKIcG9Fk0TUVZEWuaQBad+zYUbF79+6FjY2NC+DfpBGKGkBeY2MjBYPBC2VlZU9g1sZUAoFf3zvyGia9/u8RbRrmiSofvrG/1IeEaEn0/E+NkmQEmLVhjPmIaAMisRYSo8nbunXrBq/X6+N5PqzU35QgAt8177bI655+ovPNN/Z50xeJyIyIlswwQ4oI8PAgAWSAFJCjZM56ySMzo/DP7iJKTSEaGibi/jP6M2jfwbNEQzzRpBSin68yS4oItJCYCHlkJoEYcWSKvu9KkOjwxyOf7T9F1DsQ0b6CTGOS6niQIxEJNSVBHhnpA+Xwm28RPfOvSAL9t+NEy2cShcJEr5+P+EcQ+PT9ZkowGiBF8olIsMPhcBFmrnt7e4Voi4Chhzwym0BoYWFexAcODBGVvUbU3RshbxIjWrdobLQvGhKJXq+3xO12z1q3bt2aN9544x2O45A4Neshj8wmENjmJHr8ZaJQ/0iizcRk+fFvmn13eYgk1TLGWjiOwxQWKY1148H0oRwiMohiUYky8Oz3zL5zfIA0qSV6DdM18NWPiF4+FXnNogh84h9EW9cQ3TV7pC+ceVTVTNPooa5OGLLMYkgmE0fcqp8STCPwYhvRn94jauqKBBHJbOED4Q8xAtn1FtH8rxA9WUSUNthJiQy5Zs2aRX6/35usvBqqfrJQrAujmu/3+/3z5s3TJQgCxsEzRP9riuSAUsBYXhCJysCWVyP+EHkgiA0Hr9D9Xw3S/QuJJlvShIlSca4vASr0A5MG0Piuri68vnr69OmyjRs3aip1GqaByPNePRuZCMDwTSIuPY1oy32jTfWFDUQvniB67RzRta4rtDwvSN8tJBrnVT9ZGEIgpupf+C/RgGh90CpMEKwtJFq/XH5aCiOVb0zvpH+fipD3Baj6yUKNQIEOqLcWU4IPx9ANGue6k+iBQvX5PPi6lHD7dc0bD+RJgCxDQ0O0bNmyXU6n8wRjrFsxsKhUshznzp2r0VrSbAny/OcB7eU7VMdQBfuiV/3U8sAQohIcqxZgRHH7NO2/MlIVEitr4xVRVT+bkoiqBCKkIyp1dia8eEkRiHokVtbGK+JV/VQJhM17vd5ahPRAIICZCkMfU8r3xipVSQQaqn7qURjRB0u/ENIRleBYb0aaEQ+Btk4qfXLnqF7bn/oF3bFgjun3jjsWRh7kcrn2VVdXb25pablaW1uLXOl6xWo84LD36A1SHDl6akwk05QHgkTkQwjpsQsstSa/V65cGeUGMIbFMMwIyJFVfdpHj2zopVut6YbcQwmaZ2Ngzl6v9+zatWv/sHjx4u9UVlYKAzMUoOMB5HV1dV09cODAQ/NFOJ1OpxEPAKJ6evtueB/vnTrtM+IWqtA1nYXAwvM81GgAi3CUFi5KQKBobm4WyDt48OCm8vLy93me/xQNSmjEAxw5NqJ91vTJQpNQ/dE4I5AikwxWjuPWZGVlFWM9shLgI+vr6zHDcoHjuAdF8gwN5dd6eulUFEkrlhUKTQI+Q4AxE4lMqOasWrXqafg9uRREquiDvKamppe2bdv2kz179pwwmjyS8X3Lly4SWjSqT38s/2WDkMhkggUBJHbsCuIQndH6+/ubjxw58ju32/0eXKCeCUo9iDbfadMyr2sfzFjyi4ffOkZrnatNoi8xAoX1JjabrRhDnehZZBDn9/v3uFyuV+ItTEwWdQ3NVN9w+fpVViwdMV0QeeTYaeF1W1un0HdWgcNoEQQkYsJd27dvfxa+7dKlS9TQ0NBcV1d36OTJk5sLCwtXuVwujuf5WjPJIxnzvWf18uuvY834TZk80Sjo1kBxdPLp4sWLizBnKr4NewnqLQkmg1gCy575s+LVkOo8UWKOHAlV5cSAgGmadnG/WWCsyZPL/ZSAvmaNTHRroLho2xFdlGaMXRSDxZiQGJvf3bHgdtl+n1y4OOo70WZuFHQRCPKwaHvXrl1/sVqtK7EsYs6cOdsee+yxd8vLy3+Lir/ZJCKvi879Zhbk0fanfinb91dP7hSCCEXlhDnTjJ0M0WzCEnlYZ5eZmbly7ty5woLs2bNnYzxchPfxuaihpiE2r7tnlbJWRUdmMikn1ERgNHl2u33UIkUM5fA/3h8LEpHXRWPFskWKfWNNNva7RkDLZkNF8iTgf7yPFaDoh9VPZpnzvVEaZ7VOVjVJ5H4/fOjbRoswGnG2SIG8pSgu1dXV8UNDQ6pFGHyOfugv7mFT3C5FRHNRVBrLbbN6AdkgI2RNZK+cLvIkyJCYonB9XVW/mwHIBhkhayJVuWxEWyWzVYJkzjabbcGOHTvKUbBT6Kqr6nczANkgo9o2BzVWbEhVMGWllbzrF01JIXwPU16IMwrdTK36JQuxbHEVMiZEoNPpFKaaE62axSPd7KpfMoAskAmyQUa12STFKOz1egODg4PN9fX1Dqxb0TJ1LwG/HuYEg8Hgu5i9Ueo3Hqt+kB3k+Xy+p8QVWqrmoZbGtGOrJ3YrNjc3O6StonhAOTKx4h21D0xvYTYa6+0wOlHb5UMjBat9WMiDtShdXV1TvkjL21TPjcEpQJiB5jhOWM28ZMkSV0FBQTG2gsoBJU/MQp8/f/5tt9v9gZ5F20Yeq4LJXlhNPEjaRjELLEWz1eaYNR57AlWwYTs88iJsj5cDFgxhWz2218fbhq90ToN4zgF+obk4ykRvk7b2azn+JGabf754b9m0S3ceqPCAuTiYAQc0KAGCR53tIgklHQKh6RyCZFr0+QhNTU1x81f0OX78uMe0c2Ni0I7jknDiTzAYxNEiN3SA6VgsFmGV57lz50oDgcA7fr9f2ErQ0dFxlTH2ERE1mVUnwVwlY+z9lpaWB0tKSv4aDocXwOUo+VOkW6FQqJjjOI94gpG+FfsJmFk2TvqB6iudgCGZBzJ5aCsaRif4ztGjR19M9NfWKadl3bp1d+J+uG9bW5uiNra2tkojjpm675OgcLkSiXqGYjBvcWw5z2wC+RGf6uA4bqPP52v67LPPZImMGvPqliuhNdKxqUdvb+8UrJFRW6VAN2Epm+gmmhlj/ySiDzwez4/nz59f2tnZ6ZCOhEJqhvQFlUa1nFUJCS8ylxYcud3umpKSkl2hUGilJFRqaipNnjz5+hEjyLOwoa+7u1tKrk2t2MnIKmygYYzhBI5XqqqqHpgzZ84au93+dRwqgRQGlUaxzqMLSR/AKJ4Gme12uxeuX7/+0YyMjJWxORxGND09PTWNjY3vuFyu/UTUaFYQ0SizRcwOpIU0Q2JVUf8Pa6C/AZGZYuqSL+VkYh6H/3OQS46F7xvLNnGSeZKYOMU3SUwQmCQmCEwSEwQmiQkCkwER/R+aET3lwEIlXgAAAABJRU5ErkJggg==';

/**
 * The url of the translate server.
 * @type {string}
 */
const serverURL = 'https://translate-service.scratch.mit.edu/';

/**
 * How long to wait in ms before timing out requests to translate server.
 * @type {int}
 */
const serverTimeoutMs = 10000; // 10 seconds (chosen arbitrarily).

/**
 * Class for the translate block in Scratch 3.0.
 * @constructor
 */
class Scratch3TranslateBlocks {
  constructor() {
    /**
     * Language code of the viewer, based on their locale.
     * @type {string}
     * @private
     */
    this._viewerLanguageCode = this.getViewerLanguageCode();

    /**
     * List of supported language name and language code pairs, for use in the block menu.
     * Filled in by getInfo so it is updated when the interface language changes.
     * @type {Array.<object.<string, string>>}
     * @private
     */
    this._supportedLanguages = [];

    /**
     * A randomly selected language code, for use as the default value in the language menu.
     * Properly filled in getInfo so it is updated when the interface languages changes.
     * @type {string}
     * @private
     */
    this._randomLanguageCode = 'en';

    /**
     * The result from the most recent translation.
     * @type {string}
     * @private
     */
    this._translateResult = '';

    /**
     * The language of the text most recently translated.
     * @type {string}
     * @private
     */
    this._lastLangTranslated = '';

    /**
     * The text most recently translated.
     * @type {string}
     * @private
     */
    this._lastTextTranslated = '';
  }

  /**
   * The key to load & store a target's translate state.
   * @return {string} The key.
   */
  static get STATE_KEY() {
    return 'Scratch.translate';
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    this._supportedLanguages = this._getSupportedLanguages(this.getViewerLanguageCode());
    this._randomLanguageCode = this._supportedLanguages[Math.floor(Math.random() * this._supportedLanguages.length)].value;
    return {
      id: 'translate',
      name: formatMessage({
        id: 'translate.categoryName',
        default: 'Translate',
        description: 'Name of extension that adds translate blocks'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: 'getTranslate',
        text: formatMessage({
          id: 'translate.translateBlock',
          default: 'translate [WORDS] to [LANGUAGE]',
          description: 'translate some text to a different language'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'translate.defaultTextToTranslate',
              default: 'hello',
              description: 'hello: the default text to translate'
            })
          },
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: 'languages',
            defaultValue: this._randomLanguageCode
          }
        }
      }, {
        opcode: 'getViewerLanguage',
        text: formatMessage({
          id: 'translate.viewerLanguage',
          default: 'language',
          description: 'the languge of the project viewer'
        }),
        blockType: BlockType.REPORTER,
        arguments: {}
      }],
      menus: {
        languages: {
          acceptReporters: true,
          items: this._supportedLanguages
        }
      }
    };
  }

  /**
   * Computes a list of language code and name pairs for the given language.
   * @param {string} code The language code to get the list of language pairs
   * @return {Array.<object.<string, string>>} An array of languge name and
   *   language code pairs.
   * @private
   */
  _getSupportedLanguages(code) {
    return languageNames.menuMap[code].map(entry => {
      const obj = {
        text: entry.name,
        value: entry.code
      };
      return obj;
    });
  }
  /**
   * Get the human readable language value for the reporter block.
   * @return {string} the language name of the project viewer.
   */
  getViewerLanguage() {
    this._viewerLanguageCode = this.getViewerLanguageCode();
    const names = languageNames.menuMap[this._viewerLanguageCode];
    let langNameObj = names.find(obj => obj.code === this._viewerLanguageCode);

    // If we don't have a name entry yet, try looking it up via the Google langauge
    // code instead of Scratch's (e.g. for es-419 we look up es to get espanol)
    if (!langNameObj && languageNames.scratchToGoogleMap[this._viewerLanguageCode]) {
      const lookupCode = languageNames.scratchToGoogleMap[this._viewerLanguageCode];
      langNameObj = names.find(obj => obj.code === lookupCode);
    }
    let langName = this._viewerLanguageCode;
    if (langNameObj) {
      langName = langNameObj.name;
    }
    return langName;
  }

  /**
   * Get the viewer's language code.
   * @return {string} the language code.
   */
  getViewerLanguageCode() {
    const locale = formatMessage.setup().locale;
    const viewerLanguages = [locale].concat(navigator.languages);
    const languageKeys = Object.keys(languageNames.menuMap);
    // Return the first entry in viewerLanguages that matches
    // one of the available language keys.
    const languageCode = viewerLanguages.reduce((acc, lang) => {
      if (acc) {
        return acc;
      }
      if (languageKeys.indexOf(lang.toLowerCase()) > -1) {
        return lang;
      }
      return acc;
    }, '') || 'en';
    return languageCode.toLowerCase();
  }

  /**
   * Get a language code from a block argument. The arg can be a language code
   * or a language name, written in any language.
   * @param  {object} arg A block argument.
   * @return {string} A language code.
   */
  getLanguageCodeFromArg(arg) {
    const languageArg = Cast.toString(arg).toLowerCase();
    // Check if the arg matches a language code in the menu.
    if (Object.prototype.hasOwnProperty.call(languageNames.menuMap, languageArg)) {
      return languageArg;
    }
    // Check for a dropped-in language name, and convert to a language code.
    if (Object.prototype.hasOwnProperty.call(languageNames.nameMap, languageArg)) {
      return languageNames.nameMap[languageArg];
    }

    // There are some languages we launched in the language menu that Scratch did not
    // end up launching in. In order to keep projects that may have had that menu item
    // working, check for those language codes and let them through.
    // Examples: 'ab', 'hi'.
    if (languageNames.previouslySupported.indexOf(languageArg) !== -1) {
      return languageArg;
    }
    // Default to English.
    return 'en';
  }

  /**
   * Translates the text in the translate block to the language specified in the menu.
   * @param {object} args - the block arguments.
   * @return {Promise} - a promise that resolves after the response from the translate server.
   */
  getTranslate(args) {
    // If the text contains only digits 0-9 and nothing else, return it without
    // making a request.
    if (/^\d+$/.test(args.WORDS)) return Promise.resolve(args.WORDS);

    // Don't remake the request if we already have the value.
    if (this._lastTextTranslated === args.WORDS && this._lastLangTranslated === args.LANGUAGE) {
      return this._translateResult;
    }
    const lang = this.getLanguageCodeFromArg(args.LANGUAGE);
    let urlBase = "".concat(serverURL, "translate?language=");
    urlBase += lang;
    urlBase += '&text=';
    urlBase += encodeURIComponent(args.WORDS);
    const tempThis = this;
    const translatePromise = fetchWithTimeout(urlBase, {}, serverTimeoutMs).then(response => response.text()).then(responseText => {
      const translated = JSON.parse(responseText).result;
      tempThis._translateResult = translated;
      // Cache what we just translated so we don't keep making the
      // same call over and over.
      tempThis._lastTextTranslated = args.WORDS;
      tempThis._lastLangTranslated = args.LANGUAGE;
      return translated;
    }).catch(err => {
      log.warn("error fetching translate result! ".concat(err));
      return '';
    });
    return translatePromise;
  }
}
module.exports = Scratch3TranslateBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/index.js":
/*!********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Runtime = __webpack_require__(/*! ../../engine/runtime */ "./src/engine/runtime.js");
const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const Video = __webpack_require__(/*! ../../io/video */ "./src/io/video.js");
const VideoMotion = __webpack_require__(/*! ./library */ "./src/extensions/scratch3_video_sensing/library.js");

/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxnIGlkPSJFeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDUuMDAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjI1IiBjeD0iMTYiIGN5PSI4IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjUiIGN4PSIxNiIgY3k9IjYiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiMwRUJEOEMiIG9wYWNpdHk9IjAuNzUiIGN4PSIxNiIgY3k9IjQiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMEVCRDhDIiBjeD0iMTYiIGN5PSIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjMzNTk3MzksMi4yMDk3ODgyNSBMOC4yNSw0LjIwOTk1NjQ5IEw4LjI1LDMuMDUgQzguMjUsMi4wNDQ4ODIyNyA3LjQ2ODU5MDMxLDEuMjUgNi41LDEuMjUgTDIuMDUsMS4yNSBDMS4wMzgwNzExOSwxLjI1IDAuMjUsMi4wMzgwNzExOSAwLjI1LDMuMDUgTDAuMjUsNyBDMC4yNSw3Ljk2MzY5OTM3IDEuMDQyMjQ5MTksOC43NTU5NDg1NiAyLjA1LDguOCBMNi41LDguOCBDNy40NTA4MzAwOSw4LjggOC4yNSw3Ljk3MzI3MjUgOC4yNSw3IEw4LjI1LDUuODU4NDUyNDEgTDguNjI4NjIzOTQsNi4wODU2MjY3NyBMMTEuNDI2Nzc2Nyw3Ljc3MzIyMzMgQzExLjQzNjg5NDMsNy43ODMzNDA5MSAxMS40NzU3NjU1LDcuOCAxMS41LDcuOCBDMTEuNjMzNDkzMiw3LjggMTEuNzUsNy42OTEyNjAzNCAxMS43NSw3LjU1IEwxMS43NSwyLjQgQzExLjc1LDIuNDE4MzgyNjkgMTEuNzIxOTAyOSwyLjM1MjgyMjgyIDExLjY4NTYyNjgsMi4yNzg2MjM5NCBDMTEuNjEyOTUyOCwyLjE1NzUwMDY5IDExLjQ3MDc5NjgsMi4xMjkwNjk1IDExLjMzNTk3MzksMi4yMDk3ODgyNSBaIiBpZD0idmlkZW9fMzdfIiBzdHJva2Utb3BhY2l0eT0iMC4xNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctQmxvY2s8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9WaWRlby1TZW5zaW5nLUJsb2NrIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2Utb3BhY2l0eT0iMC4xNSI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjE2IiByPSI0LjUiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiNGRkZGRkYiIG9wYWNpdHk9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjeD0iMzIiIGN5PSIxMiIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjgiIHI9IjQuNSI+PC9jaXJjbGU+CiAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgY3g9IjMyIiBjeT0iNCIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTIyLjY3MTk0NzcsNC40MTk1NzY0OSBMMTYuNSw4LjQxOTkxMjk4IEwxNi41LDYuMSBDMTYuNSw0LjA4OTc2NDU0IDE0LjkzNzE4MDYsMi41IDEzLDIuNSBMNC4xLDIuNSBDMi4wNzYxNDIzNywyLjUgMC41LDQuMDc2MTQyMzcgMC41LDYuMSBMMC41LDE0IEMwLjUsMTUuOTI3Mzk4NyAyLjA4NDQ5ODM5LDE3LjUxMTg5NzEgNC4xLDE3LjYgTDEzLDE3LjYgQzE0LjkwMTY2MDIsMTcuNiAxNi41LDE1Ljk0NjU0NSAxNi41LDE0IEwxNi41LDExLjcxNjkwNDggTDIyLjc1NzI0NzksMTUuNDcxMjUzNSBMMjIuODUzNTUzNCwxNS41NDY0NDY2IEMyMi44NzM3ODg2LDE1LjU2NjY4MTggMjIuOTUxNTMxLDE1LjYgMjMsMTUuNiBDMjMuMjY2OTg2NSwxNS42IDIzLjUsMTUuMzgyNTIwNyAyMy41LDE1LjEgTDIzLjUsNC44IEMyMy41LDQuODM2NzY1MzggMjMuNDQzODA1OCw0LjcwNTY0NTYzIDIzLjM3MTI1MzUsNC41NTcyNDc4OCBDMjMuMjI1OTA1Niw0LjMxNTAwMTM5IDIyLjk0MTU5MzcsNC4yNTgxMzg5OSAyMi42NzE5NDc3LDQuNDE5NTc2NDkgWiIgaWQ9InZpZGVvXzM3XyIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';

/**
 * Sensor attribute video sensor block should report.
 * @readonly
 * @enum {string}
 */
const SensingAttribute = {
  /** The amount of motion. */
  MOTION: 'motion',
  /** The direction of the motion. */
  DIRECTION: 'direction'
};

/**
 * Subject video sensor block should report for.
 * @readonly
 * @enum {string}
 */
const SensingSubject = {
  /** The sensor traits of the whole stage. */
  STAGE: 'Stage',
  /** The senosr traits of the area overlapped by this sprite. */
  SPRITE: 'this sprite'
};

/**
 * States the video sensing activity can be set to.
 * @readonly
 * @enum {string}
 */
const VideoState = {
  /** Video turned off. */
  OFF: 'off',
  /** Video turned on with default y axis mirroring. */
  ON: 'on',
  /** Video turned on without default y axis mirroring. */
  ON_FLIPPED: 'on-flipped'
};

/**
 * Class for the motion-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */
class Scratch3VideoSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;

    /**
     * The motion detection algoritm used to power the motion amount and
     * direction values.
     * @type {VideoMotion}
     */
    this.detect = new VideoMotion();

    /**
     * The last millisecond epoch timestamp that the video stream was
     * analyzed.
     * @type {number}
     */
    this._lastUpdate = null;

    /**
     * A flag to determine if this extension has been installed in a project.
     * It is set to false the first time getInfo is run.
     * @type {boolean}
     */
    this.firstInstall = true;
    if (this.runtime.ioDevices) {
      // Configure the video device with values from globally stored locations.
      this.runtime.on(Runtime.PROJECT_LOADED, this.updateVideoDisplay.bind(this));

      // Clear target motion state values when the project starts.
      this.runtime.on(Runtime.PROJECT_RUN_START, this.reset.bind(this));

      // Kick off looping the analysis logic.
      this._loop();
    }
  }

  /**
   * After analyzing a frame the amount of milliseconds until another frame
   * is analyzed.
   * @type {number}
   */
  static get INTERVAL() {
    return 33;
  }

  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */
  static get DIMENSIONS() {
    return [480, 360];
  }

  /**
   * The key to load & store a target's motion-related state.
   * @type {string}
   */
  static get STATE_KEY() {
    return 'Scratch.videoSensing';
  }

  /**
   * The default motion-related state, to be used when a target has no existing motion state.
   * @type {MotionState}
   */
  static get DEFAULT_MOTION_STATE() {
    return {
      motionFrameNumber: 0,
      motionAmount: 0,
      motionDirection: 0
    };
  }

  /**
   * The transparency setting of the video preview stored in a value
   * accessible by any object connected to the virtual machine.
   * @type {number}
   */
  get globalVideoTransparency() {
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      return stage.videoTransparency;
    }
    return 50;
  }
  set globalVideoTransparency(transparency) {
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      stage.videoTransparency = transparency;
    }
  }

  /**
   * The video state of the video preview stored in a value accessible by any
   * object connected to the virtual machine.
   * @type {number}
   */
  get globalVideoState() {
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      return stage.videoState;
    }
    // Though the default value for the stage is normally 'on', we need to default
    // to 'off' here to prevent the video device from briefly activating
    // while waiting for stage targets to be installed that say it should be off
    return VideoState.OFF;
  }
  set globalVideoState(state) {
    const stage = this.runtime.getTargetForStage();
    if (stage) {
      stage.videoState = state;
    }
  }

  /**
   * Get the latest values for video transparency and state,
   * and set the video device to use them.
   */
  updateVideoDisplay() {
    this.setVideoTransparency({
      TRANSPARENCY: this.globalVideoTransparency
    });
    this.videoToggle({
      VIDEO_STATE: this.globalVideoState
    });
  }

  /**
   * Reset the extension's data motion detection data. This will clear out
   * for example old frames, so the first analyzed frame will not be compared
   * against a frame from before reset was called.
   */
  reset() {
    this.detect.reset();
    const targets = this.runtime.targets;
    for (let i = 0; i < targets.length; i++) {
      const state = targets[i].getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);
      if (state) {
        state.motionAmount = 0;
        state.motionDirection = 0;
      }
    }
  }

  /**
   * Occasionally step a loop to sample the video, stamp it to the preview
   * skin, and add a TypedArray copy of the canvas's pixel data.
   * @private
   */
  _loop() {
    const loopTime = Math.max(this.runtime.currentStepTime, Scratch3VideoSensingBlocks.INTERVAL);
    this._loopInterval = setTimeout(this._loop.bind(this), loopTime);

    // Add frame to detector
    const time = Date.now();
    if (this._lastUpdate === null) {
      this._lastUpdate = time;
    }
    const offset = time - this._lastUpdate;
    if (offset > Scratch3VideoSensingBlocks.INTERVAL) {
      const frame = this.runtime.ioDevices.video.getFrame({
        format: Video.FORMAT_IMAGE_DATA,
        dimensions: Scratch3VideoSensingBlocks.DIMENSIONS
      });
      if (frame) {
        this._lastUpdate = time;
        this.detect.addFrame(frame.data);
      }
    }
  }

  /**
   * Stop the video sampling loop. Only used for testing.
   */
  _stopLoop() {
    clearTimeout(this._loopInterval);
  }

  /**
   * Create data for a menu in scratch-blocks format, consisting of an array
   * of objects with text and value properties. The text is a translated
   * string, and the value is one-indexed.
   * @param {object[]} info - An array of info objects each having a name
   *   property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */
  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = entry.value || String(index + 1);
      return obj;
    });
  }

  /**
   * @param {Target} target - collect motion state for this target.
   * @returns {MotionState} the mutable motion state associated with that
   *   target. This will be created if necessary.
   * @private
   */
  _getMotionState(target) {
    let motionState = target.getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);
    if (!motionState) {
      motionState = Clone.simple(Scratch3VideoSensingBlocks.DEFAULT_MOTION_STATE);
      target.setCustomState(Scratch3VideoSensingBlocks.STATE_KEY, motionState);
    }
    return motionState;
  }
  static get SensingAttribute() {
    return SensingAttribute;
  }

  /**
   * An array of choices of whether a reporter should return the frame's
   * motion amount or direction.
   * @type {object[]}
   * @param {string} name - the translatable name to display in sensor
   *   attribute menu
   * @param {string} value - the serializable value of the attribute
   */
  get ATTRIBUTE_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.motion',
        default: 'motion',
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.MOTION
    }, {
      name: formatMessage({
        id: 'videoSensing.direction',
        default: 'direction',
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.DIRECTION
    }];
  }
  static get SensingSubject() {
    return SensingSubject;
  }

  /**
   * An array of info about the subject choices.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the subject menu
   * @param {string} value - the serializable value of the subject
   */
  get SUBJECT_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.sprite',
        default: 'sprite',
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.SPRITE
    }, {
      name: formatMessage({
        id: 'videoSensing.stage',
        default: 'stage',
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.STAGE
    }];
  }

  /**
   * States the video sensing activity can be set to.
   * @readonly
   * @enum {string}
   */
  static get VideoState() {
    return VideoState;
  }

  /**
   * An array of info on video state options for the "turn video [STATE]" block.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the video state menu
   * @param {string} value - the serializable value stored in the block
   */
  get VIDEO_STATE_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.off',
        default: 'off',
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.OFF
    }, {
      name: formatMessage({
        id: 'videoSensing.on',
        default: 'on',
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.ON
    }, {
      name: formatMessage({
        id: 'videoSensing.onFlipped',
        default: 'on flipped',
        description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' + ' horizontally (reversed as in a mirror)'
      }),
      value: VideoState.ON_FLIPPED
    }];
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    // Set the video display properties to defaults the first time
    // getInfo is run. This turns on the video device when it is
    // first added to a project, and is overwritten by a PROJECT_LOADED
    // event listener that later calls updateVideoDisplay
    if (this.firstInstall) {
      this.globalVideoState = VideoState.ON;
      this.globalVideoTransparency = 50;
      this.updateVideoDisplay();
      this.firstInstall = false;
    }

    // Return extension definition
    return {
      id: 'videoSensing',
      name: formatMessage({
        id: 'videoSensing.categoryName',
        default: 'Video Sensing',
        description: 'Label for the video sensing extension category'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        // @todo this hat needs to be set itself to restart existing
        // threads like Scratch 2's behaviour.
        opcode: 'whenMotionGreaterThan',
        text: formatMessage({
          id: 'videoSensing.whenMotionGreaterThan',
          default: 'when video motion > [REFERENCE]',
          description: 'Event that triggers when the amount of motion is greater than [REFERENCE]'
        }),
        blockType: BlockType.HAT,
        arguments: {
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        }
      }, {
        opcode: 'videoOn',
        blockType: BlockType.REPORTER,
        text: formatMessage({
          id: 'videoSensing.videoOn',
          default: 'video [ATTRIBUTE] on [SUBJECT]',
          description: 'Reporter that returns the amount of [ATTRIBUTE] for the selected [SUBJECT]'
        }),
        arguments: {
          ATTRIBUTE: {
            type: ArgumentType.NUMBER,
            menu: 'ATTRIBUTE',
            defaultValue: SensingAttribute.MOTION
          },
          SUBJECT: {
            type: ArgumentType.NUMBER,
            menu: 'SUBJECT',
            defaultValue: SensingSubject.SPRITE
          }
        }
      }, {
        opcode: 'videoToggle',
        text: formatMessage({
          id: 'videoSensing.videoToggle',
          default: 'turn video [VIDEO_STATE]',
          description: 'Controls display of the video preview layer'
        }),
        arguments: {
          VIDEO_STATE: {
            type: ArgumentType.NUMBER,
            menu: 'VIDEO_STATE',
            defaultValue: VideoState.ON
          }
        }
      }, {
        opcode: 'setVideoTransparency',
        text: formatMessage({
          id: 'videoSensing.setVideoTransparency',
          default: 'set video transparency to [TRANSPARENCY]',
          description: 'Controls transparency of the video preview layer'
        }),
        arguments: {
          TRANSPARENCY: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        ATTRIBUTE: {
          acceptReporters: true,
          items: this._buildMenu(this.ATTRIBUTE_INFO)
        },
        SUBJECT: {
          acceptReporters: true,
          items: this._buildMenu(this.SUBJECT_INFO)
        },
        VIDEO_STATE: {
          acceptReporters: true,
          items: this._buildMenu(this.VIDEO_STATE_INFO)
        }
      }
    };
  }

  /**
   * Analyze a part of the frame that a target overlaps.
   * @param {Target} target - a target to determine where to analyze
   * @returns {MotionState} the motion state for the given target
   */
  _analyzeLocalMotion(target) {
    const drawable = this.runtime.renderer._allDrawables[target.drawableID];
    const state = this._getMotionState(target);
    this.detect.getLocalMotion(drawable, state);
    return state;
  }

  /**
   * A scratch reporter block handle that analyzes the last two frames and
   * depending on the arguments, returns the motion or direction for the
   * whole stage or just the target sprite.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {number} the motion amount or direction of the stage or sprite
   */
  videoOn(args, util) {
    this.detect.analyzeFrame();
    let state = this.detect;
    if (args.SUBJECT === SensingSubject.SPRITE) {
      state = this._analyzeLocalMotion(util.target);
    }
    if (args.ATTRIBUTE === SensingAttribute.MOTION) {
      return state.motionAmount;
    }
    return state.motionDirection;
  }

  /**
   * A scratch hat block edge handle that analyzes the last two frames where
   * the target sprite overlaps and if it has more motion than the given
   * reference value.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {boolean} true if the sprite overlaps more motion than the
   *   reference
   */
  whenMotionGreaterThan(args, util) {
    this.detect.analyzeFrame();
    const state = this._analyzeLocalMotion(util.target);
    return state.motionAmount > Number(args.REFERENCE);
  }

  /**
   * A scratch command block handle that configures the video state from
   * passed arguments.
   * @param {object} args - the block arguments
   * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
   */
  videoToggle(args) {
    const state = args.VIDEO_STATE;
    this.globalVideoState = state;
    if (state === VideoState.OFF) {
      this.runtime.ioDevices.video.disableVideo();
    } else {
      this.runtime.ioDevices.video.enableVideo();
      // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.
      this.runtime.ioDevices.video.mirror = state === VideoState.ON;
    }
  }

  /**
   * A scratch command block handle that configures the video preview's
   * transparency from passed arguments.
   * @param {object} args - the block arguments
   * @param {number} args.TRANSPARENCY - the transparency to set the video
   *   preview to
   */
  setVideoTransparency(args) {
    const transparency = Cast.toNumber(args.TRANSPARENCY);
    this.globalVideoTransparency = transparency;
    this.runtime.ioDevices.video.setPreviewGhost(transparency);
  }
}
module.exports = Scratch3VideoSensingBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_wedo2/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_wedo2/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");
const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");
const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");
const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAF8klEQVR4Ae2cbWxTVRjH/7ctbVc2tyEMNpWBk0VIkLcEjSAQgglTE5HEaKqJi1E/mbCP/dJA0kQbvzgTQ0Ki2T7V6AeYGoEPLJmGKPiyzZDwEpYJCHSbQIcbdLvres1zOa13Xbvdu2eTDp9fst329Lnn5XfPPfece7tphmFAmDkuccdDBDIRgUxEIBMRyEQEMhGBTEQgExHIRAQyEYFMRCATEchEBDIRgUxEIBMRyEQEMhGBTEQgExHIxMPNIByNVQBoBUDb7kgo2KTS9wBoUmFNkVCwW6U3A1gP4JJKHwxHY/S+WcW2RkLBVhV7AMAOAIMAGlWstbyOSCh4QMU2Uoy1PBVL+a7IqZu1vOZIKNg20/azBarGvKxebw9HY22RULADwBFLTBcATQnZl4lVEimN4ssteXQrQfstebQpmW1q30xshyqvxRLbofYnYW9ZYgeV8C5LLOWlzbTxM3ouHI7GPgSwWx3Z0syBSBku6IYnlTbM+uQenJQaMnKHDaqAFnDrcCFbl3G1defEjas0a4N/Vz10OybyvapfrSX1sjpo+WIz0ME7QL3djgtHPTAcjb2mepw/b2ZaGh5NL5RnofR8R99dIC5fHusK5JsrCUpm7TSx21XvbcwTNwnbAsPR2GcA3qaG+H0LsHlDPZ7fca/ujZ+cRW9/Em5vCXzlNVhQUjFpf/3OTSRvXkKJz43Xt1bh1S1LUeq/5+njQ9/iVmLIfL1ieRU2b1iFtavztXNu6TrTi8PfnYI67WdPoOp5przV9Y8iuHdb9rOW9uumPI+vDIElddBckztPOqVn5X36Xj1WVQeynx1sOWbK83jc2PviM/dFXIYNax9H55leXLoyYHsfWwI14JCRRx7x5ckBU1oheYQ+1G9u39lVM0Hej7+cR7w/Yb7e9+5LqChfaLvixcK088BwNNZkAOV02ubK6+odwt3RcfOULSSPGEveG48bNj08If3kqXPmdtO6unkpDzYn0u/TLxrzcumJJ80Ut79sygzoFF6/siw75mUYupOEpmnY0/A0pw33FTsCa+hX5oJhZXgkZb5zub2O20CnL7EwkPeCPm+wI7CEBvi5wuOZ36tJW7X3uGXJXAgxk8P4eNpRPEvgskqfuR0Z/BNGejxvDM3/5gs0pboWv+motqybCc+tqUCzz43kaBJ/X+2eMjZ3ClNsjIzo5ioknXZ2b4AlkKYltLJoaY9jOJm/B0KJbtg4c4F/XOmH3+dF9dLKbBo1OD6QQGV56YQ55ODtO0jcHkZ1VSX8/n9nB9S7RkZ1rFy+NG8ZR9s70TeQQKDEh7vJUdt1Y9/OopXFB2/WcbMpyOexE9mlFS21aLlHMmKHfzBl0QT/hV2bzM9oLXv0xG8YGR0zpdLEn6RT2k+/XjDzoLX2G3u3TZBLUyral/Z5qCyAK1f/sl2/or+IWNel1Eji3MWrpjyCZHWqdNrSe6ieSHFERl4mP+q5GehgHGvvRGal5XI5uzU47f3A/R99YTgdF2wXrmkolr9ToZ5NvTjT4yOhoC2T057CJM/r9WDxoqmXa07R9THcuDVcMO8bt4ag6ynULKvkFjWBTLl0ugZKvNlyqLeSQKfYGgOpgXt2b5zVhlzrS+Dr451YvKg0b95txztxvS8xZ+VuXFuLJ5+oNgV+9c3PuHDxGs6cu+w4v//9RJo6x5bN9UgbBo4cPY1U6j+cSD8orFvzGFYuX4KxsRQGbth6FCICc9m5dY05HtN46AQRqPB5PWjY+ZT5RnMwkxGBFh5ZVmle9Z3MrGbjwfqccrC1vajrV7QCaVCfS6qrJj96nQlFK5CujPRT7MgYyEQEMhGBTGwJpAW4kJ9pBbo0zbx70X7y7AOv8HxP3LyB4YTpb2cZBt2iqL3QEwf9zDbX+waLca439QMeC7a+YBmOxugLiM/OTt2yaOoMoO+H6LOcNwf6xusrthsh/7mIh1yFmYhAJiKQiQhkIgKZiEAmIpCJCGQiApmIQCYikIkIZCICmYhAJiKQiQhkIgKZiEAmIpCJCGQiAjkA+AeOwQKMcWZqHgAAAABJRU5ErkJggg==';

/**
 * A list of WeDo 2.0 BLE service UUIDs.
 * @enum
 */
const BLEService = {
  DEVICE_SERVICE: '00001523-1212-efde-1523-785feabcd123',
  IO_SERVICE: '00004f0e-1212-efde-1523-785feabcd123'
};

/**
 * A list of WeDo 2.0 BLE characteristic UUIDs.
 *
 * Characteristics on DEVICE_SERVICE:
 * - ATTACHED_IO
 *
 * Characteristics on IO_SERVICE:
 * - INPUT_VALUES
 * - INPUT_COMMAND
 * - OUTPUT_COMMAND
 *
 * @enum
 */
const BLECharacteristic = {
  ATTACHED_IO: '00001527-1212-efde-1523-785feabcd123',
  LOW_VOLTAGE_ALERT: '00001528-1212-efde-1523-785feabcd123',
  INPUT_VALUES: '00001560-1212-efde-1523-785feabcd123',
  INPUT_COMMAND: '00001563-1212-efde-1523-785feabcd123',
  OUTPUT_COMMAND: '00001565-1212-efde-1523-785feabcd123'
};

/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */
const BLEBatteryCheckInterval = 5000;

/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */
const BLESendInterval = 100;

/**
 * A maximum number of BLE message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */
const BLESendRateMax = 20;

/**
 * Enum for WeDo 2.0 sensor and output types.
 * @readonly
 * @enum {number}
 */
const WeDo2Device = {
  MOTOR: 1,
  PIEZO: 22,
  LED: 23,
  TILT: 34,
  DISTANCE: 35
};

/**
 * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.
 * @readonly
 * @enum {number}
 */
// TODO: Check for these more accurately at startup?
const WeDo2ConnectID = {
  LED: 6,
  PIEZO: 5
};

/**
 * Enum for ids for various output commands on the WeDo 2.0.
 * @readonly
 * @enum {number}
 */
const WeDo2Command = {
  MOTOR_POWER: 1,
  PLAY_TONE: 2,
  STOP_TONE: 3,
  WRITE_RGB: 4,
  SET_VOLUME: 255
};

/**
 * Enum for modes for input sensors on the WeDo 2.0.
 * @enum {number}
 */
const WeDo2Mode = {
  TILT: 0,
  // angle
  DISTANCE: 0,
  // detect
  LED: 1 // RGB
};

/**
 * Enum for units for input sensors on the WeDo 2.0.
 *
 * 0 = raw
 * 1 = percent
 *
 * @enum {number}
 */
const WeDo2Unit = {
  TILT: 0,
  DISTANCE: 1,
  LED: 0
};

/**
 * Manage power, direction, and timers for one WeDo 2.0 motor.
 */
class WeDo2Motor {
  /**
   * Construct a WeDo 2.0 Motor instance.
   * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The WeDo 2.0 peripheral which owns this motor.
     * @type {WeDo2}
     * @private
     */
    this._parent = parent;

    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */
    this._index = index;

    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */
    this._direction = 1;

    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */
    this._power = 100;

    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */
    this._isOn = false;

    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */
    this._pendingTimeoutId = null;

    /**
     * The starting time for the pending timeout.
     * @type {Object}
     * @private
     */
    this._pendingTimeoutStartTime = null;

    /**
     * The delay/duration of the pending timeout.
     * @type {Object}
     * @private
     */
    this._pendingTimeoutDelay = null;
    this.startBraking = this.startBraking.bind(this);
    this.turnOff = this.turnOff.bind(this);
  }

  /**
   * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.
   * @constructor
   */
  static get BRAKE_TIME_MS() {
    return 1000;
  }

  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */
  get direction() {
    return this._direction;
  }

  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */
  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }

  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */
  get power() {
    return this._power;
  }

  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */
  set power(value) {
    const p = Math.max(0, Math.min(value, 100));
    // Lego Wedo 2.0 hub only turns motors at power range [30 - 100], so
    // map value from [0 - 100] to [30 - 100].
    if (p === 0) {
      this._power = 0;
    } else {
      const delta = 100 / p;
      this._power = 30 + 70 / delta;
    }
  }

  /**
   * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
   */
  get isOn() {
    return this._isOn;
  }

  /**
   * @return {boolean} - time, in milliseconds, of when the pending timeout began.
   */
  get pendingTimeoutStartTime() {
    return this._pendingTimeoutStartTime;
  }

  /**
   * @return {boolean} - delay, in milliseconds, of the pending timeout.
   */
  get pendingTimeoutDelay() {
    return this._pendingTimeoutDelay;
  }

  /**
   * Turn this motor on indefinitely.
   */
  turnOn() {
    if (this._power === 0) return;
    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] // power in range 0-100
    );
    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
    this._isOn = true;
    this._clearTimeout();
  }

  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */
  turnOnFor(milliseconds) {
    if (this._power === 0) return;
    milliseconds = Math.max(0, milliseconds);
    this.turnOn();
    this._setNewTimeout(this.startBraking, milliseconds);
  }

  /**
   * Start active braking on this motor. After a short time, the motor will turn off.
   */
  startBraking() {
    if (this._power === 0) return;
    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] // 127 = break
    );
    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
    this._isOn = false;
    this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);
  }

  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */
  turnOff() {
    let useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (this._power === 0) return;
    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] // 0 = stop
    );
    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);
    this._isOn = false;
  }

  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */
  _clearTimeout() {
    if (this._pendingTimeoutId !== null) {
      clearTimeout(this._pendingTimeoutId);
      this._pendingTimeoutId = null;
      this._pendingTimeoutStartTime = null;
      this._pendingTimeoutDelay = null;
    }
  }

  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */
  _setNewTimeout(callback, delay) {
    this._clearTimeout();
    const timeoutID = setTimeout(() => {
      if (this._pendingTimeoutId === timeoutID) {
        this._pendingTimeoutId = null;
        this._pendingTimeoutStartTime = null;
        this._pendingTimeoutDelay = null;
      }
      callback();
    }, delay);
    this._pendingTimeoutId = timeoutID;
    this._pendingTimeoutStartTime = Date.now();
    this._pendingTimeoutDelay = delay;
  }
}

/**
 * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.
 */
class WeDo2 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;

    /**
     * A list of the ids of the motors or sensors in ports 1 and 2.
     * @type {string[]}
     * @private
     */
    this._ports = ['none', 'none'];

    /**
     * The motors which this WeDo 2.0 could possibly have.
     * @type {WeDo2Motor[]}
     * @private
     */
    this._motors = [null, null];

    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };

    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */
    this._ble = null;
    this._runtime.registerPeripheralExtension(extensionId, this);

    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */
    this._rateLimiter = new RateLimiter(BLESendRateMax);

    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */
    this._batteryLevelIntervalId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */
  get tiltX() {
    return this._sensors.tiltX;
  }

  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */
  get tiltY() {
    return this._sensors.tiltY;
  }

  /**
   * @return {number} - the latest value received from the distance sensor.
   */
  get distance() {
    return this._sensors.distance;
  }

  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
   */
  motor(index) {
    return this._motors[index];
  }

  /**
   * Stop all the motors that are currently running.
   */
  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }

  /**
   * Set the WeDo 2.0 peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */
  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }

  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */
  setLEDMode() {
    const cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);
    return this.send(BLECharacteristic.INPUT_COMMAND, cmd);
  }

  /**
   * Switch off the LED on the WeDo 2.0.
   * @return {Promise} - a promise of the completion of the stop led send operation.
   */
  stopLED() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }

  /**
   * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.
   * @param {int} tone - the pitch of the tone, in Hz.
   * @param {int} milliseconds - the duration of the note, in milliseconds.
   * @return {Promise} - a promise of the completion of the play tone send operation.
   */
  playTone(tone, milliseconds) {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }

  /**
   * Stop the tone playing from the WeDo 2.0 peripheral, if any.
   * @return {Promise} - a promise that the command sent.
   */
  stopTone() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE);

    // Send this command without using the rate limiter, because it is
    // only triggered by the stop button.
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);
  }

  /**
   * Stop the tone playing and motors on the WeDo 2.0 peripheral.
   */
  stopAll() {
    if (!this.isConnected()) return;
    this.stopTone();
    this.stopAllMotors();
  }

  /**
   * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.
   */
  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEService.DEVICE_SERVICE]
      }],
      optionalServices: [BLEService.IO_SERVICE]
    }, this._onConnect, this.reset);
  }

  /**
   * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */
  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }

  /**
   * Disconnects from the current BLE socket.
   */
  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }
    this.reset();
  }

  /**
   * Reset all the state and timeout/interval ids.
   */
  reset() {
    this._ports = ['none', 'none'];
    this._motors = [null, null];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };
    if (this._batteryLevelIntervalId) {
      window.clearInterval(this._batteryLevelIntervalId);
      this._batteryLevelIntervalId = null;
    }
  }

  /**
   * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.
   * @return {boolean} - the connected state.
   */
  isConnected() {
    let connected = false;
    if (this._ble) {
      connected = this._ble.isConnected();
    }
    return connected;
  }

  /**
   * Write a message to the WeDo 2.0 peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */
  send(uuid, message) {
    let useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!this.isConnected()) return Promise.resolve();
    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }
    return this._ble.write(BLEService.IO_SERVICE, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');
  }

  /**
   * Generate a WeDo 2.0 'Output Command' in the byte array format
   * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).
   *
   * This sends a command to the WeDo 2.0 to actuate the specified outputs.
   *
   * @param  {number} connectID - the port (Connect ID) to send a command to.
   * @param  {number} commandID - the id of the byte command.
   * @param  {array}  values    - the list of values to write to the command.
   * @return {array}            - a generated output command.
   */
  generateOutputCommand(connectID, commandID) {
    let values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let command = [connectID, commandID];
    if (values) {
      command = command.concat(values.length).concat(values);
    }
    return command;
  }

  /**
   * Generate a WeDo 2.0 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the WeDo 2.0 that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  connectID           - the port (Connect ID) to send a command to.
   * @param  {number}  type                - the type of input sensor.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {array}   units               - the unit of the input sensor value.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */
  generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {
    const command = [1,
    // Command ID = 1 = "Sensor Format"
    2,
    // Command Type = 2 = "Write"
    connectID, type, mode, delta, 0,
    // Delta Interval Byte 2
    0,
    // Delta Interval Byte 3
    0,
    // Delta Interval Byte 4
    units, enableNotifications ? 1 : 0];
    return command;
  }

  /**
   * Sets LED mode and initial color and starts reading data from peripheral after BLE has connected.
   * @private
   */
  _onConnect() {
    this.setLEDMode();
    this.setLED(0x0000FF);
    this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);
    this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);
  }

  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */
  _onMessage(base64) {
    const data = Base64Util.base64ToUint8Array(base64);
    // log.info(data);

    /**
     * If first byte of data is '1' or '2', then either clear the
     * sensor present in ports 1 or 2 or set their format.
     *
     * If first byte of data is anything else, read incoming sensor value.
     */
    switch (data[0]) {
      case 1:
      case 2:
        {
          const connectID = data[0];
          if (data[1] === 0) {
            // clear sensor or motor
            this._clearPort(connectID);
          } else {
            // register sensor or motor
            this._registerSensorOrMotor(connectID, data[3]);
          }
          break;
        }
      default:
        {
          // read incoming sensor value
          const connectID = data[1];
          const type = this._ports[connectID - 1];
          if (type === WeDo2Device.DISTANCE) {
            this._sensors.distance = data[2];
          }
          if (type === WeDo2Device.TILT) {
            this._sensors.tiltX = data[2];
            this._sensors.tiltY = data[3];
          }
          break;
        }
    }
  }

  /**
   * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   */
  _checkBatteryLevel() {
    this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);
  }

  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} connectID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */
  _registerSensorOrMotor(connectID, type) {
    // Record which port is connected to what type of device
    this._ports[connectID - 1] = type;

    // Record motor port
    if (type === WeDo2Device.MOTOR) {
      this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);
    } else {
      // Set input format for tilt or distance sensor
      const typeString = type === WeDo2Device.DISTANCE ? 'DISTANCE' : 'TILT';
      const cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);
      this.send(BLECharacteristic.INPUT_COMMAND, cmd);
      this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);
    }
  }

  /**
   * Clear the sensor or motor present at port 1 or 2.
   * @param {number} connectID - the port to clear.
   * @private
   */
  _clearPort(connectID) {
    const type = this._ports[connectID - 1];
    if (type === WeDo2Device.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }
    if (type === WeDo2Device.DISTANCE) {
      this._sensors.distance = 0;
    }
    this._ports[connectID - 1] = 'none';
    this._motors[connectID - 1] = null;
  }
}

/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */
const WeDo2MotorLabel = {
  DEFAULT: 'motor',
  A: 'motor A',
  B: 'motor B',
  ALL: 'all motors'
};

/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */
const WeDo2MotorDirection = {
  FORWARD: 'this way',
  BACKWARD: 'that way',
  REVERSE: 'reverse'
};

/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */
const WeDo2TiltDirection = {
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};

/**
 * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.
 */
class Scratch3WeDo2Blocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'wedo2';
  }

  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */
  static get TILT_THRESHOLD() {
    return 15;
  }

  /**
   * Construct a set of WeDo 2.0 blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    // Create a new WeDo 2.0 peripheral instance
    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  getInfo() {
    return {
      id: Scratch3WeDo2Blocks.EXTENSION_ID,
      name: 'WeDo 2.0',
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorOnFor',
        text: formatMessage({
          id: 'wedo2.motorOnFor',
          default: 'turn [MOTOR_ID] on for [DURATION] seconds',
          description: 'turn a motor on for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOn',
        text: formatMessage({
          id: 'wedo2.motorOn',
          default: 'turn [MOTOR_ID] on',
          description: 'turn a motor on indefinitely'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: 'motorOff',
        text: formatMessage({
          id: 'wedo2.motorOff',
          default: 'turn [MOTOR_ID] off',
          description: 'turn a motor off'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: 'startMotorPower',
        text: formatMessage({
          id: 'wedo2.startMotorPower',
          default: 'set [MOTOR_ID] power to [POWER]',
          description: 'set the motor\'s power and turn it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'setMotorDirection',
        text: formatMessage({
          id: 'wedo2.setMotorDirection',
          default: 'set [MOTOR_ID] direction to [MOTOR_DIRECTION]',
          description: 'set the motor\'s turn direction'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_DIRECTION',
            defaultValue: WeDo2MotorDirection.FORWARD
          }
        }
      }, {
        opcode: 'setLightHue',
        text: formatMessage({
          id: 'wedo2.setLightHue',
          default: 'set light color to [HUE]',
          description: 'set the LED color'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'playNoteFor',
        text: formatMessage({
          id: 'wedo2.playNoteFor',
          default: 'play note [NOTE] for [DURATION] seconds',
          description: 'play a certain note for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NUMBER,
            // TODO: ArgumentType.MIDI_NOTE?
            defaultValue: 60
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'whenDistance',
        text: formatMessage({
          id: 'wedo2.whenDistance',
          default: 'when distance [OP] [REFERENCE]',
          description: 'check for when distance is < or > than reference'
        }),
        blockType: BlockType.HAT,
        arguments: {
          OP: {
            type: ArgumentType.STRING,
            menu: 'OP',
            defaultValue: '<'
          },
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'wedo2.whenTilted',
          default: 'when tilted [TILT_DIRECTION_ANY]',
          description: 'check when tilted in a certain direction'
        }),
        func: 'isTilted',
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: 'getDistance',
        text: formatMessage({
          id: 'wedo2.getDistance',
          default: 'distance',
          description: 'the value returned by the distance sensor'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'wedo2.isTilted',
          default: 'tilted [TILT_DIRECTION_ANY]?',
          description: 'whether the tilt sensor is tilted'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'wedo2.getTiltAngle',
          default: 'tilt angle [TILT_DIRECTION]',
          description: 'the angle returned by the tilt sensor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION',
            defaultValue: WeDo2TiltDirection.UP
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.motorId.default',
              default: 'motor',
              description: 'label for motor element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.DEFAULT
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.a',
              default: 'motor A',
              description: 'label for motor A element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.A
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.b',
              default: 'motor B',
              description: 'label for motor B element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.B
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.all',
              default: 'all motors',
              description: 'label for all motors element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.ALL
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.motorDirection.forward',
              default: 'this way',
              description: 'label for forward element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: 'wedo2.motorDirection.backward',
              default: 'that way',
              description: 'label for backward element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: 'wedo2.motorDirection.reverse',
              default: 'reverse',
              description: 'label for reverse element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.tiltDirection.up',
              default: 'up',
              description: 'label for up element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.down',
              default: 'down',
              description: 'label for down element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.left',
              default: 'left',
              description: 'label for left element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.right',
              default: 'right',
              description: 'label for right element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.tiltDirection.up',
              default: 'up'
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.down',
              default: 'down'
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.left',
              default: 'left'
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.right',
              default: 'right'
            }),
            value: WeDo2TiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.any',
              default: 'any',
              description: 'label for any element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.ANY
          }]
        },
        OP: {
          acceptReporters: true,
          items: ['<', '>']
        }
      }
    };
  }

  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */
  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);
        if (motor) {
          motor.turnOnFor(durationMS);
        }
      });

      // Run for some time even when no motor is connected
      setTimeout(resolve, durationMS);
    });
  }

  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */
  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        motor.turnOn();
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */
  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        motor.turnOff();
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */
  startMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);
        motor.turnOn();
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */
  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);
      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case WeDo2MotorDirection.FORWARD:
            motor.direction = 1;
            break;
          case WeDo2MotorDirection.BACKWARD:
            motor.direction = -1;
            break;
          case WeDo2MotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;
          default:
            log.warn("Unknown motor direction in setMotorDirection: ".concat(args.DIRECTION));
            break;
        }
        // keep the motor on if it's running, and update the pending timeout if needed
        if (motor.isOn) {
          if (motor.pendingTimeoutDelay) {
            motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());
          } else {
            motor.turnOn();
          }
        }
      }
    });
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */
  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Cast.toNumber(args.HUE);
    inputHue = MathUtil.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = color.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);
    this._peripheral.setLED(rgbDecimal);
    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }

  /**
   * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.
   * @param {object} args - the block's arguments.
   * @property {number} NOTE - the MIDI note to play.
   * @property {number} DURATION - the duration of the note, in seconds.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */
  playNoteFor(args) {
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 3000);
    const note = MathUtil.clamp(Cast.toNumber(args.NOTE), 25, 125); // valid WeDo 2.0 sounds
    if (durationMS === 0) return; // WeDo 2.0 plays duration '0' forever
    return new Promise(resolve => {
      const tone = this._noteToTone(note);
      this._peripheral.playTone(tone, durationMS);

      // Run for some time even when no piezo is connected
      setTimeout(resolve, durationMS);
    });
  }

  /**
   * Compare the distance sensor's value to a reference.
   * @param {object} args - the block's arguments.
   * @property {string} OP - the comparison operation: '<' or '>'.
   * @property {number} REFERENCE - the value to compare against.
   * @return {boolean} - the result of the comparison, or false on error.
   */
  whenDistance(args) {
    switch (args.OP) {
      case '<':
        return this._peripheral.distance < Cast.toNumber(args.REFERENCE);
      case '>':
        return this._peripheral.distance > Cast.toNumber(args.REFERENCE);
      default:
        log.warn("Unknown comparison operator in whenDistance: ".concat(args.OP));
        return false;
    }
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }

  /**
   * @return {number} - the distance sensor's value, scaled to the [0,100] range.
   */
  getDistance() {
    return this._peripheral.distance;
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */
  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }

  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */
  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }

  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */
  _isTilted(direction) {
    switch (direction) {
      case WeDo2TiltDirection.ANY:
        return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
      default:
        return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
    }
  }

  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */
  _getTiltAngle(direction) {
    switch (direction) {
      case WeDo2TiltDirection.UP:
        return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;
      case WeDo2TiltDirection.DOWN:
        return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;
      case WeDo2TiltDirection.LEFT:
        return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;
      case WeDo2TiltDirection.RIGHT:
        return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;
      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }

  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */
  _forEachMotor(motorID, callback) {
    let motors;
    switch (motorID) {
      case WeDo2MotorLabel.A:
        motors = [0];
        break;
      case WeDo2MotorLabel.B:
        motors = [1];
        break;
      case WeDo2MotorLabel.ALL:
      case WeDo2MotorLabel.DEFAULT:
        motors = [0, 1];
        break;
      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }
    for (const index of motors) {
      callback(index);
    }
  }

  /**
   * @param {number} midiNote - the MIDI note value to convert.
   * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.
   * @private
   */
  _noteToTone(midiNote) {
    // Note that MIDI note 69 is A4, 440 Hz
    return 440 * Math.pow(2, (midiNote - 69) / 12);
  }
}
module.exports = Scratch3WeDo2Blocks;

/***/ }),

/***/ "./src/import/load-costume.js":
/*!************************************!*\
  !*** ./src/import/load-costume.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const {
  loadSvgString,
  serializeSvgToString
} = __webpack_require__(/*! scratch-svg-renderer */ "./node_modules/scratch-svg-renderer/src/index.js");
const loadVector_ = function loadVector_(costume, runtime, rotationCenter, optVersion) {
  return new Promise(resolve => {
    let svgString = costume.asset.decodeText();
    // SVG Renderer load fixes "quirks" associated with Scratch 2 projects
    if (optVersion && optVersion === 2) {
      // scratch-svg-renderer fixes syntax that causes loading issues,
      // and if optVersion is 2, fixes "quirks" associated with Scratch 2 SVGs,
      const fixedSvgString = serializeSvgToString(loadSvgString(svgString, true /* fromVersion2 */));

      // If the string changed, put back into storage
      if (svgString !== fixedSvgString) {
        svgString = fixedSvgString;
        const storage = runtime.storage;
        costume.asset.encodeTextData(fixedSvgString, storage.DataFormat.SVG, true);
        costume.assetId = costume.asset.assetId;
        costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
      }
    }

    // createSVGSkin does the right thing if rotationCenter isn't provided, so it's okay if it's
    // undefined here
    costume.skinId = runtime.renderer.createSVGSkin(svgString, rotationCenter);
    costume.size = runtime.renderer.getSkinSize(costume.skinId);
    // Now we should have a rotationCenter even if we didn't before
    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
      costume.bitmapResolution = 1;
    }
    resolve(costume);
  });
};
const canvasPool = function () {
  /**
   * A pool of canvas objects that can be reused to reduce memory
   * allocations. And time spent in those allocations and the later garbage
   * collection.
   */
  class CanvasPool {
    constructor() {
      this.pool = [];
      this.clearSoon = null;
    }

    /**
     * After a short wait period clear the pool to let the VM collect
     * garbage.
     */
    clear() {
      if (!this.clearSoon) {
        this.clearSoon = new Promise(resolve => setTimeout(resolve, 1000)).then(() => {
          this.pool.length = 0;
          this.clearSoon = null;
        });
      }
    }

    /**
     * Return a canvas. Create the canvas if the pool is empty.
     * @returns {HTMLCanvasElement} A canvas element.
     */
    create() {
      return this.pool.pop() || document.createElement('canvas');
    }

    /**
     * Release the canvas to be reused.
     * @param {HTMLCanvasElement} canvas A canvas element.
     */
    release(canvas) {
      this.clear();
      this.pool.push(canvas);
    }
  }
  return new CanvasPool();
}();

/**
 * Return a promise to fetch a bitmap from storage and return it as a canvas
 * If the costume has bitmapResolution 1, it will be converted to bitmapResolution 2 here (the standard for Scratch 3)
 * If the costume has a text layer asset, which is a text part from Scratch 1.4, then this function
 * will merge the two image assets. See the issue LLK/scratch-vm#672 for more information.
 * @param {!object} costume - the Scratch costume object.
 * @param {!Runtime} runtime - Scratch runtime, used to access the v2BitmapAdapter
 * @param {?object} rotationCenter - optionally passed in coordinates for the center of rotation for the image. If
 *     none is given, the rotation center of the costume will be set to the middle of the costume later on.
 * @property {number} costume.bitmapResolution - the resolution scale for a bitmap costume.
 * @returns {?Promise} - a promise which will resolve to an object {canvas, rotationCenter, assetMatchesBase},
 *     or reject on error.
 *     assetMatchesBase is true if the asset matches the base layer; false if it required adjustment
 */
const fetchBitmapCanvas_ = function fetchBitmapCanvas_(costume, runtime, rotationCenter) {
  if (!costume || !costume.asset) {
    // TODO: We can probably remove this check...
    // TODO: reject with an Error (breaking API change!)
    // eslint-disable-next-line prefer-promise-reject-errors
    return Promise.reject('Costume load failed. Assets were missing.');
  }
  if (!runtime.v2BitmapAdapter) {
    // TODO: reject with an Error (breaking API change!)
    // eslint-disable-next-line prefer-promise-reject-errors
    return Promise.reject('No V2 Bitmap adapter present.');
  }
  return Promise.all([costume.asset, costume.textLayerAsset].map(asset => {
    if (!asset) {
      return null;
    }
    if (typeof createImageBitmap !== 'undefined') {
      return createImageBitmap(new Blob([asset.data], {
        type: asset.assetType.contentType
      }));
    }
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = function () {
        resolve(image);
        image.onload = null;
        image.onerror = null;
      };
      image.onerror = function () {
        // TODO: reject with an Error (breaking API change!)
        // eslint-disable-next-line prefer-promise-reject-errors
        reject('Costume load failed. Asset could not be read.');
        image.onload = null;
        image.onerror = null;
      };
      image.src = asset.encodeDataURI();
    });
  })).then(_ref => {
    let [baseImageElement, textImageElement] = _ref;
    const mergeCanvas = canvasPool.create();
    const scale = costume.bitmapResolution === 1 ? 2 : 1;
    mergeCanvas.width = baseImageElement.width;
    mergeCanvas.height = baseImageElement.height;
    const ctx = mergeCanvas.getContext('2d');
    ctx.drawImage(baseImageElement, 0, 0);
    if (textImageElement) {
      ctx.drawImage(textImageElement, 0, 0);
    }
    // Track the canvas we merged the bitmaps onto separately from the
    // canvas that we receive from resize if scale is not 1. We know
    // resize treats mergeCanvas as read only data. We don't know when
    // resize may use or modify the canvas. So we'll only release the
    // mergeCanvas back into the canvas pool. Reusing the canvas from
    // resize may cause errors.
    let canvas = mergeCanvas;
    if (scale !== 1) {
      canvas = runtime.v2BitmapAdapter.resize(mergeCanvas, canvas.width * scale, canvas.height * scale);
    }

    // By scaling, we've converted it to bitmap resolution 2
    if (rotationCenter) {
      rotationCenter[0] = rotationCenter[0] * scale;
      rotationCenter[1] = rotationCenter[1] * scale;
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
    }
    costume.bitmapResolution = 2;

    // Clean up the costume object
    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
    return {
      canvas,
      mergeCanvas,
      rotationCenter,
      // True if the asset matches the base layer; false if it required adjustment
      assetMatchesBase: scale === 1 && !textImageElement
    };
  }).finally(() => {
    // Clean up the text layer properties if it fails to load
    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
  });
};
const loadBitmap_ = function loadBitmap_(costume, runtime, _rotationCenter) {
  return fetchBitmapCanvas_(costume, runtime, _rotationCenter).then(fetched => {
    const updateCostumeAsset = function updateCostumeAsset(dataURI) {
      if (!runtime.v2BitmapAdapter) {
        // TODO: This might be a bad practice since the returned
        // promise isn't acted on. If this is something we should be
        // creating a rejected promise for we should also catch it
        // somewhere and act on that error (like logging).
        //
        // Return a rejection to stop executing updateCostumeAsset.
        // TODO: reject with an Error (breaking API change!)
        // eslint-disable-next-line prefer-promise-reject-errors
        return Promise.reject('No V2 Bitmap adapter present.');
      }
      const storage = runtime.storage;
      costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, storage.DataFormat.PNG, runtime.v2BitmapAdapter.convertDataURIToBinary(dataURI), null, true // generate md5
      );
      costume.dataFormat = storage.DataFormat.PNG;
      costume.assetId = costume.asset.assetId;
      costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
    };
    if (!fetched.assetMatchesBase) {
      updateCostumeAsset(fetched.canvas.toDataURL());
    }
    return fetched;
  }).then(_ref2 => {
    let {
      canvas,
      mergeCanvas,
      rotationCenter
    } = _ref2;
    // createBitmapSkin does the right thing if costume.rotationCenter is undefined.
    // That will be the case if you upload a bitmap asset or create one by taking a photo.
    let center;
    if (rotationCenter) {
      // fetchBitmapCanvas will ensure that the costume's bitmap resolution is 2 and its rotation center is
      // scaled to match, so it's okay to always divide by 2.
      center = [rotationCenter[0] / 2, rotationCenter[1] / 2];
    }

    // TODO: costume.bitmapResolution will always be 2 at this point because of fetchBitmapCanvas_, so we don't
    // need to pass it in here.
    costume.skinId = runtime.renderer.createBitmapSkin(canvas, costume.bitmapResolution, center);
    canvasPool.release(mergeCanvas);
    const renderSize = runtime.renderer.getSkinSize(costume.skinId);
    costume.size = [renderSize[0] * 2, renderSize[1] * 2]; // Actual size, since all bitmaps are resolution 2

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);
      // Actual rotation center, since all bitmaps are resolution 2
      costume.rotationCenterX = rotationCenter[0] * 2;
      costume.rotationCenterY = rotationCenter[1] * 2;
      costume.bitmapResolution = 2;
    }
    return costume;
  });
};

// Handle all manner of costume errors with a Gray Question Mark (default costume)
// and preserve as much of the original costume data as possible
// Returns a promise of a costume
const handleCostumeLoadError = function handleCostumeLoadError(costume, runtime) {
  // Keep track of the old asset information until we're done loading the default costume
  const oldAsset = costume.asset; // could be null
  const oldAssetId = costume.assetId;
  const oldRotationX = costume.rotationCenterX;
  const oldRotationY = costume.rotationCenterY;
  const oldBitmapResolution = costume.bitmapResolution;
  const oldDataFormat = costume.dataFormat;
  const AssetType = runtime.storage.AssetType;
  const isVector = costume.dataFormat === AssetType.ImageVector.runtimeFormat;

  // Use default asset if original fails to load
  costume.assetId = isVector ? runtime.storage.defaultAssetId.ImageVector : runtime.storage.defaultAssetId.ImageBitmap;
  costume.asset = runtime.storage.get(costume.assetId);
  costume.md5 = "".concat(costume.assetId, ".").concat(costume.asset.dataFormat);
  const defaultCostumePromise = isVector ? loadVector_(costume, runtime) : loadBitmap_(costume, runtime);
  return defaultCostumePromise.then(loadedCostume => {
    loadedCostume.broken = {};
    loadedCostume.broken.assetId = oldAssetId;
    loadedCostume.broken.md5 = "".concat(oldAssetId, ".").concat(oldDataFormat);

    // Should be null if we got here because the costume was missing
    loadedCostume.broken.asset = oldAsset;
    loadedCostume.broken.dataFormat = oldDataFormat;
    loadedCostume.broken.rotationCenterX = oldRotationX;
    loadedCostume.broken.rotationCenterY = oldRotationY;
    loadedCostume.broken.bitmapResolution = oldBitmapResolution;
    return loadedCostume;
  });
};

/**
 * Initialize a costume from an asset asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @property {!Asset} costume.asset - the asset of the costume loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set
 *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */
const loadCostumeFromAsset = function loadCostumeFromAsset(costume, runtime, optVersion) {
  costume.assetId = costume.asset.assetId;
  const renderer = runtime.renderer;
  if (!renderer) {
    log.warn('No rendering module present; cannot load costume: ', costume.name);
    return Promise.resolve(costume);
  }
  const AssetType = runtime.storage.AssetType;
  let rotationCenter;
  // Use provided rotation center and resolution if they are defined. Bitmap resolution
  // should only ever be 1 or 2.
  if (typeof costume.rotationCenterX === 'number' && !isNaN(costume.rotationCenterX) && typeof costume.rotationCenterY === 'number' && !isNaN(costume.rotationCenterY)) {
    rotationCenter = [costume.rotationCenterX, costume.rotationCenterY];
  }
  if (costume.asset.assetType.runtimeFormat === AssetType.ImageVector.runtimeFormat) {
    return loadVector_(costume, runtime, rotationCenter, optVersion).catch(error => {
      log.warn("Error loading vector image: ".concat(error));
      return handleCostumeLoadError(costume, runtime);
    });
  }
  return loadBitmap_(costume, runtime, rotationCenter, optVersion).catch(error => {
    log.warn("Error loading bitmap image: ".concat(error));
    return handleCostumeLoadError(costume, runtime);
  });
};

/**
 * Load a costume's asset into memory asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {!string} md5ext - the MD5 and extension of the costume to be loaded.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set
 *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */
const loadCostume = function loadCostume(md5ext, costume, runtime, optVersion) {
  const idParts = StringUtil.splitFirst(md5ext, '.');
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  costume.dataFormat = ext;
  if (costume.asset) {
    // Costume comes with asset. It could be coming from image upload, drag and drop, or file
    return loadCostumeFromAsset(costume, runtime, optVersion);
  }

  // Need to load the costume from storage. The server should have a reference to this md5.
  if (!runtime.storage) {
    log.warn('No storage module present; cannot load costume asset: ', md5ext);
    return Promise.resolve(costume);
  }
  if (!runtime.storage.defaultAssetId) {
    log.warn("No default assets found");
    return Promise.resolve(costume);
  }
  const AssetType = runtime.storage.AssetType;
  const assetType = ext === 'svg' ? AssetType.ImageVector : AssetType.ImageBitmap;
  const costumePromise = runtime.storage.load(assetType, md5, ext);
  let textLayerPromise;
  if (costume.textLayerMD5) {
    textLayerPromise = runtime.storage.load(AssetType.ImageBitmap, costume.textLayerMD5, 'png');
  } else {
    textLayerPromise = Promise.resolve(null);
  }
  return Promise.all([costumePromise, textLayerPromise]).then(assetArray => {
    if (assetArray[0]) {
      costume.asset = assetArray[0];
    } else {
      return handleCostumeLoadError(costume, runtime);
    }
    if (assetArray[1]) {
      costume.textLayerAsset = assetArray[1];
    }
    return loadCostumeFromAsset(costume, runtime, optVersion);
  }).catch(error => {
    // Handle case where storage.load rejects with errors
    // instead of resolving null
    log.warn('Error loading costume: ', error);
    return handleCostumeLoadError(costume, runtime);
  });
};
module.exports = {
  loadCostume,
  loadCostumeFromAsset
};

/***/ }),

/***/ "./src/import/load-sound.js":
/*!**********************************!*\
  !*** ./src/import/load-sound.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

/**
 * Initialize a sound from an asset asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Asset} soundAsset - the asset loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */
const loadSoundFromAsset = function loadSoundFromAsset(sound, soundAsset, runtime, soundBank) {
  sound.assetId = soundAsset.assetId;
  if (!runtime.audioEngine) {
    log.warn('No audio engine present; cannot load sound asset: ', sound.md5);
    return Promise.resolve(sound);
  }
  return runtime.audioEngine.decodeSoundPlayer(Object.assign({}, sound, {
    data: soundAsset.data
  })).then(soundPlayer => {
    sound.soundId = soundPlayer.id;
    // Set the sound sample rate and sample count based on the
    // the audio buffer from the audio engine since the sound
    // gets resampled by the audio engine
    const soundBuffer = soundPlayer.buffer;
    sound.rate = soundBuffer.sampleRate;
    sound.sampleCount = soundBuffer.length;
    if (soundBank !== null) {
      soundBank.addSoundPlayer(soundPlayer);
    }
    return sound;
  });
};

// Handle sound loading errors by replacing the runtime sound with the
// default sound from storage, but keeping track of the original sound metadata
// in a `broken` field
const handleSoundLoadError = function handleSoundLoadError(sound, runtime, soundBank) {
  // Keep track of the old asset information until we're done loading the default sound
  const oldAsset = sound.asset; // could be null
  const oldAssetId = sound.assetId;
  const oldSample = sound.sampleCount;
  const oldRate = sound.rate;
  const oldFormat = sound.format;
  const oldDataFormat = sound.dataFormat;

  // Use default asset if original fails to load
  sound.assetId = runtime.storage.defaultAssetId.Sound;
  sound.asset = runtime.storage.get(sound.assetId);
  sound.md5 = "".concat(sound.assetId, ".").concat(sound.asset.dataFormat);
  return loadSoundFromAsset(sound, sound.asset, runtime, soundBank).then(loadedSound => {
    loadedSound.broken = {};
    loadedSound.broken.assetId = oldAssetId;
    loadedSound.broken.md5 = "".concat(oldAssetId, ".").concat(oldDataFormat);

    // Should be null if we got here because the sound was missing
    loadedSound.broken.asset = oldAsset;
    loadedSound.broken.sampleCount = oldSample;
    loadedSound.broken.rate = oldRate;
    loadedSound.broken.format = oldFormat;
    loadedSound.broken.dataFormat = oldDataFormat;
    return loadedSound;
  });
};

/**
 * Load a sound's asset into memory asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */
const loadSound = function loadSound(sound, runtime, soundBank) {
  if (!runtime.storage) {
    log.warn('No storage module present; cannot load sound asset: ', sound.md5);
    return Promise.resolve(sound);
  }
  const idParts = StringUtil.splitFirst(sound.md5, '.');
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  sound.dataFormat = ext;
  return (sound.asset && Promise.resolve(sound.asset) || runtime.storage.load(runtime.storage.AssetType.Sound, md5, ext)).then(soundAsset => {
    sound.asset = soundAsset;
    if (!soundAsset) {
      log.warn('Failed to find sound data: ', sound.md5);
      return handleSoundLoadError(sound, runtime, soundBank);
    }
    return loadSoundFromAsset(sound, soundAsset, runtime, soundBank);
  }).catch(e => {
    log.warn("Failed to load sound: ".concat(sound.md5, " with error: ").concat(e));
    return handleSoundLoadError(sound, runtime, soundBank);
  });
};
module.exports = {
  loadSound,
  loadSoundFromAsset
};

/***/ }),

/***/ "./src/io/ble.js":
/*!***********************!*\
  !*** ./src/io/ble.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");
class BLE extends JSONRPC {
  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback) {
    let resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    super();
    this._socket = runtime.getScratchLinkSocket('BLE');
    this._socket.setOnOpen(this.requestPeripheral.bind(this));
    this._socket.setOnClose(this.handleDisconnectError.bind(this));
    this._socket.setOnError(this._handleRequestError.bind(this));
    this._socket.setHandleMessage(this._handleMessage.bind(this));
    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;
    this._socket.open();
  }

  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */
  requestPeripheral() {
    this._availablePeripherals = {};
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }
    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => {
      this._handleRequestError(e);
    });
  }

  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   */
  connectPeripheral(id) {
    this.sendRemoteRequest('connect', {
      peripheralId: id
    }).then(() => {
      this._connected = true;
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);
      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }

  /**
   * Close the websocket.
   */
  disconnect() {
    if (this._connected) {
      this._connected = false;
    }
    if (this._socket.isOpen()) {
      this._socket.close();
    }
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    // Sets connection status icon to orange
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }

  /**
   * @return {bool} whether the peripheral is connected.
   */
  isConnected() {
    return this._connected;
  }

  /**
   * Start receiving notifications from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to get notifications from.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote startNotifications request.
   */
  startNotifications(serviceId, characteristicId) {
    let onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const params = {
      serviceId,
      characteristicId
    };
    this._characteristicDidChangeCallback = onCharacteristicChanged;
    return this.sendRemoteRequest('startNotifications', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }

  /**
   * Read from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to read.
   * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote read request.
   */
  read(serviceId, characteristicId) {
    let optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    const params = {
      serviceId,
      characteristicId
    };
    if (optStartNotifications) {
      params.startNotifications = true;
    }
    if (onCharacteristicChanged) {
      this._characteristicDidChangeCallback = onCharacteristicChanged;
    }
    return this.sendRemoteRequest('read', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }

  /**
   * Write data to the specified ble service.
   * @param {number} serviceId - the ble service to write.
   * @param {number} characteristicId - the ble characteristic to write.
   * @param {string} message - the message to send.
   * @param {string} encoding - the message encoding type.
   * @param {boolean} withResponse - if true, resolve after peripheral's response.
   * @return {Promise} - a promise from the remote send request.
   */
  write(serviceId, characteristicId, message) {
    let encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    let withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    const params = {
      serviceId,
      characteristicId,
      message
    };
    if (encoding) {
      params.encoding = encoding;
    }
    if (withResponse !== null) {
      params.withResponse = withResponse;
    }
    return this.sendRemoteRequest('write', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }

  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */
  didReceiveCall(method, params) {
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'userDidPickPeripheral':
        this._availablePeripherals[params.peripheralId] = params;
        this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'userDidNotPickPeripheral':
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'characteristicDidChange':
        if (this._characteristicDidChangeCallback) {
          this._characteristicDidChangeCallback(params.message);
        }
        break;
      case 'ping':
        return 42;
    }
  }

  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */
  handleDisconnectError( /* e */
  ) {
    // log.error(`BLE error: ${JSON.stringify(e)}`);

    if (!this._connected) return;
    this.disconnect();
    if (this._resetCallback) {
      this._resetCallback();
    }
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }
  _handleRequestError( /* e */
  ) {
    // log.error(`BLE error: ${JSON.stringify(e)}`);

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }
  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }
}
module.exports = BLE;

/***/ }),

/***/ "./src/io/bt.js":
/*!**********************!*\
  !*** ./src/io/bt.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");
class BT extends JSONRPC {
  /**
   * A BT peripheral socket object.  It handles connecting, over web sockets, to
   * BT peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   * @param {object} messageCallback - a callback for message sending.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback) {
    let resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    let messageCallback = arguments.length > 5 ? arguments[5] : undefined;
    super();
    this._socket = runtime.getScratchLinkSocket('BT');
    this._socket.setOnOpen(this.requestPeripheral.bind(this));
    this._socket.setOnError(this._handleRequestError.bind(this));
    this._socket.setOnClose(this.handleDisconnectError.bind(this));
    this._socket.setHandleMessage(this._handleMessage.bind(this));
    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._messageCallback = messageCallback;
    this._runtime = runtime;
    this._socket.open();
  }

  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */
  requestPeripheral() {
    this._availablePeripherals = {};
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }
    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => this._handleRequestError(e));
  }

  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   * @param {string} pin - an optional pin for pairing
   */
  connectPeripheral(id) {
    let pin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const params = {
      peripheralId: id
    };
    if (pin) {
      params.pin = pin;
    }
    this.sendRemoteRequest('connect', params).then(() => {
      this._connected = true;
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);
      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }

  /**
   * Close the websocket.
   */
  disconnect() {
    if (this._connected) {
      this._connected = false;
    }
    if (this._socket.isOpen()) {
      this._socket.close();
    }
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    // Sets connection status icon to orange
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }

  /**
   * @return {bool} whether the peripheral is connected.
   */
  isConnected() {
    return this._connected;
  }
  sendMessage(options) {
    return this.sendRemoteRequest('send', options).catch(e => {
      this.handleDisconnectError(e);
    });
  }

  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */
  didReceiveCall(method, params) {
    // TODO: Add peripheral 'undiscover' handling
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'userDidPickPeripheral':
        this._availablePeripherals[params.peripheralId] = params;
        this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'userDidNotPickPeripheral':
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }
        break;
      case 'didReceiveMessage':
        this._messageCallback(params); // TODO: refine?
        break;
      default:
        return 'nah';
    }
  }

  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */
  handleDisconnectError( /* e */
  ) {
    // log.error(`BT error: ${JSON.stringify(e)}`);

    if (!this._connected) return;
    this.disconnect();
    if (this._resetCallback) {
      this._resetCallback();
    }
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }
  _handleRequestError( /* e */
  ) {
    // log.error(`BT error: ${JSON.stringify(e)}`);

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }
  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }
}
module.exports = BT;

/***/ }),

/***/ "./src/io/clock.js":
/*!*************************!*\
  !*** ./src/io/clock.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
class Clock {
  constructor(runtime) {
    this._projectTimer = new Timer({
      now: () => runtime.currentMSecs
    });
    this._projectTimer.start();
    this._pausedTime = null;
    this._paused = false;
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }
  projectTimer() {
    if (this._paused) {
      return this._pausedTime / 1000;
    }
    return this._projectTimer.timeElapsed() / 1000;
  }
  pause() {
    this._paused = true;
    this._pausedTime = this._projectTimer.timeElapsed();
  }
  resume() {
    this._paused = false;
    const dt = this._projectTimer.timeElapsed() - this._pausedTime;
    this._projectTimer.startTime += dt;
  }
  resetProjectTimer() {
    this._projectTimer.start();
  }
}
module.exports = Clock;

/***/ }),

/***/ "./src/io/cloud.js":
/*!*************************!*\
  !*** ./src/io/cloud.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
class Cloud {
  /**
   * @typedef updateVariable
   * @param {string} name The name of the cloud variable to update on the server
   * @param {(string | number)} value The value to update the cloud variable with.
   */

  /**
   * A cloud data provider, responsible for managing the connection to the
   * cloud data server and for posting data about cloud data activity to
   * this IO device.
   * @typedef {object} CloudProvider
   * @property {updateVariable} updateVariable A function which sends a cloud variable
   * update to the cloud data server.
   * @property {Function} requestCloseConnection A function which closes
   * the connection to the cloud data server.
   */

  /**
   * Part of a cloud io data post indicating a cloud variable update.
   * @typedef {object} VarUpdateData
   * @property {string} name The name of the variable to update
   * @property {(number | string)} value The scalar value to update the variable with
   */

  /**
   * A cloud io data post message.
   * @typedef {object} CloudIOData
   * @property {VarUpdateData} varUpdate A {@link VarUpdateData} message indicating
   * a cloud variable update
   */

  /**
   * Cloud IO Device responsible for sending and receiving messages from
   * cloud provider (mananging the cloud server connection) and interacting
   * with cloud variables in the current project.
   * @param {Runtime} runtime The runtime context for this cloud io device.
   */
  constructor(runtime) {
    /**
     * Reference to the cloud data provider, responsible for mananging
     * the web socket connection to the cloud data server.
     * @type {?CloudProvider}
     */
    this.provider = null;

    /**
     * Reference to the runtime that owns this cloud io device.
     * @type {!Runtime}
     */
    this.runtime = runtime;

    /**
     * Reference to the stage target which owns the cloud variables
     * in the project.
     * @type {?Target}
     */
    this.stage = null;
  }

  /**
   * Set a reference to the cloud data provider.
   * @param {CloudProvider} provider The cloud data provider
   */
  setProvider(provider) {
    this.provider = provider;
  }

  /**
   * Set a reference to the stage target which owns the
   * cloud variables in the project.
   * @param {Target} stage The stage target
   */
  setStage(stage) {
    this.stage = stage;
  }

  /**
   * Handle incoming data to this io device.
   * @param {CloudIOData} data The {@link CloudIOData} object to process
   */
  postData(data) {
    if (data.varUpdate) {
      this.updateCloudVariable(data.varUpdate);
    }
  }
  requestCreateVariable(variable) {
    if (this.runtime.canAddCloudVariable()) {
      if (this.provider) {
        this.provider.createVariable(variable.name, variable.value);
        // We'll set the cloud flag and update the
        // cloud variable limit when we actually
        // get a confirmation from the cloud data server
      }
    } // TODO else track creation for later
  }

  /**
   * Request the cloud data provider to update the given variable with
   * the given value. Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to update
   * @param {string | number} value The value to update the variable with
   */
  requestUpdateVariable(name, value) {
    if (this.provider) {
      this.provider.updateVariable(name, value);
    }
  }

  /**
   * Request the cloud data provider to rename the variable with the given name
   * to the given new name. Does nothing if this io device does not have a provider set.
   * @param {string} oldName The name of the variable to rename
   * @param {string | number} newName The new name for the variable
   */
  requestRenameVariable(oldName, newName) {
    if (this.provider) {
      this.provider.renameVariable(oldName, newName);
    }
  }

  /**
   * Request the cloud data provider to delete the variable with the given name
   * Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to delete
   */
  requestDeleteVariable(name) {
    if (this.provider) {
      this.provider.deleteVariable(name);
    }
  }

  /**
   * Update a cloud variable in the runtime based on the message received
   * from the cloud provider.
   * @param {VarData} varUpdate A {@link VarData} object describing
   * a cloud variable update received from the cloud data provider.
   */
  updateCloudVariable(varUpdate) {
    const varName = varUpdate.name;
    const variable = this.stage.lookupVariableByNameAndType(varName, Variable.SCALAR_TYPE);
    if (!variable || !variable.isCloud) {
      log.warn("Received an update for a cloud variable that does not exist: ".concat(varName));
      return;
    }
    variable.value = varUpdate.value;
  }

  /**
   * Request the cloud data provider to close the web socket connection and
   * clear this io device of references to the cloud data provider and the
   * stage.
   */
  clear() {
    if (!this.provider) return;
    this.provider.requestCloseConnection();
    this.provider = null;
    this.stage = null;
  }
}
module.exports = Cloud;

/***/ }),

/***/ "./src/io/keyboard.js":
/*!****************************!*\
  !*** ./src/io/keyboard.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

/**
 * Names used internally for keys used in scratch, also known as "scratch keys".
 * @enum {string}
 */
const KEY_NAME = {
  SPACE: 'space',
  LEFT: 'left arrow',
  UP: 'up arrow',
  RIGHT: 'right arrow',
  DOWN: 'down arrow',
  ENTER: 'enter'
};

/**
 * An array of the names of scratch keys.
 * @type {Array<string>}
 */
const KEY_NAME_LIST = Object.keys(KEY_NAME).map(name => KEY_NAME[name]);
class Keyboard {
  constructor(runtime) {
    /**
     * List of currently pressed scratch keys.
     * A scratch key is:
     * A key you can press on a keyboard, excluding modifier keys.
     * An uppercase string of length one;
     *     except for special key names for arrow keys and space (e.g. 'left arrow').
     * Can be a non-english unicode letter like:      .
     * @type{Array.<string>}
     */
    this._keysPressed = [];
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Convert from a keyboard event key name to a Scratch key name.
   * @param  {string} keyString the input key string.
   * @return {string} the corresponding Scratch key, or an empty string.
   */
  _keyStringToScratchKey(keyString) {
    keyString = Cast.toString(keyString);
    // Convert space and arrow keys to their Scratch key names.
    switch (keyString) {
      case ' ':
        return KEY_NAME.SPACE;
      case 'ArrowLeft':
      case 'Left':
        return KEY_NAME.LEFT;
      case 'ArrowUp':
      case 'Up':
        return KEY_NAME.UP;
      case 'Right':
      case 'ArrowRight':
        return KEY_NAME.RIGHT;
      case 'Down':
      case 'ArrowDown':
        return KEY_NAME.DOWN;
      case 'Enter':
        return KEY_NAME.ENTER;
    }
    // Ignore modifier keys
    if (keyString.length > 1) {
      return '';
    }
    return keyString.toUpperCase();
  }

  /**
   * Convert from a block argument to a Scratch key name.
   * @param  {string} keyArg the input arg.
   * @return {string} the corresponding Scratch key.
   */
  _keyArgToScratchKey(keyArg) {
    // If a number was dropped in, try to convert from ASCII to Scratch key.
    if (typeof keyArg === 'number') {
      // Check for the ASCII range containing numbers, some punctuation,
      // and uppercase letters.
      if (keyArg >= 48 && keyArg <= 90) {
        return String.fromCharCode(keyArg);
      }
      switch (keyArg) {
        case 32:
          return KEY_NAME.SPACE;
        case 37:
          return KEY_NAME.LEFT;
        case 38:
          return KEY_NAME.UP;
        case 39:
          return KEY_NAME.RIGHT;
        case 40:
          return KEY_NAME.DOWN;
      }
    }
    keyArg = Cast.toString(keyArg);

    // If the arg matches a special key name, return it.
    if (KEY_NAME_LIST.includes(keyArg)) {
      return keyArg;
    }

    // Use only the first character.
    if (keyArg.length > 1) {
      keyArg = keyArg[0];
    }

    // Check for the space character.
    if (keyArg === ' ') {
      return KEY_NAME.SPACE;
    }
    return keyArg.toUpperCase();
  }

  /**
   * Keyboard DOM event handler.
   * @param  {object} data Data from DOM event.
   */
  postData(data) {
    if (!data.key) return;
    const scratchKey = this._keyStringToScratchKey(data.key);
    if (scratchKey === '') return;
    const index = this._keysPressed.indexOf(scratchKey);
    if (data.isDown) {
      this.runtime.emit('KEY_PRESSED', scratchKey);
      // If not already present, add to the list.
      if (index < 0) {
        this._keysPressed.push(scratchKey);
      }
    } else if (index > -1) {
      // If already present, remove from the list.
      this._keysPressed.splice(index, 1);
    }
  }

  /**
   * Get key down state for a specified key.
   * @param  {Any} keyArg key argument.
   * @return {boolean} Is the specified key down?
   */
  getKeyIsDown(keyArg) {
    if (keyArg === 'any') {
      return this._keysPressed.length > 0;
    }
    const scratchKey = this._keyArgToScratchKey(keyArg);
    return this._keysPressed.indexOf(scratchKey) > -1;
  }
}
module.exports = Keyboard;

/***/ }),

/***/ "./src/io/mouse.js":
/*!*************************!*\
  !*** ./src/io/mouse.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
class Mouse {
  constructor(runtime) {
    this._x = 0;
    this._y = 0;
    this._isDown = false;
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Activate "event_whenthisspriteclicked" hats.
   * @param  {Target} target to trigger hats on.
   * @private
   */
  _activateClickHats(target) {
    // Activate both "this sprite clicked" and "stage clicked"
    // They were separated into two opcodes for labeling,
    // but should act the same way.
    // Intentionally not checking isStage to make it work when sharing blocks.
    // @todo the blocks should be converted from one to another when shared
    this.runtime.startHats('event_whenthisspriteclicked', null, target);
    this.runtime.startHats('event_whenstageclicked', null, target);
  }

  /**
   * Find a target by XY location
   * @param  {number} x X position to be sent to the renderer.
   * @param  {number} y Y position to be sent to the renderer.
   * @return {Target} the target at that location
   * @private
   */
  _pickTarget(x, y) {
    if (this.runtime.renderer) {
      const drawableID = this.runtime.renderer.pick(x, y);
      for (let i = 0; i < this.runtime.targets.length; i++) {
        const target = this.runtime.targets[i];
        if (Object.prototype.hasOwnProperty.call(target, 'drawableID') && target.drawableID === drawableID) {
          return target;
        }
      }
    }
    // Return the stage if no target was found
    return this.runtime.getTargetForStage();
  }

  /**
   * Mouse DOM event handler.
   * @param  {object} data Data from DOM event.
   */
  postData(data) {
    if (data.x) {
      this._clientX = data.x;
      this._scratchX = Math.round(MathUtil.clamp(480 * (data.x / data.canvasWidth - 0.5), -240, 240));
    }
    if (data.y) {
      this._clientY = data.y;
      this._scratchY = Math.round(MathUtil.clamp(-360 * (data.y / data.canvasHeight - 0.5), -180, 180));
    }
    if (typeof data.isDown !== 'undefined') {
      const previousDownState = this._isDown;
      this._isDown = data.isDown;

      // Do not trigger if down state has not changed
      if (previousDownState === this._isDown) return;

      // Never trigger click hats at the end of a drag
      if (data.wasDragged) return;

      // Do not activate click hats for clicks outside canvas bounds
      if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;
      const target = this._pickTarget(data.x, data.y);
      const isNewMouseDown = !previousDownState && this._isDown;
      const isNewMouseUp = previousDownState && !this._isDown;

      // Draggable targets start click hats on mouse up.
      // Non-draggable targets start click hats on mouse down.
      if (target.draggable && isNewMouseUp) {
        this._activateClickHats(target);
      } else if (!target.draggable && isNewMouseDown) {
        this._activateClickHats(target);
      }
    }
  }

  /**
   * Get the X position of the mouse in client coordinates.
   * @return {number} Non-clamped X position of the mouse cursor.
   */
  getClientX() {
    return this._clientX;
  }

  /**
   * Get the Y position of the mouse in client coordinates.
   * @return {number} Non-clamped Y position of the mouse cursor.
   */
  getClientY() {
    return this._clientY;
  }

  /**
   * Get the X position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded X position of the mouse cursor.
   */
  getScratchX() {
    return this._scratchX;
  }

  /**
   * Get the Y position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded Y position of the mouse cursor.
   */
  getScratchY() {
    return this._scratchY;
  }

  /**
   * Get the down state of the mouse.
   * @return {boolean} Is the mouse down?
   */
  getIsDown() {
    return this._isDown;
  }
}
module.exports = Mouse;

/***/ }),

/***/ "./src/io/mouseWheel.js":
/*!******************************!*\
  !*** ./src/io/mouseWheel.js ***!
  \******************************/
/***/ ((module) => {

class MouseWheel {
  constructor(runtime) {
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }

  /**
   * Mouse wheel DOM event handler.
   * @param  {object} data Data from DOM event.
   */
  postData(data) {
    const matchFields = {};
    if (data.deltaY < 0) {
      matchFields.KEY_OPTION = 'up arrow';
    } else if (data.deltaY > 0) {
      matchFields.KEY_OPTION = 'down arrow';
    } else {
      return;
    }
    this.runtime.startHats('event_whenkeypressed', matchFields);
  }
}
module.exports = MouseWheel;

/***/ }),

/***/ "./src/io/userData.js":
/*!****************************!*\
  !*** ./src/io/userData.js ***!
  \****************************/
/***/ ((module) => {

class UserData {
  constructor() {
    this._username = '';
  }

  /**
   * Handler for updating the username
   * @param {object} data Data posted to this ioDevice.
   * @property {!string} username The new username.
   */
  postData(data) {
    this._username = data.username;
  }

  /**
   * Getter for username. Initially empty string, until set via postData.
   * @returns {!string} The current username
   */
  getUsername() {
    return this._username;
  }
}
module.exports = UserData;

/***/ }),

/***/ "./src/io/video.js":
/*!*************************!*\
  !*** ./src/io/video.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
class Video {
  constructor(runtime) {
    this.runtime = runtime;

    /**
     * @typedef VideoProvider
     * @property {Function} enableVideo - Requests camera access from the user, and upon success,
     * enables the video feed
     * @property {Function} disableVideo - Turns off the video feed
     * @property {Function} getFrame - Return frame data from the video feed in
     * specified dimensions, format, and mirroring.
     */
    this.provider = null;

    /**
     * Id representing a Scratch Renderer skin the video is rendered to for
     * previewing.
     * @type {number}
     */
    this._skinId = -1;

    /**
     * Id for a drawable using the video's skin that will render as a video
     * preview.
     * @type {Drawable}
     */
    this._drawable = -1;

    /**
     * Store the last state of the video transparency ghost effect
     * @type {number}
     */
    this._ghost = 0;

    /**
     * Store a flag that allows the preview to be forced transparent.
     * @type {number}
     */
    this._forceTransparentPreview = false;
  }
  static get FORMAT_IMAGE_DATA() {
    return 'image-data';
  }
  static get FORMAT_CANVAS() {
    return 'canvas';
  }

  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */
  static get DIMENSIONS() {
    return [480, 360];
  }

  /**
   * Order preview drawable is inserted at in the renderer.
   * @type {number}
   */
  static get ORDER() {
    return 1;
  }

  /**
   * Set a video provider for this device. A default implementation of
   * a video provider can be found in scratch-gui/src/lib/video/video-provider
   * @param {VideoProvider} provider - Video provider to use
   */
  setProvider(provider) {
    this.provider = provider;
  }

  /**
   * Request video be enabled.  Sets up video, creates video skin and enables preview.
   *
   * ioDevices.video.requestVideo()
   *
   * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.
   */
  enableVideo() {
    if (!this.provider) return null;
    return this.provider.enableVideo().then(() => this._setupPreview());
  }

  /**
   * Disable video stream (turn video off)
   * @return {void}
   */
  disableVideo() {
    this._disablePreview();
    if (!this.provider) return null;
    this.provider.disableVideo();
  }

  /**
   * Return frame data from the video feed in a specified dimensions, format, and mirroring.
   *
   * @param {object} frameInfo A descriptor of the frame you would like to receive.
   * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]
   * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global
   *                                   mirror state (ioDevices.video.mirror)
   * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.
   * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than
   *                                        the cacheTimeout.  Defaults to 16ms.
   *
   * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.
   */
  getFrame(_ref) {
    let {
      dimensions = Video.DIMENSIONS,
      mirror = this.mirror,
      format = Video.FORMAT_IMAGE_DATA,
      cacheTimeout = this._frameCacheTimeout
    } = _ref;
    if (this.provider) return this.provider.getFrame({
      dimensions,
      mirror,
      format,
      cacheTimeout
    });
    return null;
  }

  /**
   * Set the preview ghost effect
   * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect
   */
  setPreviewGhost(ghost) {
    this._ghost = ghost;
    // Confirm that the default value has been changed to a valid id for the drawable
    if (this._drawable !== -1) {
      this.runtime.renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : ghost);
    }
  }
  _disablePreview() {
    if (this._skinId !== -1) {
      this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
      this.runtime.renderer.updateDrawableVisible(this._drawable, false);
    }
    this._renderPreviewFrame = null;
  }
  _setupPreview() {
    const {
      renderer
    } = this.runtime;
    if (!renderer) return;
    if (this._skinId === -1 && this._drawable === -1) {
      this._skinId = renderer.createBitmapSkin(new ImageData(...Video.DIMENSIONS), 1);
      this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);
      renderer.updateDrawableSkinId(this._drawable, this._skinId);
    }

    // if we haven't already created and started a preview frame render loop, do so
    if (!this._renderPreviewFrame) {
      renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : this._ghost);
      renderer.updateDrawableVisible(this._drawable, true);
      this._renderPreviewFrame = () => {
        clearTimeout(this._renderPreviewTimeout);
        if (!this._renderPreviewFrame) {
          return;
        }
        this._renderPreviewTimeout = setTimeout(this._renderPreviewFrame, this.runtime.currentStepTime);
        const imageData = this.getFrame({
          format: Video.FORMAT_IMAGE_DATA,
          cacheTimeout: this.runtime.currentStepTime
        });
        if (!imageData) {
          renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
          return;
        }
        renderer.updateBitmapSkin(this._skinId, imageData, 1);
        this.runtime.requestRedraw();
      };
      this._renderPreviewFrame();
    }
  }
  get videoReady() {
    if (this.provider) return this.provider.videoReady;
    return false;
  }

  /**
   * Method implemented by all IO devices to allow external changes.
   * The only change available externally is hiding the preview, used e.g. to
   * prevent drawing the preview into project thumbnails.
   * @param {object} - data passed to this IO device.
   * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.
   */
  postData(_ref2) {
    let {
      forceTransparentPreview
    } = _ref2;
    this._forceTransparentPreview = forceTransparentPreview;
    // Setting the ghost to the current value will pick up the forceTransparentPreview
    // flag and override the current ghost. The complexity is to prevent blocks
    // from overriding forceTransparentPreview
    this.setPreviewGhost(this._ghost);
  }
}
module.exports = Video;

/***/ }),

/***/ "./src/serialization/deserialize-assets.js":
/*!*************************************************!*\
  !*** ./src/serialization/deserialize-assets.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

/**
 * Deserializes sound from file into storage cache so that it can
 * be loaded into the runtime.
 * @param {object} sound Descriptor for sound from sb3 file
 * @param {Runtime} runtime The runtime containing the storage to cache the sounds in
 * @param {JSZip} zip The zip containing the sound file being described by `sound`
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @return {Promise} Promise that resolves after the described sound has been stored
 * into the runtime storage cache, the sound was already stored, or an error has
 * occurred.
 */
const deserializeSound = function deserializeSound(sound, runtime, zip, assetFileName) {
  const fileName = assetFileName ? assetFileName : sound.md5;
  const storage = runtime.storage;
  if (!storage) {
    log.warn('No storage module present; cannot load sound asset: ', fileName);
    return Promise.resolve(null);
  }
  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }
  let soundFile = zip.file(fileName);
  if (!soundFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp("^([^/]*/)?".concat(fileName, "$"));
    soundFile = zip.file(fileMatch)[0]; // use first matching file
  }
  if (!soundFile) {
    log.error("Could not find sound file associated with the ".concat(sound.name, " sound."));
    return Promise.resolve(null);
  }
  if (!JSZip.support.uint8array) {
    log.error('JSZip uint8array is not supported in this browser.');
    return Promise.resolve(null);
  }
  const dataFormat = sound.dataFormat.toLowerCase() === 'mp3' ? storage.DataFormat.MP3 : storage.DataFormat.WAV;
  return soundFile.async('uint8array').then(data => storage.createAsset(storage.AssetType.Sound, dataFormat, data, null, true)).then(asset => {
    sound.asset = asset;
    sound.assetId = asset.assetId;
    sound.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
  });
};

/**
 * Deserializes costume from file into storage cache so that it can
 * be loaded into the runtime.
 * @param {object} costume Descriptor for costume from sb3 file
 * @param {Runtime} runtime The runtime containing the storage to cache the costumes in
 * @param {JSZip} zip The zip containing the costume file being described by `costume`
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @param {string} textLayerFileName Optional file name for the given asset's text layer
 * (sb2 only; files have filenames of the form [int].png)
 * @return {Promise} Promise that resolves after the described costume has been stored
 * into the runtime storage cache, the costume was already stored, or an error has
 * occurred.
 */
const deserializeCostume = function deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName) {
  const storage = runtime.storage;
  const assetId = costume.assetId;
  const fileName = assetFileName ? assetFileName : "".concat(assetId, ".").concat(costume.dataFormat);
  if (!storage) {
    log.warn('No storage module present; cannot load costume asset: ', fileName);
    return Promise.resolve(null);
  }
  if (costume.asset) {
    // When uploading a sprite from an image file, the asset data will be provided
    // @todo Cache the asset data somewhere and pull it out here
    return Promise.resolve(storage.createAsset(costume.asset.assetType, costume.asset.dataFormat, new Uint8Array(Object.keys(costume.asset.data).map(key => costume.asset.data[key])), null, true)).then(asset => {
      costume.asset = asset;
      costume.assetId = asset.assetId;
      costume.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
    });
  }
  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }
  let costumeFile = zip.file(fileName);
  if (!costumeFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp("^([^/]*/)?".concat(fileName, "$"));
    costumeFile = zip.file(fileMatch)[0]; // use the first matched file
  }
  if (!costumeFile) {
    log.error("Could not find costume file associated with the ".concat(costume.name, " costume."));
    return Promise.resolve(null);
  }
  let assetType = null;
  const costumeFormat = costume.dataFormat.toLowerCase();
  if (costumeFormat === 'svg') {
    assetType = storage.AssetType.ImageVector;
  } else if (['png', 'bmp', 'jpeg', 'jpg', 'gif'].indexOf(costumeFormat) >= 0) {
    assetType = storage.AssetType.ImageBitmap;
  } else {
    log.error("Unexpected file format for costume: ".concat(costumeFormat));
  }
  if (!JSZip.support.uint8array) {
    log.error('JSZip uint8array is not supported in this browser.');
    return Promise.resolve(null);
  }

  // textLayerMD5 exists if there is a text layer, which is a png of text from Scratch 1.4
  // that was opened in Scratch 2.0. In this case, set costume.textLayerAsset.
  let textLayerFilePromise;
  if (costume.textLayerMD5) {
    const textLayerFile = zip.file(textLayerFileName);
    if (!textLayerFile) {
      log.error("Could not find text layer file associated with the ".concat(costume.name, " costume."));
      return Promise.resolve(null);
    }
    textLayerFilePromise = textLayerFile.async('uint8array').then(data => storage.createAsset(storage.AssetType.ImageBitmap, 'png', data, costume.textLayerMD5)).then(asset => {
      costume.textLayerAsset = asset;
    });
  } else {
    textLayerFilePromise = Promise.resolve(null);
  }
  return Promise.all([textLayerFilePromise, costumeFile.async('uint8array').then(data => storage.createAsset(assetType,
  // TODO eventually we want to map non-png's to their actual file types?
  costumeFormat, data, null, true)).then(asset => {
    costume.asset = asset;
    costume.assetId = asset.assetId;
    costume.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
  })]);
};
module.exports = {
  deserializeSound,
  deserializeCostume
};

/***/ }),

/***/ "./src/serialization/sb2.js":
/*!**********************************!*\
  !*** ./src/serialization/sb2.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * Partial implementation of an SB2 JSON importer.
 * Parses provided JSON and then generates all needed
 * scratch-vm runtime structures.
 */

const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");
const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");
const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");
const Color = __webpack_require__(/*! ../util/color */ "./src/util/color.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
const specMap = __webpack_require__(/*! ./sb2_specmap */ "./src/serialization/sb2_specmap.js");
const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");
const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");
const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");
const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js");

// Constants used during deserialization of an SB2 file
const CORE_EXTENSIONS = ['argument', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound'];

// Adjust script coordinates to account for
// larger block size in scratch-blocks.
// @todo: Determine more precisely the right formulas here.
const WORKSPACE_X_SCALE = 1.5;
const WORKSPACE_Y_SCALE = 2.2;

/**
 * Convert a Scratch 2.0 procedure string (e.g., "my_procedure %s %b %n")
 * into an argument map. This allows us to provide the expected inputs
 * to a mutated procedure call.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {object} Argument map compatible with those in sb2specmap.
 */
const parseProcedureArgMap = function parseProcedureArgMap(procCode) {
  const argMap = [{} // First item in list is op string.
  ];
  const INPUT_PREFIX = 'input';
  let inputCount = 0;
  // Split by %n, %b, %s.
  const parts = procCode.split(/(?=[^\\]%[nbs])/);
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].trim();
    if (part.substring(0, 1) === '%') {
      const argType = part.substring(1, 2);
      const arg = {
        type: 'input',
        inputName: INPUT_PREFIX + inputCount++
      };
      if (argType === 'n') {
        arg.inputOp = 'math_number';
      } else if (argType === 's') {
        arg.inputOp = 'text';
      } else if (argType === 'b') {
        arg.inputOp = 'boolean';
      }
      argMap.push(arg);
    }
  }
  return argMap;
};

/**
 * Generate a list of "argument IDs" for procdefs and caller mutations.
 * IDs just end up being `input0`, `input1`, ... which is good enough.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {Array.<string>} Array of argument id strings.
 */
const parseProcedureArgIds = function parseProcedureArgIds(procCode) {
  return parseProcedureArgMap(procCode).map(arg => arg.inputName).filter(name => name); // Filter out unnamed inputs which are labels
};

/**
 * Flatten a block tree into a block list.
 * Children are temporarily stored on the `block.children` property.
 * @param {Array.<object>} blocks list generated by `parseBlockList`.
 * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.
 */
const flatten = function flatten(blocks) {
  let finalBlocks = [];
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    finalBlocks.push(block);
    if (block.children) {
      finalBlocks = finalBlocks.concat(flatten(block.children));
    }
    delete block.children;
  }
  return finalBlocks;
};

/**
 * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.
 * Could be used to parse a top-level script,
 * a list of blocks in a branch (e.g., in forever),
 * or a list of blocks in an argument (e.g., move [pick random...]).
 * @param {Array.<object>} blockList SB2 JSON-format block list.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The current index of the top block in this list if it were in a flattened
 * list of all blocks for the target
 * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and
 * second item is the updated comment index
 */
const parseBlockList = function parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const resultingList = [];
  let previousBlock = null; // For setting next.
  for (let i = 0; i < blockList.length; i++) {
    const block = blockList[i];
    // eslint-disable-next-line no-use-before-define
    const parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
    const parsedBlock = parsedBlockAndComments[0];
    // Update commentIndex
    commentIndex = parsedBlockAndComments[1];
    if (!parsedBlock) continue;
    if (previousBlock) {
      parsedBlock.parent = previousBlock.id;
      previousBlock.next = parsedBlock.id;
    }
    previousBlock = parsedBlock;
    resultingList.push(parsedBlock);
  }
  return [resultingList, commentIndex];
};

/**
 * Parse a Scratch object's scripts into VM blocks.
 * This should only handle top-level scripts that include X, Y coordinates.
 * @param {!object} scripts Scripts object from SB2 JSON.
 * @param {!Blocks} blocks Blocks object to load parsed blocks into.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {object} comments Comments that need to be attached to the blocks that need to be parsed
 */
const parseScripts = function parseScripts(scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {
  // Keep track of the index of the current script being
  // parsed in order to attach block comments correctly
  let scriptIndexForComment = 0;
  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    const scriptX = script[0];
    const scriptY = script[1];
    const blockList = script[2];
    const parseState = {};
    const [parsedBlockList, newCommentIndex] = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment);
    scriptIndexForComment = newCommentIndex;
    if (parsedBlockList[0]) {
      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;
      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;
      parsedBlockList[0].topLevel = true;
      parsedBlockList[0].parent = null;
    }
    // Flatten children and create add the blocks.
    const convertedBlocks = flatten(parsedBlockList);
    for (let j = 0; j < convertedBlocks.length; j++) {
      blocks.createBlock(convertedBlocks[j]);
    }
  }
};

/**
 * Create a callback for assigning fixed IDs to imported variables
 * Generator stores the global variable mapping in a closure
 * @param {!string} targetId the id of the target to scope the variable to
 * @return {string} variable ID
 */
const generateVariableIdGetter = function () {
  let globalVariableNameMap = {};
  const namer = (targetId, name, type) => "".concat(targetId, "-").concat(StringUtil.replaceUnsafeChars(name), "-").concat(type);
  return function (targetId, topLevel) {
    // Reset the global variable map if topLevel
    if (topLevel) globalVariableNameMap = {};
    return function (name, type) {
      if (topLevel) {
        // Store the name/id pair in the globalVariableNameMap
        globalVariableNameMap["".concat(name, "-").concat(type)] = namer(targetId, name, type);
        return globalVariableNameMap["".concat(name, "-").concat(type)];
      }
      // Not top-level, so first check the global name map
      if (globalVariableNameMap["".concat(name, "-").concat(type)]) return globalVariableNameMap["".concat(name, "-").concat(type)];
      return namer(targetId, name, type);
    };
  };
}();
const globalBroadcastMsgStateGenerator = function () {
  let broadcastMsgNameMap = {};
  const allBroadcastFields = [];
  const emptyStringName = uid();
  return function (topLevel) {
    if (topLevel) broadcastMsgNameMap = {};
    return {
      broadcastMsgMapUpdater: function broadcastMsgMapUpdater(name, field) {
        name = name.toLowerCase();
        if (name === '') {
          name = emptyStringName;
        }
        broadcastMsgNameMap[name] = "broadcastMsgId-".concat(StringUtil.replaceUnsafeChars(name));
        allBroadcastFields.push(field);
        return broadcastMsgNameMap[name];
      },
      globalBroadcastMsgs: broadcastMsgNameMap,
      allBroadcastFields: allBroadcastFields,
      emptyMsgName: emptyStringName
    };
  };
}();

/**
 * Parse a single monitor object and create all its in-memory VM objects.
 *
 * It is important that monitors are parsed last,
 * - after all sprite targets have finished parsing, and
 * - after the rest of the stage has finished parsing.
 *
 * It is specifically important that all the scripts in the project
 * have been parsed and all the relevant targets exist, have uids,
 * and have their variables initialized.
 * Calling this function before these things are true, will result in
 * undefined behavior.
 * @param {!object} object - From-JSON "Monitor object"
 * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.
 * @param {!Array.<Target>} targets - Targets have already been parsed.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 */

const parseMonitorObject = (object, runtime, targets, extensions) => {
  // If we can't find the block in the spec map, ignore it.
  // This happens for things like Lego Wedo 1.0 monitors.
  const mapped = specMap[object.cmd];
  if (!mapped) {
    log.warn("Could not find monitor block with opcode: ".concat(object.cmd));
    return;
  }
  // In scratch 2.0, there are two monitors that now correspond to extension
  // blocks (tempo and video motion/direction). In the case of the
  // video motion/direction block, this reporter is not monitorable in Scratch 3.0.
  // In the case of the tempo block, we should import it and load the music extension
  // only when the monitor is actually visible.

  const opcode = specMap[object.cmd].opcode;
  const extIndex = opcode.indexOf('_');
  const extID = opcode.substring(0, extIndex);
  if (extID === 'videoSensing') {
    return;
  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== '' && !extensions.extensionIDs.has(extID) && !object.visible) {
    // Don't import this monitor if it refers to a non-core extension that
    // doesn't exist anywhere else in the project and it isn't visible.
    // This should only apply to the tempo block at this point since
    // there are no other sb2 blocks that are now extension monitors.
    return;
  }
  let target = null;
  // List blocks don't come in with their target name set.
  // Find the target by searching for a target with matching variable name/type.
  if (!Object.prototype.hasOwnProperty.call(object, 'target')) {
    for (let i = 0; i < targets.length; i++) {
      const currTarget = targets[i];
      const listVariables = Object.keys(currTarget.variables).filter(key => {
        const variable = currTarget.variables[key];
        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;
      });
      if (listVariables.length > 0) {
        target = currTarget; // Keep this target for later use
        object.target = currTarget.getName(); // Set target name to normalize with other monitors
      }
    }
  }

  // Get the target for this monitor, if not gotten above.
  target = target || targets.filter(t => t.getName() === object.target)[0];
  if (!target) throw new Error('Cannot create monitor for target that cannot be found by name');

  // Create var id getter to make block naming/parsing easier, variables already created.
  const getVariableId = generateVariableIdGetter(target.id, false);
  // eslint-disable-next-line no-use-before-define
  const [block, _] = parseBlock([object.cmd, object.param],
  // Scratch 2 monitor blocks only have one param.
  null,
  // `addBroadcastMsg`, not needed for monitor blocks.
  getVariableId, extensions, {}, null,
  // `comments`, not needed for monitor blocks
  null // `commentIndex`, not needed for monitor blocks
  );

  // Monitor blocks have special IDs to match the toolbox obtained from the getId
  // function in the runtime.monitorBlocksInfo. Variable monitors, however,
  // get their IDs from the variable id they reference.
  if (object.cmd === 'getVar:') {
    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);
  } else if (object.cmd === 'contentsOfList:') {
    block.id = getVariableId(object.param, Variable.LIST_TYPE);
  } else if (Object.prototype.hasOwnProperty.call(runtime.monitorBlockInfo, block.opcode)) {
    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);
  } else {
    // If the opcode can't be found in the runtime monitorBlockInfo,
    // then default to using the block opcode as the id instead.
    // This is for extension monitors, and assumes that extension monitors
    // cannot be sprite specific.
    block.id = block.opcode;
  }

  // Block needs a targetId if it is targetting something other than the stage
  block.targetId = target.isStage ? null : target.id;

  // Property required for running monitored blocks.
  block.isMonitored = object.visible;
  const existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];
  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    // Update the existing block with the relevant monitor information.
    existingMonitorBlock.isMonitored = object.visible;
    existingMonitorBlock.targetId = block.targetId;
  } else {
    // Blocks can be created with children, flatten and add to monitorBlocks.
    const newBlocks = flatten([block]);
    for (let i = 0; i < newBlocks.length; i++) {
      runtime.monitorBlocks.createBlock(newBlocks[i]);
    }
  }

  // Convert numbered mode into strings for better understandability.
  switch (object.mode) {
    case 1:
      object.mode = 'default';
      break;
    case 2:
      object.mode = 'large';
      break;
    case 3:
      object.mode = 'slider';
      break;
  }

  // Create a monitor record for the runtime's monitorState
  runtime.requestAddMonitor(MonitorRecord({
    id: block.id,
    targetId: block.targetId,
    spriteName: block.targetId ? object.target : null,
    opcode: block.opcode,
    params: runtime.monitorBlocks._getBlockParams(block),
    value: '',
    mode: object.mode,
    sliderMin: object.sliderMin,
    sliderMax: object.sliderMax,
    isDiscrete: object.isDiscrete,
    x: object.x,
    y: object.y,
    width: object.width,
    height: object.height,
    visible: object.visible
  }));
};

/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}
 *   Object of arrays of promises and child objects for asset objects used in
 *   Sprites. As well as a SoundBank for the sound assets. null for unsupported
 *   objects.
 */
const parseScratchAssets = function parseScratchAssets(object, runtime, topLevel, zip) {
  if (!Object.prototype.hasOwnProperty.call(object, 'objName')) {
    // Skip parsing monitors. Or any other objects missing objName.
    return null;
  }
  const assets = {
    costumePromises: [],
    soundPromises: [],
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),
    children: []
  };

  // Costumes from JSON.
  const costumePromises = assets.costumePromises;
  if (Object.prototype.hasOwnProperty.call(object, 'costumes')) {
    for (let i = 0; i < object.costumes.length; i++) {
      const costumeSource = object.costumes[i];
      const bitmapResolution = costumeSource.bitmapResolution || 1;
      const costume = {
        name: costumeSource.costumeName,
        bitmapResolution: bitmapResolution,
        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,
        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        md5: costumeSource.baseLayerMD5,
        skinId: null
      };
      const md5ext = costumeSource.baseLayerMD5;
      const idParts = StringUtil.splitFirst(md5ext, '.');
      const md5 = idParts[0];
      let ext;
      if (idParts.length === 2 && idParts[1]) {
        ext = idParts[1];
      } else {
        // Default to 'png' if baseLayerMD5 is not formatted correctly
        ext = 'png';
        // Fix costume md5 for later
        costume.md5 = "".concat(costume.md5, ".").concat(ext);
      }
      costume.dataFormat = ext;
      costume.assetId = md5;
      if (costumeSource.textLayerMD5) {
        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, '.')[0];
      }
      // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the costume should be the baseLayerID followed by the file ext
      const assetFileName = "".concat(costumeSource.baseLayerID, ".").concat(ext);
      const textLayerFileName = costumeSource.textLayerID ? "".concat(costumeSource.textLayerID, ".png") : null;
      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(() => loadCostume(costume.md5, costume, runtime, 2 /* optVersion */)));
    }
  }
  // Sounds from JSON
  const {
    soundBank,
    soundPromises
  } = assets;
  if (Object.prototype.hasOwnProperty.call(object, 'sounds')) {
    for (let s = 0; s < object.sounds.length; s++) {
      const soundSource = object.sounds[s];
      const sound = {
        name: soundSource.soundName,
        format: soundSource.format,
        rate: soundSource.rate,
        sampleCount: soundSource.sampleCount,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        // (for example, the audio engine currently relies on this
        // property to be named 'md5')
        md5: soundSource.md5,
        data: null
      };
      const md5ext = soundSource.md5;
      const idParts = StringUtil.splitFirst(md5ext, '.');
      const md5 = idParts[0];
      const ext = idParts[1].toLowerCase();
      sound.dataFormat = ext;
      sound.assetId = md5;
      // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the sound should be the soundID (provided from the project.json)
      // followed by the file ext
      const assetFileName = "".concat(soundSource.soundID, ".").concat(ext);
      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(() => loadSound(sound, runtime, soundBank)));
    }
  }

  // The stage will have child objects; recursively process them.
  const childrenAssets = assets.children;
  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));
    }
  }
  return assets;
};

/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * TODO: parse the "info" section, especially "savedExtensions"
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.
 */
const parseScratchObject = function parseScratchObject(object, runtime, extensions, topLevel, zip, assets) {
  if (!Object.prototype.hasOwnProperty.call(object, 'objName')) {
    if (Object.prototype.hasOwnProperty.call(object, 'listName')) {
      // Shim these objects so they can be processed as monitors
      object.cmd = 'contentsOfList:';
      object.param = object.listName;
      object.mode = 'list';
    }
    // Defer parsing monitors until targets are all parsed
    object.deferredMonitor = true;
    return Promise.resolve(object);
  }

  // Blocks container for this object.
  const blocks = new Blocks(runtime);
  // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.
  const sprite = new Sprite(blocks, runtime);
  // Sprite/stage name from JSON.
  if (Object.prototype.hasOwnProperty.call(object, 'objName')) {
    if (topLevel && object.objName !== 'Stage') {
      for (const child of object.children) {
        if (!Object.prototype.hasOwnProperty.call(child, 'objName') && child.target === object.objName) {
          child.target = 'Stage';
        }
      }
      object.objName = 'Stage';
    }
    sprite.name = object.objName;
  }
  // Costumes from JSON.
  const costumePromises = assets.costumePromises;
  // Sounds from JSON
  const {
    soundBank,
    soundPromises
  } = assets;

  // Create the first clone, and load its run-state from JSON.
  const target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
  const getVariableId = generateVariableIdGetter(target.id, topLevel);
  const globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);
  const addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater;

  // Load target properties from JSON.
  if (Object.prototype.hasOwnProperty.call(object, 'variables')) {
    for (let j = 0; j < object.variables.length; j++) {
      const variable = object.variables[j];
      // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable
      const isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();
      const newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable.value;
      target.variables[newVariable.id] = newVariable;
    }
  }

  // If included, parse any and all comments on the object (this includes top-level
  // workspace comments as well as comments attached to specific blocks)
  const blockComments = {};
  if (Object.prototype.hasOwnProperty.call(object, 'scriptComments')) {
    const comments = object.scriptComments.map(commentDesc => {
      const [commentX, commentY, commentWidth, commentHeight, commentFullSize, flattenedBlockIndex, commentText] = commentDesc;
      const isBlockComment = commentDesc[5] >= 0;
      const newComment = new Comment(null,
      // generate a new id for this comment
      commentText,
      // text content of sb2 comment
      // Only serialize x & y position of comment if it's a workspace comment
      // If it's a block comment, we'll let scratch-blocks handle positioning
      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);
      if (isBlockComment) {
        // commentDesc[5] refers to the index of the block that this
        // comment is attached to --  in a flattened version of the
        // scripts array.
        // If commentDesc[5] is -1, this is a workspace comment (we don't need to do anything
        // extra at this point), otherwise temporarily save the flattened script array
        // index as the blockId property of the new comment. We will
        // change this to refer to the actual block id of the corresponding
        // block when that block gets created
        newComment.blockId = flattenedBlockIndex;
        // Add this comment to the block comments object with its script index
        // as the key
        if (Object.prototype.hasOwnProperty.call(blockComments, flattenedBlockIndex)) {
          blockComments[flattenedBlockIndex].push(newComment);
        } else {
          blockComments[flattenedBlockIndex] = [newComment];
        }
      }
      return newComment;
    });

    // Add all the comments that were just created to the target.comments,
    // referenced by id
    comments.forEach(comment => {
      target.comments[comment.id] = comment;
    });
  }

  // If included, parse any and all scripts/blocks on the object.
  if (Object.prototype.hasOwnProperty.call(object, 'scripts')) {
    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);
  }

  // If there are any comments referring to a numerical block ID, make them
  // workspace comments. These are comments that were originally created as
  // block comments, detached from the block, and then had the associated
  // block deleted.
  // These comments should be imported as workspace comments
  // by making their blockIDs (which currently refer to non-existing blocks)
  // null (See #1452).
  for (const commentIndex in blockComments) {
    const currBlockComments = blockComments[commentIndex];
    currBlockComments.forEach(c => {
      if (typeof c.blockId === 'number') {
        c.blockId = null;
      }
    });
  }

  // Update stage specific blocks (e.g. sprite clicked <=> stage clicked)
  blocks.updateTargetSpecificBlocks(topLevel); // topLevel = isStage

  if (Object.prototype.hasOwnProperty.call(object, 'lists')) {
    for (let k = 0; k < object.lists.length; k++) {
      const list = object.lists[k];
      const newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);
      newVariable.value = list.contents;
      target.variables[newVariable.id] = newVariable;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'scratchX')) {
    target.x = object.scratchX;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'scratchY')) {
    target.y = object.scratchY;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'direction')) {
    // Sometimes the direction can be outside of the range: LLK/scratch-gui#5806
    // wrapClamp it (like we do on RenderedTarget.setDirection)
    target.direction = MathUtil.wrapClamp(object.direction, -179, 180);
  }
  if (Object.prototype.hasOwnProperty.call(object, 'isDraggable')) {
    target.draggable = object.isDraggable;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'scale')) {
    // SB2 stores as 1.0 = 100%; we use % in the VM.
    target.size = object.scale * 100;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'visible')) {
    target.visible = object.visible;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'currentCostumeIndex')) {
    // Current costume index can sometimes be a floating
    // point number, use Math.floor to come up with an appropriate index
    // and clamp it to the actual number of costumes the object has for good measure.
    target.currentCostume = MathUtil.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);
  }
  if (Object.prototype.hasOwnProperty.call(object, 'rotationStyle')) {
    if (object.rotationStyle === 'none') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (object.rotationStyle === 'leftRight') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    } else if (object.rotationStyle === 'normal') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'tempoBPM')) {
    target.tempo = object.tempoBPM;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'videoAlpha')) {
    // SB2 stores alpha as opacity, where 1.0 is opaque.
    // We convert to a percentage, and invert it so 100% is full transparency.
    target.videoTransparency = 100 - 100 * object.videoAlpha;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'info')) {
    if (Object.prototype.hasOwnProperty.call(object.info, 'videoOn')) {
      if (object.info.videoOn) {
        target.videoState = RenderedTarget.VIDEO_STATE.ON;
      } else {
        target.videoState = RenderedTarget.VIDEO_STATE.OFF;
      }
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'indexInLibrary')) {
    // Temporarily store the 'indexInLibrary' property from the sb2 file
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.indexInLibrary;
  }
  target.isStage = topLevel;
  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds;
    // Make sure if soundBank is undefined, sprite.soundBank is then null.
    sprite.soundBank = soundBank || null;
  });

  // The stage will have child objects; recursively process them.
  const childrenPromises = [];
  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));
    }
  }
  return Promise.all(costumePromises.concat(soundPromises)).then(() => Promise.all(childrenPromises).then(children => {
    // Need create broadcast msgs as variables after
    // all other targets have finished processing.
    if (target.isStage) {
      const allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;
      const allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;
      const oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;
      if (allBroadcastMsgs[oldEmptyMsgName]) {
        // Find a fresh 'messageN'
        let currIndex = 1;
        while (allBroadcastMsgs["message".concat(currIndex)]) {
          currIndex += 1;
        }
        const newEmptyMsgName = "message".concat(currIndex);
        // Add the new empty message name to the broadcast message
        // name map, and assign it the old id.
        // Then, delete the old entry in map.
        allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];
        delete allBroadcastMsgs[oldEmptyMsgName];
        // Now update all the broadcast message fields with
        // the new empty message name.
        for (let i = 0; i < allBroadcastMsgFields.length; i++) {
          if (allBroadcastMsgFields[i].value === '') {
            allBroadcastMsgFields[i].value = newEmptyMsgName;
          }
        }
      }
      // Traverse the broadcast message name map and create
      // broadcast messages as variables on the stage (which is this
      // target).
      for (const msgName in allBroadcastMsgs) {
        const msgId = allBroadcastMsgs[msgName];
        const newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);
        target.variables[newMsg.id] = newMsg;
      }
    }
    let targets = [target];
    const deferredMonitors = [];
    for (let n = 0; n < children.length; n++) {
      if (children[n]) {
        if (children[n].deferredMonitor) {
          deferredMonitors.push(children[n]);
        } else {
          targets = targets.concat(children[n]);
        }
      }
    }
    // It is important that monitors are parsed last
    // - after all sprite targets have finished parsing
    // - and this is the last thing that happens in the stage parsing
    // It is specifically important that all the scripts in the project
    // have been parsed and all the relevant targets exist, have uids,
    // and have their variables initialized.
    for (let n = 0; n < deferredMonitors.length; n++) {
      parseMonitorObject(deferredMonitors[n], runtime, targets, extensions);
    }
    return targets;
  }));
};
const reorderParsedTargets = function reorderParsedTargets(targets) {
  // Reorder parsed targets based on the temporary targetPaneOrder property
  // and then delete it.

  const reordered = targets.map((t, index) => {
    t.layerOrder = index;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder);

  // Delete the temporary target pane ordering since we shouldn't need it anymore.
  reordered.forEach(t => {
    delete t.targetPaneOrder;
  });
  return reordered;
};

/**
 * Top-level handler. Parse provided JSON,
 * and process the top-level object (the stage object).
 * @param {!object} json SB2-format JSON to load.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).
 * @param {?object} zip Optional zipped assets for local file import
 * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.
 */
const sb2import = function sb2import(json, runtime, optForceSprite, zip) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  };
  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip))
  // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets)).then(reorderParsedTargets).then(targets => ({
    targets,
    extensions
  }));
};

/**
 * Given the sb2 block, inspect the specmap for a translation method or object.
 * @param {!object} block a sb2 formatted block
 * @return {object} specmap block to parse this opcode
 */
const specMapBlock = function specMapBlock(block) {
  const opcode = block[0];
  const mapped = opcode && specMap[opcode];
  if (!mapped) {
    log.warn("Couldn't find SB2 block: ".concat(opcode));
    return null;
  }
  if (typeof mapped === 'function') {
    return mapped(block);
  }
  return mapped;
};

/**
 * Parse a single SB2 JSON-formatted block and its children.
 * @param {!object} sb2block SB2 JSON-formatted block.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retrieve a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened
 * list of all blocks for the target
 * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),
 * and second item is the updated comment index (after this block and its children are parsed)
 */
const parseBlock = function parseBlock(sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const commentsForParsedBlock = comments && typeof commentIndex === 'number' && !isNaN(commentIndex) ? comments[commentIndex] : null;
  const blockMetadata = specMapBlock(sb2block);
  if (!blockMetadata) {
    // No block opcode found, exclude this block, increment the commentIndex,
    // make all block comments into workspace comments and send them to zero/zero
    // to prevent serialization issues.
    if (commentsForParsedBlock) {
      commentsForParsedBlock.forEach(comment => {
        comment.blockId = null;
        comment.x = comment.y = 0;
      });
    }
    return [null, commentIndex + 1];
  }
  const oldOpcode = sb2block[0];

  // If the block is from an extension, record it.
  const index = blockMetadata.opcode.indexOf('_');
  const prefix = blockMetadata.opcode.substring(0, index);
  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== '') extensions.extensionIDs.add(prefix);
  }

  // Block skeleton.
  const activeBlock = {
    id: uid(),
    // Generate a new block unique ID.
    opcode: blockMetadata.opcode,
    // Converted, e.g. "motion_movesteps".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block.
    shadow: false,
    // No shadow blocks in an SB2 by default.
    children: [] // Store any generated children, flattened in `flatten`.
  };

  // Attach any comments to this block..
  if (commentsForParsedBlock) {
    // Attach only the last comment to the block, make all others workspace comments
    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;
    commentsForParsedBlock.forEach(comment => {
      if (comment.id === activeBlock.comment) {
        comment.blockId = activeBlock.id;
      } else {
        // All other comments don't get a block ID and are sent back to zero.
        // This is important, because if they have `null` x/y, serialization breaks.
        comment.blockId = null;
        comment.x = comment.y = 0;
      }
    });
  }
  commentIndex++;
  const parentExpectedArg = parseState.expectedArg;

  // For a procedure call, generate argument map from proc string.
  if (oldOpcode === 'call') {
    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);
  }
  // Look at the expected arguments in `blockMetadata.argMap.`
  // The basic problem here is to turn positional SB2 arguments into
  // non-positional named Scratch VM arguments.
  for (let i = 0; i < blockMetadata.argMap.length; i++) {
    const expectedArg = blockMetadata.argMap[i];
    const providedArg = sb2block[i + 1]; // (i = 0 is opcode)
    // Whether the input is obscuring a shadow.
    let shadowObscured = false;
    // Positional argument is an input.
    if (expectedArg.type === 'input') {
      // Create a new block and input metadata.
      const inputUid = uid();
      activeBlock.inputs[expectedArg.inputName] = {
        name: expectedArg.inputName,
        block: null,
        shadow: null
      };
      if (typeof providedArg === 'object' && providedArg) {
        // Block or block list occupies the input.
        let innerBlocks;
        parseState.expectedArg = expectedArg;
        if (typeof providedArg[0] === 'object' && providedArg[0]) {
          // Block list occupies the input.
          [innerBlocks, commentIndex] = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
        } else {
          // Single block occupies the input.
          const parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : [];
          // Update commentIndex
          commentIndex = parsedBlockDesc[1];
        }
        parseState.expectedArg = parentExpectedArg;

        // Check if innerBlocks is not an empty list.
        // An empty list indicates that all the inner blocks from the sb2 have
        // unknown opcodes and have been skipped.
        if (innerBlocks.length > 0) {
          let previousBlock = null;
          for (let j = 0; j < innerBlocks.length; j++) {
            if (j === 0) {
              innerBlocks[j].parent = activeBlock.id;
            } else {
              innerBlocks[j].parent = previousBlock;
            }
            previousBlock = innerBlocks[j].id;
          }
          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;
          activeBlock.children = activeBlock.children.concat(innerBlocks);
        }

        // Obscures any shadow.
        shadowObscured = true;
      }
      // Generate a shadow block to occupy the input.
      if (!expectedArg.inputOp) {
        // Undefined inputOp. inputOp should always be defined for inputs.
        log.warn("Unknown input operation for input ".concat(expectedArg.inputName, " of opcode ").concat(activeBlock.opcode, "."));
        continue;
      }
      if (expectedArg.inputOp === 'boolean' || expectedArg.inputOp === 'substack') {
        // No editable shadow input; e.g., for a boolean.
        continue;
      }
      // Each shadow has a field generated for it automatically.
      // Value to be filled in the field.
      let fieldValue = providedArg;
      // Shadows' field names match the input name, except for these:
      let fieldName = expectedArg.inputName;
      if (expectedArg.inputOp === 'math_number' || expectedArg.inputOp === 'math_whole_number' || expectedArg.inputOp === 'math_positive_number' || expectedArg.inputOp === 'math_integer' || expectedArg.inputOp === 'math_angle') {
        fieldName = 'NUM';
        // Fields are given Scratch 2.0 default values if obscured.
        if (shadowObscured) {
          fieldValue = 10;
        }
      } else if (expectedArg.inputOp === 'text') {
        fieldName = 'TEXT';
        if (shadowObscured) {
          fieldValue = '';
        }
      } else if (expectedArg.inputOp === 'colour_picker') {
        // Convert SB2 color to hex.
        fieldValue = Color.decimalToHex(providedArg);
        fieldName = 'COLOUR';
        if (shadowObscured) {
          fieldValue = '#990000';
        }
      } else if (expectedArg.inputOp === 'event_broadcast_menu') {
        fieldName = 'BROADCAST_OPTION';
        if (shadowObscured) {
          fieldValue = '';
        }
      } else if (expectedArg.inputOp === 'sensing_of_object_menu') {
        if (shadowObscured) {
          fieldValue = '_stage_';
        } else if (fieldValue === 'Stage') {
          fieldValue = '_stage_';
        }
      } else if (expectedArg.inputOp === 'note') {
        if (shadowObscured) {
          fieldValue = 60;
        }
      } else if (expectedArg.inputOp === 'music.menu.DRUM') {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === 'music.menu.INSTRUMENT') {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.ATTRIBUTE') {
        if (shadowObscured) {
          fieldValue = 'motion';
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.SUBJECT') {
        if (shadowObscured) {
          fieldValue = 'this sprite';
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.VIDEO_STATE') {
        if (shadowObscured) {
          fieldValue = 'on';
        }
      } else if (shadowObscured) {
        // Filled drop-down menu.
        fieldValue = '';
      }
      const fields = {};
      fields[fieldName] = {
        name: fieldName,
        value: fieldValue
      };
      // event_broadcast_menus have some extra properties to add to the
      // field and a different value than the rest
      if (expectedArg.inputOp === 'event_broadcast_menu') {
        // Need to update the broadcast message name map with
        // the value of this field.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);
        fields[fieldName].id = broadcastId;
        fields[fieldName].variableType = expectedArg.variableType;
      }
      activeBlock.children.push({
        id: inputUid,
        opcode: expectedArg.inputOp,
        inputs: {},
        fields: fields,
        next: null,
        topLevel: false,
        parent: activeBlock.id,
        shadow: true
      });
      activeBlock.inputs[expectedArg.inputName].shadow = inputUid;
      // If no block occupying the input, alias to the shadow.
      if (!activeBlock.inputs[expectedArg.inputName].block) {
        activeBlock.inputs[expectedArg.inputName].block = inputUid;
      }
    } else if (expectedArg.type === 'field') {
      // Add as a field on this block.
      activeBlock.fields[expectedArg.fieldName] = {
        name: expectedArg.fieldName,
        value: providedArg
      };
      if (expectedArg.fieldName === 'CURRENTMENU') {
        // In 3.0, the field value of the `sensing_current` block
        // is in all caps.
        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();
        if (providedArg === 'day of week') {
          activeBlock.fields[expectedArg.fieldName].value = 'DAYOFWEEK';
        }
      }
      if (expectedArg.fieldName === 'VARIABLE') {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);
      } else if (expectedArg.fieldName === 'LIST') {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);
      } else if (expectedArg.fieldName === 'BROADCAST_OPTION') {
        // Add the name in this field to the broadcast msg name map.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);
        activeBlock.fields[expectedArg.fieldName].id = broadcastId;
      }
      const varType = expectedArg.variableType;
      if (typeof varType === 'string') {
        activeBlock.fields[expectedArg.fieldName].variableType = varType;
      }
    }
  }

  // Updates for blocks that have new menus (e.g. in Looks)
  switch (oldOpcode) {
    case 'comeToFront':
      activeBlock.fields.FRONT_BACK = {
        name: 'FRONT_BACK',
        value: 'front'
      };
      break;
    case 'goBackByLayers:':
      activeBlock.fields.FORWARD_BACKWARD = {
        name: 'FORWARD_BACKWARD',
        value: 'backward'
      };
      break;
    case 'backgroundIndex':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'number'
      };
      break;
    case 'sceneName':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'name'
      };
      break;
    case 'costumeIndex':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'number'
      };
      break;
    case 'costumeName':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'name'
      };
      break;
  }

  // Special cases to generate mutations.
  if (oldOpcode === 'stopScripts') {
    // Mutation for stop block: if the argument is 'other scripts',
    // the block needs a next connection.
    if (sb2block[1] === 'other scripts in sprite' || sb2block[1] === 'other scripts in stage') {
      activeBlock.mutation = {
        tagName: 'mutation',
        hasnext: 'true',
        children: []
      };
    }
  } else if (oldOpcode === 'procDef') {
    // Mutation for procedure definition:
    // store all 2.0 proc data.
    const procData = sb2block.slice(1);
    // Create a new block and input metadata.
    const inputUid = uid();
    const inputName = 'custom_block';
    activeBlock.inputs[inputName] = {
      name: inputName,
      block: inputUid,
      shadow: inputUid
    };
    activeBlock.children = [{
      id: inputUid,
      opcode: 'procedures_prototype',
      inputs: {},
      fields: {},
      next: null,
      shadow: true,
      children: [],
      mutation: {
        tagName: 'mutation',
        proccode: procData[0],
        // e.g., "abc %n %b %s"
        argumentnames: JSON.stringify(procData[1]),
        // e.g. ['arg1', 'arg2']
        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),
        argumentdefaults: JSON.stringify(procData[2]),
        // e.g., [1, 'abc']
        warp: procData[3],
        // Warp mode, e.g., true/false.
        children: []
      }
    }];
  } else if (oldOpcode === 'call') {
    // Mutation for procedure call:
    // string for proc code (e.g., "abc %n %b %s").
    activeBlock.mutation = {
      tagName: 'mutation',
      children: [],
      proccode: sb2block[1],
      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))
    };
  } else if (oldOpcode === 'getParam') {
    let returnCode = sb2block[2];

    // Ensure the returnCode is "b" if used in a boolean input.
    if (parentExpectedArg && parentExpectedArg.inputOp === 'boolean' && returnCode !== 'b') {
      returnCode = 'b';
    }

    // Assign correct opcode based on the block shape.
    switch (returnCode) {
      case 'r':
        activeBlock.opcode = 'argument_reporter_string_number';
        break;
      case 'b':
        activeBlock.opcode = 'argument_reporter_boolean';
        break;
    }
  }
  return [activeBlock, commentIndex];
};
module.exports = {
  deserialize: sb2import
};

/***/ }),

/***/ "./src/serialization/sb2_specmap.js":
/*!******************************************!*\
  !*** ./src/serialization/sb2_specmap.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * The specMap below handles a few pieces of "translation" work between
 * the SB2 JSON format and the data we need to run a project
 * in the Scratch 3.0 VM.
 * Notably:
 *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).
 *  - Map ordered, unnamed args to unordered, named inputs and fields.
 * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.
 * Originally this was generated largely by a hand-guided scripting process.
 * The relevant data lives here:
 * https://github.com/scratchfoundation/scratch-flash/blob/master/src/Specs.as
 * (for the old opcode and argument order).
 * and here:
 * https://github.com/scratchfoundation/scratch-blocks/tree/develop/blocks_vertical
 * (for the new opcodes and argument names).
 * and here:
 * https://github.com/scratchfoundation/scratch-blocks/blob/develop/tests/
 * (for the shadow blocks created for each block).
 * I started with the `commands` array in Specs.as, and discarded irrelevant
 * properties. By hand, I matched the opcode name to the 3.0 opcode.
 * Finally, I filled in the expected arguments as below.
 */

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

/**
 * @typedef {object} SB2SpecMap_blockInfo
 * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.
 * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.
 */

/**
 * @typedef {object} SB2SpecMap_argInfo
 * @property {string} type - the type of this arg (such as 'input' or 'field')
 * @property {string} inputOp - the scratch-blocks shadow type for this arg
 * @property {string} inputName - the name this argument will take when provided to the block implementation
 */

/**
 * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.
 * @type {object.<SB2SpecMap_blockInfo>}
 */
const specMap = {
  'forward:': {
    opcode: 'motion_movesteps',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STEPS'
    }]
  },
  'turnRight:': {
    opcode: 'motion_turnright',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'turnLeft:': {
    opcode: 'motion_turnleft',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'heading:': {
    opcode: 'motion_pointindirection',
    argMap: [{
      type: 'input',
      inputOp: 'math_angle',
      inputName: 'DIRECTION'
    }]
  },
  'pointTowards:': {
    opcode: 'motion_pointtowards',
    argMap: [{
      type: 'input',
      inputOp: 'motion_pointtowards_menu',
      inputName: 'TOWARDS'
    }]
  },
  'gotoX:y:': {
    opcode: 'motion_gotoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'gotoSpriteOrMouse:': {
    opcode: 'motion_goto',
    argMap: [{
      type: 'input',
      inputOp: 'motion_goto_menu',
      inputName: 'TO'
    }]
  },
  'glideSecs:toX:y:elapsed:from:': {
    opcode: 'motion_glidesecstoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'changeXposBy:': {
    opcode: 'motion_changexby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DX'
    }]
  },
  'xpos:': {
    opcode: 'motion_setx',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }]
  },
  'changeYposBy:': {
    opcode: 'motion_changeyby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DY'
    }]
  },
  'ypos:': {
    opcode: 'motion_sety',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'bounceOffEdge': {
    opcode: 'motion_ifonedgebounce',
    argMap: []
  },
  'setRotationStyle': {
    opcode: 'motion_setrotationstyle',
    argMap: [{
      type: 'field',
      fieldName: 'STYLE'
    }]
  },
  'xpos': {
    opcode: 'motion_xposition',
    argMap: []
  },
  'ypos': {
    opcode: 'motion_yposition',
    argMap: []
  },
  'heading': {
    opcode: 'motion_direction',
    argMap: []
  },
  'scrollRight': {
    opcode: 'motion_scroll_right',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollUp': {
    opcode: 'motion_scroll_up',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollAlign': {
    opcode: 'motion_align_scene',
    argMap: [{
      type: 'field',
      fieldName: 'ALIGNMENT'
    }]
  },
  'xScroll': {
    opcode: 'motion_xscroll',
    argMap: []
  },
  'yScroll': {
    opcode: 'motion_yscroll',
    argMap: []
  },
  'say:duration:elapsed:from:': {
    opcode: 'looks_sayforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'say:': {
    opcode: 'looks_say',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'think:duration:elapsed:from:': {
    opcode: 'looks_thinkforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'think:': {
    opcode: 'looks_think',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'show': {
    opcode: 'looks_show',
    argMap: []
  },
  'hide': {
    opcode: 'looks_hide',
    argMap: []
  },
  'hideAll': {
    opcode: 'looks_hideallsprites',
    argMap: []
  },
  'lookLike:': {
    opcode: 'looks_switchcostumeto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_costume',
      inputName: 'COSTUME'
    }]
  },
  'nextCostume': {
    opcode: 'looks_nextcostume',
    argMap: []
  },
  'startScene': {
    opcode: 'looks_switchbackdropto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'changeGraphicEffect:by:': {
    opcode: 'looks_changeeffectby',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setGraphicEffect:to:': {
    opcode: 'looks_seteffectto',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'filterReset': {
    opcode: 'looks_cleargraphiceffects',
    argMap: []
  },
  'changeSizeBy:': {
    opcode: 'looks_changesizeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setSizeTo:': {
    opcode: 'looks_setsizeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'changeStretchBy:': {
    opcode: 'looks_changestretchby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setStretchTo:': {
    opcode: 'looks_setstretchto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STRETCH'
    }]
  },
  'comeToFront': {
    opcode: 'looks_gotofrontback',
    argMap: []
  },
  'goBackByLayers:': {
    opcode: 'looks_goforwardbackwardlayers',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'NUM'
    }]
  },
  'costumeIndex': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'costumeName': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'sceneName': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'scale': {
    opcode: 'looks_size',
    argMap: []
  },
  'startSceneAndWait': {
    opcode: 'looks_switchbackdroptoandwait',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'nextScene': {
    opcode: 'looks_nextbackdrop',
    argMap: []
  },
  'backgroundIndex': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'playSound:': {
    opcode: 'sound_play',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'doPlaySoundAndWait': {
    opcode: 'sound_playuntildone',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'stopAllSounds': {
    opcode: 'sound_stopallsounds',
    argMap: []
  },
  'playDrum': {
    opcode: 'music_playDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_DRUM',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'drum:duration:elapsed:from:': {
    opcode: 'music_midiPlayDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'rest:elapsed:from:': {
    opcode: 'music_restForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'noteOn:duration:elapsed:from:': {
    opcode: 'music_playNoteForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'note',
      inputName: 'NOTE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'instrument:': {
    opcode: 'music_setInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_INSTRUMENT',
      inputName: 'INSTRUMENT'
    }]
  },
  'midiInstrument:': {
    opcode: 'music_midiSetInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'INSTRUMENT'
    }]
  },
  'changeVolumeBy:': {
    opcode: 'sound_changevolumeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'setVolumeTo:': {
    opcode: 'sound_setvolumeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'volume': {
    opcode: 'sound_volume',
    argMap: []
  },
  'changeTempoBy:': {
    opcode: 'music_changeTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'setTempoTo:': {
    opcode: 'music_setTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'tempo': {
    opcode: 'music_getTempo',
    argMap: []
  },
  'clearPenTrails': {
    opcode: 'pen_clear',
    argMap: []
  },
  'stampCostume': {
    opcode: 'pen_stamp',
    argMap: []
  },
  'putPenDown': {
    opcode: 'pen_penDown',
    argMap: []
  },
  'putPenUp': {
    opcode: 'pen_penUp',
    argMap: []
  },
  'penColor:': {
    opcode: 'pen_setPenColorToColor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'changePenHueBy:': {
    opcode: 'pen_changePenHueBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'setPenHueTo:': {
    opcode: 'pen_setPenHueToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'changePenShadeBy:': {
    opcode: 'pen_changePenShadeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'setPenShadeTo:': {
    opcode: 'pen_setPenShadeToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'changePenSizeBy:': {
    opcode: 'pen_changePenSizeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'penSize:': {
    opcode: 'pen_setPenSizeTo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'senseVideoMotion': {
    opcode: 'videoSensing_videoOn',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_ATTRIBUTE',
      inputName: 'ATTRIBUTE'
    }, {
      type: 'input',
      inputOp: 'videoSensing_menu_SUBJECT',
      inputName: 'SUBJECT'
    }]
  },
  'whenGreenFlag': {
    opcode: 'event_whenflagclicked',
    argMap: []
  },
  'whenKeyPressed': {
    opcode: 'event_whenkeypressed',
    argMap: [{
      type: 'field',
      fieldName: 'KEY_OPTION'
    }]
  },
  'whenClicked': {
    opcode: 'event_whenthisspriteclicked',
    argMap: []
  },
  'whenSceneStarts': {
    opcode: 'event_whenbackdropswitchesto',
    argMap: [{
      type: 'field',
      fieldName: 'BACKDROP'
    }]
  },
  'whenSensorGreaterThan': _ref => {
    let [, sensor] = _ref;
    if (sensor === 'video motion') {
      return {
        opcode: 'videoSensing_whenMotionGreaterThan',
        argMap: [
        // skip the first arg, since we converted to a video specific sensing block
        {}, {
          type: 'input',
          inputOp: 'math_number',
          inputName: 'REFERENCE'
        }]
      };
    }
    return {
      opcode: 'event_whengreaterthan',
      argMap: [{
        type: 'field',
        fieldName: 'WHENGREATERTHANMENU'
      }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'VALUE'
      }]
    };
  },
  'whenIReceive': {
    opcode: 'event_whenbroadcastreceived',
    argMap: [{
      type: 'field',
      fieldName: 'BROADCAST_OPTION',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'broadcast:': {
    opcode: 'event_broadcast',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'doBroadcastAndWait': {
    opcode: 'event_broadcastandwait',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'wait:elapsed:from:': {
    opcode: 'control_wait',
    argMap: [{
      type: 'input',
      inputOp: 'math_positive_number',
      inputName: 'DURATION'
    }]
  },
  'doRepeat': {
    opcode: 'control_repeat',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'TIMES'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForever': {
    opcode: 'control_forever',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIf': {
    opcode: 'control_if',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIfElse': {
    opcode: 'control_if_else',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK2'
    }]
  },
  'doWaitUntil': {
    opcode: 'control_wait_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }]
  },
  'doUntil': {
    opcode: 'control_repeat_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doWhile': {
    opcode: 'control_while',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForLoop': {
    opcode: 'control_for_each',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'stopScripts': {
    opcode: 'control_stop',
    argMap: [{
      type: 'field',
      fieldName: 'STOP_OPTION'
    }]
  },
  'whenCloned': {
    opcode: 'control_start_as_clone',
    argMap: []
  },
  'createCloneOf': {
    opcode: 'control_create_clone_of',
    argMap: [{
      type: 'input',
      inputOp: 'control_create_clone_of_menu',
      inputName: 'CLONE_OPTION'
    }]
  },
  'deleteClone': {
    opcode: 'control_delete_this_clone',
    argMap: []
  },
  'COUNT': {
    opcode: 'control_get_counter',
    argMap: []
  },
  'INCR_COUNT': {
    opcode: 'control_incr_counter',
    argMap: []
  },
  'CLR_COUNT': {
    opcode: 'control_clear_counter',
    argMap: []
  },
  'warpSpeed': {
    opcode: 'control_all_at_once',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'touching:': {
    opcode: 'sensing_touchingobject',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_touchingobjectmenu',
      inputName: 'TOUCHINGOBJECTMENU'
    }]
  },
  'touchingColor:': {
    opcode: 'sensing_touchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'color:sees:': {
    opcode: 'sensing_coloristouchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }, {
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR2'
    }]
  },
  'distanceTo:': {
    opcode: 'sensing_distanceto',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_distancetomenu',
      inputName: 'DISTANCETOMENU'
    }]
  },
  'doAsk': {
    opcode: 'sensing_askandwait',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'QUESTION'
    }]
  },
  'answer': {
    opcode: 'sensing_answer',
    argMap: []
  },
  'keyPressed:': {
    opcode: 'sensing_keypressed',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_keyoptions',
      inputName: 'KEY_OPTION'
    }]
  },
  'mousePressed': {
    opcode: 'sensing_mousedown',
    argMap: []
  },
  'mouseX': {
    opcode: 'sensing_mousex',
    argMap: []
  },
  'mouseY': {
    opcode: 'sensing_mousey',
    argMap: []
  },
  'soundLevel': {
    opcode: 'sensing_loudness',
    argMap: []
  },
  'isLoud': {
    opcode: 'sensing_loud',
    argMap: []
  },
  // 'senseVideoMotion': {
  //     opcode: 'sensing_videoon',
  //     argMap: [
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenuone',
  //             inputName: 'VIDEOONMENU1'
  //         },
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenutwo',
  //             inputName: 'VIDEOONMENU2'
  //         }
  //     ]
  // },
  'setVideoState': {
    opcode: 'videoSensing_videoToggle',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_VIDEO_STATE',
      inputName: 'VIDEO_STATE'
    }]
  },
  'setVideoTransparency': {
    opcode: 'videoSensing_setVideoTransparency',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TRANSPARENCY'
    }]
  },
  'timer': {
    opcode: 'sensing_timer',
    argMap: []
  },
  'timerReset': {
    opcode: 'sensing_resettimer',
    argMap: []
  },
  'getAttribute:of:': {
    opcode: 'sensing_of',
    argMap: [{
      type: 'field',
      fieldName: 'PROPERTY'
    }, {
      type: 'input',
      inputOp: 'sensing_of_object_menu',
      inputName: 'OBJECT'
    }]
  },
  'timeAndDate': {
    opcode: 'sensing_current',
    argMap: [{
      type: 'field',
      fieldName: 'CURRENTMENU'
    }]
  },
  'timestamp': {
    opcode: 'sensing_dayssince2000',
    argMap: []
  },
  'getUserName': {
    opcode: 'sensing_username',
    argMap: []
  },
  'getUserId': {
    opcode: 'sensing_userid',
    argMap: []
  },
  '+': {
    opcode: 'operator_add',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '-': {
    opcode: 'operator_subtract',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '*': {
    opcode: 'operator_multiply',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '/': {
    opcode: 'operator_divide',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'randomFrom:to:': {
    opcode: 'operator_random',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'FROM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TO'
    }]
  },
  '<': {
    opcode: 'operator_lt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '=': {
    opcode: 'operator_equals',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '>': {
    opcode: 'operator_gt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '&': {
    opcode: 'operator_and',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  '|': {
    opcode: 'operator_or',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  'not': {
    opcode: 'operator_not',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND'
    }]
  },
  'concatenate:with:': {
    opcode: 'operator_join',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING2'
    }]
  },
  'letter:of:': {
    opcode: 'operator_letter_of',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'LETTER'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  'stringLength:': {
    opcode: 'operator_length',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  '%': {
    opcode: 'operator_mod',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'rounded': {
    opcode: 'operator_round',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'computeFunction:of:': {
    opcode: 'operator_mathop',
    argMap: [{
      type: 'field',
      fieldName: 'OPERATOR'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'readVariable': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  // Scratch 2 uses this alternative variable getter opcode only in monitors,
  // blocks use the `readVariable` opcode above.
  'getVar:': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'setVar:to:': {
    opcode: 'data_setvariableto',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }]
  },
  'changeVar:by:': {
    opcode: 'data_changevariableby',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'showVariable:': {
    opcode: 'data_showvariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'hideVariable:': {
    opcode: 'data_hidevariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'contentsOfList:': {
    opcode: 'data_listcontents',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'append:toList:': {
    opcode: 'data_addtolist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'deleteLine:ofList:': {
    opcode: 'data_deleteoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'insert:at:ofList:': {
    opcode: 'data_insertatlist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'setLine:ofList:to:': {
    opcode: 'data_replaceitemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'getLine:ofList:': {
    opcode: 'data_itemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'lineCountOfList:': {
    opcode: 'data_lengthoflist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'list:contains:': {
    opcode: 'data_listcontainsitem',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'showList:': {
    opcode: 'data_showlist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'hideList:': {
    opcode: 'data_hidelist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'procDef': {
    opcode: 'procedures_definition',
    argMap: []
  },
  'getParam': {
    // Doesn't map to single opcode. Import step assigns final correct opcode.
    opcode: 'argument_reporter_string_number',
    argMap: [{
      type: 'field',
      fieldName: 'VALUE'
    }]
  },
  'call': {
    opcode: 'procedures_call',
    argMap: []
  }
};

/**
 * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same
 * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.
 * @param {string} sb2Extension - the Scratch 2.0 name of the extension
 * @param {string} sb2Opcode - the Scratch 2.0 opcode
 * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info
 */
const addExtensionOp = function addExtensionOp(sb2Extension, sb2Opcode, blockInfo) {
  /**
   * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.
   * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...
   * @type {string}
   */
  const sep = '\u001F'; // Unicode Unit Separator

  // make one entry for projects saved by recent versions of the Scratch 2.0 editor
  specMap["".concat(sb2Extension).concat(sep).concat(sb2Opcode)] = blockInfo;

  // make a second for projects saved by older versions of the Scratch 2.0 editor
  specMap["".concat(sb2Extension, ".").concat(sb2Opcode)] = blockInfo;
};
const weDo2 = 'LEGO WeDo 2.0';
addExtensionOp(weDo2, 'motorOnFor', {
  opcode: 'wedo2_motorOnFor',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'motorOn', {
  opcode: 'wedo2_motorOn',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'motorOff', {
  opcode: 'wedo2_motorOff',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'startMotorPower', {
  opcode: 'wedo2_startMotorPower',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'POWER'
  }]
});
addExtensionOp(weDo2, 'setMotorDirection', {
  opcode: 'wedo2_setMotorDirection',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_DIRECTION',
    inputName: 'MOTOR_DIRECTION'
  }]
});
addExtensionOp(weDo2, 'setLED', {
  opcode: 'wedo2_setLightHue',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'HUE'
  }]
});
addExtensionOp(weDo2, 'playNote', {
  opcode: 'wedo2_playNoteFor',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'NOTE'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'whenDistance', {
  opcode: 'wedo2_whenDistance',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_OP',
    inputName: 'OP'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'REFERENCE'
  }]
});
addExtensionOp(weDo2, 'whenTilted', {
  opcode: 'wedo2_whenTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getDistance', {
  opcode: 'wedo2_getDistance',
  argMap: []
});
addExtensionOp(weDo2, 'isTilted', {
  opcode: 'wedo2_isTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getTilt', {
  opcode: 'wedo2_getTiltAngle',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION',
    inputName: 'TILT_DIRECTION'
  }]
});
module.exports = specMap;

/***/ }),

/***/ "./src/serialization/sb3.js":
/*!**********************************!*\
  !*** ./src/serialization/sb3.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * An SB3 serializer and deserializer. Parses provided
 * JSON and then generates all needed scratch-vm runtime structures.
 */

const vmPackage = __webpack_require__(/*! ../../package.json */ "./package.json");
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");
const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");
const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");
const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");
const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");
const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");
const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js");
const hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * @typedef {object} ImportedProject
 * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.
 * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.
 */

/**
 * @typedef {object} ImportedExtensionsInfo
 * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.
 * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.
 */

// Constants used during serialization and deserialization
const INPUT_SAME_BLOCK_SHADOW = 1; // unobscured shadow
const INPUT_BLOCK_NO_SHADOW = 2; // no shadow
const INPUT_DIFF_BLOCK_SHADOW = 3; // obscured shadow
// There shouldn't be a case where block is null, but shadow is present...

// Constants used during deserialization of an SB3 file
const CORE_EXTENSIONS = ['argument', 'colour', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound'];

// Constants referring to 'primitive' blocks that are usually shadows,
// or in the case of variables and lists, appear quite often in projects
// math_number
const MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide
// math_positive_number
const POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity
// math_whole_number
const WHOLE_NUM_PRIMITIVE = 6;
// math_integer
const INTEGER_NUM_PRIMITIVE = 7;
// math_angle
const ANGLE_NUM_PRIMITIVE = 8;
// colour_picker
const COLOR_PICKER_PRIMITIVE = 9;
// text
const TEXT_PRIMITIVE = 10;
// event_broadcast_menu
const BROADCAST_PRIMITIVE = 11;
// data_variable
const VAR_PRIMITIVE = 12;
// data_listcontents
const LIST_PRIMITIVE = 13;

// Map block opcodes to the above primitives and the name of the field we can use
// to find the value of the field
const primitiveOpcodeInfoMap = {
  math_number: [MATH_NUM_PRIMITIVE, 'NUM'],
  math_positive_number: [POSITIVE_NUM_PRIMITIVE, 'NUM'],
  math_whole_number: [WHOLE_NUM_PRIMITIVE, 'NUM'],
  math_integer: [INTEGER_NUM_PRIMITIVE, 'NUM'],
  math_angle: [ANGLE_NUM_PRIMITIVE, 'NUM'],
  colour_picker: [COLOR_PICKER_PRIMITIVE, 'COLOUR'],
  text: [TEXT_PRIMITIVE, 'TEXT'],
  event_broadcast_menu: [BROADCAST_PRIMITIVE, 'BROADCAST_OPTION'],
  data_variable: [VAR_PRIMITIVE, 'VARIABLE'],
  data_listcontents: [LIST_PRIMITIVE, 'LIST']
};

/**
 * Serializes primitives described above into a more compact format
 * @param {object} block the block to serialize
 * @return {array} An array representing the information in the block,
 * or null if the given block is not one of the primitives described above.
 */
const serializePrimitiveBlock = function serializePrimitiveBlock(block) {
  // Returns an array represeting a primitive block or null if not one of
  // the primitive types above
  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {
    const primitiveInfo = primitiveOpcodeInfoMap[block.opcode];
    const primitiveConstant = primitiveInfo[0];
    const fieldName = primitiveInfo[1];
    const field = block.fields[fieldName];
    const primitiveDesc = [primitiveConstant, field.value];
    if (block.opcode === 'event_broadcast_menu') {
      primitiveDesc.push(field.id);
    } else if (block.opcode === 'data_variable' || block.opcode === 'data_listcontents') {
      primitiveDesc.push(field.id);
      if (block.topLevel) {
        primitiveDesc.push(block.x ? Math.round(block.x) : 0);
        primitiveDesc.push(block.y ? Math.round(block.y) : 0);
      }
    }
    return primitiveDesc;
  }
  return null;
};

/**
 * Serializes the inputs field of a block in a compact form using
 * constants described above to represent the relationship between the
 * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow
 * -- a block plugged into a droppable input -- or, if there is just a block).
 * Based on this relationship, serializes the ids of the block and shadow (if present)
 *
 * @param {object} inputs The inputs to serialize
 * @return {object} An object representing the serialized inputs
 */
const serializeInputs = function serializeInputs(inputs) {
  const obj = Object.create(null);
  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue;
    // if block and shadow refer to the same block, only serialize one
    if (inputs[inputName].block === inputs[inputName].shadow) {
      // has block and shadow, and they are the same
      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];
    } else if (inputs[inputName].shadow === null) {
      // does not have shadow
      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];
    } else {
      // block and shadow are both present and are different
      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];
    }
  }
  return obj;
};

/**
 * Serialize the fields of a block in a more compact form.
 * @param {object} fields The fields object to serialize
 * @return {object} An object representing the serialized fields
 */
const serializeFields = function serializeFields(fields) {
  const obj = Object.create(null);
  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    obj[fieldName] = [fields[fieldName].value];
    if (Object.prototype.hasOwnProperty.call(fields[fieldName], 'id')) {
      obj[fieldName].push(fields[fieldName].id);
    }
  }
  return obj;
};

/**
 * Serialize the given block in the SB3 format with some compression of inputs,
 * fields, and primitives.
 * @param {object} block The block to serialize
 * @return {object | array} A serialized representation of the block. This is an
 * array if the block is one of the primitive types described above or an object,
 * if not.
 */
const serializeBlock = function serializeBlock(block) {
  const serializedPrimitive = serializePrimitiveBlock(block);
  if (serializedPrimitive) return serializedPrimitive;
  // If serializedPrimitive is null, proceed with serializing a non-primitive block
  const obj = Object.create(null);
  obj.opcode = block.opcode;
  // NOTE: this is extremely important to serialize even if null;
  // not serializing `next: null` results in strange behavior with block
  // execution
  obj.next = block.next;
  obj.parent = block.parent;
  obj.inputs = serializeInputs(block.inputs);
  obj.fields = serializeFields(block.fields);
  obj.shadow = block.shadow;
  if (block.topLevel) {
    obj.topLevel = true;
    obj.x = block.x ? Math.round(block.x) : 0;
    obj.y = block.y ? Math.round(block.y) : 0;
  } else {
    obj.topLevel = false;
  }
  if (block.mutation) {
    obj.mutation = block.mutation;
  }
  if (block.comment) {
    obj.comment = block.comment;
  }
  return obj;
};

/**
 * Compresses the serialized inputs replacing block/shadow ids that refer to
 * one of the primitives with the primitive itself. E.g.
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']
 *          }
 *      },
 *      aUidForAnUnobscuredShadowPrimitive: [4, 10]
 *      // the above is a primitive representing a 'math_number' with value 10
 * }
 *
 * becomes:
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, [4, 10]]
 *          }
 *      }
 * }
 * Note: this function modifies the given blocks object in place
 * @param {object} block The block with inputs to compress
 * @param {objec} blocks The object containing all the blocks currently getting serialized
 * @return {object} The serialized block with compressed inputs
 */
const compressInputTree = function compressInputTree(block, blocks) {
  // This is the second pass on the block
  // so the inputs field should be an object of key - array pairs
  const serializedInputs = block.inputs;
  for (const inputName in serializedInputs) {
    // don't need to check for hasOwnProperty because of how we constructed
    // inputs
    const currInput = serializedInputs[inputName];
    // traverse currInput skipping the first element, which describes whether the block
    // and shadow are the same
    for (let i = 1; i < currInput.length; i++) {
      if (!currInput[i]) continue; // need this check b/c block/shadow can be null
      const blockOrShadowID = currInput[i];
      // replace element of currInput directly
      // (modifying input block directly)
      const blockOrShadow = blocks[blockOrShadowID];
      if (Array.isArray(blockOrShadow)) {
        currInput[i] = blockOrShadow;
        // Modifying blocks in place!
        delete blocks[blockOrShadowID];
      }
    }
  }
  return block;
};

/**
 * Get sanitized non-core extension ID for a given sb3 opcode.
 * Note that this should never return a URL. If in the future the SB3 loader supports loading extensions by URL, this
 * ID should be used to (for example) look up the extension's full URL from a table in the SB3's JSON.
 * @param {!string} opcode The opcode to examine for extension.
 * @return {?string} The extension ID, if it exists and is not a core extension.
 */
const getExtensionIdForOpcode = function getExtensionIdForOpcode(opcode) {
  // Allowed ID characters are those matching the regular expression [\w-]: A-Z, a-z, 0-9, and hyphen ("-").
  const index = opcode.indexOf('_');
  const forbiddenSymbols = /[^\w-]/g;
  const prefix = opcode.substring(0, index).replace(forbiddenSymbols, '-');
  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== '') return prefix;
  }
};

/**
 * Serialize the given blocks object (representing all the blocks for the target
 * currently being serialized.)
 * @param {object} blocks The blocks to be serialized
 * @return {Array} An array of the serialized blocks with compressed inputs and
 * compressed primitives and the list of all extension IDs present
 * in the serialized blocks.
 */
const serializeBlocks = function serializeBlocks(blocks) {
  const obj = Object.create(null);
  const extensionIDs = new Set();
  for (const blockID in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, blockID)) continue;
    obj[blockID] = serializeBlock(blocks[blockID], blocks);
    const extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);
    if (extensionID) {
      extensionIDs.add(extensionID);
    }
  }
  // once we have completed a first pass, do a second pass on block inputs
  for (const blockID in obj) {
    // don't need to do the hasOwnProperty check here since we
    // created an object that doesn't get extra properties/functions
    const serializedBlock = obj[blockID];
    // caution, this function deletes parts of this object in place as
    // it's traversing it
    obj[blockID] = compressInputTree(serializedBlock, obj);
    // second pass on connecting primitives to serialized inputs directly
  }
  // Do one last pass and remove any top level shadows (these are caused by
  // a bug: LLK/scratch-vm#1011, and this pass should be removed once that is
  // completely fixed)
  for (const blockID in obj) {
    const serializedBlock = obj[blockID];
    // If the current block is serialized as a primitive (e.g. it's an array
    // instead of an object), AND it is not one of the top level primitives
    // e.g. variable getter or list getter, then it should be deleted as it's
    // a shadow block, and there are no blocks that reference it, otherwise
    // they would have been compressed in the last pass)
    if (Array.isArray(serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(serializedBlock[0]) < 0) {
      log.warn("Found an unexpected top level primitive with block ID: ".concat(blockID, "; deleting it from serialized blocks."));
      delete obj[blockID];
    }
  }
  return [obj, Array.from(extensionIDs)];
};

/**
 * Serialize the given costume.
 * @param {object} costume The costume to be serialized.
 * @return {object} A serialized representation of the costume.
 */
const serializeCostume = function serializeCostume(costume) {
  const obj = Object.create(null);
  obj.name = costume.name;
  const costumeToSerialize = costume.broken || costume;
  obj.bitmapResolution = costumeToSerialize.bitmapResolution;
  obj.dataFormat = costumeToSerialize.dataFormat.toLowerCase();
  obj.assetId = costumeToSerialize.assetId;

  // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive
  obj.md5ext = costumeToSerialize.md5;
  obj.rotationCenterX = costumeToSerialize.rotationCenterX;
  obj.rotationCenterY = costumeToSerialize.rotationCenterY;
  return obj;
};

/**
 * Serialize the given sound.
 * @param {object} sound The sound to be serialized.
 * @return {object} A serialized representation of the sound.
 */
const serializeSound = function serializeSound(sound) {
  const obj = Object.create(null);
  obj.name = sound.name;
  const soundToSerialize = sound.broken || sound;
  obj.assetId = soundToSerialize.assetId;
  obj.dataFormat = soundToSerialize.dataFormat.toLowerCase();
  obj.format = soundToSerialize.format;
  obj.rate = soundToSerialize.rate;
  obj.sampleCount = soundToSerialize.sampleCount;
  // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive
  obj.md5ext = soundToSerialize.md5;
  return obj;
};

/**
 * Serialize the given variables object.
 * @param {object} variables The variables to be serialized.
 * @return {object} A serialized representation of the variables. They get
 * separated by type to compress the representation of each given variable and
 * reduce duplicate information.
 */
const serializeVariables = function serializeVariables(variables) {
  const obj = Object.create(null);
  // separate out variables into types at the top level so we don't have
  // keep track of a type for each
  obj.variables = Object.create(null);
  obj.lists = Object.create(null);
  obj.broadcasts = Object.create(null);
  for (const varId in variables) {
    const v = variables[varId];
    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {
      obj.broadcasts[varId] = v.value; // name and value is the same for broadcast msgs
      continue;
    }
    if (v.type === Variable.LIST_TYPE) {
      obj.lists[varId] = [v.name, v.value];
      continue;
    }

    // otherwise should be a scalar type
    obj.variables[varId] = [v.name, v.value];
    // only scalar vars have the potential to be cloud vars
    if (v.isCloud) obj.variables[varId].push(true);
  }
  return obj;
};
const serializeComments = function serializeComments(comments) {
  const obj = Object.create(null);
  for (const commentId in comments) {
    if (!Object.prototype.hasOwnProperty.call(comments, commentId)) continue;
    const comment = comments[commentId];
    const serializedComment = Object.create(null);
    serializedComment.blockId = comment.blockId;
    serializedComment.x = comment.x;
    serializedComment.y = comment.y;
    serializedComment.width = comment.width;
    serializedComment.height = comment.height;
    serializedComment.minimized = comment.minimized;
    serializedComment.text = comment.text;
    obj[commentId] = serializedComment;
  }
  return obj;
};

/**
 * Serialize the given target. Only serialize properties that are necessary
 * for saving and loading this target.
 * @param {object} target The target to be serialized.
 * @param {Set} extensions A set of extensions to add extension IDs to
 * @return {object} A serialized representation of the given target.
 */
const serializeTarget = function serializeTarget(target, extensions) {
  const obj = Object.create(null);
  let targetExtensions = [];
  obj.isStage = target.isStage;
  obj.name = obj.isStage ? 'Stage' : target.name;
  const vars = serializeVariables(target.variables);
  obj.variables = vars.variables;
  obj.lists = vars.lists;
  obj.broadcasts = vars.broadcasts;
  [obj.blocks, targetExtensions] = serializeBlocks(target.blocks);
  obj.comments = serializeComments(target.comments);

  // TODO remove this check/patch when (#1901) is fixed
  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {
    log.warn("currentCostume property for target ".concat(target.name, " is out of range"));
    target.currentCostume = MathUtil.clamp(target.currentCostume, 0, target.costumes.length - 1);
  }
  obj.currentCostume = target.currentCostume;
  obj.costumes = target.costumes.map(serializeCostume);
  obj.sounds = target.sounds.map(serializeSound);
  if (Object.prototype.hasOwnProperty.call(target, 'volume')) obj.volume = target.volume;
  if (Object.prototype.hasOwnProperty.call(target, 'layerOrder')) obj.layerOrder = target.layerOrder;
  if (obj.isStage) {
    // Only the stage should have these properties
    if (Object.prototype.hasOwnProperty.call(target, 'tempo')) {
      obj.tempo = target.tempo;
    }
    if (Object.prototype.hasOwnProperty.call(target, 'videoTransparency')) {
      obj.videoTransparency = target.videoTransparency;
    }
    if (Object.prototype.hasOwnProperty.call(target, 'videoState')) {
      obj.videoState = target.videoState;
    }
    if (Object.prototype.hasOwnProperty.call(target, 'textToSpeechLanguage')) {
      obj.textToSpeechLanguage = target.textToSpeechLanguage;
    }
  } else {
    // The stage does not need the following properties, but sprites should
    obj.visible = target.visible;
    obj.x = target.x;
    obj.y = target.y;
    obj.size = target.size;
    obj.direction = target.direction;
    obj.draggable = target.draggable;
    obj.rotationStyle = target.rotationStyle;
  }

  // Add found extensions to the extensions object
  targetExtensions.forEach(extensionId => {
    extensions.add(extensionId);
  });
  return obj;
};
const getSimplifiedLayerOrdering = function getSimplifiedLayerOrdering(targets) {
  const layerOrders = targets.map(t => t.getLayerOrder());
  return MathUtil.reducedSortOrdering(layerOrders);
};
const serializeMonitors = function serializeMonitors(monitors) {
  return monitors.valueSeq().map(monitorData => {
    const serializedMonitor = {
      id: monitorData.id,
      mode: monitorData.mode,
      opcode: monitorData.opcode,
      params: monitorData.params,
      spriteName: monitorData.spriteName,
      value: monitorData.value,
      width: monitorData.width,
      height: monitorData.height,
      x: monitorData.x,
      y: monitorData.y,
      visible: monitorData.visible
    };
    if (monitorData.mode !== 'list') {
      serializedMonitor.sliderMin = monitorData.sliderMin;
      serializedMonitor.sliderMax = monitorData.sliderMax;
      serializedMonitor.isDiscrete = monitorData.isDiscrete;
    }
    return serializedMonitor;
  });
};

/**
 * Serializes the specified VM runtime.
 * @param {!Runtime} runtime VM runtime instance to be serialized.
 * @param {string=} targetId Optional target id if serializing only a single target
 * @return {object} Serialized runtime instance.
 */
const serialize = function serialize(runtime, targetId) {
  // Fetch targets
  const obj = Object.create(null);
  // Create extension set to hold extension ids found while serializing targets
  const extensions = new Set();
  const originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(target => target.isOriginal);
  const layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);
  const flattenedOriginalTargets = originalTargetsToSerialize.map(t => t.toJSON());

  // If the renderer is attached, and we're serializing a whole project (not a sprite)
  // add a temporary layerOrder property to each target.
  if (runtime.renderer && !targetId) {
    flattenedOriginalTargets.forEach((t, index) => {
      t.layerOrder = layerOrdering[index];
    });
  }
  const serializedTargets = flattenedOriginalTargets.map(t => serializeTarget(t, extensions));
  if (targetId) {
    return serializedTargets[0];
  }
  obj.targets = serializedTargets;
  obj.monitors = serializeMonitors(runtime.getMonitorState());

  // Assemble extension list
  obj.extensions = Array.from(extensions);

  // Assemble metadata
  const meta = Object.create(null);
  meta.semver = '3.0.0';
  meta.vm = vmPackage.version;
  if (runtime.origin) {
    meta.origin = runtime.origin;
  }

  // Attach full user agent string to metadata if available
  meta.agent = 'none';
  if (typeof navigator !== 'undefined') meta.agent = navigator.userAgent;

  // Assemble payload and return
  obj.meta = meta;
  return obj;
};

/**
 * Deserialize a block input descriptors. This is either a
 * block id or a serialized primitive, e.g. an array
 * (see serializePrimitiveBlock function).
 * @param {string | array} inputDescOrId The block input descriptor to be serialized.
 * @param {string} parentId The id of the parent block for this input block.
 * @param {boolean} isShadow Whether or not this input block is a shadow.
 * @param {object} blocks The entire blocks object currently in the process of getting serialized.
 * @return {object} The deserialized input descriptor.
 */
const deserializeInputDesc = function deserializeInputDesc(inputDescOrId, parentId, isShadow, blocks) {
  if (!Array.isArray(inputDescOrId)) return inputDescOrId;
  const primitiveObj = Object.create(null);
  const newId = uid();
  primitiveObj.id = newId;
  primitiveObj.next = null;
  primitiveObj.parent = parentId;
  primitiveObj.shadow = isShadow;
  primitiveObj.inputs = Object.create(null);
  // need a reference to parent id
  switch (inputDescOrId[0]) {
    case MATH_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case POSITIVE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_positive_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case WHOLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_whole_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case INTEGER_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_integer';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case ANGLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_angle';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case COLOR_PICKER_PRIMITIVE:
      {
        primitiveObj.opcode = 'colour_picker';
        primitiveObj.fields = {
          COLOUR: {
            name: 'COLOUR',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case TEXT_PRIMITIVE:
      {
        primitiveObj.opcode = 'text';
        primitiveObj.fields = {
          TEXT: {
            name: 'TEXT',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case BROADCAST_PRIMITIVE:
      {
        primitiveObj.opcode = 'event_broadcast_menu';
        primitiveObj.fields = {
          BROADCAST_OPTION: {
            name: 'BROADCAST_OPTION',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.BROADCAST_MESSAGE_TYPE
          }
        };
        primitiveObj.topLevel = false;
        break;
      }
    case VAR_PRIMITIVE:
      {
        primitiveObj.opcode = 'data_variable';
        primitiveObj.fields = {
          VARIABLE: {
            name: 'VARIABLE',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.SCALAR_TYPE
          }
        };
        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }
        break;
      }
    case LIST_PRIMITIVE:
      {
        primitiveObj.opcode = 'data_listcontents';
        primitiveObj.fields = {
          LIST: {
            name: 'LIST',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.LIST_TYPE
          }
        };
        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }
        break;
      }
    default:
      {
        log.error("Found unknown primitive type during deserialization: ".concat(JSON.stringify(inputDescOrId)));
        return null;
      }
  }
  blocks[newId] = primitiveObj;
  return newId;
};

/**
 * Deserialize the given block inputs.
 * @param {object} inputs The inputs to deserialize.
 * @param {string} parentId The block id of the parent block
 * @param {object} blocks The object representing the entire set of blocks currently
 * in the process of getting deserialized.
 * @return {object} The deserialized and uncompressed inputs.
 */
const deserializeInputs = function deserializeInputs(inputs, parentId, blocks) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};
  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue;
    const inputDescArr = inputs[inputName];
    // If this block has already been deserialized (it's not an array) skip it
    if (!Array.isArray(inputDescArr)) continue;
    let block = null;
    let shadow = null;
    const blockShadowInfo = inputDescArr[0];
    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {
      // block and shadow are the same id, and only one is provided
      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);
    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
    } else {
      // assume INPUT_DIFF_BLOCK_SHADOW
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);
    }
    obj[inputName] = {
      name: inputName,
      block: block,
      shadow: shadow
    };
  }
  return obj;
};

/**
 * Deserialize the given block fields.
 * @param {object} fields The fields to be deserialized
 * @return {object} The deserialized and uncompressed block fields.
 */
const deserializeFields = function deserializeFields(fields) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};
  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    const fieldDescArr = fields[fieldName];
    // If this block has already been deserialized (it's not an array) skip it
    if (!Array.isArray(fieldDescArr)) continue;
    obj[fieldName] = {
      name: fieldName,
      value: fieldDescArr[0]
    };
    if (fieldDescArr.length > 1) {
      obj[fieldName].id = fieldDescArr[1];
    }
    if (fieldName === 'BROADCAST_OPTION') {
      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;
    } else if (fieldName === 'VARIABLE') {
      obj[fieldName].variableType = Variable.SCALAR_TYPE;
    } else if (fieldName === 'LIST') {
      obj[fieldName].variableType = Variable.LIST_TYPE;
    }
  }
  return obj;
};

/**
 * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.
 * Should be able to deserialize a format that has already been deserialized.  The only
 * "east" path to adding new targets/code requires going through deserialize, so it should
 * work with pre-parsed deserialized blocks.
 *
 * @param {object} blocks Serialized SB3 "blocks" property of a target. Will be mutated.
 * @return {object} input is modified and returned
 */
const deserializeBlocks = function deserializeBlocks(blocks) {
  for (const blockId in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {
      continue;
    }
    const block = blocks[blockId];
    if (Array.isArray(block)) {
      // this is one of the primitives
      // delete the old entry in object.blocks and replace it w/the
      // deserialized object
      delete blocks[blockId];
      deserializeInputDesc(block, null, false, blocks);
      continue;
    }
    block.id = blockId; // add id back to block since it wasn't serialized
    block.inputs = deserializeInputs(block.inputs, blockId, blocks);
    block.fields = deserializeFields(block.fields);
  }
  return blocks;
};

/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {JSZip} zip Sb3 file describing this project (to load assets from)
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}
 * Object of arrays of promises for asset objects used in Sprites. As well as a
 * SoundBank for the sound assets. null for unsupported objects.
 */
const parseScratchAssets = function parseScratchAssets(object, runtime, zip) {
  if (!Object.prototype.hasOwnProperty.call(object, 'name')) {
    // Watcher/monitor - skip this object until those are implemented in VM.
    // @todo
    return Promise.resolve(null);
  }
  const assets = {
    costumePromises: null,
    soundPromises: null,
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()
  };

  // Costumes from JSON.
  assets.costumePromises = (object.costumes || []).map(costumeSource => {
    // @todo: Make sure all the relevant metadata is being pulled out.
    const costume = {
      // costumeSource only has an asset if an image is being uploaded as
      // a sprite
      asset: costumeSource.asset,
      assetId: costumeSource.assetId,
      skinId: null,
      name: costumeSource.name,
      bitmapResolution: costumeSource.bitmapResolution,
      rotationCenterX: costumeSource.rotationCenterX,
      rotationCenterY: costumeSource.rotationCenterY
    };
    const dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat ||
    // older format
    'png'; // if all else fails, guess that it might be a PNG
    const costumeMd5Ext = Object.prototype.hasOwnProperty.call(costumeSource, 'md5ext') ? costumeSource.md5ext : "".concat(costumeSource.assetId, ".").concat(dataFormat);
    costume.md5 = costumeMd5Ext;
    costume.dataFormat = dataFormat;
    // deserializeCostume should be called on the costume object we're
    // creating above instead of the source costume object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format
    return deserializeCostume(costume, runtime, zip).then(() => loadCostume(costumeMd5Ext, costume, runtime));
    // Only attempt to load the costume after the deserialization
    // process has been completed
  });
  // Sounds from JSON
  assets.soundPromises = (object.sounds || []).map(soundSource => {
    const sound = {
      assetId: soundSource.assetId,
      format: soundSource.format,
      rate: soundSource.rate,
      sampleCount: soundSource.sampleCount,
      name: soundSource.name,
      // TODO we eventually want this property to be called md5ext,
      // but there are many things relying on this particular name at the
      // moment, so this translation is very important
      md5: soundSource.md5ext,
      dataFormat: soundSource.dataFormat,
      data: null
    };
    // deserializeSound should be called on the sound object we're
    // creating above instead of the source sound object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format
    return deserializeSound(sound, runtime, zip).then(() => loadSound(sound, runtime, assets.soundBank));
    // Only attempt to load the sound after the deserialization
    // process has been completed.
  });
  return assets;
};

/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {JSZip} zip Sb3 file describing this project (to load assets from)
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.
 */
const parseScratchObject = function parseScratchObject(object, runtime, extensions, zip, assets) {
  if (!Object.prototype.hasOwnProperty.call(object, 'name')) {
    // Watcher/monitor - skip this object until those are implemented in VM.
    // @todo
    return Promise.resolve(null);
  }
  // Blocks container for this object.
  const blocks = new Blocks(runtime);

  // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.
  const sprite = new Sprite(blocks, runtime);

  // Sprite/stage name from JSON.
  if (Object.prototype.hasOwnProperty.call(object, 'name')) {
    sprite.name = object.name;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'blocks')) {
    deserializeBlocks(object.blocks);
    // Take a second pass to create objects and add extensions
    for (const blockId in object.blocks) {
      if (!Object.prototype.hasOwnProperty.call(object.blocks, blockId)) continue;
      const blockJSON = object.blocks[blockId];
      blocks.createBlock(blockJSON);

      // If the block is from an extension, record it.
      const extensionID = getExtensionIdForOpcode(blockJSON.opcode);
      if (extensionID) {
        extensions.extensionIDs.add(extensionID);
      }
    }
  }
  // Costumes from JSON.
  const {
    costumePromises
  } = assets;
  // Sounds from JSON
  const {
    soundBank,
    soundPromises
  } = assets;
  // Create the first clone, and load its run-state from JSON.
  const target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
  // Load target properties from JSON.
  if (Object.prototype.hasOwnProperty.call(object, 'tempo')) {
    target.tempo = object.tempo;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'volume')) {
    target.volume = object.volume;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'videoTransparency')) {
    target.videoTransparency = object.videoTransparency;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'videoState')) {
    target.videoState = object.videoState;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'textToSpeechLanguage')) {
    target.textToSpeechLanguage = object.textToSpeechLanguage;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'variables')) {
    for (const varId in object.variables) {
      const variable = object.variables[varId];
      // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable
      const isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();
      const newVariable = new Variable(varId,
      // var id is the index of the variable desc array in the variables obj
      variable[0],
      // name of the variable
      Variable.SCALAR_TYPE,
      // type of the variable
      isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable[1];
      target.variables[newVariable.id] = newVariable;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'lists')) {
    for (const listId in object.lists) {
      const list = object.lists[listId];
      const newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);
      newList.value = list[1];
      target.variables[newList.id] = newList;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'broadcasts')) {
    for (const broadcastId in object.broadcasts) {
      const broadcast = object.broadcasts[broadcastId];
      const newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false);
      // no need to explicitly set the value, variable constructor
      // sets the value to the same as the name for broadcast msgs
      target.variables[newBroadcast.id] = newBroadcast;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'comments')) {
    for (const commentId in object.comments) {
      const comment = object.comments[commentId];
      const newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);
      if (comment.blockId) {
        newComment.blockId = comment.blockId;
      }
      target.comments[newComment.id] = newComment;
    }
  }
  if (Object.prototype.hasOwnProperty.call(object, 'x')) {
    target.x = object.x;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'y')) {
    target.y = object.y;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'direction')) {
    // Sometimes the direction can be outside of the range: LLK/scratch-gui#5806
    // wrapClamp it (like we do on RenderedTarget.setDirection)
    target.direction = MathUtil.wrapClamp(object.direction, -179, 180);
  }
  if (Object.prototype.hasOwnProperty.call(object, 'size')) {
    target.size = object.size;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'visible')) {
    target.visible = object.visible;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'currentCostume')) {
    target.currentCostume = MathUtil.clamp(object.currentCostume, 0, object.costumes.length - 1);
  }
  if (Object.prototype.hasOwnProperty.call(object, 'rotationStyle')) {
    target.rotationStyle = object.rotationStyle;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'isStage')) {
    target.isStage = object.isStage;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'targetPaneOrder')) {
    // Temporarily store the 'targetPaneOrder' property
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.targetPaneOrder;
  }
  if (Object.prototype.hasOwnProperty.call(object, 'draggable')) {
    target.draggable = object.draggable;
  }
  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds;
    // Make sure if soundBank is undefined, sprite.soundBank is then null.
    sprite.soundBank = soundBank || null;
  });
  return Promise.all(costumePromises.concat(soundPromises)).then(() => target);
};
const deserializeMonitor = function deserializeMonitor(monitorData, runtime, targets, extensions) {
  // If the serialized monitor has spriteName defined, look up the sprite
  // by name in the given list of targets and update the monitor's targetId
  // to match the sprite's id.
  if (monitorData.spriteName) {
    const filteredTargets = targets.filter(t => t.sprite.name === monitorData.spriteName);
    if (filteredTargets && filteredTargets.length > 0) {
      monitorData.targetId = filteredTargets[0].id;
    } else {
      log.warn("Tried to deserialize sprite specific monitor ".concat(monitorData.opcode, " but could not find sprite ").concat(monitorData.spriteName, "."));
    }
  }

  // Get information about this monitor, if it exists, given the monitor's opcode.
  // This will be undefined for extension blocks
  const monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode];

  // Due to a bug (see https://github.com/scratchfoundation/scratch-vm/pull/2322), renamed list monitors may have been serialized
  // with an outdated/incorrect LIST parameter. Fix it up to use the current name of the actual corresponding list.
  if (monitorData.opcode === 'data_listcontents') {
    const listTarget = monitorData.targetId ? targets.find(t => t.id === monitorData.targetId) : targets.find(t => t.isStage);
    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {
      monitorData.params.LIST = listTarget.variables[monitorData.id].name;
    }
  }

  // Convert the serialized monitorData params into the block fields structure
  const fields = {};
  for (const paramKey in monitorData.params) {
    const field = {
      name: paramKey,
      value: monitorData.params[paramKey]
    };
    fields[paramKey] = field;
  }

  // Variables, lists, and non-sprite-specific monitors, including any extension
  // monitors should already have the correct monitor ID serialized in the monitorData,
  // find the correct id for all other monitors.
  if (monitorData.opcode !== 'data_variable' && monitorData.opcode !== 'data_listcontents' && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {
    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);
  } else {
    // Replace unsafe characters in monitor ID, if there are any.
    // These would have come from projects that were originally 2.0 projects
    // that had unsafe characters in the variable name (and then the name was
    // used as part of the variable ID when importing the project).
    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);
  }

  // If the runtime already has a monitor block for this monitor's id,
  // update the existing block with the relevant monitor information.
  const existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];
  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    existingMonitorBlock.isMonitored = monitorData.visible;
    existingMonitorBlock.targetId = monitorData.targetId;
  } else {
    // If a monitor block doesn't already exist for this monitor,
    // construct a monitor block to add to the monitor blocks container
    const monitorBlock = {
      id: monitorData.id,
      opcode: monitorData.opcode,
      inputs: {},
      // Assuming that monitor blocks don't have droppable fields
      fields: fields,
      topLevel: true,
      next: null,
      parent: null,
      shadow: false,
      x: 0,
      y: 0,
      isMonitored: monitorData.visible,
      targetId: monitorData.targetId
    };

    // Variables and lists have additional properties
    // stored in their fields, update this info in the
    // monitor block fields
    if (monitorData.opcode === 'data_variable') {
      const field = monitorBlock.fields.VARIABLE;
      field.id = monitorData.id;
      field.variableType = Variable.SCALAR_TYPE;
    } else if (monitorData.opcode === 'data_listcontents') {
      const field = monitorBlock.fields.LIST;
      field.id = monitorData.id;
      field.variableType = Variable.LIST_TYPE;
    }
    runtime.monitorBlocks.createBlock(monitorBlock);

    // If the block is from an extension, record it.
    const extensionID = getExtensionIdForOpcode(monitorBlock.opcode);
    if (extensionID) {
      extensions.extensionIDs.add(extensionID);
    }
  }
  runtime.requestAddMonitor(MonitorRecord(monitorData));
};

// Replace variable IDs throughout the project with
// xml-safe versions.
// This is to fix up projects imported from 2.0 where xml-unsafe names
// were getting added to the variable ids.
const replaceUnsafeCharsInVariableIds = function replaceUnsafeCharsInVariableIds(targets) {
  const allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true);
  // Re-id the variables in the actual targets
  targets.forEach(t => {
    Object.keys(t.variables).forEach(id => {
      const newId = StringUtil.replaceUnsafeChars(id);
      if (newId === id) return;
      t.variables[id].id = newId;
      t.variables[newId] = t.variables[id];
      delete t.variables[id];
    });
  });

  // Replace the IDs in the blocks refrencing variables or lists
  for (const id in allVarRefs) {
    const newId = StringUtil.replaceUnsafeChars(id);
    if (id === newId) continue; // ID was already safe, skip
    // We're calling this on the stage target because we need a
    // target to call on but this shouldn't matter because we're passing
    // in all the varRefs we want to operate on
    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);
  }
  return targets;
};

/**
 * Deserialize the specified representation of a VM runtime and loads it into the provided runtime instance.
 * @param  {object} json - JSON representation of a VM runtime.
 * @param  {Runtime} runtime - Runtime instance
 * @param {JSZip} zip - Sb3 file describing this project (to load assets from)
 * @param {boolean} isSingleSprite - If true treat as single sprite, else treat as whole project
 * @returns {Promise.<ImportedProject>} Promise that resolves to the list of targets after the project is deserialized
 */
const deserialize = function deserialize(json, runtime, zip, isSingleSprite) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  };

  // Store the origin field (e.g. project originated at CSFirst) so that we can save it again.
  if (json.meta && json.meta.origin) {
    runtime.origin = json.meta.origin;
  } else {
    runtime.origin = null;
  }

  // First keep track of the current target order in the json,
  // then sort by the layer order property before parsing the targets
  // so that their corresponding render drawables can be created in
  // their layer order (e.g. back to front)
  const targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map((t, i) => Object.assign(t, {
    targetPaneOrder: i
  })).sort((a, b) => a.layerOrder - b.layerOrder);
  const monitorObjects = json.monitors || [];
  return Promise.resolve(targetObjects.map(target => parseScratchAssets(target, runtime, zip)))
  // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => Promise.all(targetObjects.map((target, index) => parseScratchObject(target, runtime, extensions, zip, assets[index])))).then(targets => targets // Re-sort targets back into original sprite-pane ordering
  .map((t, i) => {
    // Add layer order property to deserialized targets.
    // This property is used to initialize executable targets in
    // the correct order and is deleted in VM's installTargets function
    t.layerOrder = i;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder).map(t => {
    // Delete the temporary properties used for
    // sprite pane ordering and stage layer ordering
    delete t.targetPaneOrder;
    return t;
  })).then(targets => replaceUnsafeCharsInVariableIds(targets)).then(targets => {
    monitorObjects.map(monitorDesc => deserializeMonitor(monitorDesc, runtime, targets, extensions));
    return targets;
  }).then(targets => ({
    targets,
    extensions
  }));
};
module.exports = {
  serialize: serialize,
  deserialize: deserialize,
  deserializeBlocks: deserializeBlocks,
  serializeBlocks: serializeBlocks,
  getExtensionIdForOpcode: getExtensionIdForOpcode
};

/***/ }),

/***/ "./src/serialization/serialize-assets.js":
/*!***********************************************!*\
  !*** ./src/serialization/serialize-assets.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Serialize all the assets of the given type ('sounds' or 'costumes')
 * in the provided runtime into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized asset.
 * @param {Runtime} runtime The runtime with the assets to be serialized
 * @param {string} assetType The type of assets to be serialized: 'sounds' | 'costumes'
 * @param {string=} optTargetId Optional target id to serialize assets for
 * @returns {Array<object>} An array of file descriptors for each asset
 */
const serializeAssets = function serializeAssets(runtime, assetType, optTargetId) {
  const targets = optTargetId ? [runtime.getTargetById(optTargetId)] : runtime.targets;
  const assetDescs = [];
  for (let i = 0; i < targets.length; i++) {
    const currTarget = targets[i];
    const currAssets = currTarget.sprite[assetType];
    for (let j = 0; j < currAssets.length; j++) {
      const currAsset = currAssets[j];
      const asset = currAsset.broken ? currAsset.broken.asset : currAsset.asset;
      if (asset) {
        // Serialize asset if it exists, otherwise skip
        assetDescs.push({
          fileName: "".concat(asset.assetId, ".").concat(asset.dataFormat),
          fileContent: asset.data
        });
      }
    }
  }
  return assetDescs;
};

/**
 * Serialize all the sounds in the provided runtime or, if a target id is provided,
 * in the specified target into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized sound.
 * @param {Runtime} runtime The runtime with the sounds to be serialized
 * @param {string=} optTargetId Optional targetid for serializing sounds of a single target
 * @returns {Array<object>} An array of file descriptors for each sound
 */
const serializeSounds = function serializeSounds(runtime, optTargetId) {
  return serializeAssets(runtime, 'sounds', optTargetId);
};

/**
 * Serialize all the costumes in the provided runtime into an array of file
 * descriptors. A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized costume.
 * @param {Runtime} runtime The runtime with the costumes to be serialized
 * @param {string} optTargetId Optional targetid for serializing costumes of a single target
 * @returns {Array<object>} An array of file descriptors for each costume
 */
const serializeCostumes = function serializeCostumes(runtime, optTargetId) {
  return serializeAssets(runtime, 'costumes', optTargetId);
};
module.exports = {
  serializeSounds,
  serializeCostumes
};

/***/ }),

/***/ "./src/sprites/rendered-target.js":
/*!****************************************!*\
  !*** ./src/sprites/rendered-target.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");
const Target = __webpack_require__(/*! ../engine/target */ "./src/engine/target.js");
const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

/**
 * Rendered target: instance of a sprite (clone), or the stage.
 */
class RenderedTarget extends Target {
  /**
   * @param {!Sprite} sprite Reference to the parent sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(sprite, runtime) {
    super(runtime, sprite.blocks);

    /**
     * Reference to the sprite that this is a render of.
     * @type {!Sprite}
     */
    this.sprite = sprite;
    /**
     * Reference to the global renderer for this VM, if one exists.
     * @type {?RenderWebGL}
     */
    this.renderer = null;
    if (this.runtime) {
      this.renderer = this.runtime.renderer;
    }
    /**
     * ID of the drawable for this rendered target,
     * returned by the renderer, if rendered.
     * @type {?Number}
     */
    this.drawableID = null;

    /**
     * Drag state of this rendered target. If true, x/y position can't be
     * changed by blocks.
     * @type {boolean}
     */
    this.dragging = false;

    /**
     * Map of current graphic effect values.
     * @type {!Object.<string, number>}
     */
    this.effects = {
      color: 0,
      fisheye: 0,
      whirl: 0,
      pixelate: 0,
      mosaic: 0,
      brightness: 0,
      ghost: 0
    };

    /**
     * Whether this represents an "original" non-clone rendered-target for a sprite,
     * i.e., created by the editor and not clone blocks.
     * @type {boolean}
     */
    this.isOriginal = true;

    /**
     * Whether this rendered target represents the Scratch stage.
     * @type {boolean}
     */
    this.isStage = false;

    /**
     * Scratch X coordinate. Currently should range from -240 to 240.
     * @type {Number}
     */
    this.x = 0;

    /**
     * Scratch Y coordinate. Currently should range from -180 to 180.
     * @type {number}
     */
    this.y = 0;

    /**
     * Scratch direction. Currently should range from -179 to 180.
     * @type {number}
     */
    this.direction = 90;

    /**
     * Whether the rendered target is draggable on the stage
     * @type {boolean}
     */
    this.draggable = false;

    /**
     * Whether the rendered target is currently visible.
     * @type {boolean}
     */
    this.visible = true;

    /**
     * Size of rendered target as a percent of costume size.
     * @type {number}
     */
    this.size = 100;

    /**
     * Currently selected costume index.
     * @type {number}
     */
    this.currentCostume = 0;

    /**
     * Current rotation style.
     * @type {!string}
     */
    this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;

    /**
     * Loudness for sound playback for this target, as a percentage.
     * @type {number}
     */
    this.volume = 100;

    /**
     * Current tempo (used by the music extension).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */
    this.tempo = 60;

    /**
     * The transparency of the video (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */
    this.videoTransparency = 50;

    /**
     * The state of the video input (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     *
     * Defaults to ON. This setting does not turn the video by itself. A
     * video extension once loaded will set the video device to this
     * setting. Set to ON when a video extension is added in the editor the
     * video will start ON. If the extension is loaded as part of loading a
     * saved project the extension will see the value set when the stage
     * was loaded from the saved values including the video state.
     *
     * @type {string}
     */
    this.videoState = RenderedTarget.VIDEO_STATE.ON;

    /**
     * The language to use for speech synthesis, in the text2speech extension.
     * It is initialized to null so that on extension load, we can check for
     * this and try setting it using the editor locale.
     * @type {string}
     */
    this.textToSpeechLanguage = null;
  }

  /**
   * Create a drawable with the this.renderer.
   * @param {boolean} layerGroup The layer group this drawable should be added to
   */
  initDrawable(layerGroup) {
    if (this.renderer) {
      this.drawableID = this.renderer.createDrawable(layerGroup);
    }
    // If we're a clone, start the hats.
    if (!this.isOriginal) {
      this.runtime.startHats('control_start_as_clone', null, this);
    }
  }
  get audioPlayer() {
    /* eslint-disable no-console */
    console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');
    console.warn(new Error('stack for debug').stack);
    /* eslint-enable no-console */
    const bank = this.sprite.soundBank;
    const audioPlayerProxy = {
      playSound: soundId => bank.play(this, soundId)
    };
    Object.defineProperty(this, 'audioPlayer', {
      configurable: false,
      enumerable: true,
      writable: false,
      value: audioPlayerProxy
    });
    return audioPlayerProxy;
  }

  /**
   * Initialize the audio player for this sprite or clone.
   */
  initAudio() {}

  /**
   * Event which fires when a target moves.
   * @type {string}
   */
  static get EVENT_TARGET_MOVED() {
    return 'TARGET_MOVED';
  }

  /**
   * Event which fires when a target changes visually, for updating say bubbles.
   * @type {string}
   */
  static get EVENT_TARGET_VISUAL_CHANGE() {
    return 'EVENT_TARGET_VISUAL_CHANGE';
  }

  /**
   * Rotation style for "all around"/spinning.
   * @type {string}
   */
  static get ROTATION_STYLE_ALL_AROUND() {
    return 'all around';
  }

  /**
   * Rotation style for "left-right"/flipping.
   * @type {string}
   */
  static get ROTATION_STYLE_LEFT_RIGHT() {
    return 'left-right';
  }

  /**
   * Rotation style for "no rotation."
   * @type {string}
   */
  static get ROTATION_STYLE_NONE() {
    return "don't rotate";
  }

  /**
   * Available states for video input.
   * @enum {string}
   */
  static get VIDEO_STATE() {
    return {
      OFF: 'off',
      ON: 'on',
      ON_FLIPPED: 'on-flipped'
    };
  }

  /**
   * Set the X and Y coordinates.
   * @param {!number} x New X coordinate, in Scratch coordinates.
   * @param {!number} y New Y coordinate, in Scratch coordinates.
   * @param {?boolean} force Force setting X/Y, in case of dragging
   */
  setXY(x, y, force) {
    if (this.isStage) return;
    if (this.dragging && !force) return;
    const oldX = this.x;
    const oldY = this.y;
    if (this.renderer) {
      const position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);
      this.x = position[0];
      this.y = position[1];
      this.renderer.updateDrawablePosition(this.drawableID, position);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    } else {
      this.x = x;
      this.y = y;
    }
    this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Get the rendered direction and scale, after applying rotation style.
   * @return {object<string, number>} Direction and scale to render.
   */
  _getRenderedDirectionAndScale() {
    // Default: no changes to `this.direction` or `this.scale`.
    let finalDirection = this.direction;
    let finalScale = [this.size, this.size];
    if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      // Force rendered direction to be 90.
      finalDirection = 90;
    } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      // Force rendered direction to be 90, and flip drawable if needed.
      finalDirection = 90;
      const scaleFlip = this.direction < 0 ? -1 : 1;
      finalScale = [scaleFlip * this.size, this.size];
    }
    return {
      direction: finalDirection,
      scale: finalScale
    };
  }

  /**
   * Set the direction.
   * @param {!number} direction New direction.
   */
  setDirection(direction) {
    if (this.isStage) {
      return;
    }
    if (!isFinite(direction)) {
      return;
    }
    // Keep direction between -179 and +180.
    this.direction = MathUtil.wrapClamp(direction, -179, 180);
    if (this.renderer) {
      const {
        direction: renderedDirection,
        scale
      } = this._getRenderedDirectionAndScale();
      this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Set draggability; i.e., whether it's able to be dragged in the player
   * @param {!boolean} draggable True if should be draggable.
   */
  setDraggable(draggable) {
    if (this.isStage) return;
    this.draggable = !!draggable;
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Set visibility; i.e., whether it's shown or hidden.
   * @param {!boolean} visible True if should be shown.
   */
  setVisible(visible) {
    if (this.isStage) {
      return;
    }
    this.visible = !!visible;
    if (this.renderer) {
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Set size, as a percentage of the costume size.
   * @param {!number} size Size of rendered target, as % of costume size.
   */
  setSize(size) {
    if (this.isStage) {
      return;
    }
    if (this.renderer) {
      // Clamp to scales relative to costume and stage size.
      // See original ScratchSprite.as:setSize.
      const costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);
      const origW = costumeSize[0];
      const origH = costumeSize[1];
      const minScale = Math.min(1, Math.max(5 / origW, 5 / origH));
      const maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);
      this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Set a particular graphic effect value.
   * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
   * @param {!number} value Numerical magnitude of effect.
   */
  setEffect(effectName, value) {
    if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) return;
    this.effects[effectName] = value;
    if (this.renderer) {
      this.renderer.updateDrawableEffect(this.drawableID, effectName, value);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }

  /**
   * Clear all graphic effects on this rendered target.
   */
  clearEffects() {
    for (const effectName in this.effects) {
      if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;
      this.effects[effectName] = 0;
    }
    if (this.renderer) {
      for (const effectName in this.effects) {
        if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, 0);
      }
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }

  /**
   * Set the current costume.
   * @param {number} index New index of costume.
   */
  setCostume(index) {
    // Keep the costume index within possible values.
    index = Math.round(index);
    if ([Infinity, -Infinity, NaN].includes(index)) index = 0;
    this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);
    if (this.renderer) {
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Add a costume, taking care to avoid duplicate names.
   * @param {!object} costumeObject Object representing the costume.
   * @param {?int} index Index at which to add costume
   */
  addCostume(costumeObject, index) {
    if (typeof index === 'number' && !isNaN(index)) {
      this.sprite.addCostumeAt(costumeObject, index);
    } else {
      this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);
    }
  }

  /**
   * Rename a costume, taking care to avoid duplicate names.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */
  renameCostume(costumeIndex, newName) {
    const usedNames = this.sprite.costumes.filter((costume, index) => costumeIndex !== index).map(costume => costume.name);
    const oldName = this.getCostumes()[costumeIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.getCostumes()[costumeIndex].name = newUnusedName;
    if (this.isStage) {
      // Since this is a backdrop, go through all targets and
      // update any blocks referencing the old backdrop name
      const targets = this.runtime.targets;
      for (let i = 0; i < targets.length; i++) {
        const currTarget = targets[i];
        currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');
      }
    } else {
      this.blocks.updateAssetName(oldName, newUnusedName, 'costume');
    }
  }

  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The costume that was deleted or null
   * if the index was out of bounds of the costumes list or
   * this target only has one costume.
   */
  deleteCostume(index) {
    const originalCostumeCount = this.sprite.costumes.length;
    if (originalCostumeCount === 1) return null;
    if (index < 0 || index >= originalCostumeCount) {
      return null;
    }
    const deletedCostume = this.sprite.deleteCostumeAt(index);
    if (index === this.currentCostume && index === originalCostumeCount - 1) {
      this.setCostume(index - 1);
    } else if (index < this.currentCostume) {
      this.setCostume(this.currentCostume - 1);
    } else {
      this.setCostume(this.currentCostume);
    }
    this.runtime.requestTargetsUpdate(this);
    return deletedCostume;
  }

  /**
   * Add a sound, taking care to avoid duplicate names.
   * @param {!object} soundObject Object representing the sound.
   * @param {?int} index Index at which to add costume
   */
  addSound(soundObject, index) {
    const usedNames = this.sprite.sounds.map(sound => sound.name);
    soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);
    if (typeof index === 'number' && !isNaN(index)) {
      this.sprite.sounds.splice(index, 0, soundObject);
    } else {
      this.sprite.sounds.push(soundObject);
    }
  }

  /**
   * Rename a sound, taking care to avoid duplicate names.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */
  renameSound(soundIndex, newName) {
    const usedNames = this.sprite.sounds.filter((sound, index) => soundIndex !== index).map(sound => sound.name);
    const oldName = this.sprite.sounds[soundIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.sprite.sounds[soundIndex].name = newUnusedName;
    this.blocks.updateAssetName(oldName, newUnusedName, 'sound');
  }

  /**
   * Delete a sound by index.
   * @param {number} index Sound index to be deleted
   * @return {object} The deleted sound object, or null if no sound was deleted.
   */
  deleteSound(index) {
    // Make sure the sound index is not out of bounds
    if (index < 0 || index >= this.sprite.sounds.length) {
      return null;
    }
    // Delete the sound at the given index
    const deletedSound = this.sprite.sounds.splice(index, 1)[0];
    this.runtime.requestTargetsUpdate(this);
    return deletedSound;
  }

  /**
   * Update the rotation style.
   * @param {!string} rotationStyle New rotation style.
   */
  setRotationStyle(rotationStyle) {
    if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    }
    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Get a costume index of this rendered target, by name of the costume.
   * @param {?string} costumeName Name of a costume.
   * @return {number} Index of the named costume, or -1 if not present.
   */
  getCostumeIndexByName(costumeName) {
    for (let i = 0; i < this.sprite.costumes.length; i++) {
      if (this.getCostumes()[i].name === costumeName) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Get a costume of this rendered target by id.
   * @return {object} current costume
   */
  getCurrentCostume() {
    return this.getCostumes()[this.currentCostume];
  }

  /**
   * Get full costume list
   * @return {object[]} list of costumes
   */
  getCostumes() {
    return this.sprite.costumes;
  }

  /**
   * Reorder costume list by moving costume at costumeIndex to newIndex.
   * @param {!number} costumeIndex Index of the costume to move.
   * @param {!number} newIndex New index for that costume.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */
  reorderCostume(costumeIndex, newIndex) {
    newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);
    costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);
    if (newIndex === costumeIndex) return false;
    const currentCostume = this.getCurrentCostume();
    const costume = this.sprite.costumes[costumeIndex];

    // Use the sprite method for deleting costumes because setCostume is handled manually
    this.sprite.deleteCostumeAt(costumeIndex);
    this.addCostume(costume, newIndex);
    this.currentCostume = this.getCostumeIndexByName(currentCostume.name);
    return true;
  }

  /**
   * Reorder sound list by moving sound at soundIndex to newIndex.
   * @param {!number} soundIndex Index of the sound to move.
   * @param {!number} newIndex New index for that sound.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */
  reorderSound(soundIndex, newIndex) {
    newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);
    soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);
    if (newIndex === soundIndex) return false;
    const sound = this.sprite.sounds[soundIndex];
    this.deleteSound(soundIndex);
    this.addSound(sound, newIndex);
    return true;
  }

  /**
   * Get full sound list
   * @return {object[]} list of sounds
   */
  getSounds() {
    return this.sprite.sounds;
  }

  /**
   * Update all drawable properties for this rendered target.
   * Use when a batch has changed, e.g., when the drawable is first created.
   */
  updateAllDrawableProperties() {
    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();
      this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);
      for (const effectName in this.effects) {
        if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);
      }
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
    this.runtime.requestTargetsUpdate(this);
  }

  /**
   * Return the human-readable name for this rendered target, e.g., the sprite's name.
   * @override
   * @returns {string} Human-readable name.
   */
  getName() {
    return this.sprite.name;
  }

  /**
   * Return whether this rendered target is a sprite (not a clone, not the stage).
   * @return {boolean} True if not a clone and not the stage.
   */
  isSprite() {
    return !this.isStage && this.isOriginal;
  }

  /**
   * Return the rendered target's tight bounding box.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */
  getBounds() {
    if (this.renderer) {
      return this.runtime.renderer.getBounds(this.drawableID);
    }
    return null;
  }

  /**
   * Return the bounding box around a slice of the top 8px of the rendered target.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */
  getBoundsForBubble() {
    if (this.renderer) {
      return this.runtime.renderer.getBoundsForBubble(this.drawableID);
    }
    return null;
  }

  /**
   * Return whether this target is touching the mouse, an edge, or a sprite.
   * @param {string} requestedObject an id for mouse or edge, or a sprite name.
   * @return {boolean} True if the sprite is touching the object.
   */
  isTouchingObject(requestedObject) {
    if (requestedObject === '_mouse_') {
      if (!this.runtime.ioDevices.mouse) return false;
      const mouseX = this.runtime.ioDevices.mouse.getClientX();
      const mouseY = this.runtime.ioDevices.mouse.getClientY();
      return this.isTouchingPoint(mouseX, mouseY);
    } else if (requestedObject === '_edge_') {
      return this.isTouchingEdge();
    }
    return this.isTouchingSprite(requestedObject);
  }

  /**
   * Return whether touching a point.
   * @param {number} x X coordinate of test point.
   * @param {number} y Y coordinate of test point.
   * @return {boolean} True iff the rendered target is touching the point.
   */
  isTouchingPoint(x, y) {
    if (this.renderer) {
      return this.renderer.drawableTouching(this.drawableID, x, y);
    }
    return false;
  }

  /**
   * Return whether touching a stage edge.
   * @return {boolean} True iff the rendered target is touching the stage edge.
   */
  isTouchingEdge() {
    if (this.renderer) {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      const bounds = this.getBounds();
      if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
        return true;
      }
    }
    return false;
  }

  /**
   * Return whether touching any of a named sprite's clones.
   * @param {string} spriteName Name of the sprite.
   * @return {boolean} True iff touching a clone of the sprite.
   */
  isTouchingSprite(spriteName) {
    spriteName = Cast.toString(spriteName);
    const firstClone = this.runtime.getSpriteTargetByName(spriteName);
    if (!firstClone || !this.renderer) {
      return false;
    }
    // Filter out dragging targets. This means a sprite that is being dragged
    // can detect other sprites using touching <sprite>, but cannot be detected
    // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.
    const drawableCandidates = firstClone.sprite.clones.filter(clone => !clone.dragging).map(clone => clone.drawableID);
    return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
  }

  /**
   * Return whether touching a color.
   * @param {Array.<number>} rgb [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the rendered target is touching the color.
   */
  isTouchingColor(rgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, rgb);
    }
    return false;
  }

  /**
   * Return whether rendered target's color is touching a color.
   * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
   * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the color is touching the color.
   */
  colorIsTouchingColor(targetRgb, maskRgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
    }
    return false;
  }
  getLayerOrder() {
    if (this.renderer) {
      return this.renderer.getDrawableOrder(this.drawableID);
    }
    return null;
  }

  /**
   * Move to the front layer.
   */
  goToFront() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);
    }
    this.runtime.setExecutablePosition(this, Infinity);
  }

  /**
   * Move to the back layer.
   */
  goToBack() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);
    }
    this.runtime.setExecutablePosition(this, -Infinity);
  }

  /**
   * Move forward a number of layers.
   * @param {number} nLayers How many layers to go forward.
   */
  goForwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);
    }
    this.runtime.moveExecutable(this, nLayers);
  }

  /**
   * Move backward a number of layers.
   * @param {number} nLayers How many layers to go backward.
   */
  goBackwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);
    }
    this.runtime.moveExecutable(this, -nLayers);
  }

  /**
   * Move behind some other rendered target.
   * @param {!RenderedTarget} other Other rendered target to move behind.
   */
  goBehindOther(other) {
    if (this.renderer) {
      const otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);
      this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);
    }
    const executionPosition = this.runtime.executableTargets.indexOf(other);
    this.runtime.setExecutablePosition(this, executionPosition);
  }

  /**
   * Keep a desired position within a fence.
   * @param {number} newX New desired X position.
   * @param {number} newY New desired Y position.
   * @param {object=} optFence Optional fence with left, right, top bottom.
   * @return {Array.<number>} Fenced X and Y coordinates.
   */
  keepInFence(newX, newY, optFence) {
    let fence = optFence;
    if (!fence) {
      fence = {
        left: -this.runtime.constructor.STAGE_WIDTH / 2,
        right: this.runtime.constructor.STAGE_WIDTH / 2,
        top: this.runtime.constructor.STAGE_HEIGHT / 2,
        bottom: -this.runtime.constructor.STAGE_HEIGHT / 2
      };
    }
    const bounds = this.getBounds();
    if (!bounds) return;
    // Adjust the known bounds to the target position.
    bounds.left += newX - this.x;
    bounds.right += newX - this.x;
    bounds.top += newY - this.y;
    bounds.bottom += newY - this.y;
    // Find how far we need to move the target position.
    let dx = 0;
    let dy = 0;
    if (bounds.left < fence.left) {
      dx += fence.left - bounds.left;
    }
    if (bounds.right > fence.right) {
      dx += fence.right - bounds.right;
    }
    if (bounds.top > fence.top) {
      dy += fence.top - bounds.top;
    }
    if (bounds.bottom < fence.bottom) {
      dy += fence.bottom - bounds.bottom;
    }
    return [newX + dx, newY + dy];
  }

  /**
   * Make a clone, copying any run-time properties.
   * If we've hit the global clone limit, returns null.
   * @return {RenderedTarget} New clone.
   */
  makeClone() {
    if (!this.runtime.clonesAvailable() || this.isStage) {
      return null; // Hit max clone limit, or this is the stage.
    }
    this.runtime.changeCloneCounter(1);
    const newClone = this.sprite.createClone();
    // Copy all properties.
    newClone.x = this.x;
    newClone.y = this.y;
    newClone.direction = this.direction;
    newClone.draggable = this.draggable;
    newClone.visible = this.visible;
    newClone.size = this.size;
    newClone.currentCostume = this.currentCostume;
    newClone.rotationStyle = this.rotationStyle;
    newClone.effects = Clone.simple(this.effects);
    newClone.variables = this.duplicateVariables();
    newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);
    newClone.initDrawable(StageLayering.SPRITE_LAYER);
    newClone.updateAllDrawableProperties();
    return newClone;
  }

  /**
   * Make a duplicate using a duplicate sprite.
   * @return {RenderedTarget} New clone.
   */
  duplicate() {
    return this.sprite.duplicate().then(newSprite => {
      const newTarget = newSprite.createClone();
      // Copy all properties.
      // @todo refactor with clone methods
      newTarget.x = (Math.random() - 0.5) * 400 / 2;
      newTarget.y = (Math.random() - 0.5) * 300 / 2;
      newTarget.direction = this.direction;
      newTarget.draggable = this.draggable;
      newTarget.visible = this.visible;
      newTarget.size = this.size;
      newTarget.currentCostume = this.currentCostume;
      newTarget.rotationStyle = this.rotationStyle;
      newTarget.effects = JSON.parse(JSON.stringify(this.effects));
      newTarget.variables = this.duplicateVariables(newTarget.blocks);
      newTarget.updateAllDrawableProperties();
      return newTarget;
    });
  }

  /**
   * Called when the project receives a "green flag."
   * For a rendered target, this clears graphic effects.
   */
  onGreenFlag() {
    this.clearEffects();
  }

  /**
   * Called when the project receives a "stop all"
   * Stop all sounds and clear graphic effects.
   */
  onStopAll() {
    this.clearEffects();
  }

  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   */
  postSpriteInfo(data) {
    const force = Object.prototype.hasOwnProperty.call(data, 'force') ? data.force : null;
    const isXChanged = Object.prototype.hasOwnProperty.call(data, 'x');
    const isYChanged = Object.prototype.hasOwnProperty.call(data, 'y');
    if (isXChanged || isYChanged) {
      this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);
    }
    if (Object.prototype.hasOwnProperty.call(data, 'direction')) {
      this.setDirection(data.direction);
    }
    if (Object.prototype.hasOwnProperty.call(data, 'draggable')) {
      this.setDraggable(data.draggable);
    }
    if (Object.prototype.hasOwnProperty.call(data, 'rotationStyle')) {
      this.setRotationStyle(data.rotationStyle);
    }
    if (Object.prototype.hasOwnProperty.call(data, 'visible')) {
      this.setVisible(data.visible);
    }
    if (Object.prototype.hasOwnProperty.call(data, 'size')) {
      this.setSize(data.size);
    }
  }

  /**
   * Put the sprite into the drag state. While in effect, setXY must be forced
   */
  startDrag() {
    this.dragging = true;
  }

  /**
   * Remove the sprite from the drag state.
   */
  stopDrag() {
    this.dragging = false;
  }

  /**
   * Serialize sprite info, used when emitting events about the sprite
   * @returns {object} Sprite data as a simple object
   */
  toJSON() {
    const costumes = this.getCostumes();
    return {
      id: this.id,
      name: this.getName(),
      isStage: this.isStage,
      x: this.x,
      y: this.y,
      size: this.size,
      direction: this.direction,
      draggable: this.draggable,
      currentCostume: this.currentCostume,
      costume: costumes[this.currentCostume],
      costumeCount: costumes.length,
      visible: this.visible,
      rotationStyle: this.rotationStyle,
      comments: this.comments,
      blocks: this.blocks._blocks,
      variables: this.variables,
      costumes: costumes,
      sounds: this.getSounds(),
      textToSpeechLanguage: this.textToSpeechLanguage,
      tempo: this.tempo,
      volume: this.volume,
      videoTransparency: this.videoTransparency,
      videoState: this.videoState
    };
  }

  /**
   * Dispose, destroying any run-time properties.
   */
  dispose() {
    this.runtime.changeCloneCounter(-1);
    this.runtime.stopForTarget(this);
    this.runtime.removeExecutable(this);
    this.sprite.removeClone(this);
    if (this.renderer && this.drawableID !== null) {
      this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }
}
module.exports = RenderedTarget;

/***/ }),

/***/ "./src/sprites/sprite.js":
/*!*******************************!*\
  !*** ./src/sprites/sprite.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RenderedTarget = __webpack_require__(/*! ./rendered-target */ "./src/sprites/rendered-target.js");
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");
const {
  loadSoundFromAsset
} = __webpack_require__(/*! ../import/load-sound */ "./src/import/load-sound.js");
const {
  loadCostumeFromAsset
} = __webpack_require__(/*! ../import/load-costume */ "./src/import/load-costume.js");
const newBlockIds = __webpack_require__(/*! ../util/new-block-ids */ "./src/util/new-block-ids.js");
const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
class Sprite {
  /**
   * Sprite to be used on the Scratch stage.
   * All clones of a sprite have shared blocks, shared costumes, shared variables,
   * shared sounds, etc.
   * @param {?Blocks} blocks Shared blocks object for all clones of sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(blocks, runtime) {
    this.runtime = runtime;
    if (!blocks) {
      // Shared set of blocks for all clones.
      blocks = new Blocks(runtime);
    }
    this.blocks = blocks;
    /**
     * Human-readable name for this sprite (and all clones).
     * @type {string}
     */
    this.name = '';
    /**
     * List of costumes for this sprite.
     * Each entry is an object, e.g.,
     * {
     *      skinId: 1,
     *      name: "Costume Name",
     *      bitmapResolution: 2,
     *      rotationCenterX: 0,
     *      rotationCenterY: 0
     * }
     * @type {Array.<!Object>}
     */
    this.costumes_ = [];
    /**
     * List of sounds for this sprite.
    */
    this.sounds = [];
    /**
     * List of clones for this sprite, including the original.
     * @type {Array.<!RenderedTarget>}
     */
    this.clones = [];
    this.soundBank = null;
    if (this.runtime && this.runtime.audioEngine) {
      this.soundBank = this.runtime.audioEngine.createBank();
    }
  }

  /**
   * Add an array of costumes, taking care to avoid duplicate names.
   * @param {!Array<object>} costumes Array of objects representing costumes.
   */
  set costumes(costumes) {
    this.costumes_ = [];
    for (const costume of costumes) {
      this.addCostumeAt(costume, this.costumes_.length);
    }
  }

  /**
   * Get full costume list
   * @return {object[]} list of costumes. Note that mutating the returned list will not
   *     mutate the list on the sprite. The sprite list should be mutated by calling
   *     addCostumeAt, deleteCostumeAt, or setting costumes.
   */
  get costumes() {
    return this.costumes_;
  }

  /**
   * Add a costume at the given index, taking care to avoid duplicate names.
   * @param {!object} costumeObject Object representing the costume.
   * @param {!int} index Index at which to add costume
   */
  addCostumeAt(costumeObject, index) {
    if (!costumeObject.name) {
      costumeObject.name = '';
    }
    const usedNames = this.costumes_.map(costume => costume.name);
    costumeObject.name = StringUtil.unusedName(costumeObject.name, usedNames);
    this.costumes_.splice(index, 0, costumeObject);
  }

  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The deleted costume
   */
  deleteCostumeAt(index) {
    return this.costumes.splice(index, 1)[0];
  }

  /**
   * Create a clone of this sprite.
   * @param {string=} optLayerGroup Optional layer group the clone's drawable should be added to
   * Defaults to the sprite layer group
   * @returns {!RenderedTarget} Newly created clone.
   */
  createClone(optLayerGroup) {
    const newClone = new RenderedTarget(this, this.runtime);
    newClone.isOriginal = this.clones.length === 0;
    this.clones.push(newClone);
    newClone.initAudio();
    if (newClone.isOriginal) {
      // Default to the sprite layer group if optLayerGroup is not provided
      const layerGroup = typeof optLayerGroup === 'string' ? optLayerGroup : StageLayering.SPRITE_LAYER;
      newClone.initDrawable(layerGroup);
      this.runtime.fireTargetWasCreated(newClone);
    } else {
      this.runtime.fireTargetWasCreated(newClone, this.clones[0]);
    }
    return newClone;
  }

  /**
   * Disconnect a clone from this sprite. The clone is unmodified.
   * In particular, the clone's dispose() method is not called.
   * @param {!RenderedTarget} clone - the clone to be removed.
   */
  removeClone(clone) {
    this.runtime.fireTargetWasRemoved(clone);
    const cloneIndex = this.clones.indexOf(clone);
    if (cloneIndex >= 0) {
      this.clones.splice(cloneIndex, 1);
    }
  }
  duplicate() {
    const newSprite = new Sprite(null, this.runtime);
    const blocksContainer = this.blocks._blocks;
    const originalBlocks = Object.keys(blocksContainer).map(key => blocksContainer[key]);
    const copiedBlocks = JSON.parse(JSON.stringify(originalBlocks));
    newBlockIds(copiedBlocks);
    copiedBlocks.forEach(block => {
      newSprite.blocks.createBlock(block);
    });
    const allNames = this.runtime.targets.map(t => t.sprite.name);
    newSprite.name = StringUtil.unusedName(this.name, allNames);
    const assetPromises = [];
    newSprite.costumes = this.costumes_.map(costume => {
      const newCostume = Object.assign({}, costume);
      assetPromises.push(loadCostumeFromAsset(newCostume, this.runtime));
      return newCostume;
    });
    newSprite.sounds = this.sounds.map(sound => {
      const newSound = Object.assign({}, sound);
      const soundAsset = sound.asset;
      assetPromises.push(loadSoundFromAsset(newSound, soundAsset, this.runtime, newSprite.soundBank));
      return newSound;
    });
    return Promise.all(assetPromises).then(() => newSprite);
  }
  dispose() {
    if (this.soundBank) {
      this.soundBank.dispose();
    }
  }
}
module.exports = Sprite;

/***/ }),

/***/ "./src/util/base64-util.js":
/*!*********************************!*\
  !*** ./src/util/base64-util.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const atob = __webpack_require__(/*! atob */ "./node_modules/atob/browser-atob.js");
const btoa = __webpack_require__(/*! btoa */ "./node_modules/btoa/index.js");
class Base64Util {
  /**
   * Convert a base64 encoded string to a Uint8Array.
   * @param {string} base64 - a base64 encoded string.
   * @return {Uint8Array} - a decoded Uint8Array.
   */
  static base64ToUint8Array(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const array = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      array[i] = binaryString.charCodeAt(i);
    }
    return array;
  }

  /**
   * Convert a Uint8Array to a base64 encoded string.
   * @param {Uint8Array} array - the array to convert.
   * @return {string} - the base64 encoded string.
   */
  static uint8ArrayToBase64(array) {
    const base64 = btoa(String.fromCharCode.apply(null, array));
    return base64;
  }

  /**
  * Convert an array buffer to a base64 encoded string.
  * @param {array} buffer - an array buffer to convert.
  * @return {string} - the base64 encoded string.
  */
  static arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
}
module.exports = Base64Util;

/***/ }),

/***/ "./src/util/cast.js":
/*!**************************!*\
  !*** ./src/util/cast.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Color = __webpack_require__(/*! ../util/color */ "./src/util/color.js");

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */

class Cast {
  /**
   * Scratch cast to number.
   * Treats NaN as 0.
   * In Scratch 2.0, this is captured by `interp.numArg.`
   * @param {*} value Value to cast to number.
   * @return {number} The Scratch-casted number value.
   */
  static toNumber(value) {
    // If value is already a number we don't need to coerce it with
    // Number().
    if (typeof value === 'number') {
      // Scratch treats NaN as 0, when needed as a number.
      // E.g., 0 + NaN -> 0.
      if (Number.isNaN(value)) {
        return 0;
      }
      return value;
    }
    const n = Number(value);
    if (Number.isNaN(n)) {
      // Scratch treats NaN as 0, when needed as a number.
      // E.g., 0 + NaN -> 0.
      return 0;
    }
    return n;
  }

  /**
   * Scratch cast to boolean.
   * In Scratch 2.0, this is captured by `interp.boolArg.`
   * Treats some string values differently from JavaScript.
   * @param {*} value Value to cast to boolean.
   * @return {boolean} The Scratch-casted boolean value.
   */
  static toBoolean(value) {
    // Already a boolean?
    if (typeof value === 'boolean') {
      return value;
    }
    if (typeof value === 'string') {
      // These specific strings are treated as false in Scratch.
      if (value === '' || value === '0' || value.toLowerCase() === 'false') {
        return false;
      }
      // All other strings treated as true.
      return true;
    }
    // Coerce other values and numbers.
    return Boolean(value);
  }

  /**
   * Scratch cast to string.
   * @param {*} value Value to cast to string.
   * @return {string} The Scratch-casted string value.
   */
  static toString(value) {
    return String(value);
  }

  /**
   * Cast any Scratch argument to an RGB color array to be used for the renderer.
   * @param {*} value Value to convert to RGB color array.
   * @return {Array.<number>} [r,g,b], values between 0-255.
   */
  static toRgbColorList(value) {
    const color = Cast.toRgbColorObject(value);
    return [color.r, color.g, color.b];
  }

  /**
   * Cast any Scratch argument to an RGB color object to be used for the renderer.
   * @param {*} value Value to convert to RGB color object.
   * @return {RGBOject} [r,g,b], values between 0-255.
   */
  static toRgbColorObject(value) {
    let color;
    if (typeof value === 'string' && value.substring(0, 1) === '#') {
      color = Color.hexToRgb(value);

      // If the color wasn't *actually* a hex color, cast to black
      if (!color) color = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      };
    } else {
      color = Color.decimalToRgb(Cast.toNumber(value));
    }
    return color;
  }

  /**
   * Determine if a Scratch argument is a white space string (or null / empty).
   * @param {*} val value to check.
   * @return {boolean} True if the argument is all white spaces or null / empty.
   */
  static isWhiteSpace(val) {
    return val === null || typeof val === 'string' && val.trim().length === 0;
  }

  /**
   * Compare two values, using Scratch cast, case-insensitive string compare, etc.
   * In Scratch 2.0, this is captured by `interp.compare.`
   * @param {*} v1 First value to compare.
   * @param {*} v2 Second value to compare.
   * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
   */
  static compare(v1, v2) {
    let n1 = Number(v1);
    let n2 = Number(v2);
    if (n1 === 0 && Cast.isWhiteSpace(v1)) {
      n1 = NaN;
    } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
      n2 = NaN;
    }
    if (isNaN(n1) || isNaN(n2)) {
      // At least one argument can't be converted to a number.
      // Scratch compares strings as case insensitive.
      const s1 = String(v1).toLowerCase();
      const s2 = String(v2).toLowerCase();
      if (s1 < s2) {
        return -1;
      } else if (s1 > s2) {
        return 1;
      }
      return 0;
    }
    // Handle the special case of Infinity
    if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
      return 0;
    }
    // Compare as numbers.
    return n1 - n2;
  }

  /**
   * Determine if a Scratch argument number represents a round integer.
   * @param {*} val Value to check.
   * @return {boolean} True if number looks like an integer.
   */
  static isInt(val) {
    // Values that are already numbers.
    if (typeof val === 'number') {
      if (isNaN(val)) {
        // NaN is considered an integer.
        return true;
      }
      // True if it's "round" (e.g., 2.0 and 2).
      return val === parseInt(val, 10);
    } else if (typeof val === 'boolean') {
      // `True` and `false` always represent integer after Scratch cast.
      return true;
    } else if (typeof val === 'string') {
      // If it contains a decimal point, don't consider it an int.
      return val.indexOf('.') < 0;
    }
    return false;
  }
  static get LIST_INVALID() {
    return 'INVALID';
  }
  static get LIST_ALL() {
    return 'ALL';
  }

  /**
   * Compute a 1-based index into a list, based on a Scratch argument.
   * Two special cases may be returned:
   * LIST_ALL: if the block is referring to all of the items in the list.
   * LIST_INVALID: if the index was invalid in any way.
   * @param {*} index Scratch arg, including 1-based numbers or special cases.
   * @param {number} length Length of the list.
   * @param {boolean} acceptAll Whether it should accept "all" or not.
   * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
   */
  static toListIndex(index, length, acceptAll) {
    if (typeof index !== 'number') {
      if (index === 'all') {
        return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
      }
      if (index === 'last') {
        if (length > 0) {
          return length;
        }
        return Cast.LIST_INVALID;
      } else if (index === 'random' || index === 'any') {
        if (length > 0) {
          return 1 + Math.floor(Math.random() * length);
        }
        return Cast.LIST_INVALID;
      }
    }
    index = Math.floor(Cast.toNumber(index));
    if (index < 1 || index > length) {
      return Cast.LIST_INVALID;
    }
    return index;
  }
}
module.exports = Cast;

/***/ }),

/***/ "./src/util/clone.js":
/*!***************************!*\
  !*** ./src/util/clone.js ***!
  \***************************/
/***/ ((module) => {

/**
 * Methods for cloning JavaScript objects.
 * @type {object}
 */
class Clone {
  /**
   * Deep-clone a "simple" object: one which can be fully expressed with JSON.
   * Non-JSON values, such as functions, will be stripped from the clone.
   * @param {object} original - the object to be cloned.
   * @returns {object} a deep clone of the original object.
   */
  static simple(original) {
    return JSON.parse(JSON.stringify(original));
  }
}
module.exports = Clone;

/***/ }),

/***/ "./src/util/color.js":
/*!***************************!*\
  !*** ./src/util/color.js ***!
  \***************************/
/***/ ((module) => {

class Color {
  /**
   * @typedef {object} RGBObject - An object representing a color in RGB format.
   * @property {number} r - the red component, in the range [0, 255].
   * @property {number} g - the green component, in the range [0, 255].
   * @property {number} b - the blue component, in the range [0, 255].
   */

  /**
   * @typedef {object} HSVObject - An object representing a color in HSV format.
   * @property {number} h - hue, in the range [0-359).
   * @property {number} s - saturation, in the range [0,1].
   * @property {number} v - value, in the range [0,1].
   */

  /** @type {RGBObject} */
  static get RGB_BLACK() {
    return {
      r: 0,
      g: 0,
      b: 0
    };
  }

  /** @type {RGBObject} */
  static get RGB_WHITE() {
    return {
      r: 255,
      g: 255,
      b: 255
    };
  }

  /**
   * Convert a Scratch decimal color to a hex string, #RRGGBB.
   * @param {number} decimal RGB color as a decimal.
   * @return {string} RGB color as #RRGGBB hex string.
   */
  static decimalToHex(decimal) {
    if (decimal < 0) {
      decimal += 0xFFFFFF + 1;
    }
    let hex = Number(decimal).toString(16);
    hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
    return hex;
  }

  /**
   * Convert a Scratch decimal color to an RGB color object.
   * @param {number} decimal RGB color as decimal.
   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */
  static decimalToRgb(decimal) {
    const a = decimal >> 24 & 0xFF;
    const r = decimal >> 16 & 0xFF;
    const g = decimal >> 8 & 0xFF;
    const b = decimal & 0xFF;
    return {
      r: r,
      g: g,
      b: b,
      a: a > 0 ? a : 255
    };
  }

  /**
   * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
   * CC-BY-SA Tim Down:
   * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   * @param {!string} hex Hex representation of the color.
   * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */
  static hexToRgb(hex) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  /**
   * Convert an RGB color object to a hex color.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {!string} Hex representation of the color.
   */
  static rgbToHex(rgb) {
    return Color.decimalToHex(Color.rgbToDecimal(rgb));
  }

  /**
   * Convert an RGB color object to a Scratch decimal color.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {!number} Number representing the color.
   */
  static rgbToDecimal(rgb) {
    return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
  }

  /**
  * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
  * @param {!string} hex Hex representation of the color.
  * @return {!number} Number representing the color.
  */
  static hexToDecimal(hex) {
    return Color.rgbToDecimal(Color.hexToRgb(hex));
  }

  /**
   * Convert an HSV color to RGB format.
   * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */
  static hsvToRgb(hsv) {
    let h = hsv.h % 360;
    if (h < 0) h += 360;
    const s = Math.max(0, Math.min(hsv.s, 1));
    const v = Math.max(0, Math.min(hsv.v, 1));
    const i = Math.floor(h / 60);
    const f = h / 60 - i;
    const p = v * (1 - s);
    const q = v * (1 - s * f);
    const t = v * (1 - s * (1 - f));
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 0:
        r = v;
        g = t;
        b = p;
        break;
      case 1:
        r = q;
        g = v;
        b = p;
        break;
      case 2:
        r = p;
        g = v;
        b = t;
        break;
      case 3:
        r = p;
        g = q;
        b = v;
        break;
      case 4:
        r = t;
        g = p;
        b = v;
        break;
      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }
    return {
      r: Math.floor(r * 255),
      g: Math.floor(g * 255),
      b: Math.floor(b * 255)
    };
  }

  /**
   * Convert an RGB color to HSV format.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
   */
  static rgbToHsv(rgb) {
    const r = rgb.r / 255;
    const g = rgb.g / 255;
    const b = rgb.b / 255;
    const x = Math.min(Math.min(r, g), b);
    const v = Math.max(Math.max(r, g), b);

    // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
    let h = 0;
    let s = 0;
    if (x !== v) {
      const f = r === x ? g - b : g === x ? b - r : r - g;
      const i = r === x ? 3 : g === x ? 5 : 1;
      h = (i - f / (v - x)) * 60 % 360;
      s = (v - x) / v;
    }
    return {
      h: h,
      s: s,
      v: v
    };
  }

  /**
   * Linear interpolation between rgb0 and rgb1.
   * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
   * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
   * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
   * @return {RGBObject} the interpolated color.
   */
  static mixRgb(rgb0, rgb1, fraction1) {
    if (fraction1 <= 0) return rgb0;
    if (fraction1 >= 1) return rgb1;
    const fraction0 = 1 - fraction1;
    return {
      r: fraction0 * rgb0.r + fraction1 * rgb1.r,
      g: fraction0 * rgb0.g + fraction1 * rgb1.g,
      b: fraction0 * rgb0.b + fraction1 * rgb1.b
    };
  }
}
module.exports = Color;

/***/ }),

/***/ "./src/util/fetch-with-timeout.js":
/*!****************************************!*\
  !*** ./src/util/fetch-with-timeout.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @callback FetchFunction
 * @param {RequestInfo|URL} input
 * @param {RequestInit|undefined} [init]
 * @returns {Promise<Response>}
 */

/**
 * @type {FetchFunction}
 */
let myFetch = __webpack_require__.g.fetch;

/**
 * Tell `fetchWithTimeout` to use a specific `fetch` function.
 * By default, `fetchWithTimeout` will use the global `fetch` function.
 * If there is no global `fetch`, then `fetchWithTimeout` will fail unless provided with an alternative.
 * @param {FetchFunction} newFetch The new `fetch` function to use within fetchWithTimeout.
 */
const setFetch = newFetch => {
  myFetch = newFetch;
};

/**
 * Fetch a remote resource like `fetch` does, but with a time limit.
 * @param {Request|string} resource Remote resource to fetch.
 * @param {?object} init An options object containing any custom settings that you want to apply to the request.
 * @param {number} timeout The amount of time before the request is canceled, in milliseconds
 * @returns {Promise<Response>} The response from the server.
 */
const fetchWithTimeout = (resource, init, timeout) => {
  let timeoutID = null;
  // Not supported in Safari <11
  const controller = window.AbortController ? new window.AbortController() : null;
  const signal = controller ? controller.signal : null;
  // The fetch call races a timer.
  return Promise.race([myFetch(resource, Object.assign({
    signal
  }, init)).then(response => {
    clearTimeout(timeoutID);
    return response;
  }), new Promise((resolve, reject) => {
    timeoutID = setTimeout(() => {
      if (controller) controller.abort();
      reject(new Error("Fetch timed out after ".concat(timeout, " ms")));
    }, timeout);
  })]);
};
module.exports = {
  fetchWithTimeout,
  setFetch
};

/***/ }),

/***/ "./src/util/get-monitor-id.js":
/*!************************************!*\
  !*** ./src/util/get-monitor-id.js ***!
  \************************************/
/***/ ((module) => {

/**
 * Returns a string representing a unique id for a monitored block
 * where a single reporter block can have more than one monitor
 * (and therefore more than one monitor block) associated
 * with it (e.g. when reporter blocks have inputs).
 * @param {string} baseId The base id to use for the different monitor blocks
 * @param {object} fields The monitor block's fields object.
 */
// TODO this function should eventually be the single place where all monitor
// IDs are obtained given an opcode for the reporter block and the list of
// selected parameters.
const getMonitorIdForBlockWithArgs = function getMonitorIdForBlockWithArgs(id, fields) {
  let fieldString = '';
  for (const fieldKey in fields) {
    let fieldValue = fields[fieldKey].value;
    if (fieldKey === 'CURRENTMENU') {
      // The 'sensing_current' block has field values in all caps.
      // However, when importing from scratch 2.0, these
      // could have gotten imported as lower case field values.
      // Normalize the field value here so that we don't ever
      // end up with a different monitor ID representing the same
      // block configuration
      // Note: we are not doing this for every block field that comes into
      // this function so as not to make the faulty assumption that block
      // field values coming in would be unique after being made lower case
      fieldValue = fieldValue.toLowerCase();
    }
    fieldString += "_".concat(fieldValue);
  }
  return "".concat(id).concat(fieldString);
};
module.exports = getMonitorIdForBlockWithArgs;

/***/ }),

/***/ "./src/util/jsonrpc.js":
/*!*****************************!*\
  !*** ./src/util/jsonrpc.js ***!
  \*****************************/
/***/ ((module) => {

class JSONRPC {
  constructor() {
    this._requestID = 0;
    this._openRequests = {};
  }

  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */
  sendRemoteRequest(method, params) {
    const requestID = this._requestID++;
    const promise = new Promise((resolve, reject) => {
      this._openRequests[requestID] = {
        resolve,
        reject
      };
    });
    this._sendRequest(method, params, requestID);
    return promise;
  }

  /**
   * Make an RPC notification with no expectation of a result or callback.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   */
  sendRemoteNotification(method, params) {
    this._sendRequest(method, params);
  }

  /**
   * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
   * @param {string} method - the method requested by the remote caller.
   * @param {object} params - the parameters sent with the remote caller's request.
   */
  didReceiveCall( /* method , params */
  ) {
    throw new Error('Must override didReceiveCall');
  }
  _sendMessage( /* jsonMessageObject */
  ) {
    throw new Error('Must override _sendMessage');
  }
  _sendRequest(method, params, id) {
    const request = {
      jsonrpc: '2.0',
      method,
      params
    };
    if (id !== null) {
      request.id = id;
    }
    this._sendMessage(request);
  }
  _handleMessage(json) {
    if (json.jsonrpc !== '2.0') {
      throw new Error("Bad or missing JSON-RPC version in message: ".concat(json));
    }
    if (Object.prototype.hasOwnProperty.call(json, 'method')) {
      this._handleRequest(json);
    } else {
      this._handleResponse(json);
    }
  }
  _sendResponse(id, result, error) {
    const response = {
      jsonrpc: '2.0',
      id
    };
    if (error) {
      response.error = error;
    } else {
      response.result = result || null;
    }
    this._sendMessage(response);
  }
  _handleResponse(json) {
    const {
      result,
      error,
      id
    } = json;
    const openRequest = this._openRequests[id];
    delete this._openRequests[id];
    if (openRequest) {
      if (error) {
        openRequest.reject(error);
      } else {
        openRequest.resolve(result);
      }
    }
  }
  _handleRequest(json) {
    const {
      method,
      params,
      id
    } = json;
    const rawResult = this.didReceiveCall(method, params);
    if (id !== null && typeof id !== 'undefined') {
      Promise.resolve(rawResult).then(result => {
        this._sendResponse(id, result);
      }, error => {
        this._sendResponse(id, null, error);
      });
    }
  }
}
module.exports = JSONRPC;

/***/ }),

/***/ "./src/util/log.js":
/*!*************************!*\
  !*** ./src/util/log.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const minilog = __webpack_require__(/*! minilog */ "./node_modules/minilog/lib/web/index.js");
minilog.enable();
module.exports = minilog('vm');

/***/ }),

/***/ "./src/util/math-util.js":
/*!*******************************!*\
  !*** ./src/util/math-util.js ***!
  \*******************************/
/***/ ((module) => {

class MathUtil {
  /**
   * Convert a value from degrees to radians.
   * @param {!number} deg Value in degrees.
   * @return {!number} Equivalent value in radians.
   */
  static degToRad(deg) {
    return deg * Math.PI / 180;
  }

  /**
   * Convert a value from radians to degrees.
   * @param {!number} rad Value in radians.
   * @return {!number} Equivalent value in degrees.
   */
  static radToDeg(rad) {
    return rad * 180 / Math.PI;
  }

  /**
   * Clamp a number between two limits.
   * If n < min, return min. If n > max, return max. Else, return n.
   * @param {!number} n Number to clamp.
   * @param {!number} min Minimum limit.
   * @param {!number} max Maximum limit.
   * @return {!number} Value of n clamped to min and max.
   */
  static clamp(n, min, max) {
    return Math.min(Math.max(n, min), max);
  }

  /**
   * Keep a number between two limits, wrapping "extra" into the range.
   * e.g., wrapClamp(7, 1, 5) == 2
   * wrapClamp(0, 1, 5) == 5
   * wrapClamp(-11, -10, 6) == 6, etc.
   * @param {!number} n Number to wrap.
   * @param {!number} min Minimum limit.
   * @param {!number} max Maximum limit.
   * @return {!number} Value of n wrapped between min and max.
   */
  static wrapClamp(n, min, max) {
    const range = max - min + 1;
    return n - Math.floor((n - min) / range) * range;
  }

  /**
   * Convert a value from tan function in degrees.
   * @param {!number} angle in degrees
   * @return {!number} Correct tan value
   */
  static tan(angle) {
    angle = angle % 360;
    switch (angle) {
      case -270:
      case 90:
        return Infinity;
      case -90:
      case 270:
        return -Infinity;
      default:
        return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));
    }
  }

  /**
   * Given an array of unique numbers,
   * returns a reduced array such that each element of the reduced array
   * represents the position of that element in a sorted version of the
   * original array.
   * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]
   * @param {Array<number>} elts The elements to sort and reduce
   * @return {Array<number>} The array of reduced orderings
   */
  static reducedSortOrdering(elts) {
    const sorted = elts.slice(0).sort((a, b) => a - b);
    return elts.map(e => sorted.indexOf(e));
  }

  /**
   * Return a random number given an inclusive range and a number in that
   * range that should be excluded.
   *
   * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal
   * probability)
   *
   * @param {number} lower - The lower bound (inlcusive)
   * @param {number} upper - The upper bound (inclusive), such that lower <= upper
   * @param {number} excluded - The number to exclude (MUST be in the range)
   * @return {number} A random integer in the range [lower, upper] that is not "excluded"
   */
  static inclusiveRandIntWithout(lower, upper, excluded) {
    // Note that subtraction is the number of items in the
    // inclusive range [lower, upper] minus 1 already
    // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).
    const possibleOptions = upper - lower;
    const randInt = lower + Math.floor(Math.random() * possibleOptions);
    if (randInt >= excluded) {
      return randInt + 1;
    }
    return randInt;
  }

  /**
   * Scales a number from one range to another.
   * @param {number} i number to be scaled
   * @param {number} iMin input range minimum
   * @param {number} iMax input range maximum
   * @param {number} oMin output range minimum
   * @param {number} oMax output range maximum
   * @return {number} scaled number
   */
  static scale(i, iMin, iMax, oMin, oMax) {
    const p = (i - iMin) / (iMax - iMin);
    return p * (oMax - oMin) + oMin;
  }
}
module.exports = MathUtil;

/***/ }),

/***/ "./src/util/maybe-format-message.js":
/*!******************************************!*\
  !*** ./src/util/maybe-format-message.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

/**
 * Check if `maybeMessage` looks like a message object, and if so pass it to `formatMessage`.
 * Otherwise, return `maybeMessage` as-is.
 * @param {*} maybeMessage - something that might be a message descriptor object.
 * @param {object} [args] - the arguments to pass to `formatMessage` if it gets called.
 * @param {string} [locale] - the locale to pass to `formatMessage` if it gets called.
 * @return {string|*} - the formatted message OR the original `maybeMessage` input.
 */
const maybeFormatMessage = function maybeFormatMessage(maybeMessage, args, locale) {
  if (maybeMessage && maybeMessage.id && maybeMessage.default) {
    return formatMessage(maybeMessage, args, locale);
  }
  return maybeMessage;
};
module.exports = maybeFormatMessage;

/***/ }),

/***/ "./src/util/new-block-ids.js":
/*!***********************************!*\
  !*** ./src/util/new-block-ids.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const uid = __webpack_require__(/*! ./uid */ "./src/util/uid.js");

/**
 * Mutate the given blocks to have new IDs and update all internal ID references.
 * Does not return anything to make it clear that the blocks are updated in-place.
 * @param {array} blocks - blocks to be mutated.
 */
module.exports = blocks => {
  const oldToNew = {};

  // First update all top-level IDs and create old-to-new mapping
  for (let i = 0; i < blocks.length; i++) {
    const newId = uid();
    const oldId = blocks[i].id;
    blocks[i].id = oldToNew[oldId] = newId;
  }

  // Then go back through and update inputs (block/shadow)
  // and next/parent properties
  for (let i = 0; i < blocks.length; i++) {
    for (const key in blocks[i].inputs) {
      const input = blocks[i].inputs[key];
      input.block = oldToNew[input.block];
      input.shadow = oldToNew[input.shadow];
    }
    if (blocks[i].parent) {
      blocks[i].parent = oldToNew[blocks[i].parent];
    }
    if (blocks[i].next) {
      blocks[i].next = oldToNew[blocks[i].next];
    }
  }
};

/***/ }),

/***/ "./src/util/rateLimiter.js":
/*!*********************************!*\
  !*** ./src/util/rateLimiter.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
class RateLimiter {
  /**
   * A utility for limiting the rate of repetitive send operations, such as
   * bluetooth messages being sent to hardware devices. It uses the token bucket
   * strategy: a counter accumulates tokens at a steady rate, and each send costs
   * a token. If no tokens remain, it's not okay to send.
   * @param {number} maxRate the maximum number of sends allowed per second
   * @constructor
   */
  constructor(maxRate) {
    /**
     * The maximum number of tokens.
     * @type {number}
     */
    this._maxTokens = maxRate;

    /**
     * The interval in milliseconds for refilling one token. It is calculated
     * so that the tokens will be filled to maximum in one second.
     * @type {number}
     */
    this._refillInterval = 1000 / maxRate;

    /**
     * The current number of tokens in the bucket.
     * @type {number}
     */
    this._count = this._maxTokens;
    this._timer = new Timer();
    this._timer.start();

    /**
     * The last time in milliseconds when the token count was updated.
     * @type {number}
     */
    this._lastUpdateTime = this._timer.timeElapsed();
  }

  /**
   * Check if it is okay to send a message, by updating the token count,
   * taking a token and then checking if we are still under the rate limit.
   * @return {boolean} true if we are under the rate limit
   */
  okayToSend() {
    // Calculate the number of tokens to refill the bucket with, based on the
    // amount of time since the last refill.
    const now = this._timer.timeElapsed();
    const timeSinceRefill = now - this._lastUpdateTime;
    const refillCount = Math.floor(timeSinceRefill / this._refillInterval);

    // If we're adding at least one token, reset _lastUpdateTime to now.
    // Otherwise, don't reset it so that we can continue measuring time until
    // the next refill.
    if (refillCount > 0) {
      this._lastUpdateTime = now;
    }

    // Refill the tokens up to the maximum
    this._count = Math.min(this._maxTokens, this._count + refillCount);

    // If we have at least one token, use one, and it's okay to send.
    if (this._count > 0) {
      this._count--;
      return true;
    }
    return false;
  }
}
module.exports = RateLimiter;

/***/ }),

/***/ "./src/util/scratch-link-websocket.js":
/*!********************************************!*\
  !*** ./src/util/scratch-link-websocket.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * This class provides a ScratchLinkSocket implementation using WebSockets,
 * attempting to connect with the locally installed Scratch-Link.
 *
 * To connect with ScratchLink without WebSockets, you must implement all of the
 * public methods in this class.
 * - open()
 * - close()
 * - setOn[Open|Close|Error]
 * - setHandleMessage
 * - sendMessage(msgObj)
 * - isOpen()
 */
class ScratchLinkWebSocket {
  constructor(type) {
    this._type = type;
    this._onOpen = null;
    this._onClose = null;
    this._onError = null;
    this._handleMessage = null;
    this._ws = null;
  }
  open() {
    if (!(this._onOpen && this._onClose && this._onError && this._handleMessage)) {
      throw new Error('Must set open, close, message and error handlers before calling open on the socket');
    }
    let pathname;
    switch (this._type) {
      case 'BLE':
        pathname = 'scratch/ble';
        break;
      case 'BT':
        pathname = 'scratch/bt';
        break;
      default:
        throw new Error("Unknown ScratchLink socket Type: ".concat(this._type));
    }

    // Try ws:// (the new way) and wss:// (the old way) simultaneously. If either connects, close the other. If we
    // were to try one and fall back to the other on failure, that could mean a delay of 30 seconds or more for
    // those who need the fallback.
    // If both connections fail we should report only one error.

    const setSocket = (socketToUse, socketToClose) => {
      socketToClose.onopen = socketToClose.onerror = null;
      socketToClose.close();
      this._ws = socketToUse;
      this._ws.onopen = this._onOpen;
      this._ws.onclose = this._onClose;
      this._ws.onerror = this._onError;
      this._ws.onmessage = this._onMessage.bind(this);
    };
    const ws = new WebSocket("ws://127.0.0.1:20111/".concat(pathname));
    const wss = new WebSocket("wss://device-manager.scratch.mit.edu:20110/".concat(pathname));
    const connectTimeout = setTimeout(() => {
      // neither socket succeeded before the timeout
      setSocket(ws, wss);
      this._ws.onerror(new Event('timeout'));
    }, 15 * 1000);
    ws.onopen = openEvent => {
      clearTimeout(connectTimeout);
      setSocket(ws, wss);
      this._ws.onopen(openEvent);
    };
    wss.onopen = openEvent => {
      clearTimeout(connectTimeout);
      setSocket(wss, ws);
      this._ws.onopen(openEvent);
    };
    let wsError;
    let wssError;
    const errorHandler = () => {
      // if only one has received an error, we haven't overall failed yet
      if (wsError && wssError) {
        clearTimeout(connectTimeout);
        setSocket(ws, wss);
        this._ws.onerror(wsError);
      }
    };
    ws.onerror = errorEvent => {
      wsError = errorEvent;
      errorHandler();
    };
    wss.onerror = errorEvent => {
      wssError = errorEvent;
      errorHandler();
    };
  }
  close() {
    this._ws.close();
    this._ws = null;
  }
  sendMessage(message) {
    const messageText = JSON.stringify(message);
    this._ws.send(messageText);
  }
  setOnOpen(fn) {
    this._onOpen = fn;
  }
  setOnClose(fn) {
    this._onClose = fn;
  }
  setOnError(fn) {
    this._onError = fn;
  }
  setHandleMessage(fn) {
    this._handleMessage = fn;
  }
  isOpen() {
    return this._ws && this._ws.readyState === this._ws.OPEN;
  }
  _onMessage(e) {
    const json = JSON.parse(e.data);
    this._handleMessage(json);
  }
}
module.exports = ScratchLinkWebSocket;

/***/ }),

/***/ "./src/util/string-util.js":
/*!*********************************!*\
  !*** ./src/util/string-util.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const log = __webpack_require__(/*! ./log */ "./src/util/log.js");
class StringUtil {
  static withoutTrailingDigits(s) {
    let i = s.length - 1;
    while (i >= 0 && '0123456789'.indexOf(s.charAt(i)) > -1) i--;
    return s.slice(0, i + 1);
  }
  static unusedName(name, existingNames) {
    if (existingNames.indexOf(name) < 0) return name;
    name = StringUtil.withoutTrailingDigits(name);
    let i = 2;
    while (existingNames.indexOf(name + i) >= 0) i++;
    return name + i;
  }

  /**
   * Split a string on the first occurrence of a split character.
   * @param {string} text - the string to split.
   * @param {string} separator - split the text on this character.
   * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.
   * @example
   * // returns ['foo', 'tar.gz']
   * splitFirst('foo.tar.gz', '.');
   * @example
   * // returns ['foo', null]
   * splitFirst('foo', '.');
   * @example
   * // returns ['foo', '']
   * splitFirst('foo.', '.');
   */
  static splitFirst(text, separator) {
    const index = text.indexOf(separator);
    if (index >= 0) {
      return [text.substring(0, index), text.substring(index + 1)];
    }
    return [text, null];
  }

  /**
   * A customized version of JSON.stringify that sets Infinity/NaN to 0,
   * instead of the default (null).
   * Needed because null is not of type number, but Infinity/NaN are, which
   * can lead to serialization producing JSON that isn't valid based on the parser schema.
   * It is also consistent with the behavior of saving 2.0 projects.
   * This is only needed when stringifying an object for saving.
   *
   * @param {!object} obj - The object to serialize
   * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0
   */
  static stringify(obj) {
    return JSON.stringify(obj, (_key, value) => {
      if (typeof value === 'number' && (value === Infinity || value === -Infinity || isNaN(value))) {
        return 0;
      }
      return value;
    });
  }
  /**
   * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used
   * in cases where we're replacing non-user facing strings (e.g. variable IDs).
   * When replacing user facing strings, the xmlEscape utility function should be used
   * instead so that the user facing string does not change how it displays.
   * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.
   * In some cases this argument may be an array (e.g. hacked inputs from 2.0)
   * @return {string} String with control characters replaced.
   */
  static replaceUnsafeChars(unsafe) {
    if (typeof unsafe !== 'string') {
      if (Array.isArray(unsafe)) {
        // This happens when we have hacked blocks from 2.0
        // See #1030
        unsafe = String(unsafe);
      } else {
        log.error('Unexpected input recieved in replaceUnsafeChars');
        return unsafe;
      }
    }
    return unsafe.replace(/[<>&'"]/g, c => {
      switch (c) {
        case '<':
          return 'lt';
        case '>':
          return 'gt';
        case '&':
          return 'amp';
        case '\'':
          return 'apos';
        case '"':
          return 'quot';
      }
    });
  }
}
module.exports = StringUtil;

/***/ }),

/***/ "./src/util/timer.js":
/*!***************************!*\
  !*** ./src/util/timer.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * A utility for accurately measuring time.
 * To use:
 * ---
 * var timer = new Timer();
 * timer.start();
 * ... pass some time ...
 * var timeDifference = timer.timeElapsed();
 * ---
 * Or, you can use the `time` function
 * to do some measurement yourself.
 */

class Timer {
  constructor() {
    let nowObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Timer.nowObj;
    /**
     * Used to store the start time of a timer action.
     * Updated when calling `timer.start`.
     */
    this.startTime = 0;

    /**
     * Used to pass custom logic for determining the value for "now",
     * which is sometimes useful for compatibility with Scratch 2
     */
    this.nowObj = nowObj;
  }

  /**
   * Disable use of self.performance for now as it results in lower performance
   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
   * @type {boolean}
   */
  static get USE_PERFORMANCE() {
    return false;
  }

  /**
   * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
   * @deprecated This is only called via the nowObj.now() if no other means is possible...
   */
  static get legacyDateCode() {
    return {
      now: function now() {
        return new Date().getTime();
      }
    };
  }

  /**
   * Use this object to route all time functions through single access points.
   */
  static get nowObj() {
    if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {
      return self.performance;
    } else if (Date.now) {
      return Date;
    }
    return Timer.legacyDateCode;
  }

  /**
   * Return the currently known absolute time, in ms precision.
   * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
   */
  time() {
    return this.nowObj.now();
  }

  /**
   * Start a timer for measuring elapsed time,
   * at the most accurate precision possible.
   */
  start() {
    this.startTime = this.nowObj.now();
  }
  timeElapsed() {
    return this.nowObj.now() - this.startTime;
  }

  /**
   * Call a handler function after a specified amount of time has elapsed.
   * @param {function} handler - function to call after the timeout
   * @param {number} timeout - number of milliseconds to delay before calling the handler
   * @returns {number} - the ID of the new timeout
   */
  setTimeout(handler, timeout) {
    return __webpack_require__.g.setTimeout(handler, timeout);
  }

  /**
   * Clear a timeout from the pending timeout pool.
   * @param {number} timeoutId - the ID returned by `setTimeout()`
   * @memberof Timer
   */
  clearTimeout(timeoutId) {
    __webpack_require__.g.clearTimeout(timeoutId);
  }
}
module.exports = Timer;

/***/ }),

/***/ "./src/util/uid.js":
/*!*************************!*\
  !*** ./src/util/uid.js ***!
  \*************************/
/***/ ((module) => {

/**
 * @fileoverview UID generator, from Blockly.
 */

/**
 * Legal characters for the unique ID.
 * Should be all on a US keyboard.  No XML special characters or control codes.
 * Removed $ due to issue 251.
 * @private
 */
const soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 * @return {string} A globally unique ID string.
 */
const uid = function uid() {
  const length = 20;
  const soupLength = soup_.length;
  const id = [];
  for (let i = 0; i < length; i++) {
    id[i] = soup_.charAt(Math.random() * soupLength);
  }
  return id.join('');
};
module.exports = uid;

/***/ }),

/***/ "./src/util/variable-util.js":
/*!***********************************!*\
  !*** ./src/util/variable-util.js ***!
  \***********************************/
/***/ ((module) => {

class VariableUtil {
  static _mergeVarRefObjects(accum, obj2) {
    for (const id in obj2) {
      if (accum[id]) {
        accum[id] = accum[id].concat(obj2[id]);
      } else {
        accum[id] = obj2[id];
      }
    }
    return accum;
  }

  /**
   * Get all variable/list references in the given list of targets
   * in the project.
   * @param {Array.<Target>} targets The list of targets to get the variable
   * and list references from.
   * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.
   * @return {object} An object with variable ids as the keys and a list of block fields referencing
   * the variable.
   */
  static getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {
    return targets.map(t => t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast)).reduce(VariableUtil._mergeVarRefObjects, {});
  }

  /**
   * Give all variable references provided a new id and possibly new name.
   * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable
   * references to update.
   * @param {string} newId ID of the variable that the old references should be replaced with
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */
  static updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {
    referencesToUpdate.map(ref => {
      ref.referencingField.id = newId;
      if (optNewName) {
        ref.referencingField.value = optNewName;
      }
      return ref;
    });
  }
}
module.exports = VariableUtil;

/***/ }),

/***/ "./src/util/xml-escape.js":
/*!********************************!*\
  !*** ./src/util/xml-escape.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const log = __webpack_require__(/*! ./log */ "./src/util/log.js");

/**
 * Escape a string to be safe to use in XML content.
 * CC-BY-SA: hgoebl
 * https://stackoverflow.com/questions/7918868/
 * how-to-escape-xml-entities-in-javascript
 * @param {!string | !Array.<string>} unsafe Unsafe string.
 * @return {string} XML-escaped string, for use within an XML tag.
 */
const xmlEscape = function xmlEscape(unsafe) {
  if (typeof unsafe !== 'string') {
    if (Array.isArray(unsafe)) {
      // This happens when we have hacked blocks from 2.0
      // See #1030
      unsafe = String(unsafe);
    } else {
      log.error('Unexpected input recieved in replaceUnsafeChars');
      return unsafe;
    }
  }
  return unsafe.replace(/[<>&'"]/g, c => {
    switch (c) {
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '&':
        return '&amp;';
      case '\'':
        return '&apos;';
      case '"':
        return '&quot;';
    }
  });
};
module.exports = xmlEscape;

/***/ }),

/***/ "./src/virtual-machine.js":
/*!********************************!*\
  !*** ./src/virtual-machine.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let _TextEncoder;
if (typeof TextEncoder === 'undefined') {
  _TextEncoder = (__webpack_require__(/*! text-encoding */ "./node_modules/text-encoding/index.js").TextEncoder);
} else {
  _TextEncoder = TextEncoder;
}
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
const Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);
const centralDispatch = __webpack_require__(/*! ./dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");
const ExtensionManager = __webpack_require__(/*! ./extension-support/extension-manager */ "./src/extension-support/extension-manager.js");
const log = __webpack_require__(/*! ./util/log */ "./src/util/log.js");
const MathUtil = __webpack_require__(/*! ./util/math-util */ "./src/util/math-util.js");
const Runtime = __webpack_require__(/*! ./engine/runtime */ "./src/engine/runtime.js");
const StringUtil = __webpack_require__(/*! ./util/string-util */ "./src/util/string-util.js");
const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
const Variable = __webpack_require__(/*! ./engine/variable */ "./src/engine/variable.js");
const newBlockIds = __webpack_require__(/*! ./util/new-block-ids */ "./src/util/new-block-ids.js");
const {
  loadCostume
} = __webpack_require__(/*! ./import/load-costume.js */ "./src/import/load-costume.js");
const {
  loadSound
} = __webpack_require__(/*! ./import/load-sound.js */ "./src/import/load-sound.js");
const {
  serializeSounds,
  serializeCostumes
} = __webpack_require__(/*! ./serialization/serialize-assets */ "./src/serialization/serialize-assets.js");
__webpack_require__(/*! canvas-toBlob */ "./node_modules/canvas-toBlob/canvas-toBlob.js");
const RESERVED_NAMES = ['_mouse_', '_stage_', '_edge_', '_myself_', '_random_'];
const CORE_EXTENSIONS = [
  // 'motion',
  // 'looks',
  // 'sound',
  // 'events',
  // 'control',
  // 'sensing',
  // 'operators',
  // 'variables',
  // 'myBlocks'
];

/**
 * Handles connections between blocks, stage, and extensions.
 * @constructor
 */
class VirtualMachine extends EventEmitter {
  constructor() {
    super();

    /**
     * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
     * @type {!Runtime}
     */
    this.runtime = new Runtime();
    centralDispatch.setService('runtime', this.runtime).catch(e => {
      log.error("Failed to register runtime service: ".concat(JSON.stringify(e)));
    });

    /**
     * The "currently editing"/selected target ID for the VM.
     * Block events from any Blockly workspace are routed to this target.
     * @type {Target}
     */
    this.editingTarget = null;

    /**
     * The currently dragging target, for redirecting IO data.
     * @type {Target}
     */
    this._dragTarget = null;

    // Runtime emits are passed along as VM emits.
    this.runtime.on(Runtime.SCRIPT_GLOW_ON, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.SCRIPT_GLOW_OFF, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_ON, glowData => {
      this.emit(Runtime.BLOCK_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_OFF, glowData => {
      this.emit(Runtime.BLOCK_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.PROJECT_START, () => {
      this.emit(Runtime.PROJECT_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_START, () => {
      this.emit(Runtime.PROJECT_RUN_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_STOP, () => {
      this.emit(Runtime.PROJECT_RUN_STOP);
    });
    this.runtime.on(Runtime.PROJECT_CHANGED, () => {
      this.emit(Runtime.PROJECT_CHANGED);
    });
    this.runtime.on(Runtime.VISUAL_REPORT, visualReport => {
      this.emit(Runtime.VISUAL_REPORT, visualReport);
    });
    this.runtime.on(Runtime.TARGETS_UPDATE, emitProjectChanged => {
      this.emitTargetsUpdate(emitProjectChanged);
    });
    this.runtime.on(Runtime.MONITORS_UPDATE, monitorList => {
      this.emit(Runtime.MONITORS_UPDATE, monitorList);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui => {
      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_END, (blocks, topBlockId) => {
      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
    });
    this.runtime.on(Runtime.EXTENSION_ADDED, categoryInfo => {
      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
    });
    this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, (fieldName, fieldImplementation) => {
      this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);
    });
    this.runtime.on(Runtime.BLOCKSINFO_UPDATE, categoryInfo => {
      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    });
    this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, () => {
      this.emitWorkspaceUpdate();
    });
    this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, () => {
      this.extensionManager.refreshBlocks();
    });
    this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, info => {
      this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);
    });
    this.runtime.on(Runtime.USER_PICKED_PERIPHERAL, info => {
      this.emit(Runtime.USER_PICKED_PERIPHERAL, info);
    });
    this.runtime.on(Runtime.PERIPHERAL_CONNECTED, () => this.emit(Runtime.PERIPHERAL_CONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, () => this.emit(Runtime.PERIPHERAL_REQUEST_ERROR));
    this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, () => this.emit(Runtime.PERIPHERAL_DISCONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data => this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data));
    this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, () => this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT));
    this.runtime.on(Runtime.MIC_LISTENING, listening => {
      this.emit(Runtime.MIC_LISTENING, listening);
    });
    this.runtime.on(Runtime.RUNTIME_STARTED, () => {
      this.emit(Runtime.RUNTIME_STARTED);
    });
    this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData => {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);
    });
    this.extensionManager = new ExtensionManager(this.runtime);

    // Load core extensions
    for (const id of CORE_EXTENSIONS) {
      this.extensionManager.loadExtensionIdSync(id);
    }
    this.blockListener = this.blockListener.bind(this);
    this.flyoutBlockListener = this.flyoutBlockListener.bind(this);
    this.monitorBlockListener = this.monitorBlockListener.bind(this);
    this.variableListener = this.variableListener.bind(this);
  }

  /**
   * Start running the VM - do this before anything else.
   */
  start() {
    this.runtime.start();
  }

  /**
   * Quit the VM, clearing any handles which might keep the process alive.
   * Do not use the runtime after calling this method. This method is meant for test shutdown.
   */
  quit() {
    this.runtime.quit();
  }

  /**
   * "Green flag" handler - start all threads starting with a green flag.
   */
  greenFlag() {
    this.runtime.greenFlag();
  }

  /**
   * Set whether the VM is in "turbo mode."
   * When true, loops don't yield to redraw.
   * @param {boolean} turboModeOn Whether turbo mode should be set.
   */
  setTurboMode(turboModeOn) {
    this.runtime.turboMode = !!turboModeOn;
    if (this.runtime.turboMode) {
      this.emit(Runtime.TURBO_MODE_ON);
    } else {
      this.emit(Runtime.TURBO_MODE_OFF);
    }
  }

  /**
   * Set whether the VM is in 2.0 "compatibility mode."
   * When true, ticks go at 2.0 speed (30 TPS).
   * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
   */
  setCompatibilityMode(compatibilityModeOn) {
    this.runtime.setCompatibilityMode(!!compatibilityModeOn);
  }

  /**
   * Stop all threads and running activities.
   */
  stopAll() {
    this.runtime.stopAll();
  }

  /**
   * Clear out current running project data.
   */
  clear() {
    this.runtime.dispose();
    this.editingTarget = null;
    this.emitTargetsUpdate(false /* Don't emit project change */);
  }

  /**
   * Get data for playground. Data comes back in an emitted event.
   */
  getPlaygroundData() {
    const instance = this;
    // Only send back thread data for the current editingTarget.
    const threadData = this.runtime.threads.filter(thread => thread.target === instance.editingTarget);
    // Remove the target key, since it's a circular reference.
    const filteredThreadData = JSON.stringify(threadData, (key, value) => {
      if (key === 'target' || key === 'blockContainer') return;
      return value;
    }, 2);
    this.emit('playgroundData', {
      blocks: this.editingTarget.blocks,
      threads: filteredThreadData
    });
  }

  /**
   * Post I/O data to the virtual devices.
   * @param {?string} device Name of virtual I/O device.
   * @param {object} data Any data object to post to the I/O device.
   */
  postIOData(device, data) {
    if (this.runtime.ioDevices[device]) {
      this.runtime.ioDevices[device].postData(data);
    }
  }
  setVideoProvider(videoProvider) {
    this.runtime.ioDevices.video.setProvider(videoProvider);
  }
  setCloudProvider(cloudProvider) {
    this.runtime.ioDevices.cloud.setProvider(cloudProvider);
  }

  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */
  scanForPeripheral(extensionId) {
    this.runtime.scanForPeripheral(extensionId);
  }

  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */
  connectPeripheral(extensionId, peripheralId) {
    this.runtime.connectPeripheral(extensionId, peripheralId);
  }

  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */
  disconnectPeripheral(extensionId) {
    this.runtime.disconnectPeripheral(extensionId);
  }

  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */
  getPeripheralIsConnected(extensionId) {
    return this.runtime.getPeripheralIsConnected(extensionId);
  }

  /**
   * Load a Scratch project from a .sb, .sb2, .sb3 or json string.
   * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
   * @return {!Promise} Promise that resolves after targets are installed.
   */
  loadProject(input) {
    if (typeof input === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }
    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! scratch-parser */ "./node_modules/scratch-parser/index.js");
      // The second argument of false below indicates to the validator that the
      // input should be parsed/validated as an entire project (and not a single sprite)
      validate(input, false, (error, res) => {
        if (error) return reject(error);
        resolve(res);
      });
    }).catch(error => {
      const {
        SB1File,
        ValidationError
      } = __webpack_require__(/*! scratch-sb1-converter */ "./node_modules/scratch-sb1-converter/index.js");
      try {
        const sb1 = new SB1File(input);
        const json = sb1.json;
        json.projectVersion = 2;
        return Promise.resolve([json, sb1.zip]);
      } catch (sb1Error) {
        if (sb1Error instanceof ValidationError) {
          // The input does not validate as a Scratch 1 file.
        } else {
          // The project appears to be a Scratch 1 file but it
          // could not be successfully translated into a Scratch 2
          // project.
          return Promise.reject(sb1Error);
        }
      }
      // Throw original error since the input does not appear to be
      // an SB1File.
      return Promise.reject(error);
    });
    return validationPromise.then(validatedInput => this.deserializeProject(validatedInput[0], validatedInput[1])).then(() => this.runtime.handleProjectLoaded()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (Object.prototype.hasOwnProperty.call(error, 'validationError')) {
        return Promise.reject(JSON.stringify(error));
      }
      return Promise.reject(error);
    });
  }

  /**
   * Load a project from the Scratch web site, by ID.
   * @param {string} id - the ID of the project to download, as a string.
   */
  downloadProjectId(id) {
    const storage = this.runtime.storage;
    if (!storage) {
      log.error('No storage module present; cannot load project: ', id);
      return;
    }
    const vm = this;
    const promise = storage.load(storage.AssetType.Project, id);
    promise.then(projectAsset => {
      if (!projectAsset) {
        log.error("Failed to fetch project with id: ".concat(id));
        return null;
      }
      return vm.loadProject(projectAsset.data);
    });
  }

  /**
   * @returns {string} Project in a Scratch 3.0 JSON representation.
   */
  saveProjectSb3() {
    const soundDescs = serializeSounds(this.runtime);
    const costumeDescs = serializeCostumes(this.runtime);
    const projectJson = this.toJSON();

    // TODO want to eventually move zip creation out of here, and perhaps
    // into scratch-storage
    const zip = new JSZip();

    // Put everything in a zip file
    zip.file('project.json', projectJson);
    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);
    return zip.generateAsync({
      type: 'blob',
      mimeType: 'application/x.scratch.sb3',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6 // Tradeoff between best speed (1) and best compression (9)
      }
    });
  }

  /*
   * @type {Array<object>} Array of all costumes and sounds currently in the runtime
   */
  get assets() {
    return this.runtime.targets.reduce((acc, target) => acc.concat(target.sprite.sounds.map(sound => sound.asset)).concat(target.sprite.costumes.map(costume => costume.asset)), []);
  }
  _addFileDescsToZip(fileDescs, zip) {
    for (let i = 0; i < fileDescs.length; i++) {
      const currFileDesc = fileDescs[i];
      zip.file(currFileDesc.fileName, currFileDesc.fileContent);
    }
  }

  /**
   * Exports a sprite in the sprite3 format.
   * @param {string} targetId ID of the target to export
   * @param {string=} optZipType Optional type that the resulting
   * zip should be outputted in. Options are: base64, binarystring,
   * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to
   * blob if argument not provided.
   * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option
   * for more information about these options.
   * @return {object} A generated zip of the sprite and its assets in the format
   * specified by optZipType or blob by default.
   */
  exportSprite(targetId, optZipType) {
    const soundDescs = serializeSounds(this.runtime, targetId);
    const costumeDescs = serializeCostumes(this.runtime, targetId);
    const spriteJson = this.toJSON(targetId);
    const zip = new JSZip();
    zip.file('sprite.json', spriteJson);
    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);
    return zip.generateAsync({
      type: typeof optZipType === 'string' ? optZipType : 'blob',
      mimeType: 'application/x.scratch.sprite3',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6
      }
    });
  }

  /**
   * Export project or sprite as a Scratch 3.0 JSON representation.
   * @param {string=} optTargetId - Optional id of a sprite to serialize
   * @return {string} Serialized state of the runtime.
   */
  toJSON(optTargetId) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");
    return StringUtil.stringify(sb3.serialize(this.runtime, optTargetId));
  }

  // TODO do we still need this function? Keeping it here so as not to introduce
  // a breaking change.
  /**
   * Load a project from a Scratch JSON representation.
   * @param {string} json JSON string representing a project.
   * @returns {Promise} Promise that resolves after the project has loaded
   */
  fromJSON(json) {
    log.warning('fromJSON is now just a wrapper around loadProject, please use that function instead.');
    return this.loadProject(json);
  }

  /**
   * Load a project from a Scratch JSON representation.
   * @param {string} projectJSON JSON string representing a project.
   * @param {?JSZip} zip Optional zipped project containing assets to be loaded.
   * @returns {Promise} Promise that resolves after the project has loaded
   */
  deserializeProject(projectJSON, zip) {
    // Clear the current runtime
    this.clear();
    if (typeof performance !== 'undefined') {
      performance.mark('scratch-vm-deserialize-start');
    }
    const runtime = this.runtime;
    const deserializePromise = function deserializePromise() {
      const projectVersion = projectJSON.projectVersion;
      if (projectVersion === 2) {
        const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");
        return sb2.deserialize(projectJSON, runtime, false, zip);
      }
      if (projectVersion === 3) {
        const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");
        return sb3.deserialize(projectJSON, runtime, zip);
      }
      // TODO: reject with an Error (possible breaking API change!)
      // eslint-disable-next-line prefer-promise-reject-errors
      return Promise.reject('Unable to verify Scratch Project version.');
    };
    return deserializePromise().then(_ref => {
      let {
        targets,
        extensions
      } = _ref;
      if (typeof performance !== 'undefined') {
        performance.mark('scratch-vm-deserialize-end');
        performance.measure('scratch-vm-deserialize', 'scratch-vm-deserialize-start', 'scratch-vm-deserialize-end');
      }
      return this.installTargets(targets, extensions, true);
    });
  }

  /**
   * Install `deserialize` results: zero or more targets after the extensions (if any) used by those targets.
   * @param {Array.<Target>} targets - the targets to be installed
   * @param {ImportedExtensionsInfo} extensions - metadata about extensions used by these targets
   * @param {boolean} wholeProject - set to true if installing a whole project, as opposed to a single sprite.
   * @returns {Promise} resolved once targets have been installed
   */
  installTargets(targets, extensions, wholeProject) {
    const extensionPromises = [];
    extensions.extensionIDs.forEach(extensionID => {
      if (!this.extensionManager.isExtensionLoaded(extensionID)) {
        const extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;
        extensionPromises.push(this.extensionManager.loadExtensionURL(extensionURL));
      }
    });
    targets = targets.filter(target => !!target);
    return Promise.all(extensionPromises).then(() => {
      targets.forEach(target => {
        this.runtime.addTarget(target);
        ( /** @type RenderedTarget */target).updateAllDrawableProperties();
        // Ensure unique sprite name
        if (target.isSprite()) this.renameSprite(target.id, target.getName());
      });
      // Sort the executable targets by layerOrder.
      // Remove layerOrder property after use.
      this.runtime.executableTargets.sort((a, b) => a.layerOrder - b.layerOrder);
      targets.forEach(target => {
        delete target.layerOrder;
      });

      // Select the first target for editing, e.g., the first sprite.
      if (wholeProject && targets.length > 1) {
        this.editingTarget = targets[1];
      } else {
        this.editingTarget = targets[0];
      }
      if (!wholeProject) {
        this.editingTarget.fixUpVariableReferences();
      }

      // Update the VM user's knowledge of targets and blocks on the workspace.
      this.emitTargetsUpdate(false /* Don't emit project change */);
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.runtime.ioDevices.cloud.setStage(this.runtime.getTargetForStage());
    });
  }

  /**
   * Add a sprite, this could be .sprite2 or .sprite3. Unpack and validate
   * such a file first.
   * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
   * @return {!Promise} Promise that resolves after targets are installed.
   */
  addSprite(input) {
    const errorPrefix = 'Sprite Upload Error:';
    if (typeof input === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }
    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! scratch-parser */ "./node_modules/scratch-parser/index.js");
      // The second argument of true below indicates to the parser/validator
      // that the given input should be treated as a single sprite and not
      // an entire project
      validate(input, true, (error, res) => {
        if (error) return reject(error);
        resolve(res);
      });
    });
    return validationPromise.then(validatedInput => {
      const projectVersion = validatedInput[0].projectVersion;
      if (projectVersion === 2) {
        return this._addSprite2(validatedInput[0], validatedInput[1]);
      }
      if (projectVersion === 3) {
        return this._addSprite3(validatedInput[0], validatedInput[1]);
      }
      // TODO: reject with an Error (possible breaking API change!)
      // eslint-disable-next-line prefer-promise-reject-errors
      return Promise.reject("".concat(errorPrefix, " Unable to verify sprite version."));
    }).then(() => this.runtime.emitProjectChanged()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (Object.prototype.hasOwnProperty.call(error, 'validationError')) {
        return Promise.reject(JSON.stringify(error));
      }
      // TODO: reject with an Error (possible breaking API change!)
      // eslint-disable-next-line prefer-promise-reject-errors
      return Promise.reject("".concat(errorPrefix, " ").concat(error));
    });
  }

  /**
   * Add a single sprite from the "Sprite2" (i.e., SB2 sprite) format.
   * @param {object} sprite Object representing 2.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json
   * @returns {Promise} Promise that resolves after the sprite is added
   */
  _addSprite2(sprite, zip) {
    // Validate & parse

    const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");
    return sb2.deserialize(sprite, this.runtime, true, zip).then(_ref2 => {
      let {
        targets,
        extensions
      } = _ref2;
      return this.installTargets(targets, extensions, false);
    });
  }

  /**
   * Add a single sb3 sprite.
   * @param {object} sprite Object rperesenting 3.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json
   * @returns {Promise} Promise that resolves after the sprite is added
   */
  _addSprite3(sprite, zip) {
    // Validate & parse
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");
    return sb3.deserialize(sprite, this.runtime, zip, true).then(_ref3 => {
      let {
        targets,
        extensions
      } = _ref3;
      return this.installTargets(targets, extensions, false);
    });
  }

  /**
   * Add a costume to the current editing target.
   * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
   * @param {!object} costumeObject Object representing the costume.
   * @property {int} skinId - the ID of the costume's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the costume's origin.
   * @property {number} rotationCenterY - the Y component of the costume's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @param {string} optVersion - if this is 2, load costume as sb2, otherwise load costume as sb3.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */
  addCostume(md5ext, costumeObject, optTargetId, optVersion) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;
    if (target) {
      return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(() => {
        target.addCostume(costumeObject);
        target.setCostume(target.getCostumes().length - 1);
        this.runtime.emitProjectChanged();
      });
    }
    // If the target cannot be found by id, return a rejected promise
    // TODO: reject with an Error (possible breaking API change!)
    // eslint-disable-next-line prefer-promise-reject-errors
    return Promise.reject();
  }

  /**
   * Add a costume loaded from the library to the current editing target.
   * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
   * @param {!object} costumeObject Object representing the costume.
   * @property {int} skinId - the ID of the costume's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the costume's origin.
   * @property {number} rotationCenterY - the Y component of the costume's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */
  addCostumeFromLibrary(md5ext, costumeObject) {
    // TODO: reject with an Error (possible breaking API change!)
    // eslint-disable-next-line prefer-promise-reject-errors
    if (!this.editingTarget) return Promise.reject();
    return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2 /* optVersion */);
  }

  /**
   * Duplicate the costume at the given index. Add it at that index + 1.
   * @param {!int} costumeIndex Index of costume to duplicate
   * @returns {?Promise} - a promise that resolves when the costume has been decoded and added
   */
  duplicateCostume(costumeIndex) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = "".concat(clone.assetId, ".").concat(clone.dataFormat);
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      this.editingTarget.addCostume(clone, costumeIndex + 1);
      this.editingTarget.setCostume(costumeIndex + 1);
      this.emitTargetsUpdate();
    });
  }

  /**
   * Duplicate the sound at the given index. Add it at that index + 1.
   * @param {!int} soundIndex Index of sound to duplicate
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */
  duplicateSound(soundIndex) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(() => {
      this.editingTarget.addSound(clone, soundIndex + 1);
      this.emitTargetsUpdate();
    });
  }

  /**
   * Rename a costume on the current editing target.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */
  renameCostume(costumeIndex, newName) {
    this.editingTarget.renameCostume(costumeIndex, newName);
    this.emitTargetsUpdate();
  }

  /**
   * Delete a costume from the current editing target.
   * @param {int} costumeIndex - the index of the costume to be removed.
   * @return {?function} A function to restore the deleted costume, or null,
   * if no costume was deleted.
   */
  deleteCostume(costumeIndex) {
    const deletedCostume = this.editingTarget.deleteCostume(costumeIndex);
    if (deletedCostume) {
      const target = this.editingTarget;
      this.runtime.emitProjectChanged();
      return () => {
        target.addCostume(deletedCostume);
        this.emitTargetsUpdate();
      };
    }
    return null;
  }

  /**
   * Add a sound to the current editing target.
   * @param {!object} soundObject Object representing the costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */
  addSound(soundObject, optTargetId) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;
    if (target) {
      return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(() => {
        target.addSound(soundObject);
        this.emitTargetsUpdate();
      });
    }
    // If the target cannot be found by id, return a rejected promise
    return new Promise.reject();
  }

  /**
   * Rename a sound on the current editing target.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */
  renameSound(soundIndex, newName) {
    this.editingTarget.renameSound(soundIndex, newName);
    this.emitTargetsUpdate();
  }

  /**
   * Get a sound buffer from the audio engine.
   * @param {int} soundIndex - the index of the sound to be got.
   * @return {AudioBuffer} the sound's audio buffer.
   */
  getSoundBuffer(soundIndex) {
    const id = this.editingTarget.sprite.sounds[soundIndex].soundId;
    if (id && this.runtime && this.runtime.audioEngine) {
      return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;
    }
    return null;
  }

  /**
   * Update a sound buffer.
   * @param {int} soundIndex - the index of the sound to be updated.
   * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
   * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored
   */
  updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {
    const sound = this.editingTarget.sprite.sounds[soundIndex];
    if (sound && sound.broken) delete sound.broken;
    const id = sound ? sound.soundId : null;
    if (id && this.runtime && this.runtime.audioEngine) {
      this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;
    }
    // Update sound in runtime
    if (soundEncoding) {
      // Now that we updated the sound, the format should also be updated
      // so that the sound can eventually be decoded the right way.
      // Sounds that were formerly 'adpcm', but were updated in sound editor
      // will not get decoded by the audio engine correctly unless the format
      // is updated as below.
      sound.format = '';
      const storage = this.runtime.storage;
      sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true // generate md5
      );
      sound.assetId = sound.asset.assetId;
      sound.dataFormat = storage.DataFormat.WAV;
      sound.md5 = "".concat(sound.assetId, ".").concat(sound.dataFormat);
      sound.sampleCount = newBuffer.length;
      sound.rate = newBuffer.sampleRate;
    }
    // If soundEncoding is null, it's because gui had a problem
    // encoding the updated sound. We don't want to store anything in this
    // case, and gui should have logged an error.

    this.emitTargetsUpdate();
  }

  /**
   * Delete a sound from the current editing target.
   * @param {int} soundIndex - the index of the sound to be removed.
   * @return {?Function} A function to restore the sound that was deleted,
   * or null, if no sound was deleted.
   */
  deleteSound(soundIndex) {
    const target = this.editingTarget;
    const deletedSound = this.editingTarget.deleteSound(soundIndex);
    if (deletedSound) {
      this.runtime.emitProjectChanged();
      const restoreFun = () => {
        target.addSound(deletedSound);
        this.emitTargetsUpdate();
      };
      return restoreFun;
    }
    return null;
  }

  /**
   * Get a string representation of the image from storage.
   * @param {int} costumeIndex - the index of the costume to be got.
   * @return {string} the costume's SVG string if it's SVG,
   *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.
   */
  getCostume(costumeIndex) {
    const asset = this.editingTarget.getCostumes()[costumeIndex].asset;
    if (!asset || !this.runtime || !this.runtime.storage) return null;
    const format = asset.dataFormat;
    if (format === this.runtime.storage.DataFormat.SVG) {
      return asset.decodeText();
    } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {
      return asset.encodeDataURI();
    }
    log.error("Unhandled format: ".concat(asset.dataFormat));
    return null;
  }

  /**
   * Update a costume with the given bitmap
   * @param {!int} costumeIndex - the index of the costume to be updated.
   * @param {!ImageData} bitmap - new bitmap for the renderer.
   * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,
   *     2 for double-resolution bitmaps
   */
  updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {
    const costume = this.editingTarget.getCostumes()[costumeIndex];
    if (!(costume && this.runtime && this.runtime.renderer)) return;
    if (costume && costume.broken) delete costume.broken;
    costume.rotationCenterX = rotationCenterX;
    costume.rotationCenterY = rotationCenterY;

    // If the bitmap originally had a zero width or height, use that value
    const bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;
    const bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height;
    // @todo: updateBitmapSkin does not take ImageData
    const canvas = document.createElement('canvas');
    canvas.width = bitmapWidth;
    canvas.height = bitmapHeight;
    const context = canvas.getContext('2d');
    context.putImageData(bitmap, 0, 0);

    // Divide by resolution because the renderer's definition of the rotation center
    // is the rotation center divided by the bitmap resolution
    this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]);

    // @todo there should be a better way to get from ImageData to a decodable storage format
    canvas.toBlob(blob => {
      const reader = new FileReader();
      reader.addEventListener('loadend', () => {
        const storage = this.runtime.storage;
        costume.dataFormat = storage.DataFormat.PNG;
        costume.bitmapResolution = bitmapResolution;
        costume.size = [bitmapWidth, bitmapHeight];
        costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null,
        // id
        true // generate md5
        );
        costume.assetId = costume.asset.assetId;
        costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
        this.emitTargetsUpdate();
      });
      // Bitmaps with a zero width or height return null for their blob
      if (blob) {
        reader.readAsArrayBuffer(blob);
      }
    });
  }

  /**
   * Update a costume with the given SVG
   * @param {int} costumeIndex - the index of the costume to be updated.
   * @param {string} svg - new SVG for the renderer.
   * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   */
  updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {
    const costume = this.editingTarget.getCostumes()[costumeIndex];
    if (costume && costume.broken) delete costume.broken;
    if (costume && this.runtime && this.runtime.renderer) {
      costume.rotationCenterX = rotationCenterX;
      costume.rotationCenterY = rotationCenterY;
      this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);
      costume.size = this.runtime.renderer.getSkinSize(costume.skinId);
    }
    const storage = this.runtime.storage;
    // If we're in here, we've edited an svg in the vector editor,
    // so the dataFormat should be 'svg'
    costume.dataFormat = storage.DataFormat.SVG;
    costume.bitmapResolution = 1;
    costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new _TextEncoder().encode(svg), null, true // generate md5
    );
    costume.assetId = costume.asset.assetId;
    costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
    this.emitTargetsUpdate();
  }

  /**
   * Add a backdrop to the stage.
   * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
   * @param {!object} backdropObject Object representing the backdrop.
   * @property {int} skinId - the ID of the backdrop's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the backdrop's origin.
   * @property {number} rotationCenterY - the Y component of the backdrop's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
   * @returns {?Promise} - a promise that resolves when the backdrop has been added
   */
  addBackdrop(md5ext, backdropObject) {
    return loadCostume(md5ext, backdropObject, this.runtime).then(() => {
      const stage = this.runtime.getTargetForStage();
      stage.addCostume(backdropObject);
      stage.setCostume(stage.getCostumes().length - 1);
      this.runtime.emitProjectChanged();
    });
  }

  /**
   * Rename a sprite.
   * @param {string} targetId ID of a target whose sprite to rename.
   * @param {string} newName New name of the sprite.
   */
  renameSprite(targetId, newName) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      if (!target.isSprite()) {
        throw new Error('Cannot rename non-sprite targets.');
      }
      const sprite = target.sprite;
      if (!sprite) {
        throw new Error('No sprite associated with this target.');
      }
      if (newName && RESERVED_NAMES.indexOf(newName) === -1) {
        const names = this.runtime.targets.filter(runtimeTarget => runtimeTarget.isSprite() && runtimeTarget.id !== target.id).map(runtimeTarget => runtimeTarget.sprite.name);
        const oldName = sprite.name;
        const newUnusedName = StringUtil.unusedName(newName, names);
        sprite.name = newUnusedName;
        const allTargets = this.runtime.targets;
        for (let i = 0; i < allTargets.length; i++) {
          const currTarget = allTargets[i];
          currTarget.blocks.updateAssetName(oldName, newName, 'sprite');
        }
        if (newUnusedName !== oldName) this.emitTargetsUpdate();
      }
    } else {
      throw new Error('No target with the provided id.');
    }
  }

  /**
   * Delete a sprite and all its clones.
   * @param {string} targetId ID of a target whose sprite to delete.
   * @return {Function} Returns a function to restore the sprite that was deleted
   */
  deleteSprite(targetId) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      const targetIndexBeforeDelete = this.runtime.targets.map(t => t.id).indexOf(target.id);
      if (!target.isSprite()) {
        throw new Error('Cannot delete non-sprite targets.');
      }
      const sprite = target.sprite;
      if (!sprite) {
        throw new Error('No sprite associated with this target.');
      }
      const spritePromise = this.exportSprite(targetId, 'uint8array');
      const restoreSprite = () => spritePromise.then(spriteBuffer => this.addSprite(spriteBuffer));
      // Remove monitors from the runtime state and remove the
      // target-specific monitored blocks (e.g. local variables)
      target.deleteMonitors();
      const currentEditingTarget = this.editingTarget;
      for (let i = 0; i < sprite.clones.length; i++) {
        const clone = sprite.clones[i];
        this.runtime.stopForTarget(sprite.clones[i]);
        this.runtime.disposeTarget(sprite.clones[i]);
        // Ensure editing target is switched if we are deleting it.
        if (clone === currentEditingTarget) {
          const nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);
          if (this.runtime.targets.length > 0) {
            this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);
          } else {
            this.editingTarget = null;
          }
        }
      }
      // Sprite object should be deleted by GC.
      this.emitTargetsUpdate();
      return restoreSprite;
    }
    throw new Error('No target with the provided id.');
  }

  /**
   * Duplicate a sprite.
   * @param {string} targetId ID of a target whose sprite to duplicate.
   * @returns {Promise} Promise that resolves when duplicated target has
   *     been added to the runtime.
   */
  duplicateSprite(targetId) {
    const target = this.runtime.getTargetById(targetId);
    if (!target) {
      throw new Error('No target with the provided id.');
    } else if (!target.isSprite()) {
      throw new Error('Cannot duplicate non-sprite targets.');
    } else if (!target.sprite) {
      throw new Error('No sprite associated with this target.');
    }
    return target.duplicate().then(newTarget => {
      this.runtime.addTarget(newTarget);
      newTarget.goBehindOther(target);
      this.setEditingTarget(newTarget.id);
    });
  }

  /**
   * Set the audio engine for the VM/runtime
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */
  attachAudioEngine(audioEngine) {
    this.runtime.attachAudioEngine(audioEngine);
  }

  /**
   * Set the renderer for the VM/runtime
   * @param {!RenderWebGL} renderer The renderer to attach
   */
  attachRenderer(renderer) {
    this.runtime.attachRenderer(renderer);
  }

  /**
   * @returns {RenderWebGL} The renderer attached to the vm
   */
  get renderer() {
    return this.runtime && this.runtime.renderer;
  }

  // @deprecated
  attachV2SVGAdapter() {}

  /**
   * Set the bitmap adapter for the VM/runtime, which converts scratch 2
   * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
   * @param {!function} bitmapAdapter The adapter to attach
   */
  attachV2BitmapAdapter(bitmapAdapter) {
    this.runtime.attachV2BitmapAdapter(bitmapAdapter);
  }

  /**
   * Set the storage module for the VM/runtime
   * @param {!ScratchStorage} storage The storage module to attach
   */
  attachStorage(storage) {
    this.runtime.attachStorage(storage);
  }

  /**
   * set the current locale and builtin messages for the VM
   * @param {!string} locale       current locale
   * @param {!object} messages     builtin messages map for current locale
   * @returns {Promise} Promise that resolves when all the blocks have been
   *     updated for a new locale (or empty if locale hasn't changed.)
   */
  setLocale(locale, messages) {
    if (locale !== formatMessage.setup().locale) {
      formatMessage.setup({
        locale: locale,
        translations: {
          [locale]: messages
        }
      });
    }
    return this.extensionManager.refreshBlocks();
  }

  /**
   * get the current locale for the VM
   * @returns {string} the current locale in the VM
   */
  getLocale() {
    return formatMessage.setup().locale;
  }

  /**
   * Handle a Blockly event for the current editing target.
   * @param {!Blockly.Event} e Any Blockly event.
   */
  blockListener(e) {
    if (this.editingTarget) {
      this.editingTarget.blocks.blocklyListen(e);
    }
  }

  /**
   * Handle a Blockly event for the flyout.
   * @param {!Blockly.Event} e Any Blockly event.
   */
  flyoutBlockListener(e) {
    this.runtime.flyoutBlocks.blocklyListen(e);
  }

  /**
   * Handle a Blockly event for the flyout to be passed to the monitor container.
   * @param {!Blockly.Event} e Any Blockly event.
   */
  monitorBlockListener(e) {
    // Filter events by type, since monitor blocks only need to listen to these events.
    // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.
    if (['create', 'change'].indexOf(e.type) !== -1) {
      this.runtime.monitorBlocks.blocklyListen(e);
    }
  }

  /**
   * Handle a Blockly event for the variable map.
   * @param {!Blockly.Event} e Any Blockly event.
   */
  variableListener(e) {
    // Filter events by type, since blocks only needs to listen to these
    // var events.
    if (['var_create', 'var_rename', 'var_delete'].indexOf(e.type) !== -1) {
      this.runtime.getTargetForStage().blocks.blocklyListen(e);
    }
  }

  /**
   * Delete all of the flyout blocks.
   */
  clearFlyoutBlocks() {
    this.runtime.flyoutBlocks.deleteAllBlocks();
  }

  /**
   * Set an editing target. An editor UI can use this function to switch
   * between editing different targets, sprites, etc.
   * After switching the editing target, the VM may emit updates
   * to the list of targets and any attached workspace blocks
   * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
   * @param {string} targetId Id of target to set as editing.
   */
  setEditingTarget(targetId) {
    // Has the target id changed? If not, exit.
    if (this.editingTarget && targetId === this.editingTarget.id) {
      return;
    }
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      this.editingTarget = target;
      // Emit appropriate UI updates.
      this.emitTargetsUpdate(false /* Don't emit project change */);
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(target);
    }
  }

  /**
   * Called when blocks are dragged from one sprite to another. Adds the blocks to the
   * workspace of the given target.
   * @param {!Array<object>} blocks Blocks to add.
   * @param {!string} targetId Id of target to add blocks to.
   * @param {?string} optFromTargetId Optional target id indicating that blocks are being
   * shared from that target. This is needed for resolving any potential variable conflicts.
   * @return {!Promise} Promise that resolves when the extensions and blocks have been added.
   */
  shareBlocksToTarget(blocks, targetId, optFromTargetId) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");
    const copiedBlocks = JSON.parse(JSON.stringify(blocks));
    newBlockIds(copiedBlocks);
    const target = this.runtime.getTargetById(targetId);
    if (optFromTargetId) {
      // If the blocks are being shared from another target,
      // resolve any possible variable conflicts that may arise.
      const fromTarget = this.runtime.getTargetById(optFromTargetId);
      fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);
    }

    // Create a unique set of extensionIds that are not yet loaded
    const extensionIDs = new Set(copiedBlocks.map(b => sb3.getExtensionIdForOpcode(b.opcode)).filter(id => !!id) // Remove ids that do not exist
    .filter(id => !this.extensionManager.isExtensionLoaded(id)) // and remove loaded extensions
    );

    // Create an array promises for extensions to load
    const extensionPromises = Array.from(extensionIDs, id => this.extensionManager.loadExtensionURL(id));
    return Promise.all(extensionPromises).then(() => {
      copiedBlocks.forEach(block => {
        target.blocks.createBlock(block);
      });
      target.blocks.updateTargetSpecificBlocks(target.isStage);
    });
  }

  /**
   * Called when costumes are dragged from editing target to another target.
   * Sets the newly added costume as the current costume.
   * @param {!number} costumeIndex Index of the costume of the editing target to share.
   * @param {!string} targetId Id of target to add the costume.
   * @return {Promise} Promise that resolves when the new costume has been loaded.
   */
  shareCostumeToTarget(costumeIndex, targetId) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = "".concat(clone.assetId, ".").concat(clone.dataFormat);
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      const target = this.runtime.getTargetById(targetId);
      if (target) {
        target.addCostume(clone);
        target.setCostume(target.getCostumes().length - 1);
      }
    });
  }

  /**
   * Called when sounds are dragged from editing target to another target.
   * @param {!number} soundIndex Index of the sound of the editing target to share.
   * @param {!string} targetId Id of target to add the sound.
   * @return {Promise} Promise that resolves when the new sound has been loaded.
   */
  shareSoundToTarget(soundIndex, targetId) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    const target = this.runtime.getTargetById(targetId);
    return loadSound(clone, this.runtime, target.sprite.soundBank).then(() => {
      if (target) {
        target.addSound(clone);
        this.emitTargetsUpdate();
      }
    });
  }

  /**
   * Repopulate the workspace with the blocks of the current editingTarget. This
   * allows us to get around bugs like gui#413.
   */
  refreshWorkspace() {
    if (this.editingTarget) {
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.emitTargetsUpdate(false /* Don't emit project change */);
    }
  }

  /**
   * Emit metadata about available targets.
   * An editor UI could use this to display a list of targets and show
   * the currently editing one.
   * @param {bool} triggerProjectChange If true, also emit a project changed event.
   * Disabled selectively by updates that don't affect project serialization.
   * Defaults to true.
   */
  emitTargetsUpdate(triggerProjectChange) {
    if (typeof triggerProjectChange === 'undefined') triggerProjectChange = true;
    this.emit('targetsUpdate', {
      // [[target id, human readable target name], ...].
      targetList: this.runtime.targets.filter(
      // Don't report clones.
      target => !Object.prototype.hasOwnProperty.call(target, 'isOriginal') || target.isOriginal).map(target => target.toJSON()),
      // Currently editing target id.
      editingTarget: this.editingTarget ? this.editingTarget.id : null
    });
    if (triggerProjectChange) {
      this.runtime.emitProjectChanged();
    }
  }

  /**
   * Emit an Blockly/scratch-blocks compatible XML representation
   * of the current editing target's blocks.
   */
  emitWorkspaceUpdate() {
    // Create a list of broadcast message Ids according to the stage variables
    const stageVariables = this.runtime.getTargetForStage().variables;
    let messageIds = [];
    for (const varId in stageVariables) {
      if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {
        messageIds.push(varId);
      }
    }
    // Go through all blocks on all targets, removing referenced
    // broadcast ids from the list.
    for (let i = 0; i < this.runtime.targets.length; i++) {
      const currTarget = this.runtime.targets[i];
      const currBlocks = currTarget.blocks._blocks;
      for (const blockId in currBlocks) {
        if (currBlocks[blockId].fields.BROADCAST_OPTION) {
          const id = currBlocks[blockId].fields.BROADCAST_OPTION.id;
          const index = messageIds.indexOf(id);
          if (index !== -1) {
            messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));
          }
        }
      }
    }
    // Anything left in messageIds is not referenced by a block, so delete it.
    for (let i = 0; i < messageIds.length; i++) {
      const id = messageIds[i];
      delete this.runtime.getTargetForStage().variables[id];
    }
    const globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);
    const localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);
    const globalVariables = Object.keys(globalVarMap).map(k => globalVarMap[k]);
    const localVariables = Object.keys(localVarMap).map(k => localVarMap[k]);
    const workspaceComments = Object.keys(this.editingTarget.comments).map(k => this.editingTarget.comments[k]).filter(c => c.blockId === null);
    const xmlString = "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n                            <variables>\n                                ".concat(globalVariables.map(v => v.toXML()).join(), "\n                                ").concat(localVariables.map(v => v.toXML(true)).join(), "\n                            </variables>\n                            ").concat(workspaceComments.map(c => c.toXML()).join(), "\n                            ").concat(this.editingTarget.blocks.toXML(this.editingTarget.comments), "\n                        </xml>");
    this.emit('workspaceUpdate', {
      xml: xmlString
    });
  }

  /**
   * Get a target id for a drawable id. Useful for interacting with the renderer
   * @param {int} drawableId The drawable id to request the target id for
   * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
   */
  getTargetIdForDrawableId(drawableId) {
    const target = this.runtime.getTargetByDrawableId(drawableId);
    if (target && Object.prototype.hasOwnProperty.call(target, 'id') && Object.prototype.hasOwnProperty.call(target, 'isStage') && !target.isStage) {
      return target.id;
    }
    return null;
  }

  /**
   * Reorder target by index. Return whether a change was made.
   * @param {!string} targetIndex Index of the target.
   * @param {!number} newIndex index that the target should be moved to.
   * @returns {boolean} Whether a target was reordered.
   */
  reorderTarget(targetIndex, newIndex) {
    let targets = this.runtime.targets;
    targetIndex = MathUtil.clamp(targetIndex, 0, targets.length - 1);
    newIndex = MathUtil.clamp(newIndex, 0, targets.length - 1);
    if (targetIndex === newIndex) return false;
    const target = targets[targetIndex];
    targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));
    targets.splice(newIndex, 0, target);
    this.runtime.targets = targets;
    this.emitTargetsUpdate();
    return true;
  }

  /**
   * Reorder the costumes of a target if it exists. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the costumes.
   * @param {!number} costumeIndex index of the costume to move.
   * @param {!number} newIndex index that the costume should be moved to.
   * @returns {boolean} Whether a costume was reordered.
   */
  reorderCostume(targetId, costumeIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      const reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);
      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }
      return reorderSuccessful;
    }
    return false;
  }

  /**
   * Reorder the sounds of a target if it exists. Return whether it occured.
   * @param {!string} targetId ID of the target which owns the sounds.
   * @param {!number} soundIndex index of the sound to move.
   * @param {!number} newIndex index that the sound should be moved to.
   * @returns {boolean} Whether a sound was reordered.
   */
  reorderSound(targetId, soundIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      const reorderSuccessful = target.reorderSound(soundIndex, newIndex);
      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }
      return reorderSuccessful;
    }
    return false;
  }

  /**
   * Put a target into a "drag" state, during which its X/Y positions will be unaffected
   * by blocks.
   * @param {string} targetId The id for the target to put into a drag state
   */
  startDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      this._dragTarget = target;
      target.startDrag();
    }
  }

  /**
   * Remove a target from a drag state, so blocks may begin affecting X/Y position again
   * @param {string} targetId The id for the target to remove from the drag state
   */
  stopDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      this._dragTarget = null;
      target.stopDrag();
      this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);
    }
  }

  /**
   * Post/edit sprite info for the current editing target or the drag target.
   * @param {object} data An object with sprite info data to set.
   */
  postSpriteInfo(data) {
    if (this._dragTarget) {
      this._dragTarget.postSpriteInfo(data);
    } else {
      this.editingTarget.postSpriteInfo(data);
    }
    // Post sprite info means the gui has changed something about a sprite,
    // either through the sprite info pane fields (e.g. direction, size) or
    // through dragging a sprite on the stage
    // Emit a project changed event.
    this.runtime.emitProjectChanged();
  }

  /**
   * Set a target's variable's value. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @param {!*} value The new value of that variable.
   * @returns {boolean} whether the target and variable were found and updated.
   */
  setVariableValue(targetId, variableId, value) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      const variable = target.lookupVariableById(variableId);
      if (variable) {
        variable.value = value;
        if (variable.isCloud) {
          this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);
        }
        return true;
      }
    }
    return false;
  }

  /**
   * Get a target's variable's value. Return null if the target or variable does not exist.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @returns {?*} The value of the variable, or null if it could not be looked up.
   */
  getVariableValue(targetId, variableId) {
    const target = this.runtime.getTargetById(targetId);
    if (target) {
      const variable = target.lookupVariableById(variableId);
      if (variable) {
        return variable.value;
      }
    }
    return null;
  }

  /**
   * Allow VM consumer to configure the ScratchLink socket creator.
   * @param {Function} factory The custom ScratchLink socket factory.
   */
  configureScratchLinkSocketFactory(factory) {
    this.runtime.configureScratchLinkSocketFactory(factory);
  }
}
module.exports = VirtualMachine;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const VirtualMachine = __webpack_require__(/*! ./virtual-machine */ "./src/virtual-machine.js");

const ArgumentType = __webpack_require__(/*! ./extension-support/argument-type */ "./src/extension-support/argument-type.js");
const BlockType = __webpack_require__(/*! ./extension-support/block-type */ "./src/extension-support/block-type.js");

module.exports = VirtualMachine;

// TODO: ESM named exports will save us all
module.exports.ArgumentType = ArgumentType;
module.exports.BlockType = BlockType;


/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/1-snare.mp3":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/1-snare.mp3 ***!
  \***********************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQVFBQUFUK0FBT0RnNE9EZzRrSkNRa0pDUTdPenM3T3p0U1VsSlNVbEpqWTJOalkyTmpjWEZ4Y1hGeGdvS0Nnb0tDa1pHUmtaR1JvcUtpb3FLaW9yQ3dzTEN3c0w2K3ZyNit2c3pNek16TXpOM2QzZDNkM2QzczdPenM3T3o2K3ZyNit2ci8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFZUFFRQUI0QUFBRS9qMFhRdVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQVhBQmZkUUFBQ01Tc3U4L01zSUFBSEFBQUE4QUFBRE9mOEgxVXppU1Z5UmxSU1k0NG13NFZWT2J4Q2NhaXpYRGRDSVFoWmMwaEJJOEJsZ1FVYWhFQUx2TjRyOUgxdWpXQklRQ2NQS2hVQnNWQXdGR2pnTlpOUFZtcno4aW5LR2hHMFZXSERDSG1UcGFyS1pVMC9WclhtRjVtK1lIRU5TT1lNUHBydUxjWTVmTnlaMDBMUjZuVHFEWkdxU29qek5NL3hZMzUra2laZVpyUjZDN3RlVE5IMGZXWExFNytMSEczdFdNdXFGeVptbFZqTlZ0V2xjMFNjOSs3NitDSlpXLzUzVE0wRUpJZ2tGODlPbnBTcFlMWHRqNk01MmYvRnV1eTZ5WGV2LzZ5S3JDRUFBQUFBQVFvRVpad2ltQ0RoVWdMZ3NHU0NmeGpNYlRUZmFIMkp5eS8vdVF4QStCbGJsdllaMldBQU5nc0NzNXA2WjV0U01CZ3ZKeVFxb3FObU1SR1BCQ0VwZWN4cGxwZ2RHUWxhY2sxTU9TaEdSRGs5SDFnU1gvb2I0ZnBETmN1Uk8zYldsS05ZL0VzUFNVdlJIcTdVY0tKaDcwcGJPcU1wRG55ZjQ5eHZxS09NT3A4T0hYWDMyNlg3ZHRhanUweWZobWNmaXBlODJqNllWblVaZWY3MklyVDgvUzE1dDFheTl6K3cwMTdyZk5XWTBHQ29OT0VaVVZFRHpoaEg0cS83S0l4RUFCT2dYTjBvTlBXTWtBQ3BFQ2t5NG9vQ1FCcTJMV1F0YlIwbllwbUV5dGEwUHhHQjQ0OVR0VUN0YnlqWEpQU2RxRkN6clY2YVoyeFd5b1N4cStKcU1jVEc0SjFUZHJoSms1R3BJWUw4dWpQVVNxUjdCUm9PdGN0SmxPekJKa1QxZUxvemN1QjB3bDVCTUt2U3pBZGg1dEQ1Q1doRGJ3bjltOXhiV0pqT2tzeS9zaXZSUjB4MlZZa2M0cXBLUmdvd3dTaFNCSFFoRVFXRVltQitTb2dPSkZXaGtVa2tFUkd5YmMwWE9ja2JRMEoxWlNXWmZUUzdIaEx4UXh1S1c4N1BJWEhIMEhMbE5tWnN4UGZJLzh1emZ4NTFLSTdQZWpNUkFBQUFBQUFCUUVESXBLL0ExRU1GSktoQVZUUXVsQTd2Rm5ua1p5NDJUenZ4Tk8vL3VReEJLQW1PbGRXYzA5a2NNMXJxcTVoN0k0TkVHaUlVNUxwY09ENUc2YnpwVHNrQnVqdkhhZVlvSGNaYks1MVc3UkpBanpwNVJiVnFnTXRJb1FwNEtkVkNwVnlHcUJJcVJrWGFlVmFnVXJtbGtnVUpvWWJJcHhSSUxHc01zQ0docVJWa1JGZE96QXpQeTBQSUNoOU4zRlRTTlc2dnMwV3VhS3gwdjg2VXVQeHhzbUlvV0dxazhjVEhib2RDU1BCYlVsV0pFeGRGNU5oeDlhMmVzbkhNMmhZNWxsYkFHa0M0VElDalowNHlsMzdkYUZybVZsck56RUNFQUFBUk81L09acGlwemxoRUZXOEJGWk9wclJsOVdDUTYrNzF6RmFWczduWFRKS3JsdE54VjFSWE9sYWZWR0pSUUlNUnhnTThlTXd1MmxUT2FlUnlWdEZWcWhXV04xWm1ncHlHcUtwR0l6S0lwRWs5ZnFoa1kyQXZaZmJFekxjNWprVHFCTVpPblExbjllS1RLR2tVaUNNSTlGdFVJZ2hvVVpXYUVwU1ZXcUExVExtVUZlWEY4U2w1YmhhZGdTanJLdGFoRnBsR1REdHVndVBHSEJOY1pPazY2NzZkQVhRSEIwaHZ5KzY0Kzh5dXhoNi93UlVtSG9NNTBSR0MyOWF4RXBYYk9yMEMwUlNxR0tza0FnQUJ0WllVQ3hScmVrV0NtS1FpVkszbGhvV05ITW1ZWS9jLy91UXhBNEJtcUZwVG95OWtkTVFMbW41bGlaNE5QMU9xWFBkQjdrcmxSemlaTExVZHF5aVlUZXhOMm5yNTRjaWduVExkSFQ1NHFnNDFXL2dxRmtScDFwdUNQdEhINVBWbUx5Z0k1MG00ZEsraExHN0lBWWh4ME10Y29lVFpRa2dZMU9ZaDV1S2VJV2U1QzBLT3BQcVErUU9xd29NUjVRa3lHWmprVUFTTFppd01CMk9GcnBnYkZwQkgwa0dGdzdXcjNtekplaHhuaENxc0VEb2gyRHNRVm5sQVNrd2dwa1I2NjZaS1NRd2VIR0hhV0dqc2RzUUhKVDB6K2RCbDRETHFCaFNFSkROL1hFWW9OejczZ1NuTlRBQVNMTXZZZGNoNU1DYnFTSVBKSUdWamlBZVNnNFZiNzZOY3ppYit1OWhIT1JTWHN0aEs0OU5DS2hMbjFUcDdHeGN6UEZoUFVuYUNReGdtTHB5ZmxBVHh5UHFxVnJiU3dlTkg1OVhvVlZJWm1UbkQ0NWNaSFk0TDlSNUdLc1JUWWRTMlRDZnk0Y1I4RXFtaVMyRWdqbmNJT0RTZEJZZmswcm14T09WQk9MUlkyRGpSQXdIMG1EYkV6NTJFQTJIcGhTWWpSSkNkVXhvbU9GeUpDQ2N6aUxEcUhEQ0FHU2ErMHZFa3U4Uk5wMDFzS243ZGdXRW9WTGdkQS9iVHAzTXNVK04rWWFCZGxVbTBTQ25oZWNxSnI5Ty8vdHd4QWVBRU4xdFlleXd6RW8ycmF5OWd5STlDSXJrY2lGcUpqUVNPM3RlVk5EOCtTajRGVGxOY2dNUGduYlJxWllFdGpzenRKUnBrUzh2Vll6UkQrbXFVVytveFdTOVg3ZDZaTk4zMkgrWHQrYS90VzNDYnpkNUtXcW4rRjNGTms5WHFkM3RyT3g4bzdsdzZ5ZzZXN2dDTEltNmw5bXI4dk55cmZoYzI1QTF5S1Y0Y25vS29rZ3Q5LzIxODVGdE1LcXRORUFMQzhtUU1LTW5BSjFmeXVrblVZbXQzVnV3aDRXeHUzSTVQTHB1N01uOEJtaE9abHd5UngzL1o4YW1MS1BPSlZWTEtiWVI3bEUxcHZoMXk2TTRpWnVvMFh6RXJ0RzRJWVU2cmwxUjJZNUhLUzJ5bzZSZHcwUmNUcnlsU3c1bFZaTUtmMENVVVJCZ3FwWXVQcTBPb29vMVNYb2NsT01EczFXSkxhQ1dDZ0JSTW4xcitQNHB1dnFycHNob1d5SUFGWW0zRVNxTWcwTHplSWFRUUhTalhaMWQ2eG45VVAvN1lNUVBBQSs5YTJmc0pReHFKUzhzdmFlaEpVSHhVdEo4ZzBId1JGR3pEVkREU0JHcXJuYlcwaFNIY3NQYkxuamE1MWdlc1I4YTYzTDFUMi9OTFUwc1h0WXphakI1cnM5U3M5UGQzR3ZQRlhVUjlSWHZ6UGJwcXRUUXJtc2RRN3RoUzVxb2xQWGNRaDd3MXhqZ2JZbG9kcjRPdWYwWlVURU90MFpKTTQ4aVhNRGtKalpoV2JqU1lveUZXKzJ6V0hJajN4ZTA2L1B4RnBKNHFZYXdub0NMVDBvNmgxSFdFOGVOVVhZcU5SeGVyYk1odE9rWEJ5TldlTWhxWHZacHlYUWZwVjl2d09wNzJab1pMeHROcnJ6TlVqVWFudnpYMVNHNDYrb29hRVE4b29zTUVHR2poMFVkU01LNHhTWkdzZTJLZGFqb2E3bUM1bjN6SythSDFkMXJ1NGlIYmYvN2NNUURBQkZKaFdIc1BNamg2N0FyL1lTTmxDc2tsOW9UWUUxZ0RjaXRQbCtreTBMMUl0SWZoZG42bFZyT2Y3NW5kSTVOU2d1dGJTUkZCSXRWZEg0bXliT1dSSkhscngwbStZMnBISzVjdDc1WEtzMm1mdzErMkR4T1pOSVJQZExFeVJpWlpCNlZiMlNUYmFpTXhuWnM5UzMvemMyK3BiVS9vTzRTZU1jYk5IS2VzVWxMRmVpLzNYUkRhWktvOC9WWTB6VTI2REJ1aXJaaXRtcGRsbGFSSlBiYUdtZWtPUmZUZDBjRk95OVNMVDNveE0wYmxNaGxzS2tTTXUzUHFqMVJ6VWtaMFp4b0xKaHVVdnFtMFZTWm5wWlpzTTJHR09IS2J3b0pOcDVDQVpTd3FQWHRxb0lvd2xDY25CUk5sWE55SWxqbGxYeHVOazVyblRoSWM3UFA0YXQ4WUlDTXdiUTBsVWJhelVLNUFncTZwQ3JJdk1YSmVHMXRhS25qRXQ0Vk1nTnkyUWNsTjJERW9mQTZyQklMQjlVRnBRdFNIanovKzJERUVnQVFyVjFkN0RESktnT3RhLzJXSVJ6eklqUTdYQTYwaENjdmtQcmFvclB1dldDeDBNanMwZTBvTW1aRFFrNWkzelBtMmk5NzM5cVRlcmFEZGMyUEdjcGN0anY0Um5HdERkVTg0emJFSTAxdEtxck1hYjJUOTBtUXhGRmI2Yk9WZVVhaTJQQzZBU0xiZG9BSkUvbjJkWC9JM1ZtZk5YVXZ0WTIzTzBDREpjT1ZnTWlBU0pOUjljSkNBdURjUGlHWWwwbklqeFdXVmhBdUd5NmQ5RGpEdUZQcG1xRHFwR0p5dmtqV1hSdUtHRDNnMU5LbU1ZWThWd3BFcFFyUnRpNDVvcFJzSFRsemJIcFZWVkRaZG1pc2JmdmNOSDhPOHcxYVNhY25LRUcyY2doUTlxMXZEWEhFVzBOWE9wN0Rqc0dnMFJiaktzbU4yTXVLYmF4Uk45bWtkcHovKzNERUJvQVA2WE5iN0RETW9meXI2MzJXR1J4aXBYU01oRWh3NkpOTmVUMFo0NjZ5QytqSHBUOU5OTGhVdmQ4bGVFYUJzdS9ac3RjTk94Y3ZGL1ZQNXZtVnk5eWR1TXlpbmphNU16TU5lY0luWTV1dDB2ZDcrKzNkcFRGYlBLZWtaUC8yRytORmdhcGUzWkhuL3pXNWNQckhSdVh0VTYvdStaK1FVYlR2ZnF2eTJKQ1ZlVXB2WnpYdkttUDVZM0wzTnVVZ1VoS1JaWStTU3FTQ1ZEZ1BoUURZS3pnb2tPRlVja0FpUkVxT1VhaWFUeG9zcDV4NVdncnY4dHR4NUtmbFZOTlRQck9WZG9POHlVZDJwM2RxKytFZGpLM2RsMU84cVI3SGQ4L3pObFhucWlpWXpabjFPNUtsMUVWVGFacVNKMmxJMVpXTDlOMWJmcHNlZU9OYU1ZUURZWnN5bGE2THk2cUliYXlKS2Q3WjFzaGk4THhib3dkV1ZIQmtiZXJ5YlBUdGQyN1V6STYwYnFpaVNOOXQxN2xhallhYjM1a3YvL3RneEJrQUVBMWpWZXdZY2FuK3EycDlndzR0R1k1bEwzR2lEM1hPdTJ3a2JtbHFpckVYU1NlekZtU1NYSWtDNXdjRUJxVGtGRitwOXp2VExKRDVsT1NVMFEvRW9PRWM4aUF3cllJeDBBem9WYXBHdEt0c1lVcFJHaXozTVVOL2MzL3pWVlc1RnpMeGZLazFPMWFKU3Nnb0d0VVdHakZVNmJEMVdHT3cwNDdoVEZTSjA5TkQreUtlYXhMUnFVTjd0dS9SeWpEdjMvanUvNmNrdUNyUkwyeW9zSFMxcStuQWpraGhIdWNVZUJCckZBQU5qY0dhc1RNcWkxTzZrZnR6N0MxSkhOR1BoUU1hRTRwakVnaEJsUUw5MGo4TmtGQ1lCM1ZnVTJmcnNyUFU3NUdKNjhmSWVJOWphU25oTjI0VlhIdElWQU5BYUtVSmNQQlhUNk1tV21VWEV1RjUvL3RneEJFQUQ4VlBUK3dsRE9vRnJ1azlsSTMxdWF0Skdqa3NpMEY2SGpsMlNhcTZ1YTJ0ZUNYbUd2YjFhTGhVSlpKa3IvT3EzcEVPeVZxR29wNDJWWldISDBzdU9kTHBhVzQvcXUxVjRhbm1wZ3IrTVdCc294enpuVWtYT1M5RDdmUVlxOE5rMkZhMGVNNjJYdnY5ai82OTFkdlV2Qyt0a2hQUW1tbFloa0tTM25EQ1hCS3duNnhZS3kxNW9jZ2VEbkNDZy9Ga2xWWERYcTZUYWFYSVdHZDJ6RUxyMUtlN20xaVRNbWI5bElMNzM1ZGFaKzZOc2FUZXAwR3BUQ2tBbm9wR2wrdzl2dm5CRE1iSktSc3ZibEhFZDFrRXQ2QTRCTVZER0Roc0ZiTTRRZ1c0TlJNckk3V1lLdkpwVXhwWmU5V2xlNjNKcXBpUHRJazM1TlZoMXJRbVp1Ni8vL3RneEFrQUQ0bHpTK3dZYitud3NHazlndzMxMy9HZ3VkcFUrNlZwVWFmVjhNRm5sbEVRdDBGSlZLSWs0cFdYeTNnMm8rZlRVbm1heTk3eDVrNlgzQW1uYUdzMHpVY2RmK1lUNFVseG1DQXNXamRiWm81ejgyTXpscFhpV01wNmpJZW1oVWhrZFc2cnFYMnVwNTlGR0pLcXpHMElJRXVkTEJBZTZQN054cHIyNmk3bUgvMWFTZnNaTVlWVFJXRkl3VlhVaklOTThocUIyQjNJY2Q0OHFncVNOR00yVVRJanFKdWN5cTE4eVQwTllXWEZKZURtWTlpanpaVXZDTjR0TXlDQjh5UlBwcVdVTWo5bFFTd1RpRzdrODI0RE9tVFdrM3FWaWtYTXRGcXR6Y3FiV3FtbFRJdkttaEdXeU9VYzFZVDFqMUlRTDRVR3N2U3FlcnZLdXBsNy9uSEovL3R3eEFTQUVNVmpSK3c4eFNueU0raTloNHkxNktyVE95THdYaXFYZ0hobmFoWlVZbmp3Vnlib0FBc0NGbUptQTkxRmRMdTJ3Z2NKQ0Nkc1RUdzBvbVFUU0tJdlAwcnZoc0UwS3I0MlQ4ZVliNUxzZWdSbERHdEoxclBzcUVkbUlmVlhUdDJ6dHF1N2RyTXJXbEdJTE1lTnZKcTdFTW9xZGk0ZHQ5VTl1K084MW50OGczTllpTXYwQW1nVndhYXRTaUExWGRYdVRUZjZ0TjNXYTBFTEFCOVlRUE9BV20yd1ZhcVM0VlRRajFja0k3NVF6cTNVQ09Tb0tBenE0bWh3RWtWMmRvZ2FkRUpJNUdNUFZvVmthdVo3d3dheERMMzUweXA3WkNUV2h5VlJoT1JXSG1mZERwTnBQUS9qRzRFanFvNURxTFloNkZZakdCVE9wSDk1SlFqL25aNXpqa2tQUjJuTWxmdU8zVW5KdUt1WGY2NXR0N2xXUkVoQW5LZWpVcWlhcjlWMnpRL0JiUzRjcnRlaHEzRXBBU2NDSG9wT1cvLzdZTVFWQUJBUlowSHNHSEhwM2pMbmZZTU43WkMxYlVjZzJmU3FaMnZtelRJOU5qMk9MSkp3Ni9PTTJLejZ2Zm1GZHZnYjdzNHh6M3BtTXBtMTRPa2xoc0QySXlRM1dIVmN6SExPbXhaeHFobXlvU29aVE5EeU11WHh4RkR0UlhvYTNJU0xFR0RReFh4eEJKbUppcGxYK3JhU1UrVlFRVkxCeDI1U3pGbXRiSnE3alJDVzJiOGlHZ0VzRm85RWxla3N1SDZjWGo0dThuU1ZORFZBMG1xUDRNOG0xVE1ZWVE3R2FOcks0eDdRRVJxK1NzTW9QNnZxWTZOc1EwT2xrUzlGN1pGeFlzbWJ3NXhKNVVpU1ZlblNMV1hUdWNQTExyTERTWCtVM3Y1dUxtenllYXFxdTZpUC9yWmJ1d1c2U1N3OGFlTTZLU0k2UUlCTUFZcW1ORXFLWXlTcXEvLzdZTVFSQUJBMW9VSHNKR1hodENxbVBKUU52TEx2YVlsWVVzY1V3bWtHT2t6QXdJZzRZNjdEVldvSVNkQ0dHQmdKc3NERUtjSzRBYkdyUWhCSGdRWU9qa2p4dHJteW1jY2x6WUdocWpac3hBZ0p3Vzc1MjFYVkpzRGNndytTSGd6MVo2NUo3Nkh3aXpsOWptdWhEL3NiMndFV01DcXJzOE95L1hKdHQrUWFGVFhsOUltaUVNNHFDMEpnQVNDekN3dGE4dGExd2RjVkRXcXI3V1N1cS8vMnROZVNIcU16TXlxVlhPcXpOVlZWWmYrTXpLcFFDTmFGWm1QVlNyZnFVWS9abVl3RVRrekhTaklHTlZqWC8vZ1p0bVpxQWlXZGl3a2VkRW9pQm9POVlMSk1RVTFGTXk0NU9DNHlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXF2LzdFTVFSZzhBQUFmNEFBQUFnQUFBMGdBQUFCS3FxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxIik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3 ***!
  \*****************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQU5BQUFPWEFBWUdCZ1lHQmdZTVRFeE1URXhNVEZKU1VsSlNVbEpTVjVlWGw1ZVhsNXljbkp5Y25KeWNvZUhoNGVIaDRlSG01dWJtNXVibTdTMHRMUzB0TFMweE1URXhNVEV4TVRaMmRuWjJkblo2ZW5wNmVucDZlbjM5L2YzOS9mMzkvLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFVd1FRQUI0QUFBRGx6VHBuNWtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdHd4QUFBQUFBQi9oUUFBQ1Bmc0tvL09ZQUFlY0FBQUFBeEFBQUFBQUFBQUJEZG5BZ0VFWmlDZ0VJVG9ZTENBVUxwaUlHR2FYc1lmSnhwWWdpTVdtWVFjY0lNb1VFQVVEcVE0WThtbm1SNkxMNUZ1V0tSc3RPRDdEWWdBME9jeXVHeVliZkJJMVUwUlZUTGxkbXc0MEJSUjM1eGtJdFJZVnVLa0tjTWpBVVJvbWlSeXhNNlQ3ZUxxU2NrUkxneUkzcThBeStiN3FtZW1tUVNIaUszRTZrdFVWVWlXNWdVVE5tN1RNaGYySU9aSnNjYmQxcTZzN05IbmlDMG1KSlZWNDF5bGxHTXB4NVRWOExsRmFsRnp2SFJhTkQwcGdTR3J1N0ZubWRGVFpTS2hxVS9PZmpJck5hMWM3K3YvSzdXYU9sT3dTRzVkdkRHbCtWVitmOUw5bis4Ly8vLzVqOWFsRGFGNWg1NWN3QUFBQUFBQUJmZWxGd0tnaklnSFpMSXJ0U0ZnUm5JaERMeU0xQURoMFNobXU2ekxBaVl0blN0US8vN2NNUVdBZEhGV1ZQOXA0QXFpU3VvdWFlS2ZFUUkzclZwYVR2WEdJMk0xNjBoZXNyTlJRdjRXSjlYcmI1cmVtZFd4YTlZT3RZZjQzYmJWRnduamg5NGp4M0FyaWxzNno1bTlzM2VKdnlUdnM1a3BoN0cxRXZYWHBCejgwM25PODUxWC9IeGZQeG1MdlVHMnQvLy8vSC8vLy84aldUK3REcUFRK1dwSFFZWVdNTUJMek0rRGhibG9DRFJFU0lXZlg2eXhBa3BpK3MzRVg5cldvejlhTkg0ZUpKWXN6bkRnSjFyaFNvV3VHTlNYaUo1dVpqZkowaW5iSkF2VHZGZkE4ZUxXRG5YaE5jMGRWUFpvQ2RPdU1wai9kRW5EQ0ZvZHAyWjNDbTFkcFdaSCs5bm90b0NCcXVvRGFybTJhTS9ldVN1VGFtK3hMQWppZ3o3Z1lraDZhcXVWQ2hYWVcwVXJzNWw2ZjlnZ29Zd1dIU0x0YkttaFVRenRXcVVBQUF3QUFFQUtlMGk4Rm1UMmZFaXhndG1JY00wSVJnRDF4aGduV3YvKzNERUQ0R1IvUVZGN09tS1lqeW82TDJrcmZ5TVBVZzBma3VFSmFaUTFtNUtiSHhDWTdFSXFNTG95MDY0eTI1WW5VSlJrQ29IMjc2M0JibUdNdW43YWJrM284Mnc2eWpQVVJtc1hEeUF0OVZwekgxN3VQYy9MekplQ2s0Tm1xZEdYYkhyejFJOFB4NXBCOGNUc2RkbjdNdXJUR0NBN3RDWXRxTXAvSHVZcnRiblRDVXRHUk13SUFQOVJvR0JWdWlTUTBvSUVrRVB3Y0VwbEZ6R2hpK3hrOUtJallwcHhzZ1RRRU04dzdOdGVMbFRqL0JESWxrcXFpYWFWa1JNa0FMRTNuR2JEQlhLeGFhOWIvRm5jV2x0TktBK3RBTXcxRzZ0R0lwWng1YUdUamMxU0V1NGZxTzBtSkpFUkkxenBzdzZ0Zk1zU000KzYrSFgreDFXbFo1VlZ1ak5Pbm82SVNTQ29xK3A1aDdLaFNrUnBjTXFlb1VnQVRBQUFnQS80WVZNQ2tBR0pGQW90d2w0aTY5cU5wZkZyWVZvTVBrY2JmK0cvL3RneEJJQUVJRXJSZTBaY2FJQ0lXaTlveTRjS2VubHNFNHhRRW1VRDVPOCthcHVwZXFOYnIxQkQ5Tk56b0h4WlJoUnNiK1h2cTJMZzYwUTlsd0tEYW1iUGI3RVl0dS9TVk1VWmJQTHFuM09YUWQyNm90aS81c2ZYZC93K1kvNnFUMFFPS01DQUVhZGswaUorL1JGaFp1bzhRZU1lN1dRQUVRQ0FnRlAyRmdFcVk4VUZaRW5CaFl0OHdZdjZ6ZG5zNFlaakhJbEhLYVV3TFM2dFl4d3dJTW5JVHRUdXp2TGJFekQ2RzAxL2M1dGtMdzN1WGYwNkltRmFYWVVLb2tFU210anIrWW1yaVVoUlFIY2VjZTIwMWUvVmlqVmtMMWNPL2lpdUN0b1Z3clVXQ2dYQ0l1QVRoR3dlUExKQ3NqNVZ2bW5wS0dGYUpoU0EwSUVBd0MvbGgwQ1VOaDEvL3RneEFlQUR5MHRRZXl4RE9IdUlXZzlsS0djN0ZCQ1VEUUF1RzZZd0pLbHFqT0VsY1VQWHhLUFQrL1ZsYWNCMTdybFJtVXJ5NUl6MVJzY29COS9yZ3dTQ0dheHR6M2ZGZFhuTEFvUFFReWdpUVJqWnYrNW1LOGcwZUg4VHdzRFBkR1JSV1hXWU9IVjhhbk44eDhKZjZhekE0UGhlYmUweUJoWC83U3VqU3RXNkVCS0pNbUJLL1ZIZExMZ1ZzVFVaK1JFckROYlgrd1JqUkxERkpzUWxpVUUwWk10dGNxTUlvbE9NVkJZOXJkbGtjY2p3RGMycW1lMm9HdVRSeDF2L00vNDI1c3R3OUZNR3dqRWlsdzJoTjNBK1VBWUtRc3JhV25DL0xHUTZtekpkK293cWtQNWQ0c0RpaUpFT1lkUEFNR2hIcisybTI2aGFDSnB0MkVDWXhpTUNWL2IvL3RneEFVQUQwRUpRZXdsRFNIU29PZzloaUdjUk9oZDVGZ3dsRVRFK0N3QzQwTkg5ZVlqNVl2Q0hreGtjVVpicTNuVTl4VWNRV3NuVXdxalcyVnlTakh1dm1RYkhtTVEyZC9OY2ZFTTAyV0VZTFJoMHFtek0wdXBhbmlZYXR4eEhIOHdpbXJVU0tpY2pqcWhJU2o3MHVQUERZRUFMNDRQRjNpNENGLzVjWEtaNThnaUhFbTRNUUpESkkwcDc2b3k1U3dGZ0V2cUNLR2lXYTdZVmNPQ1NSZXpSZVlQVTI3MXZvdEU4YnY3eXcxOXpZNlM1cXBVU0NDdjB1VWN3cWE1Ri9mLzF6dzFsallCdzRxTEdjVERadkZIdWd3ZmFiKzFmTkloeWMyNGhEN3A5S0dFaDhIUnpBNkhTQkdta0tnWVR2bzdFbEI2dnJwZlJWdTZZZ05sTm81U1grRncvL3RneEFXQUQzR1RRZXdZVWVIbk0yaDlnd3A4NlpqR05Ra2hXeDQyVlBzM3F3cnBDSUVIMHNHVkwwaWxjaDYyT09RTkxKd3pKRTlPUTcvSjlmREEvLzJlVUtBMEZ5WXJJLy9mUDMzdmt5V2dMQU5mcnpKbkdQWiswT09aZ3Q0aGRuaXgwSXJpRER0eWxVdnFtcnBKUldsMWFkREt0MlAybGF2LzBlaU16a2RYWllnSU1yVzd4MEZaYzlIcGJ2M1dneGpobkMyeWFSbEtKVnJvZkxPMnNIVXhodkdwWWh6R1didVNtbk9mZXhaSE9oa1ZIdlczNDRxcyt0eDdYN1FGL3ZuNy9JN1ZmbVhUeElPdTlYTkZDRlppQis0VmlFVWJGZExmL0cyRG04RUxGd1NNVFlFWk90Vk4zUjNSQ3FTczA2RjZNZXF2di9UNzdWMVQ3Z21sVldtYmhpV0ovL3R3eEFLQUQ1VUhRZXdsRGVIMG8yZjloNkRsU1c1eTc1Mkd2c3BiK3JjVnRGQzB5SEIvbGVxWVV0UU9IRzVvZ3lXZ29WVVdRUnhlZmQydGFVYW1wT2JVMVhoWWt6bzBNcG9TSnl5c00rVitaMWh1K2JoU2dGeEFhM3lYNHRvN29ZVUpRNk9FQ0x1emIrcGtnUzA5eGFtMnYwbzQ4eXNpb2trQ25rcUhDVUNyZVBIRjl4Szl0S2I1TzYxNnhWT1JNNkpiYzdmOUZhWnNMd3V3MlJvUlZGS0ZjY1MwUHV0anJZbGN0TThaNzVCRnF2Q2p4V1hGcVlhT1lnb2RCTEVEYXlTb3ZONEhpTnJYLzlmck4xVkRRSWpCeFVuTFZzUFdlRkZsRXNySTZybStxanJGU3ptTE1WaGpjRk5JTllWWXZjNUJpQVlUY2x0OXgwbzB3NTFtZi9mN3pvbi9mdXNjNjJsSW0xWWtSRWt2c20yanUxMmVDV1ExRGdBNjdIeWNDYUdWRHE0cDFnWUxNdWI0dEVhWlVHbU9YNDUrTkM3cTMvLzdVTVFYZ0E2WSt6M25tRkhoeUI4bmZHZWdySFU5eHBua2VuMnd1SWFQM3hEdFI0NW9jL0pIejVOYkwzN2RrMlFjSUVDRkhNVkZYOE94ckRBTVhlOERHV0pDSmdOR0JXUVFISVlCNitIN2RjSlJLWGZqbnhRa2tIMFo0aENWMGEyK3k3VWVFcEdNYW9WV3kwTE5Ra3hlUWtLblZxNWM0VE5lb3FLaE94c1JGUTdFeU5lQjhyWTFrTnJPdllhRUpURG91ZVo2YzE0enpWdEhZcG9sbG5sRE9KVVRpZ0NaSmNrRkl2bGJUWHc4cjJnZktsaXcwZGcySlJDZ3EwUG03RW03ZTJsaTNtS25ybXBOVnlVbmFLYi8rMkRFQVlBTjdQYzc1NWtSSWJPZXB6eG5vT1E0aVcxdnl2MTNTTSt6dHhWSmR5MUlJaDVnUTFhZkowcnQ4czJaYWNzRVBIVmRVMnlrcnZNb3F5VzBGRFpmdWZBcENZdlY4NjhrRko2a1Nra1BkOVQvUExOU0VMZ3VFWWNFMUR0dDUrWXpYbmVzUVV3NkcyTk9uRFpFZU9CVzYxNXg0Zk5SYlgzNmJsb1NiTjFrN1BNUFVRMzMrbDFrU3YwNGxKRUM2aVpuS1RFL25wZms3bHVTc2FhOGFVTklQTVVYR0dXU3FPZ2dpS0ZubktETUNuYkRiU3oyY1pFWHhWSVlQRzdyQjVxakxHMDZRMTFLa3hiR0IyTEFxRVlJK1R4amN4ZDkrekxhWTBYbURVc0ZGS1NMU1EyWDd2LytYdHVrRlFWV2RYZUhYYmV5eU1zZWxhcFF5VThvU2pOby9FTC8rMURFQ3dBTStPc3o0YjBGWVpXWVpqd1htS1FSSllGV3RPbk5zT3R6NHg4SG1tanNjWVRKUmNET0Z5MEQza1ZwWUlHV3h1OTl0RUQ3L2w1dXJpeWUwWlZkOW14Q3R4Z1lseDRlclVKM2N6TkZEOFB2WXNKclcyODkwNlJmc1QvdXBWVUx6MDhnQVZXWjFlWC92MmtqYnc2dHlxMlBrK1RwTGxSVjM1NW95RzAxRXhZbEU1QXhsSFR4TEp5ZjNrc3YxOStmbzR1WlZWYmxUdG5OaWRvNVVOaEVHUDNGYjdvK0RHeFFza0FnY0pCaGs0RHhBdUFuTFdockVJVHlEVklYM1BWKysvV1pRRlRicEFrcUFEbGwvL3RBeEFHQUMvaTlLYUNsQnVEM0ZTVDBBSXpjdXV2OWpTTC9HZ0tCWWpNTnpjZUt0SkwweWtWQnJqVElHdFBCS21xMFFLZ2VJZ3JCaExpaTVSMTdiVkR4dFNUOWpHMEZ4VllYMHVGbFRUVFJwWllUV0FNbW9lRUZxTE9DQjlYTnNkVW5wWGVyLzc5STFrRnk1QjEzVHE1OEFCdUM3YmYySUVUVFJmU1pyOTdxcXBnMExzREg3UUtKb0RxdXdVcFdJVjZxc0pvZTFTLytGSVZEU3p6cVNIVVJ3ci8vMm12Ui8vL0ZXYjJmV1JwTVFVMUZNeTcvK3hERUF3UEFBQUgrQUFBQUlBQUFOSUFBQUFRNU9DNHlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFnPT0iKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3 ***!
  \**************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91VXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUpBQUFLZ0FBYUdob2FHaG9hR2hvYUdqbzZPam82T2pvNk9qbzZXbHBhV2xwYVdscGFXbHA2ZW5wNmVucDZlbnA2ZXBXVmxaV1ZsWldWbFpXVnRiVzF0YlcxdGJXMXRiWFEwTkRRME5EUTBORFEwUFgxOWZYMTlmWDE5ZlgxLy8vLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFVUWdRQUI0QUFBQ29DYk5yL0tBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEvL3RreEFBQUFZZ0JmblFBQUNNNkx5MC9OUEFBQUFIQUEvLy8vLy80UC9XSDUyZ0VDaXpGaVNoQkRHcTAvSFl0WGpKQ1RUclRrampCc3kxSUVDSlVCRXNZUkQxNHFraDVVbmcxTlZoQUxRQ2hjbmNScGljRmdFdVdFTnc2QlppNG5tbUI2Z0NKUHF0U3dYT2lJWU5KQmNLOHRqQWg5OWsrcXBYc1d6NXlzWHFHc0o1RElhMitKVW5WS3VZR2ZBTkY4azJublNlVWE4Tm5uaE0xVW1YVkJJOC9GY2xjeFVMWm9hbkp1K2xjWU1Cc2pIcml1clhabnJlY0pJRG1iV0pSSytDY3FpSmJXMEx5c3NHRlpKUnMrdjArcmRyd3BEZ1dHZnhkeDQ2NGU1eHFGYTN4YXY5TDRyWFB4WFA3YkZaeC8vdDB4QUFBRHJGM1pmMkVBQ29ITHlxOWw2RTkvWkFBVTBJc1VHVUp4b1FFQ24rUEE0SVNTcHBRQlFKT2Q2MUtaYlM2M0VUYUpHZ0VPT1MxY2tRUWFpK2NQQWF0Zkl5emJkZTVxR1g0SHRxT3FUVnFHWm5KYzFhL2lTVHJHWFhxdFVrcnlxckRmb21wSTViajVWVm1xLy8vL3JiNHFoRll6UzQrTFZkVW0rWVQvNG0rMmI5UktReUptdjVBQlNRUVpJQUplYlBjVldNZVF3eUZ5M3hFS0llU2Fza3RESjNQWEtJU3IyV0NUZlVIS2xudlZPdzNzU09jcHdyZExicmU0UlhWYktxalNlTVBwNTU1Lzk3S2xZWjlXRVlTMUlrNWhTWlE4ZDlSeEhyTFZQbTFNeVdNUGtCZ2xLSDN4Ly9IYzFaM0JRMmlsaWVxL2tidzl1bFJOYjFjMTFCNjFjMUljc05Ua05XK3BRS2hZQkFTUktuWHMrNWR3QW5zQUVZNy8vdDB4QW1BRUNsMVUreXhDU29DTHFxOWhpRmRLQzg0RTlZZ0FkRUVZQWdnNWhXTnorMmg1UExBeVZWL3hEQW81WXJxd3FLOFFxRldlZExsaFNlaHlLUDA4YktyVDJNaGR6Z2xNcUs0cG9rZXpUWC8zY1UvN2lwc0s4QjZlRWRDaFVvcTMvZlZjRjErT0tES2lBZExjVlBmZWE2dGxRVmQzRndlblkxb2pNRklFRUxyZWdGZFdNMDAyazczbXJzQVZ2TkFqWEZsaU5hWXBOMWIwTHVWZ2Y1b3pLTXR0QVBhYWNlc1hpdzVxQ2NJZ28rdE1VTFJjZjdJdFRKdXBJY0tqck0xTWk1SWlDM1NkU2hLeU5XT0J3d2ZEUkUzLzFGd28vNXFaWkJnZ2xCTGxUTjNOVjljUkdNSHZOVWVPWVJSS3AxejY2UEJManRhTnVLaSt1cG4rT0QyS3NtTTF3SmloSHF6aUp2aFdVdmdhQWxiNVlRcUdLQzlSR25TR0xDZS8vdDB4QTRBRVVWMVQrdzlDZW9BSjZuOWxCcTAxMFdoaXFURU1UQzBSTEhRSXloS0ZybE9SWXptVUpQNHVOZlRYZzAyVkd5VVdrdU9ySHRNZ0pDY3dya1Z5eHB3aGhFaHRYMWg2cWxDTXR0ZXpIeGNmLy9zaS9PWEtQQXNjT0hXazNyLy9NUlpNanBrUktBOHdQbEp1NnByYXFIUkN3UHRXdi9wNWZHWHhCZ3RoSlhHZFlISnFoeFZTS2J3cXM5YitGM3l6aGFzRU1FTUV0Wmx5R1dHTzllN0RNSFpTNnd5UHRlUFB0bk1Zd2F5Q3cwUHp1L2dvVVYyWE9sNlI1bHIxSmRocGhONStNS2F1Smw0a2NNRHNJK2tnVktNdExtdnIrK1dIK1FkRVYweFJnT3BGSTRnMVZuKzVqOWpVRWVzR09zSUNpWFpGN3c5RXVvNjVmS3FEbVZoVlNxTTF3WnhZeWJ6amN2Zyt3NzdPQzg0QVZEWVVrUzBWR3JlbzJKVC8vdGt4QTRBRDFrblRld3hDK0hWSmltOWhpRjBRT2Z4ZUxKWFpoRXkydXdyUG1pbitad294NVBkQnJEOVlJK1JzYVJYUTB6bXp4NTk3Y3JaZzRoV0lsK0I3TllyVVgwNndkZXZQODdYTWVWUXd1VFZJc0FncUtGRXkxelhQTSthdmV4QThPUWFCaEJGYmFXRXdvL1c4bEdEanlvenFBMVNEUDJTYVQrUllWMnNMbkpnS0JpS0RCaWFiVU13WXVJZGJEa0c2eFB3NHYzUDNYMmF1RTlnNmZGQUN2bnArbkV4dlRvaXZkRW9URnVLM0tiOFZacGc1Vmw0U1RoQVhMSFBkT1BkN3FXK1A0VjBuNHhxU1BRYmdjSTVsRGRML2ovYTU3cUR4Qm9lVmRtZ3FZT2dDa1gvUmdTTTF3VjJVam1yLy90MHhBT0FEN2t0U2V3bER5SGJxU2g5aDZGVXNlL2diMjY0UG92YXdNRkpZbzFMSGJaa3NXYldXMExvaVpwZlNLYXpQWFZhaXBjN0dnUkZtNFN4eENwa250ZHVaR2RRdytJc1EyUTh1SWlKREJZdWE1RlZhcU1ra3lhV2xoZW9sWWovUzUwOWJKRlI4RWxEeXdoVVk0dDMzYmI4d2RXT3l4c2hnUkI0d3lmTEdtQXNUSmQ4V0ZkNXhqV25JQjFXUkZPT3hUMlJTSm5VeWcwamV3Z1ZPUVpiMUNKZ1pTUDFsa1hRMDltODVZT2t3aEk1TGszZUJJQ2xYK3JVaXU2SktRYmNNU1dHNzRnVFRVcXR5SzRvRVExYm00emIyRUo2SlBXU2Ezci8vVHRQeGg4NklTTUZqQTlzeUtqV3Z0YjJOZzdqb1ZEZ1QxSnJrcnhIWW5nNG12L2JSVm01Qm9kalhTUGEvaTNqU1FPMkp6cVF4akhGcE1XRkx3WkdVWjZYLy90a3hBNkFEdzB2UmV3eEs2bTZKR2g4OUJwVjMwbnQ0V200cktueDh0RUxNczJQUWUvT2JYM2IzTXVjUDdoVW43ZnBCaXlOcmM1R2dWS3NTYllibGlXeWV1SmFZVHEyV1VjOTkzL244NTRXVnZwRDJtVkFxcXZpRWlJbW9aVlJoTzYrKzQ3ZDczelNmRk9tNzJZUE0yczNZR3l3cFYyNjNjWGp4SE11Z2o0TDB1U0VFUVFhSVhvLzkxd3IxUS9XSm1SbXdyRXhJb0xxOE9EbC94b3JMMTBmbklrS0xHTTU5QlZLSjNIOWt5d1ltZEtEV2N5UjJJaXRiZWh0K2NMcXFmK0gvejd3SjRWcWNrSmtqQmtzMlBXdmpmbCsrMzV5Tm01SEw3Z3Z6a2lsSjZ5R1QrMjdmanVHRlZwY2lpQWcvL3VFeEFpQURyMHRRL1dGZ0NLL0htaS9PWUpBRUtNVXNTaGFZOHpzdk93Vm1DZ0E0TVNLVHdkSGlSVFQwWkJHYXFkRXNYbmVUakZGRnpzUnpTZmE2ZEpSTzB5dGFLWmR5ZnRCZUphZW44Z2xXR3gyNVN0OXJOdUxmYy92ODZldlNpNFYxMURZZm5HaXpJZHVkWFh2bXBiVlhUT2JXSTNBSnRLdFlzMFJCczZRN1M5LzI4M2I3V0FseUV1VURBZ1dWQkk4SVNBaGVZU21Sb0VKR0RRNFh0WkNBQU1ZZEZaaU1BSWFGbXJqUUE0NFFlSk1TWlJNUXNDSEU0SnNRMjdVcmdsdExLbUkyeHNiazFZZGpkU2FobHM3N3QxZGU2NTBrak14RDAwNGpZcEZLSlRsRTQ0NDBNV1hralVkbFYyTTQyTVlsYTNoY3MxNGc3ZFJ4NmFsb01hMXF0YTUvNDVmdmw3RERWNnIzZFd0ZHMxYk5iRzIxR3N1UU9JQXdHQ29WQUozLzlTaHc5WTBaUUEzS0J0djlnQUJ3YVVEWDFncXNGWGVXQm9ZRFQvZ3FzRlZURUZOUlRNdU9UZ3VNbFZWLy9zVXhCTUR3ekFES2J3QUFDQUFBRFNBQUFBRVZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYiKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/12-triangle.mp3":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/12-triangle.mp3 ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "b2ad26415638f722a502.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/13-bongo.mp3":
/*!************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/13-bongo.mp3 ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQVNBQUFVbFFBUUVCQVFFQ0VoSVNFaElURXhNVEV4UHo4L1B6OC9UMDlQVDA5ZFhWMWRYVjFyYTJ0cmEzdDdlM3Q3ZTRtSmlZbUpsNWVYbDVlWHA2ZW5wNmVudGJXMXRiWER3OFBEdzhQUjBkSFIwZUhoNGVIaDRlL3Y3Ky92K3ZyNit2cjYvLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFiWlFRQUI0QUFBRkpXcytUMjFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdHd4QUFBQVR3Qmo5UUFBQ1FidEdrZk81QUFBQUFBQVBBQUFBRC8xZ1FBQUFDQVlqdStPa0FwbUhCMkF3QkRnQnBSR09CcE9meGxzRUJnaUFKaU1DNWdLRlJoaUVaZ01FSUJBZFRkWjVnR0FCTUJnc0dMVWlZaGdZaFNSQU1sZ0RYbUNvYnZhd0RMVkJsMHVPMmMxQ2h3Rk5BaERSeVVTck56YWJMWXRiV3laQkl5VTBSWXJEWFZlcVBRREk3a2R4dkY4a09Tb2s3MUJpOE1DMWJNWnBacWR1MXRVMkRrRjVXY05DVk12dE1CL3NhV1UvaldsMVNZcjVUR2FrVSswMUUrVlhKcU1RUnpJZ0pxL1dyYm1xMjQ5SUlid3I0NFRkTFRvR3hKVzJGTHRreVBMTW5iWjBqYlppTDh5M2xTclZwZGQxZDcrN21QYWVsNG40NFRMQzhhR3oyT0hGcHFrZG14VE4xWXJWNVRVTlhtOGVaZi84Ly94N24vOC8vLy8rWFNyZTZab0FBQUFBQUlUYjRDSlNRMENtQW5FYytQNlAvN2NNUUpnQktSZzB1OXhZQWlEQ2hwTmNNT1hab09FaXYxQmpFb1VHaWV6dUlSV1NKektncW5CS0lFQ28wZ0VwQWpFNFB4ZW1PMGdTU2dTbFg2UFVHMVFTajVOU1RKcm5tcDI1cDBPdVBtdVhkZkVPdmFsbmwycTExc3RTR3RiRk10cVZ0MlM2Nzk3R3hWUHRaanJpYTV0dGNOcmRhTld6MkpQWmM4VFZ0WmN4M01XMkxvN0I1OHc3bTVpR080aUoxelFIc2FlcXdBQVlBQkJhYnQ2Ylppa0ZKSUdXd01EeWtHQ1loSENyVWRCSVFDdysyL2E3bzNta3hUV1oyUnlXS1hZeHdJRFVVUVlucGk4OFZ1eXFWRVZ3bkNjRnNtb01aMWROVUlheTVHR2xNZ3JRbDFpdVprUUw4ZjVsS2NiSm56ZTVDak1VTElYQkd4SnpQMVFsTDEwaFVzSG1VZ0kvc255ZnNFVGRMdVgwLzlyTCtBNXhreFZZQUFBbkFBQkpOMTNjek9EaENIbE16QkRoT1FIWlBrd1dIUjRTd0NZaUQvKzNERUQ0QVIrVXRIN2lUTzZnV2txUFd4bHUySVhCQ056VEdCd1c5YlZyaGhOWXFZUEllaVo3WndiUG0wMFRFbmZyOTRhNVg1cndSUVNRTitWSlhWRFBMc3hDMm1xaE1tUlBrRENabzU2TnJUd1haOXQybk8zOS9jbnZFWVRXMUFTSHQ4ZW43Njdhay9kbWF5OEkrYkwzTnhHbStzeTlWc3F2MG1OMXUyaFAvYTUzNk5iNEFBZ0pEUWFidDVoSW1ZSUZLcm1hRHh2c3Vpb1lNWDREQUNBUTlGaDZXQXQ3QXpaWkRVc1N2SGNzMStOMjNsOG9xelYySnlyME5pUUNZQW5yZ21wS0dTQjRyTGd4NUJ5MGlaU0NxU3ZJTWZGSXBhRStnRUhRVW5kOCtLeTN3b1VDM1pTT1A3YmxPanQwRlhYdHg0Q004WC9HRFV2cjJTczV4dkdxZU9nakdhaXlyQU1HeGdoS095N21PeWxhU2hoOUJ2ZkNpQUVDRTB1Y0tFNkJyVFdMeTJ5a3F5Mmtzdjlac3NjUXNwZHlUQ2g4VjkvL3RneEJpQUVQRkJSNnhvd2VvS0h5ajFzdzUxVHhvOG9IUzRVbTZidVU1R2Vja0lKbXNsOGpXa3M4cXBWbHZUS3NGQ2taS2JHeVZFMnIxc1g1M1pySit4VFA2dEtENTBPMmZmclUzazZ0cG5qV2tqRzAxOTRhdWFmTS9JdVNjdFU5ZVYzT3NOaE5UdmhWSU93VTgyU0lySzV1WUtGbGdXUWttU2d4d1NLSEJLQklhQ2l3RkRBRUpCTEFtd3UvTXdUUDdtOHJzcnV4ZkNrOVp3aUVGRWsrSVJ1RkdPQXR3Mk9SSW5VMGwxaGxyczg1bnhaek1VaXNYTzZuaHBFMUVmNDJyUjgyWks1Y3RJdmVOWkQ2ZVdIQ2pqQlc3ZWtMZDM2WUUwRi9xaXI5UFQ5TXVnKy8ycDUrVysvK2hMNW9BQUJGTWdBSlIyYjhTSVREeHB3UlZkRFNkbWdnSUovL3R3eEF1QUVQbERSZTJsRGVJTkgrajlveUkxcGN3OFNKVXVzNHJoU3NaV2tYSW1nK2RSeVk2ZjFvZUY0clQxVGJ5TnJTMjEzSkxHcHl1NVN0SkRLYlpWU3I4YktzZ3lVbnZVZ1VHdkdmZHBGYzRtRytxTWRkTGswdkd6VlVHQ0NBc0lVRFRmcmlvWnF0bGpucFdMaUpsVmdzeURNUUFZcUlBNDFmTElFdHR6R0U0MDZKNEFCTlhNeEJLUzNmOHdZb0ZKV1JFenc4Q3BFa0ZBaUlTRFFwYWtPRFMxVzUxcU9QMC9aTFh5MldFRlQ1bDlORkpDeWNQV2VXeXhjTnNKR0hUU2VQMzZIazI0bExUdFdyU2JJa1pScEtGR1pwbFVxUHgxaEtEUXBSemN0R202VnhGMHlraDhJUXRtcm1IQ0grQmkyaUtqN011WkdQaDh4TS92OTVpL25vbGUvRy84Sk9BQVpraUZKZGYrQjJhcW9HRFhIVG51K0tIV3V2Q1JFMFNvMitHT21Sc1hxaXhhRm9tSUV2c1pRTTdNbC9tUk1mLzdZTVFZQUJCQlYwV29hTUdxR0Nyb3ZhU04vZVRpUk41TUNxUVpYN1JkOTJlb2w4Tm5URWtWZnU1eTd4N3dwY1BqRUlwTmtkUmZ0V2YzOCtKWGI1Z2tObENDYmQ4OVo5ejU3YmMveDJaOWl2V00rLzkyejAzUUpwYk9VRWxXYS83SFUrMVlidkYwQkRlSFFDVmx1Mi9ERENnNllScnhvSXZMOUVBVURFMGpBS01TVUx5S3pQN1R2Nm4xaVhjT2xlUy9JeWo2Yk1UanNGWExSWmdzOElvcHR6eHJwUnlHNVV1L1dKU2QwMGttMEw3blBGVjRHZENkVkRnVnd0WDNFckxYbXlCbFkxT0d5OXFoMHAvNWZDcEY3cFVaU1RxeW1VSXlNd1ZSb21nbndQelBINWMxdWVLWG8vWjExb01DQW9WREF5YWJiOE9LZ1FFZ0xNTGhPTkZRb2FHaVhQLzdZTVFNQUJBaFAwWHRKRytxQUNjb3ZhU043QVJFSVlMTDJVTkJ1cndoNjlvWUhTNXdXVXIxK3BRZlVaZmhYeGc2ZFliam5hZTUwMTRzdWxhYmxZbEg5Q0xoRm9lYjB4Z0VaR0orS3o2ckRJOEswWVJWZ1lxVEtxdmd5ck15ZjVyNVpjTWp6MUN3NUZSZUJhM3RGSitPOFdmTVNibDdUYnpYMEVuZERZVURSNE0wTldhZi84ZWVqSUlkRm5hVEhsQlBtWUpBdUl2T0JnS3hFUDFCMzhqajRYdE1vSXBoNE42MDFPRk5va1VFcGV4eXZVK2trdGVPWlE5WGlvZkJZQ0pScmI1SlNlaFM4cUFDZ3QyYlVIU2htb3BTTUxjeUR5VjFZeFJwM0I1aW1RcDVyRDJxciswNXNQQ3Zna2hNeWFFemJ1eGdSR1BTS29pNWVSSExZd0kwbFVNcEx2LzdjTVFEZ0JBVS8wWHRKRzlxQ1I3b1BhWVpsZC8vMEJpcEc1R2piSFNHWFFTR1ZhOVk4bVUyWkF2K1J6cmRvUm5nbEhvekptcDNHTjUwSXdKVCtwMy9rVm9JWHFJc0dtbWtvQ2o0d3BUT2xDbWJJQWd5SDlZNkFqRks0eHVoRzVoaUZDT3ZEREFuSVdnVVBWUSswakIwU0ZkQjRXeGMrTHFySTQ3ODZNbm9uK0VtdWQvLyt2eHZvenBLMU0rTHVCckRJYWtiUHR0c1pvR0ZTd3pMRUpFek1Ga3hVU29Hb2NnQ0FlRU9Cc1VsdEVxRmtkbENyQ0NRakJUTFpFcU9TT3ZiWm42akQwaTlva09UbUdRVGcxRlNxK0krcWZBMFVPMGlmNHA1ek5TVDc5MjE1VXk4M2J5MjA4N3MyUnIzclp5azBCT05sTE5QRzF4SFJlcGlkZ0VFUkp6WVRuN24xbGI1VnYxdTc1K1VzMk1HUjRSRU5TLy8vWVdRd0U0UUVobUJuVW9nU3BOcDdCaUFIRDFEUVNrZ2w4ZE1ZTUVYeUFMLysyREVGQUFRVVJkQjdUREs2aGtqNTcya21hM0MwOU40RWpBWkY5TjMzazh3Z2FtaWRCRkhIQ0pUaDB5MGNUT3FHMDQyMFlrT3hESG8zYnlXcjV2N0Zsekh0OXhNQ3d0b240MnR5NnA4OEx1MzNjelgrZVRzQVovWE4ydDdnTG56WS9wKzlUMG45YzQ3UCt4ZUZjRzNZRUJZVTBKZWFlNjBEVUMrZ0NEQWFRYWlxb1Nsa29YQWExVXlHakxEUmQ2d2RBbUNXc25VUW9IMEczbE1ERCtpSDJqUnJYRkYyQkNldk1LTEdySG00K3dmWjkwaTF0NXgrMnRPZnZJb2lhMW1UNzI0cFh6TSs3ZVN6dm1iajYxdEpVclBTYjd2dTZLMmQydGJEMENYdFdwY2dyWThQdTJOVW0vVWlVUU5YdHYzOUdFVksyVlVCbGEwVWpjbXUrMktCRVlYbUkzLysyREVCNEFRQVUwLzdTUnU2Zm9sWjMya0RkMHh4WERlR0tCRkNwTjhPUmtRMXI2bGtDTTZhck4rMVo5QlVsRE1LbDBRK09OTU44T1V2ckdWR053QnRBOFcwQkVQb1laU2RsT05zalhVSU9zTXhPa0tGRkpoeUFBRWlPdFhGN21jamVlTGhDRGxVNGtTazNwa2J4S3RsT0VkT1N1WjBKTzJhUmQvNWRUKzJ2ckhEYUptL0VNRFI2TkNGUjIvWFVtRXV4RnpPRUQxTlVnU0ZBMEJQUXhaQW1KTEZZKzF1YmVHSC9LUEZoZWl4Ui92UU1TZGo2VjZqRVlndHBrYzJkV3RDQldESDdQb3BKR0U1b3hDaElyR0NvY1JVbFlCc2RDSVlJdzRvZElJVlVkSWxtdDBRcmtTNm1STWFscEdESUxJMHpRemI4bDNyYi80c3hUTHpXUEJreXdPcWdYLyszREVBQUFRb1RzNzdTUnZhZk1wWi8ya2pmVlVCamJGUXhWdjN0dEVrTGxMME5hTlBHR2drU0hsRDFMWUJBRXZsb0RBTlZpc0ZDMzA5SjdCREZaRWYvMmVpYU0wcWl0N2pOdCtvRnNaSm50ZUprTW96S0FCUUZsSGd0WXlPQmExM2RnZ1lRREVHNkNuMElpK0UzN21wSDdoN2xLcTBxUkZCdElaQTBQWE8xR2ZtaHhiME1pYVlVUVRSOUxKT1VYNDFoOTEzMFE2OTBiVlZRUTRwMlU1dC90dGlZVGVVck5vWkZ3azZJaUxlUk5KRmVFSDFYVmpEb09WVWlxSlV5VnRHaTJVcjRzRnJaZlM5d2tuT2JFMGFDYmxVWCs3L2xOaStLclhhRG5wYWJBM01oUk8wcG5xaGZtYlJXNGVaTWhKRXZTVUpjMkx1cGJrL0pDL0o2VTY0SXI4ektxcVlvL1FtdmRSejJuOWxkZ2w5MnJvYkVsV0JrYTFkQ212MzIyRmlKZTVSNDFIaVBJd2FHMmRSVlp5c01PdlJDV3R3VmY1Ly90Z3hCRUFEdnpQUCt5WWI2bnNwR2c5bEkxZHFZWmpVQ1lUbS9vSEZuRW93aHRmM3BDSklJT2F4eU9WdTZrYnk2MVZVcFpnaEpPV2prSU1XRzBpbGM5NmxJd09CZDF5ek4vRFpjd3RVNEc3K1UvS0RrdFoxSCtzdHJEQ3RaaDNQYit3MnplM2I5bDlvZERPVU10dERMTHYvL3NQQUxBcE9IVjZlV1VCanFZMVV5Z01HVlBZRTRDQ000REhHZzV4cE1pZWhhTGpnSW9PTk4wSTU3Q0JLa0s0bzRrUlRZamtIVVppS0cwY0xIUEJHMzlNdVN3TVplTHJzL1hSalU2WlFnYUdSZE5VRktUa2RxTUtNU21kR3BuTnphY2dGeDlmbFIzL1BiOS9QRVV1aStOOWN0MVhCbUtXZFVWdXYrdURnc3BkTTZKSUtwM21LdmdVNFVVSlVjNisxeUZ3Ly90Z3hBK0FENjJqUGUxZ1pXSUhLV2I5b3c1OHd6eXBxYWxGRGtRTkFvMFlpREFQUENEUXM2OVJoYlFPTXp3dFFSdWtaZlhza3RwRzJFSTZvVi9MSlRPTUhDaHdoUkY0N0Qwb09RVU1MbnMyV1psYzl1YktzWU5sMXo2ZHo3bXk5NTUrYUtoZVJyd2xLSko1OWhROGMwbVJRR2lnaHRLb2dtenpXU0V4RnNhQzV6RnBnWFRmR0RPTEVjb0JEUzN6RVhnZCs0ejVxRlRDTld1NTAxK2R4KzBBYUtjZm5CakY3UlpOY0lRaG00WFRrME1Zd3hPMW41azV1dHNVL2hpbk1wSTFrdGZPek9vaE9aL3JzQjFOa1YrMnlmbTEzM01NcGNMV2V4NTJ0NiszOHVTSjlETkJCUUcrc0xvSHZaV3hKTmg2a1VVcVFnVTNsbVZIZDl2YlVtSUpqQXpZLy90Z3hBZUFEOEdUTyt3d2JPbnhLcWQ5a3c0MTVUZFV0T1RCWG1rV3pCdVROcXMrK0ZOMlZhRHE4NSswVGZXV1lDd2t6WXM2ZENvNkpRMEREL3FhcUxpZ1E0aVF3WmJrRmQzWmpablo2Um1SSGM2UkNnb0d5a1JHNENHWUtZTVlCZWNqRWN5bnRrVy9rbjNTZXA1ZVI4WTdDcTVjL1B5aCtYVCtlNW1SVmpNTW9nRTZad1kxcG9SWmQvOWJSSmlhQzdKbnlteU5Bd01KYUM3S2VhL2FzVWtFU2JtOXQrUHpHcGpqRFNyUDdjU09Qdk5qNXJVNzRXS1BTZzJCVHhXa3VadGVyNVYvdkhNVG84dEtHb21oOUdNSGFaTENiM0JOcXd3TXhTcjNJbTNJKy81czJoMk45NTVrUk1mcFcvbjZrZEliRHYvMnZwS2Vtc1ZkMklxeStTcEhCRldXLy90d3hBSUFEMVU3Tyt3a2IybjRwV2I5b3c1dGRWdSsvMnRYQkxRU01GNUd5eG9sRFRSaEloS0NXczlieWRaN2U5TXdlU1FEUzdNRlc2V0VpN1NCZDhydndnbmZwY3hGUmZHLzVRd1Z3VkpFZFlIVWNuM05tZGZuaU9vaUN3WW8wRnRmTnB4RE9vT0pJdmRzdFRLbTFPSS9NcWo2RWRLNWNpamo4ZjBwaHNKZjl6UFdET1U4bzI1alh6ckJ1a1NzS3QxL3RrZ09HdytIRlRDaEFsdW1zWVFpVEo1MGVJRnFXRlFTNU1VZ0cvOUxUMVppby85ckNsSjdDTnFoSlpXNjlRVzZUN0hwRm1ja1RVMXZpWk81eVlNemVkblpWaUY5TjhpNFpRcEVoSVowdCtrQ2JQcXd2d2Z6T0dWeTNmZFNTTjU0TkRwRUxlYnQ5S2tMOCsyNmFiSytlSHo1Z2h4eDdwb1dCR0tIWmp1djJzamJOYkRERVZEQXFHUkVKV3BSMU9kdjg2ak42d09ndk5VYmZSZ2dJNVY4aFRZYXhsbWRHZi83WU1RWGdBODFEelhzSkcwaUFxUG1kWlloYmVrU2dSVW1Oa2FtQ0lOZ2dOSEN3Y2w0S0RFNFNKUUtuU1pBanhUamxzUzVGdUNjZEhDTUoxY2FWVGJKYkgrbG5xWU5JU0xnVXNFUmhBZmhFZUFUYVVoNXUvblNEYjFrRXZTc2NxNi8vNC9idnBHMXFYMTlHN2dBYVhFRWJ6T0xROE1FRFFYVXlOeXFoSFpkTVdGaUwyNDkzTVFpZUM1WWZRbHpYTTJqd3hEcEFpSkhUcnd3dWZBMk54emtNOWpFZ0xoN0JodERxWXVVRDJ5N09lbG1ZOUx2aVNEb3VtTnRIaU9rSWFKN1ZuYU8zZDFtRFU0NG94Qzd4Wmk3enVTZC84djd6RDcyRG15aE5mNXA2alFHZUdaa1M3L2FTUjZYTEZRek50QzVraFgwRU9JeUo3TVdkQllNRkFvTWNWMnpPLy83VU1RU0FBOTlFelhzcFFzcGJvZ212R3dNTFNmRUR2TzNoY1FDMVJzK2JGNXZVaVNXVXRIRkRhNFNrR3JDR1FRMFhrWEpraUlSeDB0clpFRnlzMGkzNzE2Mk5kclc5OGE2YnpqYWU4WnN0cDNsVVZDanBGb0hlcUpIQUtPVVovbmZmK0g1Tlg4Nmp5SjZCWGhNanRFeEN2Zi8vclFjREpYQVRacUcyamZ0Z1ZNemxsckRWaXRkZDBUTUtBcjRVQkVrek5Rb0tDaFFVK0tEQlJRYkN5ZndLQ1JXUVVGQ3NRVmdKZGlDaXNRVVYwRy8vaWxCcDJXUVYvOS96c3V1L2h3ci8vNXNUZitiR2t4QlRVVXpMam4vK3hERUE0UEFBQUdrQUFBQUlBQUFOSUFBQUFRNExqS3FxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFnPT0iKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/14-conga.mp3":
/*!************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/14-conga.mp3 ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQU5BQUFPNEFBVEV4TVRFeE1US3lzckt5c3JLeXRDUWtKQ1FrSkNRbHBhV2xwYVdscHljbkp5Y25KeWNvV0ZoWVdGaFlXRm5aMmRuWjJkbmJHeHNiR3hzYkd4eU1qSXlNakl5TWpjM056YzNOemM4UER3OFBEdzhQRDQrUGo0K1BqNCtQLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFoRlFRQUI0QUFBRHVEMGRYcmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQUFBQi9oUUFBQ093c3U3M040SVJhQ2dGQllDQVFCQndkTDFzdS9CSUdZR0FzTEZrWXdONVBiRG1waFFBU2pIZ2NBQUlrWElPT293RmtDMFVPVmh1ajZ5OW9va2RnaVlqS1g2amNQb0oweDBlVXIyZm9wc29wWXZMcFl3UlJkaURZRkhtQ080eWlJV3BxTmN4Y21JSkRRVXk2RVp2L3lCYkVhbHVkMlNROVcvQ0hxMVpyOE95cWt5ZUZvVTl5clMzTFZ2S3JoTHZyVkhFYTAxQ0huNW1ITHBKN0RzU2xOTEtkL2xJYldxQ3JZczR6TGNvZ3ZSRWR4RkJKMWRheDNJaG4vK3JTNDVaZnJMc3RwYVhHbHEyY01OMDFtWHcrNjlTY25JSWJ4WVZtVXRhay9PWDQwdi9ySGxiOGVieGswelMxcWJuTThMZmUyZGxPdjBxRUJrQS8vdHd4QUdBRWlXWlhmMmxnQ0l4Sk9yMXRoazlBQUFBQUFWSnkrcGRVeGoweEdvSEZoWVdZd0tGQURxQ0FHSXdEd05iZ0MvSUlpNnlacVJDY1ppQUk2UThvRGNTaWVIQkRIVFFFb1pFdkxTdlJMMGFjaWNoYzZpNTFXNjRzN2NzaC9YVjh4ZlZ1cG45ZTdpK254ODFENnowVEVWUDF0NXA1NWo2aDIrbldpODVMWGRNK0xwMHRlY3VZKzU0ZGJIVE1WTVQrM1k2cXUzMUg2MXRqbjM4WHUzclNuQ2lZSklBRFRidkpoa3hVckNCQTlZcENBTXhJakVnOUk1VXpEd2hIQVJocUdZN0hSTlVMVnBmYmQxSWVMV0dGU3c2UkZWY1RGWE1mdGpkSlNZWWdTMldNM2tIa2haV1BqZENsYTlSY1Fldlp6YzZCMXQ4cnV5Ti90eUprNW03aXhSN2ZTM3pPK3RHL2YvckZZOXhqUnZ6bUN3WUVoZ0FtOVZhQTYwUVVkUUh6N3FlK2FBY2plaHJLWkJXVllCeXlraUFISW5Pdy8vN2NNUUVnQkUxTVZXdHBNM2lRcWRxZmJZWk5Zd1lUQ3A0ZEdZZ3BTRlNRczRJU05MMmRic29OSVd3T05aUUZHajVLbThtQjRBOTFOc3FTdEZEamFIRGpiQnRCT2Q0T0p4eGVCQXFtSUl2Wmp0YkZDdUpZb3F6cDF1VEFpUHlIcDQycWZHN0VNWlhJYnJiRVR1bnQrM25lMU81Vy9mMjRyK25RTFFXMHZ5aTBrczA5TFhEZm9FNHFxUERBV2lGU3A0Um5Ed1FaQUF4SVJtQUFGT1NYbVBFWmdSNEZ5czVkS0REY3dVbEZpaFI5SHBNWUlBZ1AzQWpWcDJqZy9QR3J4Vm9xVHVyM1N0cExoV3ZqVEpQYXllWFlNUk9DaXpqTGRpZjgxTHRqRG1mdGtHUHNvTGpmdFQ1ak0yYjVoYlBwTU1aSjYzazRNa2w5STVPWjliRGY5OTY1NkFVQ21wNlRkekZ1Y1hjZ2g3aVRjWnpCdlZHUjVrM3RSYVA0bEJwTFRUeXU4S1kxcFhCZE9SSUFCdU9ibUpCb0dGZ0lHbmpCd24vKzNERUNRQVJjWGRUcmFVTnFqa3k2Zlc4R0hVQ0dYQ0JFcENRd3NDMk5hdEJYWjVDOW1EcU9ocGhBdWdUUFlvM1RGby95TmxUSHAzS2RVZmc2cXk0aEkwVXJYY2U0K0ppNkdVVk5GTm54QTZweDAzRjdqSEhveTBUd2J5NDhScDM1L240anJpWW9tMUZScUVyREpFakNoNHVLaDROTlVndXZhSXBKM1VtMnJxNTNXZmIvUFZQdUxYMkt2dWxXQVV4ZEFBQnF4M3NZSlJrVVREUW9NQUFQOEFQZ2lFcWxIV3R1WkFyWW5lZHlDWC8vTjNiekhhWkpuSEZEM0ROQXlpZ1JudTVmQ0tLYVdWeVFvMFNpWnJQdWZTTTQzL25kb3FyS3A1aVlRbThuOHNLeEE4bnN1a1JUWmRrcTJhMjYzTmZkMzdUYjJud3lUYmpQTVFzb0MxQkE0Y2J2ei9JZi96OWI1c002QzU3dHZWRytuanMxK25ic3JsY2pDV1FOMFpWTXdCTHR0M1YwYUVHcGRCSzBuMlpJdGdvbll5bmF5Y3QvL3R3eEE0QUVHVkRVKzJZYytvMXMybzFwSm05N0RrZGRCdzVERGI4MXFzVytsNUY4S003OXB0L1dIOXAvTFg1VTUrVXVVa3UvM0cvOHgzZmxYZHlOeW11UGYyL25iV3dUdlNlWXdzOVFNcGtpVzRYc25aeE40b2E0TytDWXVHSmF5NzRwMW9JUVpTTWRtSjQ2MjRmbTJXZ2RKV2VXTXRPbzR2empXQzhWamlCY3VsL01rVE1DY0lHcHRKUU9LaUI0SkdsMnBiSmx5eHY2enVOa1Brb1BKTEVyMU5YeXlKMnFxemJ1TjRtdnI3Z25KUVhUbFN5VDBqakQ3ck5qOHA0ell0ejByV2xvYy9hcklNTnN1WTJNc3hES2t6ZDNHdmNsWnZlYytNN1gyeU5ydnBhTVN3T3o3T014OGM1ayszamJwM2NsV2VHaUtlcmJzLy9mUDczNjJmL1piNXJWMnptWWNWd05ZTlZVd0JUa3N2TVdBVEh4TXdJRVBJTnc1WU0xSFJKSURnSUtpYUtEd09VMTV1a0Y2UEFvTUJkRW5hNjkvLzdZTVFYZ0JJcGswM3RwUTFxRVRScC9hTU43TE9MNHJKcHV0a3ltVVJ5UnlXTWtwbWNtamhjZUd6T20vNVFnYnVyTVVQa2FsN1RVdEUxUFUrVFZpbEQ0MEluNWdSaGlXaEk1b0h0MmxmTXdwdVY2bldyalBtTEtzWWRVUXcrMWhlME9XTmhta3lzb3QxTVJNamRyNjl2bTdoUzNFdUpJQTBkbVpFRUEyYTI4cUdESUt4Q2lQcWxEbVJtakk4TGJFVzBYZ2c4M3Jhc3RqVW9iQlBvQkptbkVVSlNJelVxTDkzVDVVWHZiTUdaMEV2enNjTU5lc3VqQ2o4bEJRSGtNNklqVzF5ZWI0NEZWVUxZTE5oWWNxQTJGVkJKVko1YWZDT1dNa1pkU1ZiK1FVVldMbGRqOVMxbTFOaUdWSDUyV05DM0w2cFYxZDJSTDlqUWRhQlpkR2RVSktmYlcvLzdjTVFFZ0JCZGsxSHRHSEdpSHlYcVBhWVpIY0ZiRFJVQlVlYjlVYThHTVBBRXFHQW95RFd0UlBremw0bzA4c3B0dzlVcDdDeXdpODV1bFVhbzNWSVlEMjB2Q0poR2hjS0xrMUVzT08yaXRwVUxJWmozcFZ0U1RsdzVlSU8zT2JxRmI4WEZKZ3FWV3EyVWIvelQrVkp4TzY1NitrUkdiSWpPeUgvLy9yNlUwaDcvQ09GVnBxVjFvVE1RZDZnMVFNanExTWhwUy8vZm5HS21wSUY1Uk53R1VBNjJUQlhUV0lEQW9EVDRRd2tFS29SRUJVUzBVUllGQ2svQzlaeUtEcExPaHB2T1ljRHBKR3dua2pROTErMzh2Q2tFWlJSbWtDRlBZbWsrM3d0cjNibTQ2WnIxTzA2MnovekJETlkwa1U4NDFkdlBQdnF5aThwSXJ0N00zY1FZMHJ5QWdxd0JrdWluRC9HT1VaNnV6azlDeXBvMU9xRTNkb2xrUnA3L1c4ekNJWWxraDRLT1c2QlpHTkkwNkJvR2w2c1JxUzczSWMzLysyREVFUUFRTlJWUDdTUnVxaHF6YWYyaklpVjI0bkN4OGhwNlRMZEZLVUlwcVFjbFl6QUROeWx4Ym9nS2tPS0hFbUVJUjlXT0lBRXhRY1NKbGUzSFl3aDRJNHRVSzJyUGpJMktTbUtOVWpraHBwVy9tM2xraElDMGJUd205Vng1VW4vVHhmeno3VWRPK2VNQ0JwMEFQRWlyOFN5Q1BFUkxHVXMyKzI1Y3dTZ051RDFSRUNNaENDQXlDQkt4UFYyR0xOZGhVUE9RKzhKK1NUZE5WSHlpZEV1RjVKSW1KZDV5VE13bEpweGI1QjV3UlRjVFh2c2t3T0dkWk1EMzR0YXU0TnRsMW1uNEdKT3ZpUmRFNldZWHV1NDd2ZTlYWXdwTjZlNnF2ZUlPZElXM2oxWjJJOW9jdXJnYlNkMzZ5djUrOHlwMnVyWENiT05WOFNxUk43aVpSRmNuL3QzLyszREVCSUFRbVZkTjdUQnQ2aWd5cVgya0RuMk9jTEFxNFlNbXdVQmdVMEpNT2lwQk5JSEFzRWhnQmxMd3ZpTFRrbHhRbldReFBycjJaK0RLMHI4SEpYS2JydnZybmZ2NjZ6ZENxL1J0MzZ1dGZOUTdFMkZUaXZWWUZNNnNET1VrakNzYktHYU1WVExjMSt6dGtZU1JsQ3NRMUl0M25YWTZhSEhNcm1RbUVZdEZLd1ROeWMxekg4VUhYNjZ3YlUxMlFKWWRuZERNZnUydUZ2QWpJb0lEa0VVWVRNQXlnbXoxYmhjQlcxcHNMY0tGWVJpUVcvN1RicCsxMmhVYjBqWVB3bkNoMmtrMUk5dDFwNkdEaGNoN2RqM1BGbmluV0dxWTFocTJtcHFPcmF5NmJ1VHhFdVZuY3BNbExOSEZlb01lb05nemNjUlJWcXpjeHpOVHR6bEl5c09vUEZkTXBVb3BxNkpoYnFEVzIxUVRyWEtoMExVV1RLNHlvU2laZDNacE52dGIxS2pJR1JrUWNjT3Vvd1p3UkJFVlVnbHpTWnRILy90Z3hBOEFFSG1qVGUwWWJlSUVyYWs5bGcwdFdicFRCY0JZV2tUR2ZvRXFJZEh4NC9BMGl5dFJLOVJCS0poaUtDSXRVeG0xT1VrYVoyTTVhR1NVaHdTUHFSYTVuRW83Nml6eGdTZWdhNEllQ0RJaXlLbC9DdkpuWXpvNy9zWG5IaCtabTVacXR6TE11aWhBV1NrNWxId1pNaUhxeW9STDVJSU9TTlllcWhWZGUzOW1HNkFzc0kwVDEyTHhoYnNPRmFvNmFjNEdSM0JrSEpKSEtBY1VId1l1ekRCQXZUZnJaYUZycmV1TFhNUnNDTlVLMEZzVkpoNktyR3l4eUc4U01Za0RSd1hFckJRakRCaUMwNExZSkcwZkRFNGtVZ05hVk1qN1ZMalZYTUV6RXl4NnBaWjVYVDJod2pTNUhOaisvWUpYYVVidkFPSGMvNzI3a21qWm00aHJmLzl0Ly90Z3hBU0FEMFdqU2UwZ2I2SDNNV2U5b3czc3phRHk3d29GRHhLc0JqR3dRdlpBdWdEQVhCbVdteTIxRm9HaGVZQ2RIRklOZ3BPcGd6R2pPVFRlR2V4eVpKbE1VYWJTM2ZiZnJVV0ZHWktwSDdrYzJadDZwNVM2R0hnZFNzMy8yZGM5Z2FxbnZaR3piSm01dWlQeC9VN0l4bFpyODE3UFB2REx6cmwvZHUwbk1pSTdMMEVxdFVSTnk3MjMzMjJ5eGtZSWJBaXFGeEJ1eEJsRGd5WFdZM0pZdHFVdkUwS0t5OXVnd0JCazlLSWczNHFqdEtYV21vb21YMGEzRGtxb3ZNclhJS1FEcm5rRzFLd3VxYXFtekxHTXdGbWF3NEhLbnFxdFpTbTVmYUtWVjBYTjl0bUxOYm1XcmNwWjVXWlV5L2tiUnFUUDhOdmg4aDY1MlhwcmpMbFRJOUFCLy9zUXhBQ0R5VkJ4S2FOaEFLQUFBRC9BQUFBRVN5U2J5YjJwQVdFQWxoellSVEFBUUZsL0FUTElGbXRhV2xwclVvV3lsV20yYVZrbFlhR1prYjhrVlZaRlRKWThFeEdHaXAwR2hFU0JXZEVvYUR2Q3VSeEVleWNTcStKcTNOcE1RVTFGTXk0NU9DNy8reERFQklQQUFBR2tBQUFBSUFBQU5JQUFBQVF5cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcWc9PSIp";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3 ***!
  \*************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiU1VRekF3QUFBQUFBVFZSWVdGZ0FBQUFaQUFBQVUyOW1kSGRoY21VQVUyOTFibVFnUm05eVoyVWdOQzQxVkZsRlVnQUFBQXNBQUFBeU1ERXlMVEEwTFRBMlZFUlNRd0FBQUFzQUFBQXlNREV5TFRBMExUQTIvL09BeEFBQUFBQUFBQUFBQUZocGJtY0FBQUFQQUFBQUNBQUFCNklBQXdNREF3TURBd01EQXdNRFFFQkFRRUJBUUVCQVFFQkFkbloyZG5aMmRuWjJkbloyZHF1cnE2dXJxNnVycTZ1cnE4Ykd4c2JHeHNiR3hzYkd4c2IwOVBUMDlQVDA5UFQwOVBUOC9QejgvUHo4L1B6OC9QejgvLy8vLy8vLy8vLy8vLy8vQUFBQVVFeEJUVVV6TGprNGNnUnVBQUFBQUFBQUFBQTBDQ1FGR3lFQUFlQUFBQWVpWDA1WnBRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUC96RU1RQUFBQUQvQUZBQUFEdW51eityYmFYT1hEd0VBQU4vL1BBeEExanBIYXJHWmpRQkduNmNTV1VzS2dESjJoUmpBU3E4K0FIdE9HQXVBSzgybzQ2NmI3WkE0UEgyRXJBTVJqa0piYXRUUTR5cC9aZllydXUzR2Rrc0JPeE80UzV5NVBNWEtTUlRlNVJFNlo2NlorWU9hMXlWMXBSVnVUL3h4L0pFMHgzS0JiS0d6WFJrR0FoYU14aVE5UG5mL3ZhK1VZcEl4RUlTN2NEdnM3YnNyL01DRkJBdE9jeEExVWFPSW9FVlczcHc2bThwTkRFTGh2MzhkeUdGMk1PYWRBRWNkTmRhVmpCRVoyRG8yR0xDR2xDZ2M4Yzg4SkRqRExUV0tEcDMwR0RUQURXaXhVdURqRUV3ZG5KR3VTekdNT0pacDZsK1Y4cEdLb1dpQUlOQVYxcEVJNFBtbW5HM3JhZXp0TmRpekVEYk56UHVRSVNNMmRNcUpNRFVOUUZBQ3N5TDBLREFsc1owc1pRMllwR0dPeFFiV2xtVVloaWNpemlUa3RvL2pydHV2RDgvMkdibURpdHE0Nzl1Z3JlaU1yWTNxdEpiQlZpcWQ4dkE0cXU0bWttNzcvRzFCR0xOaUVjS2xUU21BTk1DcEU0SlkxQUF3ekltdUdjRWdLQ0F1NWhUNXdCUklLWjhjMVVBb0lKSnYvTjl1OS8vOUs5M25mZXFXZC8vTUhITXlrTWdURVJwaVBWak8vYm1XUTRmdmIreDl4VmlzaFNwRkFHLy9Pd3hCSmNYRnFqQ2RqQUFGQUZ4UUVEbHJIWXExOUZSeVdhVHoxczVhWTBsNG5SZmFGdnRac3cxZWxrdnU0eTJsd3Y0YjFZcGFQRGVwN2xhSVlWTSs0eldOenN0N1p2UmVXeFY0blZlTi9hbTVlMmFBN0RxUVZMSkRFcDVhRUJ2OVVsendPL0ZIaGQ1bk1YZlprcFo1M25ZUUVxUmYyQTEvTVVycjVUQWFZRmlMcGFNdVJLc3VERktWR2hEczNFdGFMT2E2bkU3U2p5RlFCRk5JL3RKTDhnWWdKU2dnWHNMREM1RTBWQVhqUlNTUlFtUHVwYVdyVXNaMFhSVG5XUWl3bVcvQmY5SEc0UEtEQUZHa0V6emdZbzZKRE42aEFVRENRRW9vQTBva2h3ek1sU3RlNUtDQTBKWk1RdmxGUkx5ZlNXSVFwR1Y2SVdQSnJKZG1FSUZFbjB1MXJDUlRER0Fwb1pybExhS3l6akswVFdzclBnMVFSWUJINURCZXhJTkZ3eWlFWlI1S2h6VHhxQ0RiREV2MldwckJnbWxCeDJHc01ReFo4aEpUTmU4dm1pc3Y5SmRnU2thVnBzUEx0VGthNUpZSFluQWJub3JKbElYTVFWMDFadzV4azBBek1zcnh2QzFhci84N0RFQUV5RVVwOFFleDdkQzkzZnJJWk5BLzl2Ty9WQ2JYVDVVcms4RFpMcW5oNjdGVW56MFNGWUJ4bUFOQUtSRUYzc3ZhY3ZMVDA1eHQ1byt4Yzk5ZGQxZFhuWFhiVXZTbnh1L0NpWFdiNldrNUZTb2pvZFNxaWtlZTFjdVJKa0VlUkZSQXFhRGlVWXJFU295aVZJV1hrZlNnVlJ6RnlmcFUzaTVEQ1FLK1dGaVgwTVM3aThSYkl6S2NzSzhvQjlFdU5OVUNIRXBNQVVxSXdwd3lUb0wySmlIOEcrU1UreENTL21TOXllU2lKY1NrVjB0d3lWQVVZTVVKTUxVUzBscGJWZVNrL0Zla2pYZUdhYVIvb3NlcG1IeUtjQmFFZExjUG9ZemNYVU5FZ1FPWXVZeG9obE5TSkxzZWNZSVVKaVp4eGw0T1l1UVFJRnNaS0phSTZGTk02TEp5UVUzZ1lRbVJCaGpQQVV4WEVKUktNYlRSVHRvckt1MG1xTjltVHhkU2F2b3JhOFZBcnc0bUFKRXE1V1doekhVb2xFcWxjYUtzWnNNVE1ORE03Ly9kcU5FUi85M2dVanhsMGhLcGhrek9sbVRDa0crTFFWNnJPSktITW8xWTdBQTBnTFRJMVlnWVlScC8vemNNUXVMNHYyb3hsUFlBRkhMcWx2NlA5ZmN6NFZzVEY2NURhbHJ4NVc5cHRrOXRiVWZ2Q3R2YXVmYWJYMTNyN05XYTJ2MTJyV3RWcCtMZVlkaVd6VFpldXpDN3RQYWZydmZFaDNacEtiOStIclR0K2F2aTJxMllMVXU3RHpIdFBWMHhQV1dES0JkNWprOGZOT1d5cTJKN1ZPOGw3YS9yMXQ5ZGFzVTVWNjljWE5XMmE0OWExK3J0dnkvTlcvYXN1dTdsbnFpanUzbGxDaHUvNVZjd2hFbGxwbXQzbUgvdSt0UFVIL3g2L2wwQ3Uxd09KYS8vT2d4QmhMM0VxVEhZYkFKVzAyTU96Vk5ERmJ1NGZkaWRrNzhMMi82c21hby9jSFRNTVF3VzUzUzRYYUtFUUM4TFdYampTdldDbzZTbVc3aG1IY3FhN1JMeW4zZlFjWmc2Q0tDZXdBSTJrTlE5VFZxc2VyUXFudE9XK01BcnpaNUFhYXJkM0xWVFR5REJKMXFwT0J1VTFyWHpMK3c3MnhEOGVnS2hoRWdmYW8vY1plaWVheWdvcmZCTHFNb1lBc1pRUmRTdE1Nc0RxMlpsM2JIMXFhdGRqTXFydExwYXRlRXkrOUg2S0hLV01VRXFlYVhLWXlkb2J6VlgxZFcvRzI0MU52VExJL25ET1YyR2EzYXRhbXBzY2NjczZXVDZnQ25hOURlZFdsaCtMVDhkcTI1eTVDNXpDT3JtZjlvcmhWWEpsOFlkOWxDV3podzA0RVBPVTE2MDBCNm9UV3RWZFZvMUVZZGx1cWFtcTh5cTJackhqN2ZuanZuLy96RUZVMHFVL0ZGTW9BZjYwRC8vLy8vLy9CVWVDcmhFZUVUNTNJclAveklNUVVDMkFDUEIvQUFBRG9sQldEU2c3NVpZS2dVTkpLaHNTdWlYSWxRMkpRMUJwUjZreEJUVVV6TGprNExqS3FxcXIvOHhERURRQUFBMGdBQUFBQXFxcXFxcXFxcXFxcXFxcXFxZz09Iik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/16-guiro.mp3":
/*!************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/16-guiro.mp3 ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUtBQUFUS1FBT0RnNE9EZzRPRGc0c0xDd3NMQ3dzTEN3c1NrcEtTa3BLU2twS1NtNXVibTV1Ym01dWJtNkxpNHVMaTR1TGk0dUxyNit2cjYrdnI2K3ZyODNOemMzTnpjM056YzNyNit2cjYrdnI2K3ZyK3ZyNit2cjYrdnI2K3YvLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFTclFRQUI0QUFBRXluV0c0M0ZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQWhnQlYvUUFBQ05rc1doL012QUFBQUFBQUFrQUFPQUFQL25BLy8vLzhFS2FkekdJQUFCSlRSZzhsbXNqYmZ0d0lVWW9JWFVlVTZDUjRnN2p6aTNCSXdpSFVHYjVyMStJckRYVzRoZ0o4STZwUTBzRGNMa25VSmV4anE4WXpDZktFdXltZFdIcm5jWnl3ZzJERVZjVGdmemFZWTJBOHRTZnRDT2diQUVveHJGVG1iaDlXYm95NXFTc3lISlpaeXh2cHBvNWNIeDJzTVRHTFJYVU41RmdPUjVLMHl5VnFKa3p1SmpLbHM5ci9hYTJuV00xeFl2Qi9vZ3FEcFBOTEdRbjF5eFFtSmFpUHBhNXI5UlB0bWt0Q3puY2RDSEtaV0YrTHlaYXZWQ2ZlcHlyalo5bkRFeVJtSE5QcTBiRzk1OVkyWU1VU0V3WmJ4SGN1VnZiUXdBQS8vdWd4QU1BSE4yUFFmbXNnQU9OTWFoL05ZSkFFRlFSSlNBUkpDWXNYQXZVeHBFeU1WbVljWVFIQnhNMnpRMGgwelpBd1l4ZURFRU5KMFlPMXhVQ2haQVlaeTFrWEhsN2J5dDkxVUdXeXlNdlkxMTU1eC80M0FTN1hzUjcrbHV1UzNqVzRYRjdZWGRXQWE5ZnJOVXBaQjNIRmtrVGw5U1dRRzZhZkVqb0lkM3Q0cGQzSGNVamR2UFBPNm9uREV4R2VPL2pLZnh5N0thbUZoK0p1M25ubmYzQkxkWVJMcjMzTFdjUnl4eS8vcDZmc3JwL2Z1NVkxU1k1VUV0aVYrdFBZMDI4N003dldOUFMzcFRVd2xtTitCSDNrOFAwL2FmUFBQY21sdU5scE1DUDk5YTE5eTFyNmJMbExqTGFsL2RVb0Z2Lytxb2pLUEQ0QWlBQUJPTFN0eitybk5MNU1jakFDcjRHcE80SkYxZU82cG8wUjdoR09acThZT0VYUklOZGZVK2VjSXlkZ1JkVzJ2VnFkb1RyV21ldkRLWnVtM0JVbVV5ZWxTcDR1Ung1V2xWSVhNWkRFMFJGOU9aRGpkSGZlV0pWNmt4eDhvWmtMd3YyeitxaURLNVZsSHNMRkJmZ2lqc1hwTkozc2FjKzBFVThOdFRsa2hwTTdNTzJKaWNwWGNsbGVNMTlScDVvQ2Z1UTBNWGs5MnRxeFJ6TmF4cTlVbW9hbkpUS3Q0NVp5bTFNVFVicEpaVDI3ZmI5UGpNNDAzTmYyMWpsdXRxa3RiN3YrWjVmclBMUEtSM09XT2ZqbjJ6amwrRlNibCtkMis1U3YvL2hjbmZWbVl2S2d3UWdVQ1Vob2xEN1ZROGUxQ080dU9hc3VHRWdwanhVWWNHTWdDb1dWakowSXFZSU9tSUZxN3lVS0w2Ry8vdWd4QmdBSkxYZlFmbTlBQVBJc1dnL041QUFCQjBlQnBjVEVXMElpeUpCM0JDK2NLSnA2dzVFQVZPb3JEQ0ZVa2s4cm8zNkRBYTBINWV2T0hXUnNyZmFHSWhWTVVNRGdqdHViRDVNK0t3QzduZ2RhU1BWVFc2ZmZXc05weUNYSGxVQWw1eXNJaDdCTU9QdERrRzdkOStXY0dGQnVmRGtEUmg3S1FSQllqR3FIY3ZoZWRaMUtlbW5MdGRYYlpGTEhHVUFleUhLdHllcUx5WEsvTlNsL2xlWDE1Uys5cWtrSGFUVEwzMldJcjlsRUNSSjNJcEVKVFZneHdvQmlzMXpQV3M3RzY5ZC9NSzlQci96ejN0T3RuS203WFRJZzFwQTRBenBna3RoRWpsbE0xaDlmanEwV3N5R0FyTnlIc3M2MVd6Ly8vLy8vLy8vLy8vLy8vLy8vLzRmbm5mNGt5US80VERWMVYxZ0NJQUptWXNENWRHZ2VtOS9abWV5YVVIZ0VYTUxCUm9nQVIwT0FaaVlNMFZNcGRKaVpoS1FxRzA0Q0NZaURnWXdaMm5HQ3RkQkM3a05SanNKWlpSekxFRUlHaDRYdHRKamtVbTN4aHhya2RmdUFXZ3hpempOUEk4RVNoNWk4WWk4WHR2RFRMNWpNN0U1WC8ySnlGOHYvTDNuZlJsS1ZDZWNUaXJ1MmMyeVhKaWJzVEZpRzUra2xtNDNWcEgydjI3bFR0eVdSVnUxbmtYbjZLbmY5MEhFbVdtVWw3RzI3dEpDcmNzb3FDL2pVNURiK3RHanVkMlczYzlZd3VydTMzdCs5Ym42Q3hLSkpmZ1NKVnFLMWpodnVGSm5QUldYUk96T2JqZExTNDNhbEJla0Vyc3Z4ZGdmYTVSMy8vM2Yva203MnU0QUFBQUJBQlFHZ05HcC8vdXd4QWFBSWgyWlNmbTlBQVJyc3lsL041QUFTVDc0d2dYTkZFQVpMQUFGTVRLRFNFQnVKaDV3RlFVREFnVktBdzV0bUZBMUlBUXpSQU1nSlUxMEhtYlkxTGJBV25BeEZHcGZjQVJ4VmFCSkMzZUp5RkJJMGRxNy9JcEs5YzZaTHlnQXNpaTNTYXB6QUFXU1UxK25SNFY4MXVPU3l1N3pYRUFqVEFjSHE0cnlwU3dBYmFFeGk0M1FaRExXQndBaUFwTk5qak10WHhLMlpOOVd5cnUwNUJjeDFxenlRTzdxN3A5N0NZZ3MrY25Mc29oK1lyUEJhcTYza3l5YWxrNWhXcjd6bFVLU0lpRXJxUVE5Y3F3alY2SXV4THRSSzVXdjU1UXkrN3N5cURZWXZVT1ZKTEZ0bHFVT2lJYnd1Szl6Qm5acVY2a2JnWitaSk1RSkRidVNxQlg3c2I1cWRxNHlhYzdUUHhNVEVNV0xGN08zRk0xUk0xTlZ0NzVnQUFBQUFtd1RBQ09TcmQwNW9BQ0FnOGtWQ0pKTVJpemFCZ0dsWmxTcVlJU21KbHBnNUdEa1pEZ01pTTBCUWVoQWdhZWl5UnBvMnM1T0dSeHpMRE1JY09mQkFxU2FLUVhBanFvV1dLRVE4RlEzZ1phMTBLUnNRYitEUkFPSkFwQnNFZ1NuTTJSdUQwWEw0VlRXNng2Q0o5OTRMbGFtNWM4WUl2VTY4WFlFU0kwTGJzeXg3MkUzU3M0T1JWRStURVllVlhZQW1sRDA5aHVJczZROWVwclVZWFd4bE1GM21SbEFxdTdrOVpsZExibHJiT2RLZVlYWmlxMVZUWjVvbGxjcWNaeEQ3ZXkrN1BOWXV4U1MyWXM0VW8xcS9UU3JDM1NRMURVcXE4cnp0TGhMZ1VHcG1xUmMrS2RCZDlkcnhSM09XTmZoOTlHUTRUdFc5UHl1eG5sK3JOdmpTbWFYS2FHbnhiaTZuWkRqVjdOMmJRS2JkLysxdTg3OVF5SUFBQUltRFlTTXF0YzJ2Q01BVkttZmRHY0lHanVoMUExVmc5R2c0dHdlUGtnRWREb1ptQk5OSE1nRnBDK3hnUnFuTTlaY3BwRXU0ai8vKzZERUh3QWh2WTlSK2F5QURDVXlxdjgza0FDRFVRRkdZeWNYVG1Dd09UTFd3Tk9sQmNpbWIxc2d5UTZIc3lMMmp3Y09WNHJiT0JXWmdPVVNjeHpHUE1pbFdXZExQVDdLVEJKc2Ric3RZWVFOTWJPOUhvUFJ1dWh4OHJjQ2hmbWVpaWZoaUtqd3NJc1NwSTZQSkV3eTlVYnJ0T2R4OTZZdCs5OUpGNlRiSW4rQ3hvUWszV0lRRFhucjhhWDBwYkFzNUJXZWRtZWpFLzJXUkoxTWNJWXN1akpiY3BsRkREMGFtWUk3SHJkdXJPNVlScUkwcjJoQkVSaGhueXdwZXQwV3lONUxhTnlJdFpML1E3VFdzNmFLeXZQTHZNYy9VcGdoNW85R1piQk4vRzhJQmovM3RkL2F3QVFBQUFaR0xBUUtFbkxmK2FZUkFBck1oRkFFQUdNVHBVT1RHa1kwWm9NVkZCQWdGQStaSWtESUdZYVI3WURVV3dUREZ1eHBKcElrQXp3dEdQQ2dJZEUxWTVhNWpTS2c4Q1JEdmZOdTh3ZWtqS0RxdjdiWWxjcER3ZlJVbmdHU0NIUWxVMG53MEJ0NHBHZDNwaDNGZ0ZMTFdwdVVzWVlsdk9oemdaNTVzRWdwZHc1TlVOb0xvRTJBUEdMVk52WVFkcDNIZCsweStYN2JPNGtyVEFmakdCSytjZHpTT1Z6WTdhN1ZURFozT01UdDdwNmZ0cWsrMUxKWEIwKy9pOEcxdVNPMVQ3cTBrYWExRGt4RzY4citwZXBJeEtHdVNFeFFVNFc1T29uUXdPT0t1VTBtWkRRVGtnamNuczFuU3A3VXBobVc3czFhYlc2Ri9KeXUrazVGWDh3dWR3dkZONnJOdmYxQU1BQUFBQUdVZ0FBRUI0MzB4VExFUUVGbVkyOFNDaTMvKzdERURZQWdlWmxWK2J5QUJJZ3pLajgxa0FBWWNCR01sNWlaSVkwZGhpV1lzRkdVZ2NsVVB4S2dISkMyZ2tpV0FpWjVUNjVGVVREbFNIQkJiSFZmSmFLM21BQXpoZVZkc2dYRmQvR0pNUm1GME5ja2hvdm9LdiszVnpBdkZBYUJLSnlrT0FiVFZQMm0rV3U4cmxzV3NyZHJPTzkxU1dIYmRkYlJlRkVaVXl1bmVhMDFSWER2cTV4eXZSZElScERURWYySnV2QUVLUUprUVZTVlR0YTFacnM1NWU3bC9WME94R0pmK3FlbnQycjNkWjB1RnBtTU5zNStoalZudHFwWmdPSDRUR0ljbGt2ejcvYzR4U1VrdWRtZHZYWXpNODVxZXE1Wlp6WGI5YlQrUzdtR2V0NzkrS21OdXZEZHVINDNQMGxKWWgrTi8vLy8rQkF3Zm1Jbk5NbUFBQUFBQURBQUJBSlVrOU5YTE1nVE1BVFMrRHBBSzVpTThZZ1dJZ0JFME5zL092UllLbC9Rc0ZNUUFCUTRMQ2d3Y0JGT21QRUJVOHhBalVKRU5xUkVPQ0FRcWtEK1M5UlkxbHMyQUJRNWQwSGpYb2Jab1lLT2xIRWNqckxZWXV5cFBablR4eXlMb25PVERVMVMwMWlaaE5FODJOeUp4MStxc1hkcGdMbElkbUF4bGxDV0JmdXMvcmNYTEx6cmhnRnc1QmlBQkRCRVRNTXdwUll1T1lnVk5HbDFQKzdzWm1xYTQ3ZEk5a1oxU1RtNmhkeE05R2hJRmV6WTJZdkF3K1BQMDFtVlM2bXV4bDJZMWFmaTVFcFpicjIvbWJmbHd6QUNWdmFCSFlLYmd5dGxEdUxyaU1FdGRuS1Y2bGhyTmFHcFRHY0t2eEdGVGtaMUFjQ1QxQlR5TzUyMWFVRW40SGlqWTJ0SldNNFhPNkVTZjkvTEZHb0dqdi8vLzhheWpiNy9aalZFQUFBQVJBSUFEaHV1OU1SSkdYZ3NvTkdTVFB5d0lOeVVKU0hHQVlFeWh1WmNFTU1aQ293dGtFRFZvWUFES1VSOUI1REpjYllsV25xMDBRaVFmSm9vSTNIYmRYTU5wOExrVVdFb3BQLzdvTVFwQUNHMWwxbjV2QUFFb3J4cy96ZWlRRG92Q1pFSk1CTEpLcDBrZVRYTFlQdkVLV2l4RnB5U0tZWjlwS2xSKzViSTZyZEcwWDZ4UHNUcjVOT28zU2hoekdReEtWT2swQUhEaXFsOEV6VDJ3SXRtSEhhb0hJYkZWcG9mZ3FENmZEQ3lvazBkUzV3WFpaTTRia1A2eVRIczFNV1lwVm8yZXhDZ281NkxVRTFVbDhyTCtNMmY5MEpjemlSUkZnN0EzUGZxQW9hZHpsSERrek40eDJLMzYrTkRCTC9SS3RTNnQ5MXhQdWlUcmVCMzJJS1lPc253ek5ycmZPeFdsTFdkVy9wWDF2eE8zZmkrN050bi8raGM1dWY1QXdDZ0FBQUFBQVlCQlNkU3Bnam1ZYU1HVlhBWFBESDJNellsQVJVWXNibUtCUnhKaUZoQUxBY0Fnb0RqNFdDNWNZSVRQT2doRWo1YWNtSE15QmhSREFoRUs2WDhnTFpGTFltSVNhZlFVV2hhQUl3SmFnT0VsdGFTQlY0aVFreXBKSnB1TnVjTmNXREFrQ2JzSjZzRmpPWHhLbmRCWnorSVpXTncyN2F0aUVpWjArc0NKUFFNRlFZc3ZMMkp5dGFwMHdWdWlFZXpGVDZ4R1VPaE14aVcvbE5RK2lMUXlhT1RiK3hGM1pJNFRnU3lkaCtOdFljaVFQYzdMTFpxSG8xS1pUR1phNlR1dXoyUVNtTXhDVzIybnhlUnJDTzVMSDdwODM0cFpKQ245amQ2VlhhV003aU1zZjJtM3lVeHlNeXExVFpmckszeU56N2tOWWh5M2I3M0RtZndCRE5tdGpkWURCVVBSckhtOHN0Ly8vcjlmLy8vLy8vLy8vLy8vLzU1NTBsSmhienF5Yi9NWUVBQkFSQUFBQUFBQUFTV2VQLzdvTVFJQUNQTmxWZjV2SUFERVRScVA3T0FCT2dhREpFc3pFK0tvWVlXdW1hRVlaekdUaEpuSU1DUkVrRERCeVJJd1dBc0NFUVlXWTZQbDZ5NUJlWnJCdGhvL0xFTE9PMklTaTg0OEE1NlF4QUVIRmc1VTBhUUYrOFlqSkVOSnlLb1RoUWtLU0Q3WVVGQlRkQTI5UUhGRVEwdHBhcENJd1p4b3pacFgvYzkvRmdrRk9VOFlnUlE5WE5TQ242Z1pQV0NyeXFiQjJ1UE5kbTJOb2ZNU1o3SktTYVZYVkUwRmMvWmJPdU95aVBvNFJCWWpKblVkOTNYNWhwKzNnZFNXU2psQkEwRktMSkpKVXlxWGRaeTY5aUFKeWtrWEkzZHR0ODg4TlE3akw1WllzMnFqNE9WQ28vRHNtNUtxZWpqTCtxYVFIVFc0SlpQSFdpTUVtcVdYNDZkNWlGN09XU3l6amhoK3VaNWkxSm9HcVd1VEhtVXVURW51a09GTmJCai8vLy84bE83M1VnQUFBQkFBam5ReWdOQXBaTUViQktnYmpKakY3bUFNQ2xHVldRc0JMbWw4WTBCck5PMVRXdVZjY3M2MFRhYlMzcFU2U2ROMlV4ZGN6QmwzTTZsOFBRTEFOSmhYbWN2M2h2TExMS21qVkxleDF5VS96dFdVelV1dGRqTGtzTmE5TnRaZDJsczAxdWg3ait1ZldyV3FXclZqdUdzYWFKUm1VM0t1TXpUWlg2MXF0amEvTFB1clZOVFpVMWEvak5VMlgvdjgvLy8vLy85OHh4L0t0R24ralU3eXRsbC8vcWxzMnNyV005WnRiLzhzY08vVFZjZC9qemVPc2Q0NC9qejhjYXRuTTNzTUJNQUF3QXJ6anR3Z0FOcUp3aVhvV2E4SVNnVWFKTXlOUjhYVklPMlUvLzdZTVFSQUJBWllVdnNNUWRpRnkxb3ZaTWlQUnVuTkc0dnc1RDFkY0d6dUhJVkNJMEZxZ3ZFeHdxT2dhSHYwdXZNUk5GZkpzV2RNcnh0S1FRelRzemYzMTN0ZDV6Rjh1VUxaTXcwMWJkL0xYam1ZcDJLL240dVYrNHZSclNPaVJFT1k0Vjd2aTljNUR3bUpQUW9lZHFObTZZNkp1N3R6RXlJTVRWL1AxNWRrY2EwcFVKRXdSZHVQNDVFc3BiTE1wSEdacUM0T3ZiVTFrVGFOeEhlLzVGdFVPYXlXQ1FVeDRPOWJtVjZwL1U5R2RoNTdZYk5NUzNib09neFlhSGVHcExYcEdGVGVJc2xwMkZtYlhXQ1ZOTjFhTzhWRlZZNmFtbXJueVZGajFoaHVYdVV6Z3RRVzZTNDRhcFdscVZGYWE5cCtuNHZRUHFpK2pWWWlhcWtOVVlmbHY0SHlmLzdFTVFGZzh1RTJ6L25zR0hvQUFBMGdBQUFCR0dva3FXaWNaQ1VlME9oS0hJS3RaSnFHZTUrekJtejJiL2IvOVNZR0FxVVptei9abTlZS3V4K3paVFVCRlVCRTlnWnJzMzFZVEdxeGpBVDgwVWROM0xKL1VSeVhoM3l6d3ZGZU54QlRjVGYvYXBNIik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3 ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c25fe36c9d17306b2c4e.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/18-cuica.mp3":
/*!************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/18-cuica.mp3 ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQU1BQUFNdVFBU0VoSVNFaElTRWk0dUxpNHVMaTR1UzB0TFMwdExTMHRpWW1KaVltSmlZbUtEZzRPRGc0T0RnNStmbjUrZm41K2Z0N2UzdDdlM3Q3ZTN5Y25KeWNuSnljbmMzTnpjM056YzNPM3Q3ZTN0N2UzdDdmYjI5dmIyOXZiMi8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFnc1FRQUI0QUFBRExrUGdSOE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdFF4QUFBQVRBQmZkUUFBQ0o0bnljM081QUFBQUFQQUFBQUFBRDQzWGdBZ3Nnb2VIYi9lN1dXQ0FCa1lnRTRoQlV3aUhvSUFzeGdDSVNBUXg0Q3d3eEdrekVDMHh4YjA0Wk1zQkFoTWp3U3RiTUdRV0xpSzhwbEE0OEMrNk9ETW9XNUFXRXFna0V3WDJYTllnYU9WSGFmMlhaUlIvTlkzOEpaQTlxWHlDbmhFclpJL2pwd0RyT3hWbzkvdW12WE96dEJ5ZXF2eEllNGQ3K1BKMnBaMzgxcDBLZWp0OXI3MTNMbk1kYXkxLzd5Ly8vbmMvL08vYUxDSmY5eXZRQUlBQUFRVHY5bVhqSUNDUVJVZ3dBcGV2LzdjTVFKZ0EvMDVVRzkyZ0FpWnFObi9kMHRQRUtCS1lBbDRjZ2xBWkVoQVlOZ1UvajVPTGJqRGNnT1lxRGtCNk4xblRBWFlwWURQTUFGRnc3RGNuMHpSSTFFdkZ6azhlUVZaQWpob1gyMWpXSnhkQ2hUSXd1TXJWbkRRMFFXbXF4T3BKV3E3UDlTQjVOQyt5RFRkM0N4RU1HYXhJeXB4emNJdi8vL1NTUmlrUXJUQ0FFQUFBQktUMzBsYVFZTGc2WVBCVVlDZ2VZSUJJV2ZCQVZHQjRaSDNESUI5QU1ITnMzNndraVdBUm5OZUtCM0NNM04yb2lqZWhjWW5vZDkrdjV6WTFkbHRtaVpDamhDdDNNY3YyWkNEQVlxSFJFdEtTRGR0N21ZSmRuMnhFNmdJUXZIV1ducU9uNWFkWWRkdC9OaXh2Yzl4QlVaUXlacjB4L1haVnhMU2NiTnFPanFCcXRiSWh2QzdRWU5oczlCNmlCSFZFZi8vcHBxV3BBQUlBQUFIeTUrTGtwTFVBRUN6QUlFakIwSldRQlVDVENrYlR2LyszREVEb0VSZlI5RDdyMTA0alVqNkgzZG9mek9SeDRiM2NwWHBhLzdkSGtMd2l4SVJmRFBuVVVIWlplWktpa2piSG9NYW1KOXRpT2pmNXJwY0trQkZZczRwWGZaZ3FCZnZNUTRkYmFPMFJ5bzM4YmhjWkxjWjY0Y214ZXJaK1NpeSs0U2RES2t0dVR2YmJKN0tyZG1pQkJsMDY1K1VFMEZ1djFiZW1hQmlLRy9ieWlWTEFBQzJVMy9lclJMMklCd3NBUktBWVFCaGlZQXgzNVR5SlRZNWhvYzlUcU9RNkRTTVd6TCtHK1RKZWVCRkV6Z29ORnVPMDl5bHk1ZFRjYUhoKytjL0dvSXdLVGIvdVd2elQrWEZqcTdWdmJ0MDZjOW10ZW5NYThmbTBaR0MvTDZrclc0UUdsVDlmakJGN2RvaXBGN2FiYStSQUJPdnFZaGdhUGZweGlRbTNkcFNsRlBMZS9sdityczJ3SlZSN1FBRUFBQURXM2Z0MnM4RStBY0VEZHlJQ0RFc016eHVtVEFBQUpZeTV0SlZLMVVHbWhRLy90Z3hCT0JFR1VoUSs3RlZxSkxvK2g5M2FHOExTc2RMZjc3aWlaRzNRTVpTcWZ6dHk5TFpWWnJCTUE1c2t5ZXB3S1YxSnFTc1loK0JtczNZdm9ua0RnbEIyTlZUYkFhRTg5RDBMbm5LSFdUYXN3VFVlK2h3VUM3S2V5bmkxMzFOR3hoNkd6Smd1ZnRiSVlRWElPNVhyUWN1QUFBckU5L3pqYU12VG9IZ0drQ2c1aXNLUjE1UlJnQUNiS2xpeXFXeUpSeHF4Z2FHSFpzdXg3dUlLQncrS0JSd0R1VENEZlFpL1MycCtKQ0llVkZ2ODZtSDRzL0FRVko4ZDNzTi9FNENpLzRWcFpVNW16QmJpV2dwTkZFaGVCZTBEK3B3UEJqaXB2dkV0KzZXcUNnZDE5L1VBc1c2N2s0ZVNPa2FrR2o0MWFCM2FROER5UjhNaWgwcnFxeW5wNmVtK2hwLy91QXhBQ0FGQzBkUSs3dERlSm5vNmg5M0NIc1lBQXdBQUFOU1YvcDEyR0JJTG1Fd1hHQm9NbUVnV0EwQlRBb09ESDlGVENlTXpCd0Fsa3BlTFZjYXM1NkpoaTlHR0xNWS9HdFh6WEVCRDQzMENMNU1sbXNlMm5haXdRRFo5eC9EZXJTaWREWTFWL1BVYkw3b1ZVOC95dlA1eE53MWEzaDM5bmNzQ0l2SGoxQmVFWUFFVjZycHhlQWJYN1dpRUEyRVo0cjVjUUJIcU9jWVk0ZzJuZldoY1Q4Sk13TlBDVUhpd3htUlBLL2tlbmJ2U0tuQkNzdUFDQUFBQkJBdS96VUZnd0VEQXNJVEFZR2pBTUl3WUFSVkMweWZsRTFkWEpaNmF6VjF5TXNmaE5Bd0dDbzFxSW0wbXFTTVNoZG9CS2Y0SHRVYmJkeTJkb1N3S0VtOGQySTl1L3RwY0xpRHFSbUhIS2tYYzZkLzVmQkVrQ0k4ZWVIWXZJR0IwTU9GdjFFRGFWSGwyaG9FWm9jeUlocHVyWEhzVkpJNXJvM1Mya1lkamgxTWpuUnhWeGY3UjM3U1VkUHlvYXJkLzdmK2RvVmFsQUFBQUFBQUFYLzl0UENvQ0dDZ0tCUUNBSUdKaEdHWmlBTmgxYi8rM0RFRG9FVFlSTkQ3dWtKNGtDaHFEM01JWFFnNW9zdDQvSkhSZzBrTTIxQVE0T21oVVdZbzJZaWVseEQ4OUNHVnJvRVEwQktXUk03ZlpjRHRxSHVPQ2dxQkJJSnV6L3hweVhHWWxsZW1pVHhLb1FoOEhaZ2NpS2JRNFFaQ3ZOTGVJb1RwTk90TGtqQnRHcWdxOU5QekYzbXhNMFQxTWVOSjUxanhRVnlMTm1URlE5MGVpRHhZOEl6bGNLZi8vL1U5eE5aSUFBQUZPZitaZVJjZ0pCdzZCQU1HakR3L01QVXc4Q3FqQmlrTmRpNHFqQTUxSU5DV3dXRXRLV1ZYNjhLbDEySzZpU21Rb2xVUytZelNOaFNGVEtBSmtlMFZsblQ4d3pxQTduZmNSclVkREdnNkZnYW0wMGtrUEMwMGxGbUN4cUpxek1OQnRqTXh6U2p1WWE3dmNxSVdEMmxaTm1wbHFtNE9jaUdwbnVia1paTWdXRVNLVkp0dS8vMlhVQjEyTWNxV2tBQUFBQUFFMjUvcnovbUNBaGtZYTJVb0FoZy8vdGd4QXFCRCtVTFArMjlEU0d2SWFnOWpSamtpTkRPalpBazZCZk0wQjAweGdFUW10MVZ3c2FPT0ltekRUM1dVY2J6Z2h6UE5LaHFOZUwxQWxGUldWSlcyRVk3cFZsbUVBU2pxNU9kMmpqZ2VPbzBWUHVsZFAxaHIrVm43ckxkRDRsSmlxdWJMUjlaeGxGU1Z0Vk1laG1JeVFMQXlsSHJQZi8vM3QxbHlTd29BQVRjdi8vS2JjT0NBcEZTOE5HRytadm1DZ1Q2czBhOUUzdWY2U0phMFYvbUhGcVlrVmlUempJeFI5VlMrc0dUUWZHcW93cmEvdERLdDlMUVAyNDFvdHJabjkxUzErdFo1ZjNpUlJBMCs4VWZSZFRieXhEWlZNNDlObU40ZlNyRTdsaDJyLy8vL0gyRGx6ZVVBUUFEQUoyNzhiOEwxcHRpQVJqMFcvSWtoM0ZyQzFTdi8vdFF4QTBBRFVUeFAreG94eUdJSEdlOWt5STFDNnR6T2VmK09SZmY1Z1VDbWxBdVBPNjc1VzhTOHVrSVNTZCt6NGpxVGVjVnNVMlU5TFNTcWkyaFBYKzNsVS8zU1hqZGZZTUptRThYbGJCQkpxTHkwanlMbXgxTHpKUVJPelAvLy8wZXVvbWJ5Z0FCQVpKM2YvZ2J6bEx5TmZRb1kwWERPMVpFdGFzekduenRTbCtvZ3RpUjRiN1VkR2tsdHV2aHBjN003aFZDa3NZam5yV0xYSGRJK3lVUFJibW9DdXlVYjY1MG5jKzhIYVZrTjNRS2k3b2NhdEcxRGo0TmpSTVhUbStlVjhqYnVLbzNrd1FqQmpydi8vLzdVTVFFQUF0WTFUdnNNUXRwV2hhbTlZU050ZUExbFFTdFlRVXlvbURhbGl3T0cwUmt3VGxBNU55Y3RFSjZzOHpFK3BSVWE5bGh0ZXQrR3Z1N2dIQnF4VHdzNXMxYlVjOVJSSzcwNkRIWjJkaTU3aVl1RHFxYXAvbWpvbWhtUGhlR3F0V05yYTlvN2dPUnh5Lzc2Z2ErTFU3L1hHNmlveFFBZ0U0TDdQVTh0c0FSVnRzbVBzd2t5aWhOSGx4eDZyRExvTU5ZbkhBMHN2Q010VVVjVE9wUERrT1UyVlNEWnlyTkd6eWpDcVFVMGhVdzRyeENWYWFsLzk4LzNXWnFMMUJsR2R1MzlvZjc3MlB2b1ZBbmFKdi8rMERFQ0lBTEtNRXpyQ1J0SVZzT1pUUThtSFNzZzQwQ3FzVnlLY0JnMGdCWis5emtLaDJrVysyV2xHb0JuSkNiZFZOU2ZRQ00zcFgzSmpJeHkxaGlvNE9UTnNwUnR3VFowS2ttYlFJYUIxbGFIRVVZcFIvLy8vcTFVMk9DYkNwTU4yOXJRUFJNdXppczRBa00rb0hPdWJPc3NibmEvQ0pRTFIveVd3NGt5TCtqcmpEbkpVK0NXMGpBdFdOdFZLa2c0QWxxTmxXQXNUVVNFWWlETHpVUnVCUjdYTFV0OXJrNlhmLy8vL3p6U1U5V1hZZ0JRLy83RU1RQkE4WUlQU2VnWVNMZ0FBQS93QUFBQkNNN2IvaWdBYTdVQzVDNFN4V214bFFtVGpFUWtUWC9qU0lpUXFORmg0Q0dCVUpEZ29KWEVUc05Wenp2LzRpcVRFRk5SVE11T1RndU1xcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcS8vc1F4QklEd0FBQnBBQUFBQ0FBQURTQUFBQUVxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcW89Iik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3 ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUdBQUFIVlFBdExTMHRMUzB0TFMwdExTMHRMUzB0VzF0YlcxdGJXMXRiVzF0YlcxdGJXMXVTa3BLU2twS1NrcEtTa3BLU2twS1N5Y25KeWNuSnljbkp5Y25KeWNuSnljbnQ3ZTN0N2UzdDdlM3Q3ZTN0N2UzdDdmLy8vLy8vLy8vLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFjM1FRQUI0QUFBQjFWVldXNUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQXFRRGsvUUFBQ05xTVcyL052QkpBQUFPQUFBQUFBT0FQUTMvLy8vLy84b0Q3LzRQa0FRMU1LdVRvYW9pWGZXeWQzVGEvaXgyWUlJR0FhNWdRbWFGSUxmSlFFeHczRG5nc0R4ZUF6RktZWU9BTGZ3aDdXY2llZ1R5U1ZDZ0xvVElsSXRxSFJHOUQxVXRqOVREU2hxS2Z2dHRVQnZiaHpEK0c5RGdvOVJPMlZLTXVvaWdjRGVxY040MDBWOCtpdlk2b2h4R0M5MDhwUzRrcFA1RG84bTkzZzZsVjg2bFlJakRCdEMzaFhITWZxR3VuOFdldG9VZDd1TGVrYnZLNW85VG8zVGVJVWRWY0taaFZxbWdhZTRwR3pUVjROdDEzYTJIM21jY1FWS3hLNURtMVdzTnJTd21MMWNvZFpjUW9EZTlpU3ZjWHJxOHU0dkQxMlgrRWdzcS8vdGd4QUFBRGxWOVhmMmhnQ255cUdwOXZJdzlBVFU1UkdKSWxaSkx3YXdPMGRDQklrQllxdlJielpXa3YwLzBFWEl0Y29jSmNLRGluNGFCWXp0b0YxNTJHdFUrOE9Hck9yb1prKzRrcVlXL3J4blVHZlNmVXBjTXh6UnVOa1JadFpkbXpqVWl6Uzh6YnFrYkhOcVZNdGFVYVRxOTNJdjRjeW1URzJ4S1huMllWeG5tMjdjMFdDTzBSREtpU1hXemZtdjZab0F1QzVFM1IxWUxSaUVaZHpGR05zQWpqb3pUbFNweHE5REViMVVTNFZBSmVxQXBneVdpWUtaVDRGS0Nxa2RvWnBCVGlZS1U2U3M3TWRScTFoN1JtNTNYNFRLb205dnN4dzE1RkpOREJxaXNhbGhVVjFucVhpV0k3bVlKVlh0RXJhaEQzSjJlVkZQdC94MEo0TFY3dTFkcS8vdHd4QUFBRUZHSFRlMllidXBMcytsMXd3N3RBU2FGZG1aZHY5OXRqM2xVMTBWQnpDcVl3QUhaMk5CYlNrQVRwTkRnK1B1NjVzUW1xYUJSVW9sMm51SkpXSkl0RWJVbUpwbUlaQllvT3BGWm1pVUt4Q1ViTmpCdExJekRJMkpKRzRLOWhkZUdZc3dXVCsrR2VHY0V0VVpTNnVRazFWOC8zbUZKVHFsOGVzYzJTa3FDN1ZxR1k1T2NZL05uaTcyR1daWVZYdjJYenBBdnUyOTMvMytzNW1YSUJ4Y0RoYXprQ0JndzBBbUFnb0xvK1FwTHh1cmh1NU91M0hvaEVKYlR4NjVUMXNLVzliM2hCZTZsWHNwakNJVWFDSlJXRUR6V2srS25OWlZ0cmZYU0pzZXFFOG84RUx1dHVhSmtCK0o4cVRDYzBXV1drblRhdG9RYThmVEN5c3BlcXlWRTF6SlV6Vm5Rd2FacXlmcW5Nbnk5aXlaWjR6S2tDZ3E1TXNZbUVkSWxpVklSQlg0RGFEVUVSSmVIaDMxMzM5dE1kMlUxa2YvN2NNUUhBQkZabDBYdUdIR3FGVE5uZmJ5TVBFVEFnU01KQzBDQmNJRWdjRW14cERwR3FhcVpNRGtNRFJpV3lpQllhb1pRbG9Hb2tWOHByZE0vTTkzOTFuMnRmL1hpbG80aFRIVmNPYTd0M2U5MWdwM25USWZ3dE16T1lvS0RBSWFuVkRPeDRmUnNLTmxVSVpnbm9URStTRXFpQTNXVUVNeXprTXJETkcwMEJOM0s5bkNQc1haVno1MTkySTdRK29SWUNTSVY0ZGtzKzJrVFBXVlRRelVIaUJ4NVlXTDFBSlJFb1JrTVVhZENtNHU3S25mZG1VTzdPM0w0Q0phcWFreHJKaGhYdzFYZ1FDQlZJQmpLbzBEWVl3eTc1UjFXTWRUc3A0b1VDRk5uWTJWVW9GRStiT1RlanFVSXN5R3ExQ1loZ3dBM2taR2ptR1RYTEtHYXViVzlUY2o4aTFNRTlUTzVHbVpyVlppOTUxdWR4QXcxNlFTSGQzWjJiYS9WRUUyeklBeGhBQzBFbEdWU0lZQUFLb0VzRzNlS3d1V1NDTzMvKzFERUVRQVFBWjh4N21SaDRSdUI1UFdjUEFRdWQ2L0txVG9wd2pCaEQrYUJjaktveDJPNlBIaXNTd3hOSkF0TVVnNG5EallVU3FrSENHdk54dGFXYWxIUzAxTkh5WW9UeXBkQ3Jaa2NPNUt4bGNuV1ptWHc2VjVld3M0YXJMbGNwcVpIZjhwdDJOdDdLZnNobjhnNUpIZHJCalNjbDIvOUNSQmtRZ0lnVE1sYU1ZWXAxQk0yQ29pS2pRa2VEUWlFVUpCVnl4anlwSlJWZ28rRWg1cW55VFAvN0R6b1MrTUhoSjU0NkhUc2kwZUFpSVNIK1BULy85Wk1RVTFGTXk0NU9DNHlxcXFxcXFxcXFxcXFxcXFxLy9zUXhBc0R3QUFCcEFBQUFDQUFBRFNBQUFBRXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxbz0iKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3 ***!
  \****************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91VXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQU1BQUFOVUFBWUdCZ1lHQmdZR0VGQlFVRkJRVUZCVlZWVlZWVlZWVlZ0YlcxdGJXMXRiVzJDZ29LQ2dvS0NncHFhbXBxYW1wcWFzckt5c3JLeXNyS3l4OGZIeDhmSHg4ZmIyOXZiMjl2YjIrL3Y3Ky92NysvdjcvZjM5L2YzOS9mMy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFqamdRQUI0QUFBRFZBaUg0VWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEvL3QweEFBQUJzaVRhYlFSZ0NNakx1My9NNEFCQUFGQUFBQVlBQS8vcmtwb2lJaUZ1aWZFUktBQUNGNkovLytudTd1ZlU2N3VlZ0dENmdRREVFQVFESDRuQi9sLy8vLytDRHY2cG1qVmlBa0FqQlFBQUFBQVFrN043d3dzYUVUVk5JMU9zMDdMQzgxWEFZc1JteVNCbXl5WjhZRmdGU0R0dTVtNlVRVnBHa3RlZ0xDeXpKdXJzTXJlV25XQStOUk41dHh1VFJaK0ZxVEVTZjZOTldqajcyb25WZGh4SWpJNnl4SlJFWGFtbjVkMk5PbEg0ZzZVczdHM255b3IvMTY4ekxabVl2eHFpcDZTNy9PVGRTbmgyMy80YXRTTExMT250VWxYbXNhdDJBSUZtYWIrVUhLbkk1Y3JkeHo3VjFuSUlqVnpyMDg5blkrYnU2bzRobHp0K3h6TGRYSDg2MXJMK2YvZjdTU2k3enVHL3ZkWmhVRUFBQUFBQUFZQkhNcDAvL3VreEFZQmxtMWJXOTJIZ0Fzd3JtbnhsNmFvZHdCZGRTVkR6dWRBYlhGWW1CTTRtcEUvalZWaFNZRnZJQ2pUa291VGxFSVR5dFl6UlhaY1I4bjZISTlQU1I0bm5KaE1GVkx3VkthTGlnU0VtYW56eWVEcUZ1WW5hNHVwVU5Kc2dodXE2VTZVTmpuUUVHZnpvWHQ1Y2xTOFEyTkhMNnk2ZlR2WTZ2ZVduYm5UYks4M1YxRGk0WWxkRmV4RzNFZXJiVzd5TEJ6bnp4YlozRXhmMDNUNjk4UW8ydmZ2ZmZlN1ZyV2x2OFl6ck0ycXhMWmc0N05mZ29kZEovTmFGRUFFb29IZ0E4VUt0cVpEb29zZEtHWnJuWVNIQWhpQVFPMnJXbjJaTXFjdktDblZ2RjFXSnA5NkdBQzQ4Tk9HTGFoZ3JpUUY0UkFRNFVweVpWTXBoWkJuaEFTQUIya3RSNTdOU0tMR09nbUJmd3JIeXZJU1F0SkNZS3Buc1Q0d0JNazh3RjRId09jSThlSllTaVNZTzRzUzBVUlhHN0tyMWFoS3dva01QV3JDR1NBRXBoNWhHSlVBOUthZzRBVW1XRFFtTUVJRUdHQ0ZEMUFxK0NaUm9kazFaNWljTEtQZE5sbTdaYm5zYjlmNU8xTHllVW10T1V5dXdSWEJuTXBpZExjRWd5eDh5NWhCVkNLRjJhdFNaQU1TZ0FpcHhvUXc1d0w0V05LZ1VJdU9MQWRwTmFsYjEzV3NPc01CSHdDV1FCbG1rQWVzWHA5YzRYR3B4cmFLc2xiVFZxUWF3V2F4b2I3cjEwTGpTcm1FVXVuSkZoWnZ4ZzZENXR2RjNsT1hDMnhWLy90a3hDdUFEK2xoYWV6Z3dXb1JMdXg5aGhqZGVrdnJZSGJOZjFWUG1kdlZWT2Z2YUd0c2R1L205cDJudk5XK2Y5UGZwMExwZFFBNnh2aEF6TzdxRUlqUVJBQUJMbkVVUktnV3VyU0hwZ0VaRVhqQUtKSW1DMGdKVU95Q0lSTTVKSDNWQzhKV1ZUdVVBMUl1UlJMZzR3NkVpUzIzMFJLUGJQRHoxakNMeXJTZG1OU1dtbWtLM0dvbE92TE1lNWVST0lCODBqQjNRcU05T2kxNVIwYWpwK1ExYjhwbnBrejN6NDIvMFhMTWhmM0hwdHg4N2M2WHV6Wmk1YkxsTGxvOG1OV2Jsek16RUJCQUFMbkIwU2M1MWptVld1UXpVR2RGN2dWQjRKUXBBcWVMRUEvQ1JxSW93ckhVNXlLMGVTUlMvL3QweEJjQUVLVnRYK3l3eHFvdk1DcjlsaG04OUxWeTNKRzFaRlRpU0t6a0MyaDlwSXhFeFo1Wm8wb1h3cjRRdDV1Vkx2dm1YUzYzZmV5ZzJQelhPckRVWHcwNHNMZUt0SmpMalhTK0piTXY3a3ZKeU4zbmJ0TjJaMWZXMUovNzZWc2szWjUrWlpjVVVLVnpUTXFoQUlBQUFBQlU0a1FZUkpuSm1KS0lrekpKWThocXl0Wnl3RlY3T1pZZkhGMHhZbHZkcTFDaFdmem5BS1JIRHk5Yy9aK2w2SDdoTWpYVzhxdFdyYTkwbkxZQWxOVURmWlZFWHRxb01lVWtsbWY1dEZROFJ1elJ1RlZyc3B2UGlQTzVaQXBZbnlqTHY0cW14RjRmbWdmVkpweU5UTXRXekcyYTdmOTdtWDk3VG5FMmlzTEl4c2x4OGxTNm1ESUNBQkFCQUtuT1R3RHdFVEFaMXZnQWpiRjQyT3c2K0RzTldzV1lwTE9VOHRtU0ZEa1cvL3RreEJRQUVGVm5WZXdrY2VuN29hcDlsaGxWRU1aeVNIa1NKYVNwYWRrTlVpbk9peXNZeE5JMFRKTmNZNUJEUkZUR0lxdFpBZnlkSW93VlB0ZTI3bkp1RzE4RHJSQW5EcjNCQmZCUDZwUmIwSE9oVjJCcDVIODhNYVg0R0s5aVJpcTMxbkpRR25ESmRpY1FZa204amt1eUdZQ0lBQUFLVGprUnJPZzBZRWd1RUNta2tVMW1aS0F5eFlRVmx0Y3pxbWhaU0ZXYktDRTB3VlNpZ3FpUEo3TnNnQkNydUZkWkxBWDdXbTRjQmJ4NlJ3L0JTbGxIVGptU2pFMmF6bDQzZnZLaUR5bWZ6Tk8yVHZMdHZ6VGtETW80aWJLdFFjYnlpV1ZqRGh1UTJSbEM0WkdKLy9WSTNKVTMvL09iWlpxYS8vdDB4QUNBajYxaFRld2tiK242S3ltOWxoa1VobE1EQUFBQUFDbk1WV1lKaUFWNVpVSFlRMGQ5cExQRk5vczFxWDNxOEQyaU1Jb2lqRUU4V1dlNlZFOWlJU0VpeExVbnZSU2ptUmltOUluRmJsb3NxS3lTeGxpVjRWMWRMWDE3bHpDc01DTXgyaVVwVFJ6d3JFd2hTT1VwNFZES0MxL2lJNStWL2hPOXJKY3VlV3JONUwrUzltRlp5UWQ5cUpYNmZQVnk1RUpBSUV6Y0plTGRvR2kxaUc1dWhBZ2xxYTJhUUNoc1MwcDNDSlppVUtXYkRFQ1VOdzZROVBVakVSMmhSOXNVK21NZGVOeUxHeXdyNWJLMDM1cEdMdVNGcE9KcWNNWEVXN29SSnJzMFc5L2s0ak5iNTd4M0lvNmVwc2gzWkhJcWN6MDE1VUhjd3VGbDRtMHoxZTdRWG01clprUTNjNEZTd3VhaW1wV0lobEloQVFCQUtUM0xhQjhHVkhEZy8vdDB4QWdBRHdFclMrd1ljNm5ZSTJsOWd3NDBlWUdGVmlIaHNDUU1XbEFqVTRoU3lUT21vY1BrZmQyM09ZdHFvS01NUEluRTJVWXhBem14Mm4ySXV1cnhYK0VUV1ZhQ2tIa3pJWk9pQmlTR29Sck15WmNNZGxKb3ZEUUZDTkJCa3JsR0JudER3UmxyemZ6TUNoT1MrT2I3WnNyL0p6VXVkZG9xU3QySmRrVXpRaEJTU2MvTUJ3bTV6Q01XTkFSMGhka3ZNd3FER3JPOURiazdwb3pPeTJNU05Gc0o4bERvSXg0RkJaVTVWYTdKaml0MHN6WnM4b3hLN05RSkgyaXhtbHlKa0tpVnlPd0VYcU0xd1FndW1IUlJPMUkzaWpwYzlTRzZPNHJKOTZWcEVYMzNFa2JBSVVGYkhFanBKZzVVajcrU2pKWlFSQklRZ0NYZnplSWJ5SXZuUFpNMFp1Z0ZMd3RQVmU2VGpRUENuNWJuWWkxQTRrSlBuTWg4bVpRcy8vdGt4QmFBRFpraFNld1lieUc5SnFoMWd3MzhWempTQ1NNTlZybitjbEpEK0h3bkZhdkNDNVMzTVZ6SS90SnRkMkY1Z1daUlUyTjVsamtLQjlxRTVhbTZsb3VlcHp4Sjk0bkpMY0hVclRtOXpCV3pzLzFhVERBQkthdnEvQU1kWklWL2lJQ3IwVnBZV3o2ZFhmQU80SmlFTDY5Q0NRT1RrNG90MHYzTFlsVEZsSi96cDUrdCtxVXlpc2xSYytvSTZFTnpZMnpUaDg0TUNCUStVZ0tId1VYcmZwQmZ6ZjhyYU9qMmx0Y05qREJvaHhLU0pPaVlJZ1ZJMkxnY3hCODFPL3Q5YW9pbk5ETWtBTW9xYjB2K0luQ3JFSktHYXdISkJRRmZyT0Z1TFhZbUJvUkZtMlJTMWpZaElGa1kyYTdXLy90a3hCWUFEaUVMUSt5a3l1SFdvS2g5bDR6a1NPc2l5Vk1TUW5RcGxYNGFmU0J5UUxXbnhyMVJ2ajVGTmxmejJNdjVmYzYwYTNQOUxSV2l6YjJqTnlrY1lydTVJS2JWOXU3dmp1WHpxemdkTUI2c05vQktULy9xaW5oRE5rSVNrbEovalFLUUVqR0lGWVlNQ2xVR0F3MGFUT1FrZklmaXJlSWNjc1pjTXpyY1lLd2NDckZhQ01ETUJMREVZQ0pNWXBJb1JqQWUyT3dFemdETUdLd3ZhcUtGQ2dNWWNja2NSUmFNY3VSTWJFRU9JMmZSeVlJQml3SWpQWkFZb05qTWNKU2gwVk1Dd3RGUWdwVnl0bE5QU21tSmdqSXlFdE5TLzF6QjdRZTh2OGdoQmpBVUFNUXFva0hNdE9ZZEJzSWkvL3RreEJBQVRvRUZRZXdnejZHbW5tZzluQmcxRWEwSjNGeFV0VHBscGhDM21oVEhtaXRvcFl4VjNtTXZPY0tRWFRHVTNJdStEc2FhZDgxSW92bWpsdXpJVGZiTm1xbFNhRU1yY1JlNWo1djAwa2I0MnAxNWdpVEVnakFZZkhwbUZzSkp2RGdvei9ib2VwVjBJeUlpNDJ1TU5CQVB6TEJJRXdoWWtyR3lOY3pacTd0d0p1NThRd0JtVURYS1MxNWNMbGRvU1JNUFFyREhpMDN1MUVjVHhFaHAvdDJKYmx4dXBaRkxvNmFLdTNPeHBxbS84M0MzanhjZW1kbHZNYXlKZEV6alFDWkVJYkprZTNxOG4vSC8rL1ZNMVZtcWhYWmxOK1M3OEI2aWdhU2hBMWcwbTBmSXRwcERrRlJESFhHVC8vc1V4QTZEeWdTclArZXdhU0FBQURTQUFBQUVGYWRYZHMwdVhOcXFycUZBVmF3MUNnS05HK3F0V3JoZ0lVemVxa3FscXpDanUzcUZBUUU3K0lqMEZSTVBjSlZoM3kzSXFreEJUVVV6TGprNExqS3FxcXFxcXFxcXFxcXFxcXFxLy9zVXhBdUR3QUFCcEFBQUFDQUFBRFNBQUFBRXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXEiKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3 ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a21582283f5e3a2b8aac.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3 ***!
  \*****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8e9056727657ec509d3c.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3 ***!
  \*******************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUhBQUFKK3dBZkh4OGZIeDhmSHg4Zkh4OGZIMUZSVVZGUlVWRlJVVkZSVVZGUmc0T0RnNE9EZzRPRGc0T0RnNE9vcUtpb3FLaW9xS2lvcUtpb3FLak96czdPenM3T3pzN096czdPenZQejgvUHo4L1B6OC9QejgvUHovLy8vLy8vLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFVQVFRQUI0QUFBQ2Z1Ly84M2RBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQVRnQmg5UUFBQ05Oc3UrL05QSkFBQUFQQUFBQUFBRDRZL08vLzk3cVpscVZJU3BEQUFDQWlNQVQwTGpEbkNCQUdNY0VSN0lpQlpNMHE4elI0TUJMcUdBWmM5UjlYOCt3TkJxSWM0ZGJpb3AxMUt0d1ZsQ0dCangxQkFWRWQ4ZU1HTXNzVWtrMGFyWnBjeHIyalFYaTRwdkVzZXo1SkpTaVBlK1J4MDVUc2NqQzFTTlV4UERSYTFPYkFiY1BHNVkwaTR0UnBZejhXTVd2SGxVUjNtR3ROemZWbWl0RXB1WGdidlp5OVpzL1ZzMHM2aFBLeFpzdWRNdnNYclNzKzVZVWRUMWZQV3l4eHQ5SUVPUER0U3pndHg1MUtmam5BaVJIWHZDaDZod0xOc09tOFJ2ZVhRTnUvL0x4Q1pRcTM4cWFsalk3Q0FBQVFzTURGUmRZalZhTy8vdVF4QWtBRUhXWmIvMkZnQVFEUFNwNW5DYjRxVmFyZTR2aENxS1h6L0xjNUtMV3RmVTF4Zjk5T2ZUMDJUL3ovZk16M0U4YmRNbXMvcGZyT1B5NGVreDZ2dVExTHFwaFdkSHhyb1h0TEpaMzJsRFNBT1ZNWHh5MVIwc2UxZDlXakxuVGQ4Y1ZzbWVKcGtxR3B0ZnRxV2RSeFViS2xrUzkzRlZicmQvbmE2L2piVUl0MlJkVjcrVkVzb21vQUFIa0VzR1ppcGJFUW1JU0ZBUndFZEdSVmZGSG1JUEhEa0VUZDZtdVJhTldzOTVXN3VXcm1WQmY3K2RYQ1UycHI2bVdYM01jczZUR1pqbFRXVldMVWNUM0E5S3FxcUZTT3ExeE1sOCtYSTg1OHRlRnNTYjY1MFVHVFlZc3lhY1BHZmlrZ2RESm96QlhuaWNkZk9PT0U2SmUyWHd5NHpvSm4xaTZxSkxOV2l2MUNKcUJvdzVNTnY2OTBUYnlVVExTMzVobHpaTkY4M3VpVVJnV0FYNW1iY3FneUtaME5pa3J4cDBaUlQybVRPVlNTNmViRFV2VWQ2TFM1M1pYQmxTSFJNakJFaEI1RUV5QURTemJZN0FNbGlRQmpBR0ViQzVRVXJLTHhSV2ZWSEQwekxIYkxJclJMK2NJNGxaTEJETlM1bG0yZWZndnFzSlNSWlcrL2YzNWxTd0FBRHVCblZoMkhNTkdTQ3pTNmt6SU91c1EvL3VReEF5QVcwSGpVOHpoazhLeE9Pbzh4NmZCaUR3THlqVVdqVkZRVEZMTHM4L3h5NTNMNm5PVmN1LzlMWjVscjhONngrdmxFdDQ1WmRzOG9ybktSWmNVa2ZaeXMrOC9uVnVTaXJNdXF3R3k1ajNYOWVCUk5TdDRVS3RyWkZuUE5mazdxM3BMS1d4TjkxL0pjMWw2RWxYUnNTMnBkczNLV0lIN2k5Q1JuU0NxZnN1ZUswQWxLbUNzZG52TW5zVjFkREZsT1RVN0M4UGl5MXNLcEQxZmg4cG9kRm8vZ0lITlFlNll3L1ZveGlhVHBETjZVUnE3N2VYVFh0ZjVYWGV4NTZCNmFQWlJ2NG1ZbHpPWk8vYUdINmY4YTdKN1haemUvdjY0U01nQWZWR0xNVHhkRVVhQUNpU29Ua0ZNbUVZdFhxMFRoK091clAvOXE2NDl2MjNvK21IcHJTZXExYUJiYkxXcnJTNTNSeGtuYjNwKzJZRS9hb0dwNTFxMjVSNkpLeGFGdVE0Y1RsQ2FrOUkzQlloSVVLb09GZ050elE0dExFbFNER2RCSktldGVTb0dtV2M2aU9FY2tiTHBrTktpSEN6V1RKTlZUSmNZajlZMlV2RGFtMVNjYWxHMHB4V3RFK1VjMjNSbms3aHEyWXJjYXpVcFI5WHZxUHlXZkhaR1VtNlZpYnpNN3JodmtRQUFCc2RwVG1PUjlLSnNrd0wrcGtocmN2LzR1ZVR1Ly90d3hBOEFVZGwzVGV3RklRcFNNdWs5UXpGOENkNFdna25DVE8rUCtNMUpabisycW5jNktrN3E5cTMvUkZYTWlvaUhtcjZSR2VoNkZLNGkzRWpWSjJNdWxaQ3VxV1JTVDZlVkJWS0VabVpYdVpLMTNSMi9kd25VSi9wc1R4bk5WVmxLdGN4cWFIb21yOHZIM3RXejR4dUh2Rmdyb0xMQ0dReHNYZzAxcjdkNDJpK2kxUFptcXU4ektmeG9BalJsWkhkZFRMM1B0L0RVSUhHK3Q3TVc4SDh0UC9xYlRUb3c2V3JlNXR0eWUybDNtbURZOW5xbXNYYktuMnFrRjQyTnZhMEszRytYRVlwa3p0eDc5VGpvKzZmWFFFb0xIekxLMkJwaHc2WFlXdk9UemVjNXJCNVNQbFUrWk90dGFqRUVQT25LTGJXWnBaYmE4R09IekxuczEzVUtDdldmaVl2YWsvVm5xVHN6VCsrdGQ2Y21Yc0EwZHJVSFZXcWFxcnJMajZvQUFBRnU3c2JQU2VndGFWSldrbkIwRnBPdmxwcXhadi83Y01RUEFGRlJiMFBxSVkvaUx5em5QVVF4L0RtMFpnaVBoWW14WFJSWTRYR2M3Y0Q2ckVJSWgvUEJ0WHZiSGpvWTQrbEtTVG1jdWFyU2dlMTFkUkN3T24ydmFIYUUrSnJtV2Rjem1WTFQxbzRMTzErN1gvQXFkZHBsZDI4N1hwY2duYW1TNjAxWjZiMXMxOU5kL2MvZGR6K3RPclJLNklvR0xuUmhVaGQ5L3BOWGQ0bDVxUG1RREdxVDNkOTFXVnVxT0NCR04yMWxDaWl5Wlh6c1Vib1p3MXNnN2dRYjJ1NHJ1UU9zNjdnUW1aWEtsVUJWRHoxbW9RWW0rVDUzQVBEMXJ1dE5TSE1LbUZEQnFYUzZwNWxpNjR5aEx6VS9pQ3R6SjlkaGNzcWM5cG1QN3FjWllqcmRTK3V6MXp2V3M4ZFdYY3pUVVBGenp6MHpmTXU2TGdvT0Ryd1JGcFVaSUZJZFJSMmExVmJLTnY5NUVBQUFDTU1LVERweUJsNDBRbzlQUnQvL2xyZmFadm1UVitqeldjejI5ODBvdHBXS2VjYi8rM0RFRllBUzlac3h0VVlBSXRVaVpmODI4QUVydWIzMi9zWVd4VFYxcnRubE5ZVkpUZkxMMDBLUk9OMXVYS1NRZWo3N09YUTFob2pmZkxvbkYwQnJOWEg2UHBrcDJldVM4NGhXbGlyYlZvcGZaZFp1djFNeXpBOUg4VEZlT0ZLNnpIeElXZHp5NUd5ZTdldjV2UXZYcGZPNzV0czczejAyeWUrZnkweEdSMjVpR2hzeUl5S3FyRHN2K21oamFRQkFCT25ZRVhuSGpIVEFlSXRlaFFqZ1lVRmhRRnozTnhjZUJVQTJMblcyRENLN2M5SGlvZmdDa0E5QjBUenE1aWMxR3BJcE9qZVRhaFhWa3NmcWxSREdYODE0WlBVQWhSL0tQSjJLbU5keVhucGlwMWFMQTRuNnNzejZQRmNZU0R1NVpVeVlPOHNTSkpMZHNQMVU5dVpzNE5kelpMS2FLd0w4T01uMUhXSk8raXdYdGErRGExL211YlgrWVUxNE1IWFpJMHhKTk1hRm5ud21YUHhNL1lLeTI3a3h1UzAzT2dnQS8vc1F4QUVEd3B3REpWd1FBQ0FBQURTQUFBQUVBMy9vQUFNRlExLy96dkVSM1dHK0RUdjROVXhCVFVVekxqazRMakpWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlU9Iik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3 ***!
  \****************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUtBQUFSVWdBWEZ4Y1hGeGNYRnhjNE9EZzRPRGc0T0RnNFdWbFpXVmxaV1ZsWldYUjBkSFIwZEhSMGRIU1ZsWldWbFpXVmxaV1ZxYW1wcWFtcHFhbXBxY3JLeXNyS3lzckt5c3JlM3Q3ZTN0N2UzdDdlK2ZuNStmbjUrZm41K2YvLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFYVlFRQUI0QUFBRVZJMC85SEpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdUF4QUFBQVR3QmhkUUFBQ1M5eEN6N01hQUlBQUFBRHdBQUFBRC9LWjA1bVhyMWJRd29RV0NBQUFBR1lxVkFDbURSQ1MxZWlOaVBBTkdMTUJOd29WWXk3a2ttZk5qdVNpQm1Cd08vVURjZ0J6c0swcC9DSlNDUVN0OUxlNlNkeHV6RDdWb25xZXV4WEdFeHVyYWJFek40cVBsUE1RL1F4REt6TlpUdDJXTk5kbDhaWSsxaU96bWN3NnFSRmU3RytSSnlWT20ycFhCa0NNaG5TWndteVNiK3Bqc2hwM0VyMHRBUkUzVFpWRHQ2V1JkKzVBUkFBNEdJeVFFR1BtckFyQ1h2UzdvNE5vTGNTbE5XVlh2dElURk4xUDM0OVpwZTRYSmVaVU9iR1VKRm14dVN2Uks1dTdISGRiNnBXb2JtZGVXWVc5MlByMDl5dG45KzFLNzlEK0dWclY2T3NTZDUxSDZjcDdwR3p0cGpFWjEzbmVYbXllV2FpSGFhUXZmcTMvLy8vLy8vLy8vLy8rYkNuNW1hV05UT2VYLy8vLy8vLy8vLy8vbzZDakFFZ2hwUXVsQXhpTUR4R09PMDFaWE8rNm1JaFVRQUFBN1FZWU9xemttTElYMVdCYnh3MjBwc3JVU3A0akwvKzZERUR3QmZ4ZWxiM1l3QUEvODhLcm1FNGZtYTluT2hzL2hqbnZ1Vk4zV1c5ZmhqK056T3B6RDkzZVM3SHRqazd5eCtYYnZOV3BydVdYMDBTMXllL0hXTk04OWZjQThZZkNhWGtQV29oT0tyTkFpd2dDb1lBRkd4TGFLY3YrejFvVHlvYXNsaThmaGM3RFVZbFVLakVRZ2FpaWN2WkEyMENOZWdFT0FpQUNFR0VnbUdKU2lKVFQrMDFMTDM0amNwbGVlcHU5UXlpbWw5TGpacHBkYXJWS1BHWXRVbnpWUy9EOFhxeGFKMkt0bnRiQ3ZVc1lWb2hoemt6VGR5Z205ekNDblJuWlQxL254WmpGR2N5SjZFRmxOVkRSVUJhT1FJUUtlcE9zb1pyOFVoVWppMFRxMzVYTHBwK2R3MWZ2eW5tUDhtYlUvKzdkeTZwSURUSlNXeE9Za3l6bWtJQWhReXBMMWFTbER6eHAwSmRGSTZVSkpFOGJYbTYxUkV2RDVzRTR5dVZOdXk1NjIyUkJzdzFOaG5kbFd5OVQxWllVdUZpOVJMdVY1Ui9aRkhvK3JYRjRsWGpja2NKbWJNazQwdXljQ0lJOVJ4bjdnSmthcXMyclc0VU1OcTRWTThUMHZsRGxtTlMyQjE4UktXdTAzSXRjNFRpaFdhQndZTVB1WkRwRHdoL1hubGNqbFRsT28vY0x5aDZSNXpFT3ZyTFhKdVc1alZyN0VQUlRLa2trelFWTFc0SW9aOTVOMXBUU1hLWFc3VmJHbmxIOXNURXZqMDFQemROQnNwcjJIaWdqQ0c0TGE2eXBub29OUVpZWm5JV0FMdW5nRWVaZnVmWGRlZzZMNXRmcjBzeEtNM3FabzUwL0I5eW10NTJSeS8zK3lxbHpvQUFBQVFTTmRNS3dpU0dva0lnd1gvKzZERUNvQmZJZWxWN0pzUHcyVzdhdm1EWWpGU3BpakVHTDFZR1p6VnBvdG8wR0JBVkp4eURaTE9RQlNvT1R4cTdvenlnTk9qYUFqcFBRcnhsUExtNXlKMXRibTFWaDdOVmVzd21GdFRkQ3ZYbmJNTmRWbHJKVVBVREtsY20xZDJZYTRzMUx0Z1R2V1lQZXAxWnljaCtsamI3VDhaZisvRzNsYTB4RnpGc2gwRHFnSG5CV1M5QWtaNUhobGsxUXZwV2ZlWFJxOUk4UHEwOFNsRS9uS3JkbXpqMjFsTmNwcTlKblZrbCt4TlM2bHF6ZXV6MXptRlBUVEV1eG5KNjNjM1V1MWIwb3dwcEJadVVtTG1yVmRsbDdMMytMdk9zWGdRY1pjQkJNR28zM1RHaHVLU3A5SEdmbVZkbE1vZUpxZGF2K2Nad3YvbjJ0eTkvKzdieW4rZ0lGQ0NhSzYzMVZSVC9XbWxjcVNXS05zdFhhNnRUR0JZQmlOeUdpUjVNK2Vjc2o5Ny9IOExCVEVzcnJKSk1TSkM2MXRrMUdjaHlCT2NtbitmMU5VOWJHZGlMelhlZHpyWGEvTGp6Z1FLSEZBMUJDMDJWeUYwblRYVFpwYmR1ZWplOE83bjZDN08xdE9QRGJvVGNCT0NEQkR3bWNwTks3YjJhZ1hWTFVuNlNqdlpTN1BMdllqMlU5MXY3ZFdwYXp4MWQrN2RsdmNNTjluNjJHWDVjeCtyanJlT1g1WloxTXJGQlgzaGxsK2RXT3VFakczWjJiRURNN1YwOHI2RjdXbjUxb0FtN21jMVRaOXI0OXh4bk8wbFhtVE9WWjN2Ny9xb1NsSUFBQlA5b0FEUTdTdkV2WC9kcFhrdFZlOEV4TDI2VDF1Q0NLRnc5S0VWK2FxR01KcTdxcCtaclBwQ0FWaDBLcVgvKzVERUc0QmJ2ZDFSN0NNUHd6YTdhajJEUGpHaU1QZmFYMnNmc2cxZW1aYW9zamVyalAxYW9WUFh1V2VTbU1SOTJ5NFVUVUZhRzZ6NVE3Zzd1VW9sc0F4RExLaG1iR0ZxZnhsc0ltMSt5MThJSlNJTGNnZWo3ZzdDNG1idzVTejlxelB3NUxjUDVsdktnd2wyWGF0QnluaWxXVTNiZjU0ZHU4dDBMUzQxSUpaYndvTlpmbmpseXpVMS9MZmIxWERDZCtyYnBKWnl6N2M0WmtwZHArSm5MTmM2MFkyNUN3TTFhbFV1bkpUcVVPdnl0dmxKYnNVOXU3cWJ2VnYvdWJ0eTFTUUFvSGtPZ20rWUFIWkwvaW9rWmw4WFhOY0M0OGtYaCtmczBtY091Y2ErMXJ1aFR2eisvcnc4U29wWVdrU2o2MjF1VGo3Vk44b2pYdUlOWGxqWHVGc3ZwM1JiWmd4dFYwaVRwSmFRZ3YyU1NzNTBNYVBtMTJKR3hZOHF4ZHRjSWpBOTA4R2FLY0E3TTVVQUVnQXRWUVNrRjFoellKNTVJV0ZtdS9tRGpjOXA3c1dvL2JiV2x6L0N6U0IxODYxSEhYM09LMVBNMjN1dGNVeFdmUGxwZUJTU05qU3NmTmk4cHBRYWFSUnlOSks4SlNsRUpVcDJRNTlRcHNkU0VtZlUzRHpNK24rY3ZJV2x6LzcvLzltUEN3QUFEc0tTRkRaVnRKeVFCRGtHT2dyLys2REVDNEJjbGNWVDdKc1Jxdys4YWYyRFBmZ0pEcm5NeWpFY3doTVR6bUllbDdWU0dtSFJCZ2xsbXF5ZFlqU2JQU1FnQkpzL2IxYXQ5ZDM1RjVadDliMWx3YStUNnV5eGxacnVTeXpLSm1CcExOUENLQlJWWU16Y3Y2b0luRys2MVhLcnRNcFhXbUp1ZXN3KzdNTlN1TjBNb2ZPSUR4bGZGNlI1cENRSXNQdWw2Rzc2UTVEc2lpVlBiaU1BeXVtbzlYb2R2U25HWWs5UEs5UytEWVhOVWxOVFZNb3pobkVKZGczQ3ZDNzhhN1FVVnJsblBQN3V0OCtybHJYSWxjbUl0OVc5WDNaaWpXV1NMZ2ErNnRKMlN3eXlHdGpSMHV0NGZ1Z2x1OFBGQU1rSXBPOTIvM1hUMUpBYTY2QjBJdmNta0lUc21TZlVmY2g5bXhMMGEvZXlndUpCSmc2WTFZSFduNlczckhOL241L2puTURaalo5eDI5VjN0bWJXYTU4TkYvYVN3OWZFOGNHeDVHeG1EZVdpN3VreURxRnhWcXNUOEZjcFJ3TW1MU3o1WTNCbGI2VmoyTDhhUktnWHJtUzR0aCtBT2ljYzFLOWk1MUcyN3Rhc0M5dmRsbG1relAzMk1OVlBqMDF2Y2hrUkc2Wm93M1Z2di9PLzk1MS9mR1pLWWk0dk5CeHRxUmdicDRLdGRkRUVKRW9WRE9oVWFCTTNWM3R0aFZqMXhuZnpEemovMm1XKzdQL2YvSitVSUFBSG9yR0JnV3ZMYVg5bmdscXpXT09WU002cjZxUVJMYXNNeTJYWTB0MTNyVHBPb3NMb0ZGaEJIMWpBbVEwWTJPQTRaV2ptUjJ4Znlpemt0dWpubWx0M3o0Y1JsRnpRbER6RGxwSmRyaGFoVFFzUnNiOXJXeHJOSWF2LyszREVNWUJWaGNWVDdBM3pTMCs2cWIyRFlqVlJxY291RVBNZVZGU3c0bHNZOHN1dFNZeld1dFpyZkZzNXhyT3YvL2lGOVZ4OWZQK1BiZisvLzkxem5Icm42M2JPclBVU24wc3pzVkdOV2xpYjEwcXJzdHNhMXFYd2tyejkxbWJ1LzIxUGpRRFdRTXdwWTBmN0ttN1JPSVE3SVlKaGlXUmZLUnhYSzdiTmZuRkhheG0xMEYzMjJuSTA1ekZtRGl4S1VuWnU5c3gvMGM3SmJ1NzQrNG5OeTNMWmhxVkxsbmpYbHN1cHFOcktMeVhUVzFUTlBpa3RkcUhhV015bWxuS1dVMG1YWlRLWm1XempsUkJlRDl0Z2hsOUFkWlFJdmF3Rko1aHpyeDdQS1lqMFRzek10eHBkMGxxVlJXMVdsV0dFM3pjMXJlUGFXemV5ak1TaG1XUmFsbmNhdUdPV3FuZWJxN3cxbG4vZDQzYkU5L0wrV2YwME14T0x5eWx5eGhseG9WZ3BqUC9xbHE3NWJyZjN2L2o5N29wNnpOek42bjhMLy91Z3hBT0FXVG5SU2VmbG5xdHZPZWg4ODJJMUFBQUJIUnpSY3BGdy9nSlZncE5TdWRQYk5xbGIzOEdrbDkycjRXNHRjMHJXWGRONnBYZXZkN25IMXExY2ZXOFp2VE92NmF2L2p3TmFnMnhyeTloYitUZmNzSzNMdFNuZWRTMkgxcnZpcFk3Vzg1VEdhU0xUcnU1M2R4aXRHS3NhcVJDWHRrYnhob0dEWktJQTNkRDBVSm90S0ZBSEtkK1cwR0dweDlZM2hyQ0hZbUZVcjJUOVV0T1I4WVo1WEZDM1cwRHpBUmg2WUw3VVFwMi9iRFQ1K2YyMGZ5NzkyRzBPUzNSOFd2akFFa0VxR056Z25vQmtUbXY1cVBZVXFQdm52eUJab3FydTgyNTZDQUVWelBxTklydTlWaUd6d1dDcjY2b2M0OEZiV2FRV3RKQzZFQlJVWWlDOS80ckgvZzROdVo5MTN2ZmVVL3R2UU5UUzlKR3lKUnRSSnpKbENtbi9mMVkvRzU1MDBqbGFXNk1yU3lZcXB3dFY2MU9ZZnBvKzZEWjZ0ckZ3WURrY1BTQ1h5V1h0d0psRWdFQUtONkRZaDhXbldLSlJZR3EyVFBCR0tXckxyRURWNzI2dVVWM1NibnBUTzFKNmJsOWl2SHErKzBXNzBrdTBDUDdUYkxZcTl1UFV0N2wzTFA3dks5WERPM1pxNDNZdE0zNzFXYWxjcWlzYWZ3dEM4VFlYMGkwMVJ0ZWV5Vnc3UzNQdVZ2M2VxOXgzbDk0WDFXbTdxOHphcngwZ0FBZUxqcWlGak55NXdZanIySkNDUkZTSXc2QkFNd0htbjNMM3N3QVlNMzJEbXNFTm1TRG5Fa3phRmNVbVhGWEU1UEJUTWZpdTJxa2RyaUc0b2lidXg2U1VuVWRWQ2Z0eWxaRlcxeXMyLy90d3hDc0FWcm5EUitTTjcrTFh1S2o5Z2IzOHQ0WlhKK3c2VEFtcjhSc0pHVEVJYUJQRG1KZWdVZkhhVmE4cHBTcXJUajYzbWV0VzRMOXpwSkRTN2JDMWFINlBzT1dteGxYZFh6SmhxbTFuMy85djg2OS9qRVBVT3VyN24wMHRZa0Irb2F5VFBvYVBWYXFkN3JqZjFhVmlDejVaNnE4dk4zWjl0QThlMjY5RmZ0WCt3MzI1bFZ0WjFidm1HTUJOUlowZ3JBanJDMkVvVE9YWURBUWdRQkE4UXpDeWozSXhBNmZ5Ui9jdGxXUnRpcU5DRkpEMU42UklOTzJvV0llcHRSbXd5bVJoUWcrVTlDaXNiYXJydzRUeDlWNHVEU01JNEFGWkZua0thU01CZVNwbFBscFcrMnJ3SXVZdGJRKzFScGR6WW12QXZsdXB2UGlaZ1JEMFNMUEdlUGN6eGZxdnZySHhqNHpTK2NidjhVODFLTHVveklpRU1YZ3F0RHFPMlhGSm9PdGVGRDBUWEdwNWlZbXF2TDljQUFBSnozVGNlUC83a01RSEFCZVp1VUgxbDRBclhEc2wvelZBQUw5NXpXUGQ0N3ZhNzNkOVY4WFVWWmlSSU0wT2xhMHZuT2QxdFdQTHJ5ek0xc1BhVFozdXo2TnUvM0d0dk5hMS8zN2I4SEw2TlNoK3dJTUdMdWtkcm1NOGJRVndoNGFUMVZ1VWpFbDNGNnBzOTl1TFhiM2ZaWGJzMlU0ZkNSUnhCd09ZU1VPVWxCRnZ6aXBtV0N1Nlo3VnFGU3NyNmFLMVE2d2MxMUJtemYvTUNNbms4cTR1TjNnNTFXRGlmNi8zdmRyZXZ0ak90YXRhVlNtU3JTN0Z4bFlueXhBT1phUGVQOHpJTGljUVgyRU1sUkVRR1VIWUlRUEJtQUlRQ0FBQmQreWRESklyZnY0eTlvYkF0L1VwR25QVC9sc1hJSzJKUEZzRUtFSUlDa1dHTjQwQmNBK1E4QXpKMFpVdGVHTEJDb3VNekZiRXlPYVZTR2tGK2JCaEUzSlVSNklPT0V5ZUljaVE3OUVyQjY2aVBFUkFpQUpwRkZBeFlZN3ExQjJSa3lvSVNES2kvRnlGTURBZ0NHam1rN09rQkpvbmh5ditCbGpnQ1VRYmNzakNIbE14Sms2U1l4d2xJbnh5aURGa21qWXhXVFAvMkpnK1VCekNPY3dNa3poQXpZd0hJSXJNV1U2dFZaaVpEbGYvOEJZQU1lQVNDRGt3N0E3Um5mLy8rR0loalJ3anFreEJUVVV6THYvN0VNUURBOEFBQWFRY0FBQWdBQUEwZ0FBQUJEazRMaktxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXEiKQ==";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3 ***!
  \***************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUpBQUFLRmdBZUhoNGVIaDRlSGg0ZUhrTkRRME5EUTBORFEwTkRhR2hvYUdob2FHaG9hR2lIaDRlSGg0ZUhoNGVIaDZhbXBxYW1wcWFtcHFhbXhjWEZ4Y1hGeGNYRnhjWGs1T1RrNU9UazVPVGs1UFB6OC9QejgvUHo4L1B6Ly8vLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFlZVFRQUI0QUFBQ2hZMnBCSUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQWp3RGluUUFBQ05kTXE0L01QQkFBQUFBSC8vLy8vLy8vLy8vLy8vLy8vZys3MnBPQUVBQ0lNQUd4WWMxbXZKNWZGekJsWVlvNG80RjV0S0M2eGc2Y0JFUVNVd1ZPWlBWYjdQWUxKZ0tvQmJCMXh5Mm1pZkp1SWcwUzJCek9TY090dk9oWG5SSFZiWEdMaW0zSWdwMW5NZFJMa1U1SzJJOVVEMnNLY2xKTVhpcVY2TmV5N21pNWp6TGwyL1l5N01xZVJVQXVTbnd6MldKSG00Tjg3aHl2RmMzS2RSUVpJVGxCaXVEVzlydmVhUTJLYU5xSnFrYWo1U3NUYWh1MUs0VFgyL2Z3ODVWa0dQRWhZZlN2WjgyZlJzeXZXR0pHM0JhbTE2eFYrR0dCcmFIdjRqWkpIdE84cFRXSU04MllNK0kxbmtla0ErZUJyYXEvN2RUTVFBQS8vdHd4QU1BRDAxemEvMkVBQW85c1d3OWxobGxGWkwvd2VZMmdJRnNxQjJTOEwxdHpjbTQxMmtubjloMjVHckk4SFJoUnc4a1RCeXp5dEhqSk9jcVJ0VjMydkIzUDdJL2NhV3lWUzFZK3IvdG92dExUaVl0TzZpR2hZTnJqdmx1LytZNVh2c3FsNnFZcHRaZXVmMXF0b3ZxYlcxNnFsbFpSNitsWEpqaXBnbWpVWjBWU20wMVhPVTk5dXBtQUFBQmpia3dRV1lESXFxT1FHR21raXRZWkJpS2FTeUlLVGoySllKRHRMUXdUa2tkSFRvc0t5K2huc0M2Q2lTQ3NHQ3l5bUx6OHpwRlAvcGhaSXZwbGJMbm1UYUgxanNlNnhzODVacmZjZm11aHU0RFhMdTZOZGtYZlhyKzZaODE4emNxWmRzeXJkNmZKMW4vcVRNbi9QV1VsWE56N2ZpTFk0MHF0MVZZbm01WnNKVG03azJyQkV0bUNDcmUzb013QUFBTVRrdlNETGdpR2dOd0JsQm9UTzFUU0hXZ3NsWjhKUTZFTXYvN2NNUVFBQklwbjF2c01RdHFGckhyUFlNT0xQREpXZUdRQmp0Y3djbDdVaUh5U0cwYkI4bWFBc1NjbktreXRLdnlRY1dTNlU2a29PYVY3WGdXbTI2UWV6bzJxYUtUTFd5MGM1b0xVb1ZoU2hacDBlcml0MVhpT0pUYnJxNHZZcXh6Vk54UTh3MVh5RzBXSEpKSERVdkthMUtQUTRhejZqS2xvRzU2MmcxWUdTVmtWTW5RODY3aGtBUUFEV1M3Y1Myc0lER25ESzl3cTRGYVJXVlNLbzJ6SjR4bDI0TGxNUFRXTldRNGlRa3dXaVNaVGFSSFpPa2JGVmMrcU5nc0xMZUhraTVQbWwrL0NLVFVyTFVadFJCMWtBanE0WWFYTUZ3TXlzUXJLcUxFdEhJbStSU0Vxc3lVclh4UnBxZVNodDZrTXp5REt2ckRJM3U1ZWJOWk85VlZLU09iR1RIQXpCaHhwMVdlK1VSQUFBQVRjbHZaQkFac2tpWHB1eG1nYUhFUUxNS09MR1hUSG1IMHRENDA4R1NCY3d5a01pZ293ckgvKzJERUZvQVFBV2RQN0tSdGFqeXphTDJFRHUzckk0alJKSkdnMHhyRWdZbFJUWGpTdlhoNnQybXBLbGpjWHpoTlZDNGtaUVZLOUlHNVdNak9NWnViTjBpb2xvYk1vVXR2emYzYThiTExaenVSbFNJbXo2VFJTbUM4NEtORmlDbkdiQnVjcUhaTm9WdUhjU0FBQUFOeVM4ZUpFUWtqWTBPZ2dJeFlIR2NRWkEzYVh1bzhNQVNtdzFwOFhaYlZ6bUwyb3JQelV0bTZHeFRTeTN1bW5nZWt0d29QSGtuT21uTlRBMDFwYTRhYlFjTmdxeHQxTGFvbHBpeGNIZEZTMFdTbzlqbGdScUphVjJsWm5xNXZPTVVZdU0zWmxETnNsT0VEdlpXRktxaFdFSHJEMWx6SVNiZzFJZGNodlptWnlRejZVek5mWUttaktvbXBjekFBRUIyM2Y4ZmtmbTMvKzJERUJvQVFOVVZGN0poejZjNHBhRDJVamJ4amNFQktxUlo5dkV2cUJ3b0RrQ3BvYXFPN1N2NUdyczNFWXpXcEJWUHFRL0ZDWEpFcW1XNUdIMzU2eWd0OTM2WEw0UitxTWJsNDlOQkVxeXFoTEpOSUpGY2pMenU2UUVvRkhaYVc1clBPVnZmMFFSbG5uSFI2Tmh5NUdsVVVUYXFubVRiM0JTRE5hYkZOLy9zN3J1YzFmbDN4NXR2RXc2S0FBQURzay93MjdKSWVoVDd4QkRWRG03cWQ3S0dSMDBLZEVSRFJNRDB4VHBzVEhWZ0NrN1UySnFzeHRhenpON2tPZnZxK1diZUc5amFVZktOSlNwUXkvT3MrMEpybXV5ZXg3ZXhGclZ6WEw4Ly9rSXhLbTVmK1J5blVqZlM4MzdLeFN6NFlwSmdZN3VlaU5tVnhjU2FsVldpWWNqQUFBcS8vKzJERUE0QVBIUXMvN0RESkliaVlKdlR6RGl6Ly80ampUeTJSczlhY25taURBNmZwQ0JrRDU4RUJnUGppeFViS2grTHZHS05BMG9rcHFacE1ZVk1YRkJKSGtqaWl0M0p5Y1ZJTVJ4dGtGN2t2RkltdWFkdTdTSjdSSmxObUpXSjh2S1VuVmVlTnJOMXJ5YXovZGI1bjNhZFJGeklQbm5UejNtMkI1enphMDh3bXJSdUZ0RmIyOVNBQUNuMXRzTkdNMXE0K0lUQktYc1RpR1Z4dUZ5UWxJRjVjVmN0bzF0T0JRTW1ORW9uNGE2YlFhQ2xBcUtYTGZLVmhGcWE5TUJTU2ZOUmFLbXN3OUJFRFdveW8yUVJwV09WeTBETWdRT0RBT0NWdzl3MFBLY09vWWlnVlNOaG94cmEwaStyL2pPeHBJUWt6REJSb2RVQUFBdWU2MnNpOTQybDBrQXovKzJERUNBQVBvVGMxNTZUT1lkTWw1cjZlWUFRaXVDbENsSndyanpNQlZya3JWY1dPRnhLZWdXRFdxVG1WR0hvcVVpYVRDSXIra1U1QXJhdlNZYWttU2RqSlFMZDgzR24yeDN6Y2twR29QS1BlNGxwK0Z4YlgyMzl0eTNwdjVidDlkMmI1ZU8zMTZoZnZTQXNTa2dEZ1NKTVVnZ2V4QXNDQ0JsMzBkTG1jZzFZa05XYUhNQ0FFNzdiWXlxVmlvMDllcW9va2NKQ3pqMUsyRWZaOHBwdEhJSWl5QlpvNUdVUGlUVmFuSUZsYVVrM2szR1NWLytXZWRlR2Q0YytzUDN0UDcyeG1mcTZwZmJ1ZDMvdW1sYnZWUHVPelArN2RkM3oyUS84VGZmK0h6L3F4ODNjYWZwNTg0VTJQUXNVZmRSekRxS1VwYVhCQjJ1MFh6bWNuMCsyMWxnWVNBQUQvK3lERUJ3QU9vTHN6dWFlQUFBQUFQOE9BQUFSNXgzVDBBeXlaZll1azVTbEJjZFRTanJkYUFzb3RXNVR2SlVmbzlua2hwRWdNMWxOY3psU3pZWWtJWEpjWmxXU3hnYTJiRDU5Q216Q2pIQXliVUNvd3hLN3d0UWFXemJzaW9pd0dSOTdQczR0L25lY3hKSUUxbmtTRkNvQytDQTR5US80b09UUHBURUZOUlRNdS8vc1F4QU1Ed0FBQnBBQUFBQ0FBQURTQUFBQUVPVGd1TWxWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlU9Iik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/9-claves.mp3":
/*!************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/drums/9-claves.mp3 ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQUpBQUFMblFBYUdob2FHaG9hR2hvYUdqNCtQajQrUGo0K1BqNCtZMk5qWTJOalkyTmpZMk9IaDRlSGg0ZUhoNGVIaDZlbnA2ZW5wNmVucDZlbndjSEJ3Y0hCd2NIQndjSGIyOXZiMjl2YjI5dmIyL1gxOWZYMTlmWDE5ZlgxLy8vLy8vLy8vLy8vLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFVTFFRQUI0QUFBQzUzQnlnRHVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdGd4QUFBQUFBQi9oUUFBQ05qTTJ6L01aQUFpS2ljWjFFU0FBQUFBQUFGVFR0dS9IRENXQndMUFNLNWJGQW8xUU1KbUVERVgzWmdBbG9Ca3dvZmRHWE11aWRtQ3F5d0pLQ0FWWWs3SnZDM1pvZWpMVklMU2lRSWdsczMvbDRTTzE2N1J4V1VUMWFCdWN5ZnVmM0dhT05RekROMmR5aWJHckZ1aHltWUJzVXR5cnlBV293eitzZFg0R2VLbnpoaTVhZHlsdFZ2MXVJUnZQZXM4ODZmQzFuK2U4N3MzS0syVytmbFQxNEpnS0p6MEZ6OFRtck5xck5WcWVicXhISEgrYmkvM2JuL2orT3QzcGJNUk9TMmFrUmpXcWJuZnBzNmxxbngxVFozczcyTzg4ZitVOTNUYzVjeC8vM1BjY3o4bDBJUUFBQUJDNEJrQUZvQzZVb0lzd1IxRXhWQi8vdUF4QXVBbE8yWFkvejZBQ3JnTkduOWpTSDRCRXk1UThTdHIzSmNjdXFSVVZFVEl5Y1YwUVJBaUpEL0FZVmdHS0IxQ2tTc0xoSElRSmtyckp3ellrakUxT21oOG1YTVRaa1Mwa2JNZ1ltc2lwVmR6UXlMcFNJZVJoSmlNaUNKbXlhYk90a0VrM1pTWFNVWm1weEI2MWEwRitwZG1wTE1YUG4yVFROTDdXK3AyVTd1em5sb3JSWjJXamRLZ2JHUngwcm1xSmdpVUM2dE50YWtXVWxTNlR1ZVNYRUF0Wjl3eUdBQUNaaVdwWjVQa25XZGRFUm1nQ0lENnJMZFJZc21YYkk1VkVYQ3JQOXlGeE80NGE1MWhZS2pKY292cVljb0kxcHZhUUhRSVpRaUt3NURMTFh1VGxmbHkybHNOaU1KbXBRK3NGMk9RM0xaeXJCVUlkMjlPVFYybW04THRXL0tweDJHNU5ZR2d6eER3YTlZaENPNlVZbnlPNjJzY3A0MFZ5Ry9WcjFxNDVhWk1Pc1B3akZPbkdpQ01pMmlmLzVqaVpuMm1vblZGMHNrVEI5SXFFeDZvb3FLRHpCUU1DZGprWXVhOXVmNnpRaG1qQk93aXFxTS9aZHhJQUFBQlFtYU8yOE5zOUgvKzRERUI0Q1dHWnRUN1NEZTZvS3o2bjJVbXhWU0loRmdJVkF5Y3kyWTB4S1BOZGpPRXFsM0paU1NPZzdYbUpwMnFyOUprSTZEbWNEVFNONnphV3dBcGpINWgyWDFmWnpsTm9sTno4UFdhT3ZUVHVvL1Z5cDhzYUh1TW14cFpSRnV6ejFRZTJ0QTVVZ2RaM1YrbFNRNU5WU3FiRlRhMFNTRkdDcDlEdTRIck5MVkZTTVUwZzVwRG15YXVlQ2VYcS8vK0t1NldvdXA3UVpmVUN4NTVnc1dQQUZ3b2tGR2lMT1NzYlNqa2tYenYvKzEycU9LQko1My9tbllBQXRieXg0bS9aS2lvZ2dhb0lnMlV3TzZiSjdNYlhUQnRNNzJQYlV6aHFsa0djUmd4L0xTNVNIa3dUeUp5Sk5lVGlhKzBwL01Xbnc5UEpqU05DaE9xc3FINGxKbVNyTEZuNVExRVR0V1VGY2xSYkFpSVNmRGVGTmVaVFkrTi8yQnFEdUFFMExtZjNucy9lYW8wMGlDd1JYNlpLL3B0a1ovei8rMjF1MWF6Zi90bTkxYVpReXp3cENLUndtbEp2UlNPWk9uM1g3ZHYrenc5d1hzOVl6ZDJuVXdBQUFGdStKT29sdTFOQ2VwbUNvdCsvLzdnTVFLZ0JTTm4wM3NNUmlxZFN6cGZZWWkzWXNPc2tlS093aDAzNW1vRmpWTkFsaXJsTlg4SlM4cjd2UUFJZ0NaNVNEaVp6YlhGQTROY0tNdnJGTFFxT1NTb2VRajZhTXd0bmF5c1ZtS3Nia2JwNVN4ZkgyRXdMWWNtd0VGNUlnRENhVDl0anY2RVVhS2g2SDZuTHg5TG1wZTYwU0lJQ1IxQm9jZEpRODA0aUtGVzUvLytaN3pmcnRWYlpZRHArWjFVNm0xY09yS0g4a1FuZmZEUjhRbHBCTGhrNW0xY0taQUFDSEgrc0cwbGxxbEs0M2NnVldsdFdUdUU4RC94dGtFV2lNT1hhdHV6UzI2MWFmbGVzVkdpSVJmMGptc1Z5V3VtUTBnaWZpWWdyM25ERTRQWDRUbUtGZzJLalNkWkcwODQwMHVzMWEzTW5MTEswd0ZSVFNuVkF5elczaGFKdTdhNVFCWWplMGI0NnVKaVRZS3NNaDZIZ2ZDMlpOTk1STlZFZjl2OTFUZDNLUnFiMnRTTlU2QklIcW8xeUwzV1ZvYnJhcm1XbThhRk1wOHU4cXFVUUFCRGwvZUYzekFKaGtGdTVJcmNPS29NeFp4QThSYVk3anZ3SFluNnM5ampTNDQzNXFtLy90d3hCV0FraW1YU2V3a2Q2bzRvcWk4L0NLTjBXMkZBbW1hWWN4SWhZQ1FkU0Q3QjNUOEUvdDdKRTFOdFp2R1U1emxyR3dsNFlRTXJHeEJaOHVUeHVGK05YZGV2djYzSmk3RDZqVjdlNS8vL2taQ2tRV1dFTVJuSTA3S1lqdDVYL3FmL2x6V0hGcDBtM1pXQ3VrTzlMUmVOYjAvL1BJenVLYUJtcThxcFpCQ1M3cHhRRUtEQ09jV2NMY2U0bnFLS0VtcCtxT0tpVkl4YmE0akZDZnZuMjRWWTV2cUdEc2o2ZFFkT0YrSXhKWWkybUc1QlZCdFRqa3V4dHlTa20wT0xpMVFjV3ZOa05pNFNnUkdCMEtuS3JNc29XbkQzM0VTUUVBMmttYnA0cS83WnhSampSY1FqZ3FrMHB3KzJnN0diY2IzeW02TlBKa0VLVTR5czVtU1JsQnpNZjhJV2QzZ1huVjZ1NnVwVVFBS04rL1VlYnhJbUgxaXcwOE1scnQybEY5N29CZFYxcUZ5clB3UmJ5N2paejd1cEU0YVR1SUp5Zi83WU1RWGdCR2hsMFhzbUhscUVpYm92WUdYRFllU1JXWDBIemNqN2FxdlhONlVvL1BXVmxGNTIrRnEzWEpISktLZ3ROUFVkU055ZDJXLy83RVJLU1lWVitwajFmcHRmV2xqZ0lrRENUa1RadSt0NXJYOWQ1UXpsZkZ1RFF1R1QwbE40UzZ4ck9UVHo3NVhocEtWcHNXTnRCcHJyTHVvbEFBTEYzL2pic2hGVWFGelJaa0xabjlpakU1YkJqeFFSQlZpUFJ5SDRFakhhdHlmLzdtTWRtbTVJK2syM1k1TndMUFUzTjU0RUdhblZ0T242RHlFT1JsdnpJbzBXS0NWRkZMYXlvcnlMc3h3NlVsSE9LVXJQdE9Ib0RPREJncWRvZ1JEVlpYSVZCaHRHcWhaeEhxMkZ1KzBNeHh2V1RmcVU1SDNhczhYMjNJMWFwdTd2SVlBSEZ0L3lSaTNrLy83WU1RR2dBOVpEMFhubUhicDVLS29mUE1PM2VEUmhxWXpCeW02cFZLdXk4b1llQzBhTE8yeGxsM0F0U1g1cGlUUi9DMkJGVDVOZWpXLzlkRERMN1BDVmw1MGt2cit2cmZ2bE9KSW9HOW1YSzdkN21aY1ZRV2psenRMUEptOVJnVUY0eVE4NENZVVVJZGp3NmQwRU5Ec2Jyb1J5Ri9PM3ZmVlR5TEhSTjlsd2RpUm9xOHU1aGdBZGYyM0p3STFHVlk2RUdTMDMwd0VBeWl5OW44YjY3Y2xVK1hrOXVMTEFtL3hlakN0Z21FSGZKdVMvOC9IeDV5TnhpWnM5Z1hQTGZhcWUyVVUybTRGTC9OWUtPaHkxbkNDbXluU2l1SWx5aTZFU3hybVpOdGJyTUZzQk1sSUVRVTBhMStGdmFqL2RiMjk0dERISkR1MUgyZUdTR21hcXFwMkFLWi8yLy83WU1RRWdBL0Jsei9ubUhicDFoL25mUE1OL1lQZ09VQVVFNkdjNEc2U2RBcEZMSkpDSFJQbFc0UldWbmdYaHdZTS8vK25LaHZOenZZVGJFWjdiS2ZWSm0rbVdjbEI3VzAzSlhqK1BKQ3F0eHVqcUlkbVl1Rzh0ZXJDREJWZzRjd0hjT2g3L0gzNXhDbHZ3aUthRTc5SXFsNURpZVY5SGpPdmVGbERPMysrLzAzT1EzVWlCRC9GcDBlWm1KcDJFSys2V1V2WXRnSDg0UTRSM0trd1ZXU1orckc5dGdMbkRKSlFra2lhaXY3NEZqVFJSSmI2Um51cWVic0V0cXNPUUZ3V3lKdlZHblZwTHZoeVZIWGpvQjMxcVBJWU5LMlIvWXg2SEl2eC9JMVA5V0lMRDBKeklORHMwZkw4djZtdlRiOUxGZDNsV2YzYzMrN2kxZlhQY2pvUjJ5N2RKLy83RU1RQ2c4ZG9OeStraEdpb0FBQTBnQUFBQkwvV0FLdUUxK0t6ME13eGVSUTFSbURsTVZWSlRtbkVpcVYxalNqOFpTVXFJTmxxbWhSUXYvbHYzS1k3N25FdGYvLzl2KzVSTHVwTVFVMUZNeTQ1T0M0eXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcSIp";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "9721404c39270fd6d79e.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e53e92febc5d7579ff82.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "d2b3e8f49c3751cbc5c1.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a4660234a9d3cfe40892.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "9b7d6b1c43db0aac4342.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "caae3fda7104bf9c88e4.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "cb2de8b83aeac143de23.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0a21d2a41b076d102cd0.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3 ***!
  \************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c422e94e4635d9a187fd.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3 ***!
  \************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a4b33a900b1444863d69.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3 ***!
  \*************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a4f190f02b7730825660.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3 ***!
  \*************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "5c06939b8017d03b2c0f.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3 ***!
  \*************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "b1113e72efba6bf69966.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a6826e38dc8bdce59367.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e219e63fed3ba334c795.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3 ***!
  \****************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "268111e88798bf7ab5f6.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3 ***!
  \****************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c0be9aec7fa0093cd975.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c6aec23d0ab1443cc358.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "a3f4464f5b851134903c.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "9e4559063c19a1177a46.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0ecb9e67aefb1687cf89.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8859fd854f8c3dc864ad.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e953e5f390f3edd1e3bd.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3 ***!
  \**************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "22071bbc618373ea4564.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3 ***!
  \**************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0f2a6e3ad6cad9cb56f2.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3 ***!
  \*************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "9d865210626efd58b3f2.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3 ***!
  \**************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "150c8cceeeab02968e8c.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:audio/mpeg;base64,bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXItbG9hZGVyL2xpYi90by1hcnJheS1idWZmZXIuanMiKSgiLy91UXhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdHbHVad0FBQUE4QUFBQWZBQUFVYlFBSkNRa2FHaG9vS0Nnd01EQTdPenM3UmtaR1VGQlFXVmxaWTJOalkyMXRiWGQzZDMxOWZZYUdobzJOalkyVWxKU2FtcHFob2FHb3FLaW9yNit2dGJXMXZiMjl4TVRFeXNyS3l0RFEwTmJXMXQzZDNlTGk0dUxwNmVudjcrLzYrdnIvLy84QUFBQlFURUZOUlRNdU9UaHlCTGtBQUFBQUFBQUFBRFFnSkFWRlFRQUI0QUFBRkczTnhiMmRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS8vdEF4QUFBQUFBQi9oUUFBQ0p6SGVxM05hU0FvYkFRQkFBQUFjZmNycmVBQUFSdEFnc3dZZzRFUUVnalNtVlhpeE1CV0FRa1ROQXdKM0YwSE13SFdRSktKeWp3K0J6Y2p6RktFUG1iUXVEbWxtbUFBcGtaWVE2YlBsOU44NkU1dFhaeWpBVkpoaE16Z0F1VFhsVC8wOVBUNHRuWjZ4ZU9SZXJJZTZwSWJlK1VaUytNSmlLSkpnTWthSWw1TzZtK1hKZmV3L1V2cVdGK1kvYWFPVy92M3YvN3RiODhzUC8vLzF0cGQ0Ly8vLzBNc2NBQUFBRC8rM0RFQWdFUDhOVkR2YnFBSWpLWFppbnR0VHdBQUFBT1lJSm1EaWdBUFRXNkJUQXdjRWU1VXlrVEhRWUZFQmE0Q0FvZ1NESkJjSUlUQ0FKWlFza0VRQUdSRFpSWEJQd3RCdVBzNEdYZ0FRQUdDZ0JRRUJnOE5BWTdSUUVBQUdLaFBvWVdHU0Z6QzRpTklxYStpaTNxVTQ1UTR5NnN3Uy82akl2RzF2L1dkZEJmNjJSSWNVeW8vLy8vLy8vLzJFNm9BQUFPMEF4Z0F3d0NRTHpBU0RhTkpJajh3WUFCQTRCY3FBRUFRQ3NRQVpCZ081andxUUJKbHlLY3pWbnpMWUZBakNBWU9md1VnbUVDcGd3STdKaFlBeVlTQzBISCthYzRqWUZwb1R5VVZNUnNEU1hnREdRR0szWVRPZG1OUHJDTXIxVXVUaExheVNJcFlTSUNOSGtQSXVqaGZTL3IvK3BNMUg0UXdYczVsUXFHUVdKdS8vLy8vLy91c2RRcWdDQUFBQUNsdkFoRUJCZ2dDQWtDWjdDSUJoV0FLdUJrQlZEbC8vdGd4QTJCRG55OU9hN2hUZUdnazJiMTdTejg2SkRCd0ZDTUFRUUNwaElab1lHelRHNWw3R1JNNmlyN1NtbmNtVXl1N0xZSndWMHVzWVFiM0NhVkJwNmppdUdlcVhuL2hadzEvN3hwYjB1bWs1bjV2VXRhL3paZENUNm5mK2lIR2hPQzB1cStuaTMvLy8vLy85VUF3QUVNK0FoZ0FnQ21BcUFLWURBSnhveUNVQ3dVQWNBR1hYRWdCMDdGTEV3a3ZWM0djUGc4bTQxY1NFdmZDNTJ0S2FHZXE0MTVWRVlpN3NTSFJDYmlsRW9BT2UrOVZiZmNKR3AvbUdONWNDU2RqL2k0bi81Ty9MRlFTZis3b0VQLy8vLy8rbHk5S1pBQVJjVUJHeVVkQ1pndmdrRzJ5aENkdU1CaFNCZzl5VWNpNkk4Tkt5b0pqQk1BeUVRVnZKQUtSMlgzbTRoYS8vc3d4QmVCREdSOU1PejdZQ0ZIRHlacHIyZ0V0d2lXNjVoVmlNRzNDK1JpQUdxVjZJZW5jTSs3MzN0L0xDL2R4M3pDMWE3TEsxdkk5U1d5b0MvL2FlZnFWLy8vLy8vL3gyQUFjWTlBQnJsWm85QmdWQ01tZ0lwOGRSaVdTU0pReWZrcUFTNFRSR0lHamxHeUFOeGYxMTZPQUxHOVNYRCtaMnJ1NlNsU05USlhkSDZzaXl1ZjN2THVQTmZ2WDcxbmxyR1BBV2ovMmFmKzVWbUQvL3RReEFDQUM3U0JOVTlwNDJGUmo2WnA3S3hrZ0pBdHg4QkJnQVFnQTlDZ1hCZ01wMWdCa1ZBb2dGQTBEU0syanlocENqNEpvaGsxMnF6YUx5VlV5a2pQNld0QTNTTkpPZXJPbm9iMTdqV05mZE1TM3hmMnRQaUVyb1JScTUzRmpFZi9hMmhkMGVLZi8vLy8vKzN1M29pMEdBS0IyajBCZ3dCRVFBZEdBcUdHWm82bEI2NWd3UU9ERUJEQTAwaTNNYVhpWkhvWU9OZ1VnNUR5Z2RLallwYTNiRXBJT1FDd0Q4eUhyYTdoL0M3bmQ5VFhWRlNDbC8vcy82WEx0SC8vLy8vLy94T1dJRFlCTUFlNCtBYUhZLy83VU1RRkFBdVlmVE92WWVUaFE1QWwzZXdZcEFEd0ZUQThDMk5YWkFNd2hBSGdVQStjTUpocUdGN2lPNzk1aUlnMVk4VzlQVFpXOXpNTWVYR2N5N2hTTG9mcjd0dWMvV2ZqT0tPZFBGK2JQYU5qK081eHYveVdqN21SN3lCbHYvLy8vOWZzMmRaMkJZTjQwQVJnRGdCQ1FLQmc2Z0ZuRDZUWUNodXhJRVFlZVJFcHl3RWNOQk5LSTlLaWgrSlVnbVZiaDZNOXFzNVJ3Q0ltbGlOei85ODllV3I5MU1hWUhJN3lqdi8ydHhQK08yLy8vLy8vOXRGS1FVQ0FYMFJBQXdRQUt6QkpBOE1Lb1JVOWFqTURvUXYvKzBERUM0QUxVSU1uVDNGaklXY1BaU250dkdUTWpnQXhJQTF2b2lLSUE1RXRtZUVaQWlYQmNZREVnaDloVnBKTzhuYXQ3VlZtQTNKbU1WaWNibTlEMFpkVmQvLzRManQvVUx2OVh0RG42NEIvLy8vLy8vOGVrQUFPQmR4V0FBQ0FVWUR3RzVnemlTSExheFNlYXBHU0NJa0ZMdFlNbThZS0E1eHR0VUNUQXJUSGtmWGNLSXRVV3pQNFA5bEtjQk5xd1l0bStPczJlUjl2MysvLy8vazdFTDdtZitoRzBuc2VkVXBuLy8vLy8vL2tLZ0E2Uy8vN1FNUUJnQXBBZVRHdlpPT2hRSXZrcWUyc1pPMko4UFFHaE5CSURSZ0pCcW1ic2xRZVdJTkVBaktOeXc2QU1NU2tVNnUrS3o3dnR0MStJaEF4d1hGdHlLSWhqandJREtrRjBSSEVaeHFSLzBIUjcvK0hkUDBZclhaLy8vLy8reEs3QldnQ2dkQXZoQUFEQU5BUUtvSzVnSkQyR0JMVnVaVkZBa3JCQllZbUlsa0Mxb2tLUWkyREFlWk1DU0VENUlOQ21CUm0zdjluS2hORUVkU3JsODAxYkRxK0ltLy9yN2wvLy8vLy8vMGJldGR0VlZVQi8vdEF4QUNBQ1h4ZkpVOXRJeUUwQ2VTMTdhUmtSTlJPQkFBQ3pKZ0VBYkdEQ0thYk44dHgzTFNZNE9HSmdZRUFFQTduRjJaNmxYUW9PcUpTVllzaVR3WmJ6NVM5N0FISkNkQ2haK0tsRzFuYi8vL1Z0a2YvLy8vLy8vNVZyc1hVQUNBQ294T0pFQUFNQm9ZQzRDSmc2QmtISkk0T2ZRYUdVZ0ppUVFHQ2FwSElKaHUxUVBrMmRBSFQ4VWlCUG5UV3pYeitGakZHb0YzOUgvL1RWOGcxSDJNTVgvLy8vLzlXdnRjeGh4b0FBQU51SzhBSUFEei8rMERFQklCSThFOGxyMjJESVZhTnBEWHNLS3dBUTBCd1lRb0JaMFludEJQMk5NQTBMRFFBdXRuNlBFekhsWnA0WVBudEx2bmZuTWRudWc1bm9oT3BmVDJQNXcvLy8vKy96cS8vLy8vLy94TFMvdEFBWklVWnZBSUFDekFwQWNNSllPRThjQTlqRWlBaEJ3UHdQQ2wwSkFMeUJKWDBpVFJaREtZY3F5dVg4ekU4U3g5ejJrSmczRVFsSC9vQ3dvRTRDNDZFd1VmLy8vLzlILy8vLytqckpDMEtnb3BtR0ZFVzFRQVdFN1VoK0lnQVk2aHFRdi83UU1RR0FBbndieVdzK09IaElZa2s5WTlvQkdCK0cwYjVwNUpoTmdhR0FvQUtrRUdBQXNlWkVqWDd0TmZsRVFnT0JveFIxTmpZS2pmNmx6Um9JaGYvNExva3NTRWNZdi8vK2kyL3MzTFIvLy8vLy8vVXROQ1FCS0lwbk53S0FBY0VnblJnSEJsbWw4a01jQm1CUWdnU2lveFU2TzdFcjhNT0cydFordFk0VFV4MkM1ZC8vLzd3MVpuNnFmUVdQRXYvNVZmeHh6Ly8vLy8vLzZOckJXY2VBQ05RTkdXUHdCV0FVa0NRQThkQ2VNZzFGa3lkLy9zZ3hBcUF5SXhIS2U5cFl1RGlpT1U1N0xCY0ljSXhJVUJyUVZoYUJaS2dyTXg1SDNocWlyeW4vRk1oNWJBN2d1OUgvLy85TXl0R1cyMHNiLy8vLy8vaVhXTGdBc3FtcXZFRWxnQUFFZzRtRmFoVWRkSUlBSlhSRXdYeldHUmxoOVlEclFxSHVEL3lTcVhWbFowcUlPektVNnUvLy8vM1Qyak1USlFBQmxRbWQvLzdNTVFDZ0FlQVNTdnU1U01oQXdra3RkMGNiSTRBMllBVzhnbk1FQkFON3NiTzRoTWN5bmpERFRBZFFXU3cweks4SlFiYzFQL1VKTC82MU0ya1lKMGYvLy9UWG5teFlac3huZXdBU0J1QnpnQ0lnSXFMQ0dEb2FuOWZYSEhFbCtESGh3VUlTTFhPeVQ3RFAzNGtjR1JVck9GbitwaUNjTmp0My8vLzk3bFdiV0RQL1YvLy8vdStDMmVMcmdBNUxZQnVCYWdBajR4Y09EQS9Ldi83SU1RSGdBZjRSeWV1Z1hCZzhJam1mY3djbkRrTUpBaUFNRkFRWDdjQlNoSGVncm9jVzd2VkxKRmxmeHg3TlJsUi8vK3hPakZWUk9OZi8vLy8vLy8rcE04bFA3aUE0ZDJhUUNnQWZBT0FWZXBGSHJUZ1JIWktFOXlES04rM01JVlQzMjVRbzhOakpFTnYvOVM1Zi8vLy9VbjJRREZxaklNRHYvLy8vLzIyNVpQLyt5REVBQUJIdEVrbnJ1UkRZS0FFNVhYY3ZFUUFSeDNBWGdXc0FKZ29wR0FRV251Z2hCdUt2a21XM2c2VWl4RW8wMks3RFV2cFFNUi8rRFFDb2QvLy9tZVl0N0NHcWczZC8vLy8vK2hkdzdWUldRclpiZ09BQW9NekVFZ3NjbW5LYzRDR284Mk0xcUU5clJoVk4zRjFkMzR2Ly8vL1pmcDdQMUlCUk8yQWNBQ3MvL3NneEFPQWgweERKNjdvbzJES2lHVDEwRElNQU82cmNEQTFPZkhNT2tSUUJJb3A5ZHRxdW5zSG1pdGVXejd2LzhQQm4vLy8vcENwUFp2Rm50Y2dWLy8vLy8vczRzajlRRmpxdEFnQUJhQk5FVkR3MjlpRXdiRkFBQVNwdEFkU3lqaE9iYkhiajBXenZicDdZcFFQLy8vL3V2Ly8vLy8vLy8vdElIZUhkM0FBQVAvN0lNUURnSWJrS1RQdDZZSmd5SVRtZmJ5d1hCOEEzTGtnd0VtcWV3RWlpRU1vNnV3ZXlFQlZXd0RBb21yRVQralAvLy8vci9Fa2E3UzJwYmYvLy8vLzg2bXhsWkE3dEx4QUI2QTJIcmJFUVFZMThtWDBXWFJraHVZb0E1YkNJQlVFVm00Ly8vLy82bitzWGQvelAvLy8vLzlWNlNPRWFpTDlmZ0FBQjhJRkVIci8reURFQlFDRjRDVXZybW1DWU5zR1pqMjJITndFWUZOWHg0NjVWQnhMTkdnUnlXQXpiRmdZeTNILy8vLzMvK2hQLy85bi8vLy82TDFwSUZkbmR3b1BhR0FnQ0h4QUFIcVpKa2dFaitvSTI0Z0pBVmd1bU5Ob2ord08vLy8vLzl6MUdIZHJrZEE2bTV5VC8vLy8vNWhYb2hCWGg0YUlBQUFmVU9CSHNadWU2NEZELy9zZ3hBaUFCdHd6TSsydzZtRGFoZVk5dGdpYzJrd2lPeFJwNzFzbXlPQVhMRnQ3cVRodC8vLy8vL2RvY2hOU1VJcXEvLy8vLytwU2F4aEFTc3p1OEFBQi9ZR2l2Rm1nSC9FNUVVdm1HTVpvZWpwbWdWUmd4ZnFHLy8vLzl1eFl2YmYwRFZMVzFUYXJPLy8vLy8yVmFYRzZRbG0yQUFBSDFBVGF1U3FZNGlIdyt2LzdFTVFJQUlYb0pTK3VaTUpnc3dTbWZieWtUSldGKzdOc0FiSkdCMW5MLy8vLzYvdXAyR08yODBuLy8vLy8vcTdHTllkTUZkbmh3QVBRSXpKZ3lScDFpWUR3VjFOQmJiTERzb0NwWTBsbi8vLy8vL1oxZXovLy8vLy9YVU5UQTVJQ0pHTVhiOENKLy9zd3hBT0FCK2hiSmFod29LRDlDMlExd0NtVUFBY0NNUkdHRHE4M01UaEJCSzlWVkNFYUFqVmIrb21LTUpoOGYvOFBBaXYvLzZPbUgrbWhIWHF0MkpaLy8vMWZRKzFLSDArcnJhUEFhQ1lBdCtBWklDQ1ZaQkFMemczQUhBeWdVOGNzejdqVGZKTEFpUjhOaWcrTC8vQWRENVAvLzJkdTdzMVhiMXBmVnVWZC8vLzR0ZFRBSlJFTzlWanFBcmNsR0E0QXFRS0kwdEdBY1lUai8vc2d4QWVBaHNnMUo2NGtST0RKQnFZOW9CbU01aVFRSUkxQzZCZ0dvMk5zditJZ1lmL25mLy8reW1yL285RmxmZC8vLzczV05pNzVELzc3QkNHVm5BSkQyaDFyaWI1cGZCdTBxQWh1Y1F6cnlhcHVDNTRHNENDdi8vLy9yOTdYWTN2WFY2d0pYM2YvLy82MVNkREtRWmlKa0FBQUFBUHhWMnl1QURjU1RNWlo4Zi83RU1RSmdJWElIem50WVNKZ3hnUW1mYXdrUkVmK2toRzlHU04vLy8vLy8vNi92MzNPdVkzLy8vL2RyU2ZaY2tnVjFkM2tBK29pbW1Fck9pNkQzdklQaWlmV1ZaUk5MaHh2Ly8vLzlQNlFscDFWdU05aEgyZi8vL0daZHhKMG1vaTJRMisvQUFBQS8vc2d4QU1BeGtBbE1hWHBJR0N6aFNZNXA1eU05b1lXTm9vZXBTUEJHUGtpTVNPalhVUU1Jbi8vLy8vNkdYUWhLTmV2N3N0aCt1ei8vLytuM3hVZ3BaMHdaMmFHa0FMZlBjN1I0d0FsV1g2VFpHM3UrQkJtcUxQLy8vLy8wQU9OL1pyMHMydU4vLy8vNnZwT3NEMVFabUNJZ0FBQUgxRU9JRFVsQ1NBa0ZnWWlsLy83RU1RS0FBWGdKelBzNk9CZ3c0VGwvYXlZUk5RdXVWTC8vLy8vL3Nrb2MrOVQvdGJ1SC8vLzliTkZhR08zRkNCMlJsZUFBQUQrd05uc0pnbzZwMDhRR1doWmM3citkNVNMdS8vLy8rdjJ0cmJRdDVyRlB2N1AvLy8vQ1BlOCtwUVJaMEFJY0FBQS8vc2d4QU9BQmFnbk1lMEF5R0RHaE9YMXBoaE1IdERpOTk5VGxPRU5hWjJaZm4zQ2dwSjMvLy8vOTNhS2ZUajh5aFd5OXVwUC8vL1IvUnBSdDEzb0FBSDlnYlFubWJFYmVXQ2h5WUt4VElaK3haTUtsMy8vLy95WDN5WW1WMlZ1UXVRcy9wLy8vOTlacXVsekVUQjNaV2VBQUFBZlVORko4bzZZRnhiRjlnb2NULy83RU1RS2dJWmdKVEhzcE1RZ3ZJUG1QYVNZaEUvK0hIbzQ3Ly8vLy9iM0RyMm9wU1JTek9TVjVEVzFqdi8vLzlKcENpRjNaMmFBRDJocGN3bUNCQkJMb1JzS0laY1FRaGtCdzMvLy8vLzkzWFQzbDFMaW83cHFjLy8vLy9XZlRGc0RLaUYzVldnQS8vc2d4QUtBeGxnbE1laGt3S0MxZytZNWpDQU1BQUFlMlFHQldnczBka0I4Y2RHa3ZjbWpWY29QLy8vLy8xM1ROWTNxYzVYNldQczFyWi8vN094RXV1WFpyTUhWb2NBQUFoVU5UUjAySkFoUXJhS0VmbkcvLy8vLy9Sc3VjWlpydnRORjEyeGkyZi8vL3J4cXE2U3l6TlVuN1VBQUFBRDJDQndkbXp2WUhtMjBFZi83RU1RSWdZVk1FVEdrNVNCZ2pnSG1OTHk4Qkx3dWUvLy8vLy94WkdaNU9NVmlHLzZ2Ly8vL3ZGYkZ6aUhNL0RlME1MRkZrOGhRYUswOFBGZi8vLy8vOUxscTFWYitiNmJIOS8vLy82azE2ZFJQZlVBQUFBRDJpUUUrNmt3TzZRRVBxMDUvNzRuLy8vdFF4QXNBQmhnVE1iV2dBQ0p2R1NzL053RFkvLy8vLzJkYjlHeGVTUnRJclEwdHUvLy8yTW9XMDNIaFFYVzNFUDBRQ0VFRUZJSEllaW9OQUVBQUF3b2ZBdzRha3VqZDRYVlNjaVBRd01EQWN4TVdSQi83V2E3V0c1T2pMa09ITzQ3eENnYXNGQkVOSUw0WUlBQ3diTEMrNDVwa1hpOThBTUJ0Z0dNQUNzTGh6RlRtSkFmeHhpZEJ6Q2NIR21YVEl2RTBZbDMrbXlibUJjTkNaTWk4VFJpWFM3OEh3SUNBUGpnYXdWK1VEQi9LQ0lLZ3FJZ3FkL2x3K0NBREI4RUFUSzJjR2hMLy8wLy9oSUdxVEVGTlJmLzdFTVFDQThBQUFmNGNBQUFnQUFBMGdBQUFCRE11T1RndU1xcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxIik=";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3 ***!
  \*****************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "d76639d66d4fefaa1d9f.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3 ***!
  \**************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "1e996865a6a5c4d2427d.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3 ***!
  \*************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "af4eb46d4e0559271195.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "64f08cddd4826c06d896.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3 ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "4c7ca7de85e67e53a0d3.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3 ***!
  \******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "93c5f06c06e81f307b18.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3 ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "3910a47bd8d26200c31f.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3 ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "1e2e0a4f7bf0fa270099.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3 ***!
  \************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "91b435134e5428a2ae04.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e0a5df9026c39f44391a.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "6dbbb90da62005a4e797.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3 ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "1dd1c7fd54d8f1dd53da.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e6f7fddcff69560f93d9.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8340aeffab896e4b9774.mp3";

/***/ }),

/***/ "./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/arraybuffer-loader/index.js!./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3 ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "446764135169b4621793.mp3";

/***/ }),

/***/ "?13bc":
/*!*********************************!*\
  !*** readable-stream (ignored) ***!
  \*********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"scratch-vm","version":"4.5.144","description":"Virtual Machine for Scratch 3.0","author":"Massachusetts Institute of Technology","license":"BSD-3-Clause","homepage":"https://github.com/scratchfoundation/scratch-vm#readme","repository":{"type":"git","url":"https://github.com/scratchfoundation/scratch-vm.git","sha":"d1377e7bfa195071065cc194e58e0e0567b62a7d"},"main":"./dist/node/scratch-vm.js","browser":"./dist/web/scratch-vm.js","exports":{"webpack":"./src/index.js","browser":"./dist/web/scratch-vm.js","node":"./dist/node/scratch-vm.js","default":"./src/index.js"},"scripts":{"build":"npm run docs && webpack --progress","coverage":"tap ./test/{unit,integration}/*.js --coverage --coverage-report=lcov","docs":"jsdoc -c .jsdoc.json","i18n:src":"mkdirp translations/core && format-message extract --out-file translations/core/en.json src/extensions/**/index.js","i18n:push":"tx-push-src scratch-editor extensions translations/core/en.json","lint":"eslint . && format-message lint src/**/*.js","prepare":"husky install","prepublish":"in-publish && npm run build || not-in-publish","start":"webpack serve","tap":"tap ./test/{unit,integration}/*.js","tap:unit":"tap ./test/unit/*.js","tap:integration":"tap ./test/integration/*.js","test":"npm run lint && npm run tap","watch":"webpack --progress --watch","version":"json -f package.json -I -e \\"this.repository.sha = \'$(git log -n1 --pretty=format:%H)\'\\""},"config":{"commitizen":{"path":"cz-conventional-changelog"}},"browserslist":["Chrome >= 63","Edge >= 15","Firefox >= 57","Safari >= 11"],"tap":{"branches":60,"functions":70,"lines":70,"statements":70},"dependencies":{"@vernier/godirect":"^1.5.0","arraybuffer-loader":"^1.0.6","atob":"^2.1.2","btoa":"^1.2.1","canvas-toBlob":"^1.0.0","decode-html":"^2.0.0","diff-match-patch":"^1.0.4","format-message":"^6.2.1","htmlparser2":"^3.10.0","immutable":"^3.8.1","jszip":"^3.1.5","minilog":"^3.1.0","scratch-audio":"^1.0.6","scratch-parser":"^5.1.1","scratch-render":"^1.0.13","scratch-sb1-converter":"^1.0.0","scratch-storage":"^2.3.5","scratch-svg-renderer":"2.3.41","scratch-translate-extension-languages":"^1.0.0","text-encoding":"^0.7.0","uuid":"^8.3.2","web-worker":"^1.3.0"},"devDependencies":{"@babel/core":"7.24.5","@babel/eslint-parser":"7.24.5","@babel/preset-env":"7.24.5","@commitlint/cli":"17.8.1","@commitlint/config-conventional":"17.8.1","adm-zip":"0.4.11","babel-loader":"9.1.3","callsite":"1.0.0","copy-webpack-plugin":"4.6.0","docdash":"1.2.0","eslint":"8.57.0","eslint-config-scratch":"9.0.8","expose-loader":"1.0.3","file-loader":"6.2.0","format-message-cli":"6.2.4","husky":"8.0.3","in-publish":"2.0.1","js-md5":"0.7.3","jsdoc":"3.6.11","json":"^9.0.4","pngjs":"3.4.0","scratch-blocks":"1.1.109","scratch-l10n":"3.18.136","scratch-render-fonts":"1.0.46","scratch-semantic-release-config":"1.0.14","scratch-webpack-configuration":"1.3.0","script-loader":"0.7.2","semantic-release":"19.0.5","stats.js":"0.17.0","tap":"16.3.10","webpack":"5.91.0","webpack-cli":"4.10.0","webpack-dev-server":"3.11.3"}}');

/***/ })

}]);
//# sourceMappingURL=src_index-exposed_js.786eb488170b4f4e5219.js.map