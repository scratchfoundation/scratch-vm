(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VirtualMachine"] = factory();
	else
		root["VirtualMachine"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 60);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var minilog = __webpack_require__(121);
minilog.enable();

module.exports = minilog('vm');

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Color = __webpack_require__(23);

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */

var Cast = function () {
    function Cast() {
        _classCallCheck(this, Cast);
    }

    _createClass(Cast, null, [{
        key: 'toNumber',

        /**
         * Scratch cast to number.
         * Treats NaN as 0.
         * In Scratch 2.0, this is captured by `interp.numArg.`
         * @param {*} value Value to cast to number.
         * @return {number} The Scratch-casted number value.
         */
        value: function toNumber(value) {
            var n = Number(value);
            if (isNaN(n)) {
                // Scratch treats NaN as 0, when needed as a number.
                // E.g., 0 + NaN -> 0.
                return 0;
            }
            return n;
        }

        /**
         * Scratch cast to boolean.
         * In Scratch 2.0, this is captured by `interp.boolArg.`
         * Treats some string values differently from JavaScript.
         * @param {*} value Value to cast to boolean.
         * @return {boolean} The Scratch-casted boolean value.
         */

    }, {
        key: 'toBoolean',
        value: function toBoolean(value) {
            // Already a boolean?
            if (typeof value === 'boolean') {
                return value;
            }
            if (typeof value === 'string') {
                // These specific strings are treated as false in Scratch.
                if (value === '' || value === '0' || value.toLowerCase() === 'false') {
                    return false;
                }
                // All other strings treated as true.
                return true;
            }
            // Coerce other values and numbers.
            return Boolean(value);
        }

        /**
         * Scratch cast to string.
         * @param {*} value Value to cast to string.
         * @return {string} The Scratch-casted string value.
         */

    }, {
        key: 'toString',
        value: function toString(value) {
            return String(value);
        }

        /**
         * Cast any Scratch argument to an RGB color array to be used for the renderer.
         * @param {*} value Value to convert to RGB color array.
         * @return {Array.<number>} [r,g,b], values between 0-255.
         */

    }, {
        key: 'toRgbColorList',
        value: function toRgbColorList(value) {
            var color = Cast.toRgbColorObject(value);
            return [color.r, color.g, color.b];
        }

        /**
         * Cast any Scratch argument to an RGB color object to be used for the renderer.
         * @param {*} value Value to convert to RGB color object.
         * @return {RGBOject} [r,g,b], values between 0-255.
         */

    }, {
        key: 'toRgbColorObject',
        value: function toRgbColorObject(value) {
            var color = void 0;
            if (typeof value === 'string' && value.substring(0, 1) === '#') {
                color = Color.hexToRgb(value);
            } else {
                color = Color.decimalToRgb(Cast.toNumber(value));
            }
            return color;
        }

        /**
         * Determine if a Scratch argument is a white space string (or null / empty).
         * @param {*} val value to check.
         * @return {boolean} True if the argument is all white spaces or null / empty.
         */

    }, {
        key: 'isWhiteSpace',
        value: function isWhiteSpace(val) {
            return val === null || typeof val === 'string' && val.trim().length === 0;
        }

        /**
         * Compare two values, using Scratch cast, case-insensitive string compare, etc.
         * In Scratch 2.0, this is captured by `interp.compare.`
         * @param {*} v1 First value to compare.
         * @param {*} v2 Second value to compare.
         * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
         */

    }, {
        key: 'compare',
        value: function compare(v1, v2) {
            var n1 = Number(v1);
            var n2 = Number(v2);
            if (n1 === 0 && Cast.isWhiteSpace(v1)) {
                n1 = NaN;
            } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
                n2 = NaN;
            }
            if (isNaN(n1) || isNaN(n2)) {
                // At least one argument can't be converted to a number.
                // Scratch compares strings as case insensitive.
                var s1 = String(v1).toLowerCase();
                var s2 = String(v2).toLowerCase();
                return s1.localeCompare(s2);
            }
            // Compare as numbers.
            return n1 - n2;
        }

        /**
         * Determine if a Scratch argument number represents a round integer.
         * @param {*} val Value to check.
         * @return {boolean} True if number looks like an integer.
         */

    }, {
        key: 'isInt',
        value: function isInt(val) {
            // Values that are already numbers.
            if (typeof val === 'number') {
                if (isNaN(val)) {
                    // NaN is considered an integer.
                    return true;
                }
                // True if it's "round" (e.g., 2.0 and 2).
                return val === parseInt(val, 10);
            } else if (typeof val === 'boolean') {
                // `True` and `false` always represent integer after Scratch cast.
                return true;
            } else if (typeof val === 'string') {
                // If it contains a decimal point, don't consider it an int.
                return val.indexOf('.') < 0;
            }
            return false;
        }
    }, {
        key: 'toListIndex',


        /**
         * Compute a 1-based index into a list, based on a Scratch argument.
         * Two special cases may be returned:
         * LIST_ALL: if the block is referring to all of the items in the list.
         * LIST_INVALID: if the index was invalid in any way.
         * @param {*} index Scratch arg, including 1-based numbers or special cases.
         * @param {number} length Length of the list.
         * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
         */
        value: function toListIndex(index, length) {
            if (typeof index !== 'number') {
                if (index === 'all') {
                    return Cast.LIST_ALL;
                }
                if (index === 'last') {
                    if (length > 0) {
                        return length;
                    }
                    return Cast.LIST_INVALID;
                } else if (index === 'random' || index === 'any') {
                    if (length > 0) {
                        return 1 + Math.floor(Math.random() * length);
                    }
                    return Cast.LIST_INVALID;
                }
            }
            index = Math.floor(Cast.toNumber(index));
            if (index < 1 || index > length) {
                return Cast.LIST_INVALID;
            }
            return index;
        }
    }, {
        key: 'LIST_INVALID',
        get: function get() {
            return 'INVALID';
        }
    }, {
        key: 'LIST_ALL',
        get: function get() {
            return 'ALL';
        }
    }]);

    return Cast;
}();

module.exports = Cast;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var microee = __webpack_require__(114);

// Implements a subset of Node's stream.Transform - in a cross-platform manner.
function Transform() {}

microee.mixin(Transform);

// The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.
Transform.prototype.write = function(name, level, args) {
  this.emit('item', name, level, args);
};

Transform.prototype.end = function() {
  this.emit('end');
  this.removeAllListeners();
};

Transform.prototype.pipe = function(dest) {
  var s = this;
  // prevent double piping
  s.emit('unpipe', dest);
  // tell the dest that it's being piped to
  dest.emit('pipe', s);

  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }
  function onEnd() { !dest._isStdio && dest.end(); }

  s.on('item', onItem);
  s.on('end', onEnd);

  s.when('unpipe', function(from) {
    var match = (from === dest) || typeof from == 'undefined';
    if(match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }
    return match;
  });

  return dest;
};

Transform.prototype.unpipe = function(from) {
  this.emit('unpipe', from);
  return this;
};

Transform.prototype.format = function(dest) {
  throw new Error([
    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',
    'var Minilog = require(\'minilog\');',
    'Minilog',
    '  .pipe(Minilog.backends.console.formatClean)',
    '  .pipe(Minilog.backends.console);'].join('\n'));
};

Transform.mixin = function(dest) {
  var o = Transform.prototype, k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

module.exports = Transform;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MathUtil = function () {
    function MathUtil() {
        _classCallCheck(this, MathUtil);
    }

    _createClass(MathUtil, null, [{
        key: "degToRad",

        /**
         * Convert a value from degrees to radians.
         * @param {!number} deg Value in degrees.
         * @return {!number} Equivalent value in radians.
         */
        value: function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        /**
         * Convert a value from radians to degrees.
         * @param {!number} rad Value in radians.
         * @return {!number} Equivalent value in degrees.
         */

    }, {
        key: "radToDeg",
        value: function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }

        /**
         * Clamp a number between two limits.
         * If n < min, return min. If n > max, return max. Else, return n.
         * @param {!number} n Number to clamp.
         * @param {!number} min Minimum limit.
         * @param {!number} max Maximum limit.
         * @return {!number} Value of n clamped to min and max.
         */

    }, {
        key: "clamp",
        value: function clamp(n, min, max) {
            return Math.min(Math.max(n, min), max);
        }

        /**
         * Keep a number between two limits, wrapping "extra" into the range.
         * e.g., wrapClamp(7, 1, 5) == 2
         * wrapClamp(0, 1, 5) == 5
         * wrapClamp(-11, -10, 6) == 6, etc.
         * @param {!number} n Number to wrap.
         * @param {!number} min Minimum limit.
         * @param {!number} max Maximum limit.
         * @return {!number} Value of n wrapped between min and max.
         */

    }, {
        key: "wrapClamp",
        value: function wrapClamp(n, min, max) {
            var range = max - min + 1;
            return n - Math.floor((n - min) / range) * range;
        }

        /**
         * Convert a value from tan function in degrees.
         * @param {!number} angle in degrees
         * @return {!number} Correct tan value
         */

    }, {
        key: "tan",
        value: function tan(angle) {
            angle = angle % 360;
            switch (angle) {
                case -270:
                case 90:
                    return Infinity;
                case -90:
                case 270:
                    return -Infinity;
                default:
                    return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));
            }
        }
    }]);

    return MathUtil;
}();

module.exports = MathUtil;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(29)
var ieee754 = __webpack_require__(32)
var isArray = __webpack_require__(26)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var processNextTick = __webpack_require__(27);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(14);
util.inherits = __webpack_require__(3);
/*</replacement>*/

var Readable = __webpack_require__(49);
var Writable = __webpack_require__(34);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var Parser = __webpack_require__(44),
    DomHandler = __webpack_require__(95);

function defineProp(name, value){
	delete module.exports[name];
	module.exports[name] = value;
	return value;
}

module.exports = {
	Parser: Parser,
	Tokenizer: __webpack_require__(45),
	ElementType: __webpack_require__(15),
	DomHandler: DomHandler,
	get FeedHandler(){
		return defineProp("FeedHandler", __webpack_require__(111));
	},
	get Stream(){
		return defineProp("Stream", __webpack_require__(113));
	},
	get WritableStream(){
		return defineProp("WritableStream", __webpack_require__(46));
	},
	get ProxyHandler(){
		return defineProp("ProxyHandler", __webpack_require__(112));
	},
	get DomUtils(){
		return defineProp("DomUtils", __webpack_require__(97));
	},
	get CollectingHandler(){
		return defineProp("CollectingHandler", __webpack_require__(110));
	},
	// For legacy support
	DefaultHandler: DomHandler,
	get RssHandler(){
		return defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function(data, options){
		var handler = new DomHandler(options);
		new Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function(feed, options){
		var handler = new module.exports.FeedHandler(options);
		new Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function(cb, options, elementCb){
		var handler = new DomHandler(cb, options, elementCb);
		return new Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var adapter = __webpack_require__(71);
var mutationAdapter = __webpack_require__(38);
var xmlEscape = __webpack_require__(90);
var MonitorRecord = __webpack_require__(74);
var Clone = __webpack_require__(12);

/**
 * @fileoverview
 * Store and mutate the VM block representation,
 * and handle updates from Scratch Blocks events.
 */

var Blocks = function () {
    function Blocks() {
        _classCallCheck(this, Blocks);

        /**
         * All blocks in the workspace.
         * Keys are block IDs, values are metadata about the block.
         * @type {Object.<string, Object>}
         */
        this._blocks = {};

        /**
         * All top-level scripts in the workspace.
         * A list of block IDs that represent scripts (i.e., first block in script).
         * @type {Array.<String>}
         */
        this._scripts = [];

        /**
         * Runtime Cache
         * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
         * @private
         */
        this._cache = {
            /**
             * Cache block inputs by block id
             * @type {object.<string, !Array.<object>>}
             */
            inputs: {},
            /**
             * Cache procedure Param Names by block id
             * @type {object.<string, ?Array.<string>>}
             */
            procedureParamNames: {},
            /**
             * Cache procedure definitions by block id
             * @type {object.<string, ?string>}
             */
            procedureDefinitions: {}
        };
    }

    /**
     * Blockly inputs that represent statements/branch.
     * are prefixed with this string.
     * @const{string}
     */


    _createClass(Blocks, [{
        key: 'getBlock',


        /**
         * Provide an object with metadata for the requested block ID.
         * @param {!string} blockId ID of block we have stored.
         * @return {?object} Metadata about the block, if it exists.
         */
        value: function getBlock(blockId) {
            return this._blocks[blockId];
        }

        /**
         * Get all known top-level blocks that start scripts.
         * @return {Array.<string>} List of block IDs.
         */

    }, {
        key: 'getScripts',
        value: function getScripts() {
            return this._scripts;
        }

        /**
          * Get the next block for a particular block
          * @param {?string} id ID of block to get the next block for
          * @return {?string} ID of next block in the sequence
          */

    }, {
        key: 'getNextBlock',
        value: function getNextBlock(id) {
            var block = this._blocks[id];
            return typeof block === 'undefined' ? null : block.next;
        }

        /**
         * Get the branch for a particular C-shaped block.
         * @param {?string} id ID for block to get the branch for.
         * @param {?number} branchNum Which branch to select (e.g. for if-else).
         * @return {?string} ID of block in the branch.
         */

    }, {
        key: 'getBranch',
        value: function getBranch(id, branchNum) {
            var block = this._blocks[id];
            if (typeof block === 'undefined') return null;
            if (!branchNum) branchNum = 1;

            var inputName = Blocks.BRANCH_INPUT_PREFIX;
            if (branchNum > 1) {
                inputName += branchNum;
            }

            // Empty C-block?
            var input = block.inputs[inputName];
            return typeof input === 'undefined' ? null : input.block;
        }

        /**
         * Get the opcode for a particular block
         * @param {?object} block The block to query
         * @return {?string} the opcode corresponding to that block
         */

    }, {
        key: 'getOpcode',
        value: function getOpcode(block) {
            return typeof block === 'undefined' ? null : block.opcode;
        }

        /**
         * Get all fields and their values for a block.
         * @param {?object} block The block to query.
         * @return {?object} All fields and their values.
         */

    }, {
        key: 'getFields',
        value: function getFields(block) {
            return typeof block === 'undefined' ? null : block.fields;
        }

        /**
         * Get all non-branch inputs for a block.
         * @param {?object} block the block to query.
         * @return {?Array.<object>} All non-branch inputs and their associated blocks.
         */

    }, {
        key: 'getInputs',
        value: function getInputs(block) {
            if (typeof block === 'undefined') return null;
            var inputs = this._cache.inputs[block.id];
            if (typeof inputs !== 'undefined') {
                return inputs;
            }

            inputs = {};
            for (var input in block.inputs) {
                // Ignore blocks prefixed with branch prefix.
                if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
                    inputs[input] = block.inputs[input];
                }
            }

            this._cache.inputs[block.id] = inputs;
            return inputs;
        }

        /**
         * Get mutation data for a block.
         * @param {?object} block The block to query.
         * @return {?object} Mutation for the block.
         */

    }, {
        key: 'getMutation',
        value: function getMutation(block) {
            return typeof block === 'undefined' ? null : block.mutation;
        }

        /**
         * Get the top-level script for a given block.
         * @param {?string} id ID of block to query.
         * @return {?string} ID of top-level script block.
         */

    }, {
        key: 'getTopLevelScript',
        value: function getTopLevelScript(id) {
            var block = this._blocks[id];
            if (typeof block === 'undefined') return null;
            while (block.parent !== null) {
                block = this._blocks[block.parent];
            }
            return block.id;
        }

        /**
         * Get the procedure definition for a given name.
         * @param {?string} name Name of procedure to query.
         * @return {?string} ID of procedure definition.
         */

    }, {
        key: 'getProcedureDefinition',
        value: function getProcedureDefinition(name) {
            var blockID = this._cache.procedureDefinitions[name];
            if (typeof blockID !== 'undefined') {
                return blockID;
            }

            for (var id in this._blocks) {
                if (!this._blocks.hasOwnProperty(id)) continue;
                var block = this._blocks[id];
                if (block.opcode === 'procedures_definition') {
                    var internal = this._getCustomBlockInternal(block);
                    if (internal && internal.mutation.proccode === name) {
                        this._cache.procedureDefinitions[name] = id; // The outer define block id
                        return id;
                    }
                }
            }

            this._cache.procedureDefinitions[name] = null;
            return null;
        }

        /**
         * Get names of parameters for the given procedure.
         * @param {?string} name Name of procedure to query.
         * @return {?Array.<string>} List of param names for a procedure.
         */

    }, {
        key: 'getProcedureParamNamesAndIds',
        value: function getProcedureParamNamesAndIds(name) {
            var cachedNames = this._cache.procedureParamNames[name];
            if (typeof cachedNames !== 'undefined') {
                return cachedNames;
            }

            for (var id in this._blocks) {
                if (!this._blocks.hasOwnProperty(id)) continue;
                var block = this._blocks[id];
                if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {
                    var names = JSON.parse(block.mutation.argumentnames);
                    var ids = JSON.parse(block.mutation.argumentids);
                    this._cache.procedureParamNames[name] = [names, ids];
                    return this._cache.procedureParamNames[name];
                }
            }

            this._cache.procedureParamNames[name] = null;
            return null;
        }
    }, {
        key: 'duplicate',
        value: function duplicate() {
            var newBlocks = new Blocks();
            newBlocks._blocks = Clone.simple(this._blocks);
            newBlocks._scripts = Clone.simple(this._scripts);
            return newBlocks;
        }
        // ---------------------------------------------------------------------

        /**
         * Create event listener for blocks and variables. Handles validation and
         * serves as a generic adapter between the blocks, variables, and the
         * runtime interface.
         * @param {object} e Blockly "block" or "variable" event
         * @param {?Runtime} optRuntime Optional runtime to forward click events to.
         */

    }, {
        key: 'blocklyListen',
        value: function blocklyListen(e, optRuntime) {
            // Validate event
            if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) !== 'object') return;
            if (typeof e.blockId !== 'string' && typeof e.varId !== 'string') {
                return;
            }
            var stage = optRuntime.getTargetForStage();

            // UI event: clicked scripts toggle in the runtime.
            if (e.element === 'stackclick') {
                if (optRuntime) {
                    optRuntime.toggleScript(e.blockId, { stackClick: true });
                }
                return;
            }

            // Block create/update/destroy
            switch (e.type) {
                case 'create':
                    {
                        var newBlocks = adapter(e);
                        // A create event can create many blocks. Add them all.
                        for (var i = 0; i < newBlocks.length; i++) {
                            this.createBlock(newBlocks[i]);
                        }
                        break;
                    }
                case 'change':
                    this.changeBlock({
                        id: e.blockId,
                        element: e.element,
                        name: e.name,
                        value: e.newValue
                    }, optRuntime);
                    break;
                case 'move':
                    this.moveBlock({
                        id: e.blockId,
                        oldParent: e.oldParentId,
                        oldInput: e.oldInputName,
                        newParent: e.newParentId,
                        newInput: e.newInputName,
                        newCoordinate: e.newCoordinate
                    });
                    break;
                case 'delete':
                    // Don't accept delete events for missing blocks,
                    // or shadow blocks being obscured.
                    if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {
                        return;
                    }
                    // Inform any runtime to forget about glows on this script.
                    if (optRuntime && this._blocks[e.blockId].topLevel) {
                        optRuntime.quietGlow(e.blockId);
                    }
                    this.deleteBlock(e.blockId);
                    break;
                case 'var_create':
                    // New variables being created by the user are all global.
                    // Check if this variable exists on the current target or stage.
                    // If not, create it on the stage.
                    // TODO create global and local variables when UI provides a way.
                    if (optRuntime.getEditingTarget()) {
                        if (!optRuntime.getEditingTarget().lookupVariableById(e.varId)) {
                            stage.createVariable(e.varId, e.varName, e.varType);
                        }
                    } else if (!stage.lookupVariableById(e.varId)) {
                        // Since getEditingTarget returned null, we now need to
                        // explicitly check if the stage has the variable, and
                        // create one if not.
                        stage.createVariable(e.varId, e.varName, e.varType);
                    }
                    break;
                case 'var_rename':
                    stage.renameVariable(e.varId, e.newName);
                    break;
                case 'var_delete':
                    stage.deleteVariable(e.varId);
                    break;
            }
        }

        // ---------------------------------------------------------------------

        /**
         * Reset all runtime caches.
         */

    }, {
        key: 'resetCache',
        value: function resetCache() {
            this._cache.inputs = {};
            this._cache.procedureParamNames = {};
            this._cache.procedureDefinitions = {};
        }

        /**
         * Block management: create blocks and scripts from a `create` event
         * @param {!object} block Blockly create event to be processed
         */

    }, {
        key: 'createBlock',
        value: function createBlock(block) {
            // Does the block already exist?
            // Could happen, e.g., for an unobscured shadow.
            if (this._blocks.hasOwnProperty(block.id)) {
                return;
            }
            // Create new block.
            this._blocks[block.id] = block;
            // Push block id to scripts array.
            // Blocks are added as a top-level stack if they are marked as a top-block
            // (if they were top-level XML in the event).
            if (block.topLevel) {
                this._addScript(block.id);
            }

            this.resetCache();
        }

        /**
         * Block management: change block field values
         * @param {!object} args Blockly change event to be processed
         * @param {?Runtime} optRuntime Optional runtime to allow changeBlock to change VM state.
         */

    }, {
        key: 'changeBlock',
        value: function changeBlock(args, optRuntime) {
            // Validate
            if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;
            var block = this._blocks[args.id];
            if (typeof block === 'undefined') return;
            var wasMonitored = block.isMonitored;
            switch (args.element) {
                case 'field':
                    // Update block value
                    if (!block.fields[args.name]) return;
                    if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {
                        // Get variable name using the id in args.value.
                        var variable = optRuntime.getEditingTarget().lookupVariableById(args.value);
                        if (variable) {
                            block.fields[args.name].value = variable.name;
                            block.fields[args.name].id = args.value;
                        }
                    } else {
                        block.fields[args.name].value = args.value;
                    }
                    break;
                case 'mutation':
                    block.mutation = mutationAdapter(args.value);
                    break;
                case 'checkbox':
                    block.isMonitored = args.value;
                    if (optRuntime) {
                        var isSpriteSpecific = optRuntime.monitorBlockInfo.hasOwnProperty(block.opcode) && optRuntime.monitorBlockInfo[block.opcode].isSpriteSpecific;
                        block.targetId = isSpriteSpecific ? optRuntime.getEditingTarget().id : null;
                    }
                    if (optRuntime && wasMonitored && !block.isMonitored) {
                        optRuntime.requestRemoveMonitor(block.id);
                    } else if (optRuntime && !wasMonitored && block.isMonitored) {
                        optRuntime.requestAddMonitor(MonitorRecord({
                            // @todo(vm#564) this will collide if multiple sprites use same block
                            id: block.id,
                            targetId: block.targetId,
                            spriteName: block.targetId ? optRuntime.getTargetById(block.targetId).getName() : null,
                            opcode: block.opcode,
                            params: this._getBlockParams(block),
                            // @todo(vm#565) for numerical values with decimals, some countries use comma
                            value: ''
                        }));
                    }
                    break;
            }

            this.resetCache();
        }

        /**
         * Block management: move blocks from parent to parent
         * @param {!object} e Blockly move event to be processed
         */

    }, {
        key: 'moveBlock',
        value: function moveBlock(e) {
            if (!this._blocks.hasOwnProperty(e.id)) {
                return;
            }

            // Move coordinate changes.
            if (e.newCoordinate) {
                this._blocks[e.id].x = e.newCoordinate.x;
                this._blocks[e.id].y = e.newCoordinate.y;
            }

            // Remove from any old parent.
            if (typeof e.oldParent !== 'undefined') {
                var oldParent = this._blocks[e.oldParent];
                if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {
                    // This block was connected to the old parent's input.
                    oldParent.inputs[e.oldInput].block = null;
                } else if (oldParent.next === e.id) {
                    // This block was connected to the old parent's next connection.
                    oldParent.next = null;
                }
                this._blocks[e.id].parent = null;
            }

            // Has the block become a top-level block?
            if (typeof e.newParent === 'undefined') {
                this._addScript(e.id);
            } else {
                // Remove script, if one exists.
                this._deleteScript(e.id);
                // Otherwise, try to connect it in its new place.
                if (typeof e.newInput === 'undefined') {
                    // Moved to the new parent's next connection.
                    this._blocks[e.newParent].next = e.id;
                } else {
                    // Moved to the new parent's input.
                    // Don't obscure the shadow block.
                    var oldShadow = null;
                    if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {
                        oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
                    }
                    this._blocks[e.newParent].inputs[e.newInput] = {
                        name: e.newInput,
                        block: e.id,
                        shadow: oldShadow
                    };
                }
                this._blocks[e.id].parent = e.newParent;
            }
            this.resetCache();
        }

        /**
         * Block management: run all blocks.
         * @param {!object} runtime Runtime to run all blocks in.
         */

    }, {
        key: 'runAllMonitored',
        value: function runAllMonitored(runtime) {
            var _this = this;

            Object.keys(this._blocks).forEach(function (blockId) {
                if (_this.getBlock(blockId).isMonitored) {
                    var targetId = _this.getBlock(blockId).targetId;
                    runtime.addMonitorScript(blockId, targetId ? runtime.getTargetById(targetId) : null);
                }
            });
        }

        /**
         * Block management: delete blocks and their associated scripts. Does nothing if a block
         * with the given ID does not exist.
         * @param {!string} blockId Id of block to delete
         */

    }, {
        key: 'deleteBlock',
        value: function deleteBlock(blockId) {
            // @todo In runtime, stop threads running on this script.

            // Get block
            var block = this._blocks[blockId];
            if (!block) {
                // No block with the given ID exists
                return;
            }

            // Delete children
            if (block.next !== null) {
                this.deleteBlock(block.next);
            }

            // Delete inputs (including branches)
            for (var input in block.inputs) {
                // If it's null, the block in this input moved away.
                if (block.inputs[input].block !== null) {
                    this.deleteBlock(block.inputs[input].block);
                }
                // Delete obscured shadow blocks.
                if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
                    this.deleteBlock(block.inputs[input].shadow);
                }
            }

            // Delete any script starting with this block.
            this._deleteScript(blockId);

            // Delete block itself.
            delete this._blocks[blockId];

            this.resetCache();
        }

        // ---------------------------------------------------------------------

        /**
         * Encode all of `this._blocks` as an XML string usable
         * by a Blockly/scratch-blocks workspace.
         * @return {string} String of XML representing this object's blocks.
         */

    }, {
        key: 'toXML',
        value: function toXML() {
            var _this2 = this;

            return this._scripts.map(function (script) {
                return _this2.blockToXML(script);
            }).join();
        }

        /**
         * Recursively encode an individual block and its children
         * into a Blockly/scratch-blocks XML string.
         * @param {!string} blockId ID of block to encode.
         * @return {string} String of XML representing this block and any children.
         */

    }, {
        key: 'blockToXML',
        value: function blockToXML(blockId) {
            var block = this._blocks[blockId];
            // Encode properties of this block.
            var tagName = block.shadow ? 'shadow' : 'block';
            var xmlString = '<' + tagName + '\n                id="' + block.id + '"\n                type="' + block.opcode + '"\n                ' + (block.topLevel ? 'x="' + block.x + '" y="' + block.y + '"' : '') + '\n            >';
            // Add any mutation. Must come before inputs.
            if (block.mutation) {
                xmlString += this.mutationToXML(block.mutation);
            }
            // Add any inputs on this block.
            for (var input in block.inputs) {
                if (!block.inputs.hasOwnProperty(input)) continue;
                var blockInput = block.inputs[input];
                // Only encode a value tag if the value input is occupied.
                if (blockInput.block || blockInput.shadow) {
                    xmlString += '<value name="' + blockInput.name + '">';
                    if (blockInput.block) {
                        xmlString += this.blockToXML(blockInput.block);
                    }
                    if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
                        // Obscured shadow.
                        xmlString += this.blockToXML(blockInput.shadow);
                    }
                    xmlString += '</value>';
                }
            }
            // Add any fields on this block.
            for (var field in block.fields) {
                if (!block.fields.hasOwnProperty(field)) continue;
                var blockField = block.fields[field];
                xmlString += '<field name="' + blockField.name + '"';
                var fieldId = blockField.id;
                if (fieldId) {
                    xmlString += ' id="' + fieldId + '"';
                }
                var varType = blockField.variableType;
                if (typeof varType === 'string') {
                    xmlString += ' variabletype="' + varType + '"';
                }
                var value = blockField.value;
                if (typeof value === 'string') {
                    value = xmlEscape(blockField.value);
                }
                xmlString += '>' + value + '</field>';
            }
            // Add blocks connected to the next connection.
            if (block.next) {
                xmlString += '<next>' + this.blockToXML(block.next) + '</next>';
            }
            xmlString += '</' + tagName + '>';
            return xmlString;
        }

        /**
         * Recursively encode a mutation object to XML.
         * @param {!object} mutation Object representing a mutation.
         * @return {string} XML string representing a mutation.
         */

    }, {
        key: 'mutationToXML',
        value: function mutationToXML(mutation) {
            var mutationString = '<' + mutation.tagName;
            for (var prop in mutation) {
                if (prop === 'children' || prop === 'tagName') continue;
                var mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop];
                mutationString += ' ' + prop + '="' + mutationValue + '"';
            }
            mutationString += '>';
            for (var i = 0; i < mutation.children.length; i++) {
                mutationString += this.mutationToXML(mutation.children[i]);
            }
            mutationString += '</' + mutation.tagName + '>';
            return mutationString;
        }

        // ---------------------------------------------------------------------
        /**
         * Helper to serialize block fields and input fields for reporting new monitors
         * @param {!object} block Block to be paramified.
         * @return {!object} object of param key/values.
         */

    }, {
        key: '_getBlockParams',
        value: function _getBlockParams(block) {
            var params = {};
            for (var key in block.fields) {
                params[key] = block.fields[key].value;
            }
            for (var inputKey in block.inputs) {
                var inputBlock = this._blocks[block.inputs[inputKey].block];
                for (var _key in inputBlock.fields) {
                    params[_key] = inputBlock.fields[_key].value;
                }
            }
            return params;
        }

        /**
         * Helper to get the corresponding internal procedure definition block
         * @param {!object} defineBlock Outer define block.
         * @return {!object} internal definition block which has the mutation.
         */

    }, {
        key: '_getCustomBlockInternal',
        value: function _getCustomBlockInternal(defineBlock) {
            if (defineBlock.inputs && defineBlock.inputs.custom_block) {
                return this._blocks[defineBlock.inputs.custom_block.block];
            }
        }

        /**
         * Helper to add a stack to `this._scripts`.
         * @param {?string} topBlockId ID of block that starts the script.
         */

    }, {
        key: '_addScript',
        value: function _addScript(topBlockId) {
            var i = this._scripts.indexOf(topBlockId);
            if (i > -1) return; // Already in scripts.
            this._scripts.push(topBlockId);
            // Update `topLevel` property on the top block.
            this._blocks[topBlockId].topLevel = true;
        }

        /**
         * Helper to remove a script from `this._scripts`.
         * @param {?string} topBlockId ID of block that starts the script.
         */

    }, {
        key: '_deleteScript',
        value: function _deleteScript(topBlockId) {
            var i = this._scripts.indexOf(topBlockId);
            if (i > -1) this._scripts.splice(i, 1);
            // Update `topLevel` property on the top block.
            if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
        }
    }], [{
        key: 'BRANCH_INPUT_PREFIX',
        get: function get() {
            return 'SUBSTACK';
        }
    }]);

    return Blocks;
}();

module.exports = Blocks;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BlockType = {
    BOOLEAN: 'Boolean',
    COMMAND: 'command',
    CONDITIONAL: 'conditional',
    HAT: 'hat',
    REPORTER: 'reporter'
};

module.exports = BlockType;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Methods for cloning JavaScript objects.
 * @type {object}
 */
var Clone = function () {
  function Clone() {
    _classCallCheck(this, Clone);
  }

  _createClass(Clone, null, [{
    key: "simple",

    /**
     * Deep-clone a "simple" object: one which can be fully expressed with JSON.
     * Non-JSON values, such as functions, will be stripped from the clone.
     * @param {object} original - the object to be cloned.
     * @returns {object} a deep clone of the original object.
     */
    value: function simple(original) {
      return JSON.parse(JSON.stringify(original));
    }
  }]);

  return Clone;
}();

module.exports = Clone;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StringUtil = function () {
    function StringUtil() {
        _classCallCheck(this, StringUtil);
    }

    _createClass(StringUtil, null, [{
        key: 'withoutTrailingDigits',
        value: function withoutTrailingDigits(s) {
            var i = s.length - 1;
            while (i >= 0 && '0123456789'.indexOf(s.charAt(i)) > -1) {
                i--;
            }return s.slice(0, i + 1);
        }
    }, {
        key: 'unusedName',
        value: function unusedName(name, existingNames) {
            if (existingNames.indexOf(name) < 0) return name;
            name = StringUtil.withoutTrailingDigits(name);
            var i = 2;
            while (existingNames.indexOf(name + i) >= 0) {
                i++;
            }return name + i;
        }

        /**
         * Split a string on the first occurrence of a split character.
         * @param {string} text - the string to split.
         * @param {string} separator - split the text on this character.
         * @returns {[string, string]} - the two parts of the split string, or [text, null] if no split character found.
         * @example
         * // returns ['foo', 'tar.gz']
         * splitFirst('foo.tar.gz', '.');
         * @example
         * // returns ['foo', null]
         * splitFirst('foo', '.');
         * @example
         * // returns ['foo', '']
         * splitFirst('foo.', '.');
         */

    }, {
        key: 'splitFirst',
        value: function splitFirst(text, separator) {
            var index = text.indexOf(separator);
            if (index >= 0) {
                return [text.substring(0, index), text.substring(index + 1)];
            }
            return [text, null];
        }
    }]);

    return StringUtil;
}();

module.exports = StringUtil;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A thread is a running stack context and all the metadata needed.
 * @param {?string} firstBlock First block to execute in the thread.
 * @constructor
 */
var Thread = function () {
    function Thread(firstBlock) {
        _classCallCheck(this, Thread);

        /**
         * ID of top block of the thread
         * @type {!string}
         */
        this.topBlock = firstBlock;

        /**
         * Stack for the thread. When the sequencer enters a control structure,
         * the block is pushed onto the stack so we know where to exit.
         * @type {Array.<string>}
         */
        this.stack = [];

        /**
         * Stack frames for the thread. Store metadata for the executing blocks.
         * @type {Array.<Object>}
         */
        this.stackFrames = [];

        /**
         * Status of the thread, one of three states (below)
         * @type {number}
         */
        this.status = 0; /* Thread.STATUS_RUNNING */

        /**
         * Whether the thread is killed in the middle of execution.
         * @type {boolean}
         */
        this.isKilled = false;

        /**
         * Target of this thread.
         * @type {?Target}
         */
        this.target = null;

        /**
         * Whether the thread requests its script to glow during this frame.
         * @type {boolean}
         */
        this.requestScriptGlowInFrame = false;

        /**
         * Which block ID should glow during this frame, if any.
         * @type {?string}
         */
        this.blockGlowInFrame = null;

        /**
         * A timer for when the thread enters warp mode.
         * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
         * @type {?Timer}
         */
        this.warpTimer = null;
    }

    /**
     * Thread status for initialized or running thread.
     * This is the default state for a thread - execution should run normally,
     * stepping from block to block.
     * @const
     */


    _createClass(Thread, [{
        key: 'pushStack',


        /**
         * Push stack and update stack frames appropriately.
         * @param {string} blockId Block ID to push to stack.
         */
        value: function pushStack(blockId) {
            this.stack.push(blockId);
            // Push an empty stack frame, if we need one.
            // Might not, if we just popped the stack.
            if (this.stack.length > this.stackFrames.length) {
                // Copy warp mode from any higher level.
                var warpMode = false;
                if (this.stackFrames.length > 0 && this.stackFrames[this.stackFrames.length - 1]) {
                    warpMode = this.stackFrames[this.stackFrames.length - 1].warpMode;
                }
                this.stackFrames.push({
                    isLoop: false, // Whether this level of the stack is a loop.
                    warpMode: warpMode, // Whether this level is in warp mode.
                    reported: {}, // Collects reported input values.
                    waitingReporter: null, // Name of waiting reporter.
                    params: {}, // Procedure parameters.
                    executionContext: {} // A context passed to block implementations.
                });
            }
        }

        /**
         * Reset the stack frame for use by the next block.
         * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
         * @param {string} blockId Block ID to push to stack.
         */

    }, {
        key: 'reuseStackForNextBlock',
        value: function reuseStackForNextBlock(blockId) {
            this.stack[this.stack.length - 1] = blockId;
            var frame = this.stackFrames[this.stackFrames.length - 1];
            frame.isLoop = false;
            // frame.warpMode = warpMode;   // warp mode stays the same when reusing the stack frame.
            frame.reported = {};
            frame.waitingReporter = null;
            frame.params = {};
            frame.executionContext = {};
        }

        /**
         * Pop last block on the stack and its stack frame.
         * @return {string} Block ID popped from the stack.
         */

    }, {
        key: 'popStack',
        value: function popStack() {
            this.stackFrames.pop();
            return this.stack.pop();
        }

        /**
         * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
         */

    }, {
        key: 'stopThisScript',
        value: function stopThisScript() {
            var blockID = this.peekStack();
            while (blockID !== null) {
                var block = this.target.blocks.getBlock(blockID);
                if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {
                    break;
                }
                this.popStack();
                blockID = this.peekStack();
            }

            if (this.stack.length === 0) {
                // Clean up!
                this.requestScriptGlowInFrame = false;
                this.status = Thread.STATUS_DONE;
            }
        }

        /**
         * Get top stack item.
         * @return {?string} Block ID on top of stack.
         */

    }, {
        key: 'peekStack',
        value: function peekStack() {
            return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
        }

        /**
         * Get top stack frame.
         * @return {?object} Last stack frame stored on this thread.
         */

    }, {
        key: 'peekStackFrame',
        value: function peekStackFrame() {
            return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;
        }

        /**
         * Get stack frame above the current top.
         * @return {?object} Second to last stack frame stored on this thread.
         */

    }, {
        key: 'peekParentStackFrame',
        value: function peekParentStackFrame() {
            return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;
        }

        /**
         * Push a reported value to the parent of the current stack frame.
         * @param {*} value Reported value to push.
         */

    }, {
        key: 'pushReportedValue',
        value: function pushReportedValue(value) {
            var parentStackFrame = this.peekParentStackFrame();
            if (parentStackFrame) {
                var waitingReporter = parentStackFrame.waitingReporter;
                parentStackFrame.reported[waitingReporter] = value;
            }
        }

        /**
         * Add a parameter to the stack frame.
         * Use when calling a procedure with parameter values.
         * @param {!string} paramName Name of parameter.
         * @param {*} value Value to set for parameter.
         */

    }, {
        key: 'pushParam',
        value: function pushParam(paramName, value) {
            var stackFrame = this.peekStackFrame();
            stackFrame.params[paramName] = value;
        }

        /**
         * Get a parameter at the lowest possible level of the stack.
         * @param {!string} paramName Name of parameter.
         * @return {*} value Value for parameter.
         */

    }, {
        key: 'getParam',
        value: function getParam(paramName) {
            for (var i = this.stackFrames.length - 1; i >= 0; i--) {
                var frame = this.stackFrames[i];
                if (frame.params.hasOwnProperty(paramName)) {
                    return frame.params[paramName];
                }
            }
            return null;
        }

        /**
         * Whether the current execution of a thread is at the top of the stack.
         * @return {boolean} True if execution is at top of the stack.
         */

    }, {
        key: 'atStackTop',
        value: function atStackTop() {
            return this.peekStack() === this.topBlock;
        }

        /**
         * Switch the thread to the next block at the current level of the stack.
         * For example, this is used in a standard sequence of blocks,
         * where execution proceeds from one block to the next.
         */

    }, {
        key: 'goToNextBlock',
        value: function goToNextBlock() {
            var nextBlockId = this.target.blocks.getNextBlock(this.peekStack());
            this.reuseStackForNextBlock(nextBlockId);
        }

        /**
         * Attempt to determine whether a procedure call is recursive,
         * by examining the stack.
         * @param {!string} procedureCode Procedure code of procedure being called.
         * @return {boolean} True if the call appears recursive.
         */

    }, {
        key: 'isRecursiveCall',
        value: function isRecursiveCall(procedureCode) {
            var callCount = 5; // Max number of enclosing procedure calls to examine.
            var sp = this.stack.length - 1;
            for (var i = sp - 1; i >= 0; i--) {
                var block = this.target.blocks.getBlock(this.stack[i]);
                if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {
                    return true;
                }
                if (--callCount < 0) return false;
            }
            return false;
        }
    }], [{
        key: 'STATUS_RUNNING',
        get: function get() {
            return 0;
        }

        /**
         * Threads are in this state when a primitive is waiting on a promise;
         * execution is paused until the promise changes thread status.
         * @const
         */

    }, {
        key: 'STATUS_PROMISE_WAIT',
        get: function get() {
            return 1;
        }

        /**
         * Thread status for yield.
         * @const
         */

    }, {
        key: 'STATUS_YIELD',
        get: function get() {
            return 2;
        }

        /**
         * Thread status for a single-tick yield. This will be cleared when the
         * thread is resumed.
         * @const
         */

    }, {
        key: 'STATUS_YIELD_TICK',
        get: function get() {
            return 3;
        }

        /**
         * Thread status for a finished/done thread.
         * Thread is in this state when there are no more blocks to execute.
         * @const
         */

    }, {
        key: 'STATUS_DONE',
        get: function get() {
            return 4;
        }
    }]);

    return Thread;
}();

module.exports = Thread;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @fileoverview
 * Object representing a Scratch variable.
 */

var uid = __webpack_require__(28);

var Variable = function () {
    /**
     * @param {string} id Id of the variable.
     * @param {string} name Name of the variable.
     * @param {string} type Type of the variable, one of '' or 'list'
     * @param {boolean} isCloud Whether the variable is stored in the cloud.
     * @constructor
     */
    function Variable(id, name, type, isCloud) {
        _classCallCheck(this, Variable);

        this.id = id || uid();
        this.name = name;
        this.type = type;
        this.isCloud = isCloud;
        switch (this.type) {
            case Variable.SCALAR_TYPE:
                this.value = 0;
                break;
            case Variable.LIST_TYPE:
                this.value = [];
                break;
            case Variable.BROADCAST_MESSAGE_TYPE:
                this.value = this.name;
                break;
            default:
                throw new Error('Invalid variable type: ' + this.type);
        }
    }

    _createClass(Variable, [{
        key: 'toXML',
        value: function toXML() {
            return '<variable type="' + this.type + '" id="' + this.id + '">' + this.name + '</variable>';
        }

        /**
         * Type representation for scalar variables.
         * This is currently represented as ''
         * for compatibility with blockly.
         * @const {string}
         */

    }], [{
        key: 'SCALAR_TYPE',
        get: function get() {
            return '';
        }

        /**
         * Type representation for list variables.
         * @const {string}
         */

    }, {
        key: 'LIST_TYPE',
        get: function get() {
            return 'list';
        }

        /**
         * Type representation for list variables.
         * @const {string}
         */

    }, {
        key: 'BROADCAST_MESSAGE_TYPE',
        get: function get() {
            return 'broadcast_msg';
        }
    }]);

    return Variable;
}();

module.exports = Variable;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArgumentType = {
    ANGLE: 'angle',
    BOOLEAN: 'Boolean',
    COLOR: 'color',
    NUMBER: 'number',
    STRING: 'string'
};

module.exports = ArgumentType;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StringUtil = __webpack_require__(13);
var log = __webpack_require__(1);

/**
 * Initialize a costume from an asset asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @param {!Asset} costumeAsset - the asset of the costume loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */
var loadCostumeFromAsset = function loadCostumeFromAsset(costume, costumeAsset, runtime) {
    costume.assetId = costumeAsset.assetId;
    if (!runtime.renderer) {
        log.error('No rendering module present; cannot load costume: ', costume.name);
        return costume;
    }
    var AssetType = runtime.storage.AssetType;
    var rotationCenter = [costume.rotationCenterX / costume.bitmapResolution, costume.rotationCenterY / costume.bitmapResolution];
    if (costumeAsset.assetType === AssetType.ImageVector) {
        costume.skinId = runtime.renderer.createSVGSkin(costumeAsset.decodeText(), rotationCenter);
        return costume;
    }

    return new Promise(function (resolve, reject) {
        var imageElement = new Image();
        var onError = function onError() {
            // eslint-disable-next-line no-use-before-define
            removeEventListeners();
            reject();
        };
        var onLoad = function onLoad() {
            // eslint-disable-next-line no-use-before-define
            removeEventListeners();
            resolve(imageElement);
        };
        var removeEventListeners = function removeEventListeners() {
            imageElement.removeEventListener('error', onError);
            imageElement.removeEventListener('load', onLoad);
        };
        imageElement.addEventListener('error', onError);
        imageElement.addEventListener('load', onLoad);
        imageElement.src = costumeAsset.encodeDataURI();
    }).then(function (imageElement) {
        costume.skinId = runtime.renderer.createBitmapSkin(imageElement, costume.bitmapResolution, rotationCenter);
        return costume;
    });
};

/**
 * Load a costume's asset into memory asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */
var loadCostume = function loadCostume(md5ext, costume, runtime) {
    if (!runtime.storage) {
        log.error('No storage module present; cannot load costume asset: ', md5ext);
        return Promise.resolve(costume);
    }

    var AssetType = runtime.storage.AssetType;
    var idParts = StringUtil.splitFirst(md5ext, '.');
    var md5 = idParts[0];
    var ext = idParts[1].toLowerCase();
    var assetType = ext === 'svg' ? AssetType.ImageVector : AssetType.ImageBitmap;

    return runtime.storage.load(assetType, md5, ext).then(function (costumeAsset) {
        costume.dataFormat = ext;
        return loadCostumeFromAsset(costume, costumeAsset, runtime);
    });
};

module.exports = {
    loadCostume: loadCostume,
    loadCostumeFromAsset: loadCostumeFromAsset
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StringUtil = __webpack_require__(13);
var log = __webpack_require__(1);

/**
 * Initialize a sound from an asset asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Asset} soundAsset - the asset loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */
var loadSoundFromAsset = function loadSoundFromAsset(sound, soundAsset, runtime) {
    sound.assetId = soundAsset.assetId;
    return runtime.audioEngine.decodeSound(Object.assign({}, sound, { data: soundAsset.data })).then(function (soundId) {
        sound.soundId = soundId;
        return sound;
    });
};

/**
 * Load a sound's asset into memory asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */
var loadSound = function loadSound(sound, runtime) {
    if (!runtime.storage) {
        log.error('No storage module present; cannot load sound asset: ', sound.md5);
        return Promise.resolve(sound);
    }
    if (!runtime.audioEngine) {
        log.error('No audio engine present; cannot load sound asset: ', sound.md5);
        return Promise.resolve(sound);
    }
    var idParts = StringUtil.splitFirst(sound.md5, '.');
    var md5 = idParts[0];
    var ext = idParts[1].toLowerCase();
    return runtime.storage.load(runtime.storage.AssetType.Sound, md5, ext).then(function (soundAsset) {
        sound.dataFormat = ext;
        return loadSoundFromAsset(sound, soundAsset, runtime);
    });
};

module.exports = {
    loadSound: loadSound,
    loadSoundFromAsset: loadSoundFromAsset
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var log = __webpack_require__(1);
var MathUtil = __webpack_require__(6);
var StringUtil = __webpack_require__(13);
var Target = __webpack_require__(78);

/**
 * Rendered target: instance of a sprite (clone), or the stage.
 */

var RenderedTarget = function (_Target) {
    _inherits(RenderedTarget, _Target);

    /**
     * @param {!Sprite} sprite Reference to the parent sprite.
     * @param {Runtime} runtime Reference to the runtime.
     * @constructor
     */
    function RenderedTarget(sprite, runtime) {
        _classCallCheck(this, RenderedTarget);

        /**
         * Reference to the sprite that this is a render of.
         * @type {!Sprite}
         */
        var _this = _possibleConstructorReturn(this, (RenderedTarget.__proto__ || Object.getPrototypeOf(RenderedTarget)).call(this, runtime, sprite.blocks));

        _this.sprite = sprite;
        /**
         * Reference to the global renderer for this VM, if one exists.
         * @type {?RenderWebGL}
         */
        _this.renderer = null;
        if (_this.runtime) {
            _this.renderer = _this.runtime.renderer;
        }
        /**
         * ID of the drawable for this rendered target,
         * returned by the renderer, if rendered.
         * @type {?Number}
         */
        _this.drawableID = null;

        /**
         * Drag state of this rendered target. If true, x/y position can't be
         * changed by blocks.
         * @type {boolean}
         */
        _this.dragging = false;

        /**
         * Map of current graphic effect values.
         * @type {!Object.<string, number>}
         */
        _this.effects = {
            color: 0,
            fisheye: 0,
            whirl: 0,
            pixelate: 0,
            mosaic: 0,
            brightness: 0,
            ghost: 0
        };

        /**
         * Whether this represents an "original" non-clone rendered-target for a sprite,
         * i.e., created by the editor and not clone blocks.
         * @type {boolean}
         */
        _this.isOriginal = true;

        /**
         * Whether this rendered target represents the Scratch stage.
         * @type {boolean}
         */
        _this.isStage = false;

        /**
         * Scratch X coordinate. Currently should range from -240 to 240.
         * @type {Number}
         */
        _this.x = 0;

        /**
         * Scratch Y coordinate. Currently should range from -180 to 180.
         * @type {number}
         */
        _this.y = 0;

        /**
         * Scratch direction. Currently should range from -179 to 180.
         * @type {number}
         */
        _this.direction = 90;

        /**
         * Whether the rendered target is draggable on the stage
         * @type {boolean}
         */
        _this.draggable = false;

        /**
         * Whether the rendered target is currently visible.
         * @type {boolean}
         */
        _this.visible = true;

        /**
         * Size of rendered target as a percent of costume size.
         * @type {number}
         */
        _this.size = 100;

        /**
         * Currently selected costume index.
         * @type {number}
         */
        _this.currentCostume = 0;

        /**
         * Current rotation style.
         * @type {!string}
         */
        _this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
        return _this;
    }

    /**
     * Create a drawable with the this.renderer.
     */


    _createClass(RenderedTarget, [{
        key: 'initDrawable',
        value: function initDrawable() {
            if (this.renderer) {
                this.drawableID = this.renderer.createDrawable();
            }
            // If we're a clone, start the hats.
            if (!this.isOriginal) {
                this.runtime.startHats('control_start_as_clone', null, this);
            }

            /**
            * Audio player
            */
            this.audioPlayer = null;
            if (this.runtime && this.runtime.audioEngine) {
                this.audioPlayer = this.runtime.audioEngine.createPlayer();
            }
        }

        /**
         * Event which fires when a target moves.
         * @type {string}
         */

    }, {
        key: 'setXY',


        /**
         * Set the X and Y coordinates.
         * @param {!number} x New X coordinate, in Scratch coordinates.
         * @param {!number} y New Y coordinate, in Scratch coordinates.
         * @param {?boolean} force Force setting X/Y, in case of dragging
         */
        value: function setXY(x, y, force) {
            if (this.isStage) return;
            if (this.dragging && !force) return;
            var oldX = this.x;
            var oldY = this.y;
            if (this.renderer) {
                var position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);
                this.x = position[0];
                this.y = position[1];

                this.renderer.updateDrawableProperties(this.drawableID, {
                    position: position
                });
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            } else {
                this.x = x;
                this.y = y;
            }
            this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY);
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Get the rendered direction and scale, after applying rotation style.
         * @return {object<string, number>} Direction and scale to render.
         */

    }, {
        key: '_getRenderedDirectionAndScale',
        value: function _getRenderedDirectionAndScale() {
            // Default: no changes to `this.direction` or `this.scale`.
            var finalDirection = this.direction;
            var finalScale = [this.size, this.size];
            if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
                // Force rendered direction to be 90.
                finalDirection = 90;
            } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
                // Force rendered direction to be 90, and flip drawable if needed.
                finalDirection = 90;
                var scaleFlip = this.direction < 0 ? -1 : 1;
                finalScale = [scaleFlip * this.size, this.size];
            }
            return { direction: finalDirection, scale: finalScale };
        }

        /**
         * Set the direction.
         * @param {!number} direction New direction.
         */

    }, {
        key: 'setDirection',
        value: function setDirection(direction) {
            if (this.isStage) {
                return;
            }
            if (!isFinite(direction)) {
                return;
            }
            // Keep direction between -179 and +180.
            this.direction = MathUtil.wrapClamp(direction, -179, 180);
            if (this.renderer) {
                var renderedDirectionScale = this._getRenderedDirectionAndScale();
                this.renderer.updateDrawableProperties(this.drawableID, {
                    direction: renderedDirectionScale.direction,
                    scale: renderedDirectionScale.scale
                });
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Set draggability; i.e., whether it's able to be dragged in the player
         * @param {!boolean} draggable True if should be draggable.
         */

    }, {
        key: 'setDraggable',
        value: function setDraggable(draggable) {
            if (this.isStage) return;
            this.draggable = !!draggable;
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Set a say bubble.
         * @param {?string} type Type of say bubble: "say", "think", or null.
         * @param {?string} message Message to put in say bubble.
         */

    }, {
        key: 'setSay',
        value: function setSay(type, message) {
            if (this.isStage) {
                return;
            }
            // @todo: Render to stage.
            if (!type || !message) {
                log.info('Clearing say bubble');
                return;
            }
            log.info('Setting say bubble:', type, message);
        }

        /**
         * Set visibility; i.e., whether it's shown or hidden.
         * @param {!boolean} visible True if should be shown.
         */

    }, {
        key: 'setVisible',
        value: function setVisible(visible) {
            if (this.isStage) {
                return;
            }
            this.visible = !!visible;
            if (this.renderer) {
                this.renderer.updateDrawableProperties(this.drawableID, {
                    visible: this.visible
                });
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Set size, as a percentage of the costume size.
         * @param {!number} size Size of rendered target, as % of costume size.
         */

    }, {
        key: 'setSize',
        value: function setSize(size) {
            if (this.isStage) {
                return;
            }
            if (this.renderer) {
                // Clamp to scales relative to costume and stage size.
                // See original ScratchSprite.as:setSize.
                var costumeSize = this.renderer.getSkinSize(this.drawableID);
                var origW = costumeSize[0];
                var origH = costumeSize[1];
                var minScale = Math.min(1, Math.max(5 / origW, 5 / origH));
                var maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);
                this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;
                var renderedDirectionScale = this._getRenderedDirectionAndScale();
                this.renderer.updateDrawableProperties(this.drawableID, {
                    direction: renderedDirectionScale.direction,
                    scale: renderedDirectionScale.scale
                });
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
        }

        /**
         * Set a particular graphic effect value.
         * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
         * @param {!number} value Numerical magnitude of effect.
         */

    }, {
        key: 'setEffect',
        value: function setEffect(effectName, value) {
            if (!this.effects.hasOwnProperty(effectName)) return;
            this.effects[effectName] = value;
            if (this.renderer) {
                var props = {};
                props[effectName] = this.effects[effectName];
                this.renderer.updateDrawableProperties(this.drawableID, props);
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
        }

        /**
         * Clear all graphic effects on this rendered target.
         */

    }, {
        key: 'clearEffects',
        value: function clearEffects() {
            for (var effectName in this.effects) {
                if (!this.effects.hasOwnProperty(effectName)) continue;
                this.effects[effectName] = 0;
            }
            if (this.renderer) {
                this.renderer.updateDrawableProperties(this.drawableID, this.effects);
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
        }

        /**
         * Set the current costume.
         * @param {number} index New index of costume.
         */

    }, {
        key: 'setCostume',
        value: function setCostume(index) {
            // Keep the costume index within possible values.
            index = Math.round(index);
            this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);
            if (this.renderer) {
                var costume = this.sprite.costumes[this.currentCostume];
                var drawableProperties = {
                    skinId: costume.skinId,
                    costumeResolution: costume.bitmapResolution
                };
                if (typeof costume.rotationCenterX !== 'undefined' && typeof costume.rotationCenterY !== 'undefined') {
                    var scale = costume.bitmapResolution || 1;
                    drawableProperties.rotationCenter = [costume.rotationCenterX / scale, costume.rotationCenterY / scale];
                }
                this.renderer.updateDrawableProperties(this.drawableID, drawableProperties);
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Add a costume, taking care to avoid duplicate names.
         * @param {!object} costumeObject Object representing the costume.
         */

    }, {
        key: 'addCostume',
        value: function addCostume(costumeObject) {
            var usedNames = this.sprite.costumes.map(function (costume) {
                return costume.name;
            });
            costumeObject.name = StringUtil.unusedName(costumeObject.name, usedNames);
            this.sprite.costumes.push(costumeObject);
        }

        /**
         * Rename a costume, taking care to avoid duplicate names.
         * @param {int} costumeIndex - the index of the costume to be renamed.
         * @param {string} newName - the desired new name of the costume (will be modified if already in use).
         */

    }, {
        key: 'renameCostume',
        value: function renameCostume(costumeIndex, newName) {
            var usedNames = this.sprite.costumes.filter(function (costume, index) {
                return costumeIndex !== index;
            }).map(function (costume) {
                return costume.name;
            });
            this.sprite.costumes[costumeIndex].name = StringUtil.unusedName(newName, usedNames);
        }

        /**
         * Delete a costume by index.
         * @param {number} index Costume index to be deleted
         */

    }, {
        key: 'deleteCostume',
        value: function deleteCostume(index) {
            var originalCostumeCount = this.sprite.costumes.length;
            if (originalCostumeCount === 1) return;

            this.sprite.costumes = this.sprite.costumes.slice(0, index).concat(this.sprite.costumes.slice(index + 1));

            if (index === this.currentCostume && index === originalCostumeCount - 1) {
                this.setCostume(index - 1);
            } else if (index < this.currentCostume) {
                this.setCostume(this.currentCostume - 1);
            } else {
                this.setCostume(this.currentCostume);
            }

            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Add a sound, taking care to avoid duplicate names.
         * @param {!object} soundObject Object representing the sound.
         */

    }, {
        key: 'addSound',
        value: function addSound(soundObject) {
            var usedNames = this.sprite.sounds.map(function (sound) {
                return sound.name;
            });
            soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);
            this.sprite.sounds.push(soundObject);
        }

        /**
         * Rename a sound, taking care to avoid duplicate names.
         * @param {int} soundIndex - the index of the sound to be renamed.
         * @param {string} newName - the desired new name of the sound (will be modified if already in use).
         */

    }, {
        key: 'renameSound',
        value: function renameSound(soundIndex, newName) {
            var usedNames = this.sprite.sounds.filter(function (sound, index) {
                return soundIndex !== index;
            }).map(function (sound) {
                return sound.name;
            });
            this.sprite.sounds[soundIndex].name = StringUtil.unusedName(newName, usedNames);
        }

        /**
         * Delete a sound by index.
         * @param {number} index Sound index to be deleted
         */

    }, {
        key: 'deleteSound',
        value: function deleteSound(index) {
            this.sprite.sounds = this.sprite.sounds.slice(0, index).concat(this.sprite.sounds.slice(index + 1));
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Update the rotation style.
         * @param {!string} rotationStyle New rotation style.
         */

    }, {
        key: 'setRotationStyle',
        value: function setRotationStyle(rotationStyle) {
            if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
                this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
            } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
                this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
            } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
                this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
            }
            if (this.renderer) {
                var renderedDirectionScale = this._getRenderedDirectionAndScale();
                this.renderer.updateDrawableProperties(this.drawableID, {
                    direction: renderedDirectionScale.direction,
                    scale: renderedDirectionScale.scale
                });
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Get a costume index of this rendered target, by name of the costume.
         * @param {?string} costumeName Name of a costume.
         * @return {number} Index of the named costume, or -1 if not present.
         */

    }, {
        key: 'getCostumeIndexByName',
        value: function getCostumeIndexByName(costumeName) {
            for (var i = 0; i < this.sprite.costumes.length; i++) {
                if (this.sprite.costumes[i].name === costumeName) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * Get a costume of this rendered target by id.
         * @return {object} current costume
         */

    }, {
        key: 'getCurrentCostume',
        value: function getCurrentCostume() {
            return this.sprite.costumes[this.currentCostume];
        }

        /**
         * Get full costume list
         * @return {object[]} list of costumes
         */

    }, {
        key: 'getCostumes',
        value: function getCostumes() {
            return this.sprite.costumes;
        }

        /**
         * Get full sound list
         * @return {object[]} list of sounds
         */

    }, {
        key: 'getSounds',
        value: function getSounds() {
            return this.sprite.sounds;
        }

        /**
         * Update all drawable properties for this rendered target.
         * Use when a batch has changed, e.g., when the drawable is first created.
         */

    }, {
        key: 'updateAllDrawableProperties',
        value: function updateAllDrawableProperties() {
            if (this.renderer) {
                var renderedDirectionScale = this._getRenderedDirectionAndScale();
                var costume = this.sprite.costumes[this.currentCostume];
                var bitmapResolution = costume.bitmapResolution || 1;
                var props = {
                    position: [this.x, this.y],
                    direction: renderedDirectionScale.direction,
                    draggable: this.draggable,
                    scale: renderedDirectionScale.scale,
                    visible: this.visible,
                    skinId: costume.skinId,
                    costumeResolution: bitmapResolution,
                    rotationCenter: [costume.rotationCenterX / bitmapResolution, costume.rotationCenterY / bitmapResolution]
                };
                for (var effectName in this.effects) {
                    if (!this.effects.hasOwnProperty(effectName)) continue;
                    props[effectName] = this.effects[effectName];
                }
                this.renderer.updateDrawableProperties(this.drawableID, props);
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
            this.runtime.requestTargetsUpdate(this);
        }

        /**
         * Return the human-readable name for this rendered target, e.g., the sprite's name.
         * @override
         * @returns {string} Human-readable name.
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this.sprite.name;
        }

        /**
         * Return whether this rendered target is a sprite (not a clone, not the stage).
         * @return {boolean} True if not a clone and not the stage.
         */

    }, {
        key: 'isSprite',
        value: function isSprite() {
            return !this.isStage && this.isOriginal;
        }

        /**
         * Return the rendered target's tight bounding box.
         * Includes top, left, bottom, right attributes in Scratch coordinates.
         * @return {?object} Tight bounding box, or null.
         */

    }, {
        key: 'getBounds',
        value: function getBounds() {
            if (this.renderer) {
                return this.runtime.renderer.getBounds(this.drawableID);
            }
            return null;
        }

        /**
         * Return whether touching a point.
         * @param {number} x X coordinate of test point.
         * @param {number} y Y coordinate of test point.
         * @return {boolean} True iff the rendered target is touching the point.
         */

    }, {
        key: 'isTouchingPoint',
        value: function isTouchingPoint(x, y) {
            if (this.renderer) {
                // @todo: Update once pick is in Scratch coordinates.
                // Limits test to this Drawable, so this will return true
                // even if the clone is obscured by another Drawable.
                var pickResult = this.runtime.renderer.pick(x + this.runtime.constructor.STAGE_WIDTH / 2, -y + this.runtime.constructor.STAGE_HEIGHT / 2, null, null, [this.drawableID]);
                return pickResult === this.drawableID;
            }
            return false;
        }

        /**
         * Return whether touching a stage edge.
         * @return {boolean} True iff the rendered target is touching the stage edge.
         */

    }, {
        key: 'isTouchingEdge',
        value: function isTouchingEdge() {
            if (this.renderer) {
                var stageWidth = this.runtime.constructor.STAGE_WIDTH;
                var stageHeight = this.runtime.constructor.STAGE_HEIGHT;
                var bounds = this.getBounds();
                if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Return whether touching any of a named sprite's clones.
         * @param {string} spriteName Name of the sprite.
         * @return {boolean} True iff touching a clone of the sprite.
         */

    }, {
        key: 'isTouchingSprite',
        value: function isTouchingSprite(spriteName) {
            var firstClone = this.runtime.getSpriteTargetByName(spriteName);
            if (!firstClone || !this.renderer) {
                return false;
            }
            var drawableCandidates = firstClone.sprite.clones.map(function (clone) {
                return clone.drawableID;
            });
            return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
        }

        /**
         * Return whether touching a color.
         * @param {Array.<number>} rgb [r,g,b], values between 0-255.
         * @return {Promise.<boolean>} True iff the rendered target is touching the color.
         */

    }, {
        key: 'isTouchingColor',
        value: function isTouchingColor(rgb) {
            if (this.renderer) {
                return this.renderer.isTouchingColor(this.drawableID, rgb);
            }
            return false;
        }

        /**
         * Return whether rendered target's color is touching a color.
         * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
         * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
         * @return {Promise.<boolean>} True iff the color is touching the color.
         */

    }, {
        key: 'colorIsTouchingColor',
        value: function colorIsTouchingColor(targetRgb, maskRgb) {
            if (this.renderer) {
                return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
            }
            return false;
        }

        /**
         * Move to the front layer.
         */

    }, {
        key: 'goToFront',
        value: function goToFront() {
            if (this.renderer) {
                this.renderer.setDrawableOrder(this.drawableID, Infinity);
            }
        }

        /**
         * Move back a number of layers.
         * @param {number} nLayers How many layers to go back.
         */

    }, {
        key: 'goBackLayers',
        value: function goBackLayers(nLayers) {
            if (this.renderer) {
                this.renderer.setDrawableOrder(this.drawableID, -nLayers, true, 1);
            }
        }

        /**
         * Move behind some other rendered target.
         * @param {!RenderedTarget} other Other rendered target to move behind.
         */

    }, {
        key: 'goBehindOther',
        value: function goBehindOther(other) {
            if (this.renderer) {
                var otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, true);
                this.renderer.setDrawableOrder(this.drawableID, otherLayer);
            }
        }

        /**
         * Keep a desired position within a fence.
         * @param {number} newX New desired X position.
         * @param {number} newY New desired Y position.
         * @param {object=} optFence Optional fence with left, right, top bottom.
         * @return {Array.<number>} Fenced X and Y coordinates.
         */

    }, {
        key: 'keepInFence',
        value: function keepInFence(newX, newY, optFence) {
            var fence = optFence;
            if (!fence) {
                fence = {
                    left: -this.runtime.constructor.STAGE_WIDTH / 2,
                    right: this.runtime.constructor.STAGE_WIDTH / 2,
                    top: this.runtime.constructor.STAGE_HEIGHT / 2,
                    bottom: -this.runtime.constructor.STAGE_HEIGHT / 2
                };
            }
            var bounds = this.getBounds();
            if (!bounds) return;
            // Adjust the known bounds to the target position.
            bounds.left += newX - this.x;
            bounds.right += newX - this.x;
            bounds.top += newY - this.y;
            bounds.bottom += newY - this.y;
            // Find how far we need to move the target position.
            var dx = 0;
            var dy = 0;
            if (bounds.left < fence.left) {
                dx += fence.left - bounds.left;
            }
            if (bounds.right > fence.right) {
                dx += fence.right - bounds.right;
            }
            if (bounds.top > fence.top) {
                dy += fence.top - bounds.top;
            }
            if (bounds.bottom < fence.bottom) {
                dy += fence.bottom - bounds.bottom;
            }
            return [newX + dx, newY + dy];
        }

        /**
         * Make a clone, copying any run-time properties.
         * If we've hit the global clone limit, returns null.
         * @return {RenderedTarget} New clone.
         */

    }, {
        key: 'makeClone',
        value: function makeClone() {
            if (!this.runtime.clonesAvailable() || this.isStage) {
                return null; // Hit max clone limit, or this is the stage.
            }
            this.runtime.changeCloneCounter(1);
            var newClone = this.sprite.createClone();
            // Copy all properties.
            newClone.x = this.x;
            newClone.y = this.y;
            newClone.direction = this.direction;
            newClone.draggable = this.draggable;
            newClone.visible = this.visible;
            newClone.size = this.size;
            newClone.currentCostume = this.currentCostume;
            newClone.rotationStyle = this.rotationStyle;
            newClone.effects = JSON.parse(JSON.stringify(this.effects));
            newClone.variables = JSON.parse(JSON.stringify(this.variables));
            newClone.lists = JSON.parse(JSON.stringify(this.lists));
            newClone.initDrawable();
            newClone.updateAllDrawableProperties();
            // Place behind the current target.
            newClone.goBehindOther(this);
            return newClone;
        }

        /**
         * Make a duplicate using a duplicate sprite.
         * @return {RenderedTarget} New clone.
         */

    }, {
        key: 'duplicate',
        value: function duplicate() {
            var _this2 = this;

            return this.sprite.duplicate().then(function (newSprite) {
                var newTarget = newSprite.createClone();
                // Copy all properties.
                // @todo refactor with clone methods
                newTarget.x = Math.random() * 400 / 2;
                newTarget.y = Math.random() * 300 / 2;
                newTarget.direction = _this2.direction;
                newTarget.draggable = _this2.draggable;
                newTarget.visible = _this2.visible;
                newTarget.size = _this2.size;
                newTarget.currentCostume = _this2.currentCostume;
                newTarget.rotationStyle = _this2.rotationStyle;
                newTarget.effects = JSON.parse(JSON.stringify(_this2.effects));
                newTarget.variables = JSON.parse(JSON.stringify(_this2.variables));
                newTarget.lists = JSON.parse(JSON.stringify(_this2.lists));
                newTarget.initDrawable();
                newTarget.updateAllDrawableProperties();
                newTarget.goBehindOther(_this2);
                return newTarget;
            });
        }

        /**
         * Called when the project receives a "green flag."
         * For a rendered target, this clears graphic effects.
         */

    }, {
        key: 'onGreenFlag',
        value: function onGreenFlag() {
            this.clearEffects();
        }

        /**
         * Called when the project receives a "stop all"
         * Stop all sounds and clear graphic effects.
         */

    }, {
        key: 'onStopAll',
        value: function onStopAll() {
            this.clearEffects();
            if (this.audioPlayer) {
                this.audioPlayer.stopAllSounds();
                this.audioPlayer.clearEffects();
            }
        }

        /**
         * Post/edit sprite info.
         * @param {object} data An object with sprite info data to set.
         */

    }, {
        key: 'postSpriteInfo',
        value: function postSpriteInfo(data) {
            var force = data.hasOwnProperty('force') ? data.force : null;
            if (data.hasOwnProperty('x')) {
                this.setXY(data.x, this.y, force);
            }
            if (data.hasOwnProperty('y')) {
                this.setXY(this.x, data.y, force);
            }
            if (data.hasOwnProperty('direction')) {
                this.setDirection(data.direction);
            }
            if (data.hasOwnProperty('draggable')) {
                this.setDraggable(data.draggable);
            }
            if (data.hasOwnProperty('rotationStyle')) {
                this.setRotationStyle(data.rotationStyle);
            }
            if (data.hasOwnProperty('visible')) {
                this.setVisible(data.visible);
            }
        }

        /**
         * Put the sprite into the drag state. While in effect, setXY must be forced
         */

    }, {
        key: 'startDrag',
        value: function startDrag() {
            this.dragging = true;
        }

        /**
         * Remove the sprite from the drag state.
         */

    }, {
        key: 'stopDrag',
        value: function stopDrag() {
            this.dragging = false;
        }

        /**
         * Serialize sprite info, used when emitting events about the sprite
         * @returns {object} Sprite data as a simple object
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var costumes = this.getCostumes();
            return {
                id: this.id,
                name: this.getName(),
                isStage: this.isStage,
                x: this.x,
                y: this.y,
                size: this.size,
                direction: this.direction,
                draggable: this.draggable,
                currentCostume: this.currentCostume,
                costume: costumes[this.currentCostume],
                costumeCount: costumes.length,
                visible: this.visible,
                rotationStyle: this.rotationStyle,
                blocks: this.blocks._blocks,
                variables: this.variables,
                lists: this.lists,
                costumes: costumes,
                sounds: this.getSounds()
            };
        }

        /**
         * Dispose, destroying any run-time properties.
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this.runtime.changeCloneCounter(-1);
            this.runtime.stopForTarget(this);
            this.sprite.removeClone(this);
            if (this.renderer && this.drawableID !== null) {
                this.renderer.destroyDrawable(this.drawableID);
                if (this.visible) {
                    this.runtime.requestRedraw();
                }
            }
        }
    }], [{
        key: 'EVENT_TARGET_MOVED',
        get: function get() {
            return 'TARGET_MOVED';
        }

        /**
         * Rotation style for "all around"/spinning.
         * @type {string}
         */

    }, {
        key: 'ROTATION_STYLE_ALL_AROUND',
        get: function get() {
            return 'all around';
        }

        /**
         * Rotation style for "left-right"/flipping.
         * @type {string}
         */

    }, {
        key: 'ROTATION_STYLE_LEFT_RIGHT',
        get: function get() {
            return 'left-right';
        }

        /**
         * Rotation style for "no rotation."
         * @type {string}
         */

    }, {
        key: 'ROTATION_STYLE_NONE',
        get: function get() {
            return "don't rotate";
        }
    }]);

    return RenderedTarget;
}(Target);

module.exports = RenderedTarget;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Color = function () {
    function Color() {
        _classCallCheck(this, Color);
    }

    _createClass(Color, null, [{
        key: 'decimalToHex',


        /**
         * Convert a Scratch decimal color to a hex string, #RRGGBB.
         * @param {number} decimal RGB color as a decimal.
         * @return {string} RGB color as #RRGGBB hex string.
         */
        value: function decimalToHex(decimal) {
            if (decimal < 0) {
                decimal += 0xFFFFFF + 1;
            }
            var hex = Number(decimal).toString(16);
            hex = '#' + '000000'.substr(0, 6 - hex.length) + hex;
            return hex;
        }

        /**
         * Convert a Scratch decimal color to an RGB color object.
         * @param {number} decimal RGB color as decimal.
         * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         */

    }, {
        key: 'decimalToRgb',
        value: function decimalToRgb(decimal) {
            var a = decimal >> 24 & 0xFF;
            var r = decimal >> 16 & 0xFF;
            var g = decimal >> 8 & 0xFF;
            var b = decimal & 0xFF;
            return { r: r, g: g, b: b, a: a > 0 ? a : 255 };
        }

        /**
         * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
         * CC-BY-SA Tim Down:
         * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
         * @param {!string} hex Hex representation of the color.
         * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         */

    }, {
        key: 'hexToRgb',
        value: function hexToRgb(hex) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Convert an RGB color object to a hex color.
         * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         * @return {!string} Hex representation of the color.
         */

    }, {
        key: 'rgbToHex',
        value: function rgbToHex(rgb) {
            return Color.decimalToHex(Color.rgbToDecimal(rgb));
        }

        /**
         * Convert an RGB color object to a Scratch decimal color.
         * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         * @return {!number} Number representing the color.
         */

    }, {
        key: 'rgbToDecimal',
        value: function rgbToDecimal(rgb) {
            return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
        }

        /**
        * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
        * @param {!string} hex Hex representation of the color.
        * @return {!number} Number representing the color.
        */

    }, {
        key: 'hexToDecimal',
        value: function hexToDecimal(hex) {
            return Color.rgbToDecimal(Color.hexToRgb(hex));
        }

        /**
         * Convert an HSV color to RGB format.
         * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
         * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         */

    }, {
        key: 'hsvToRgb',
        value: function hsvToRgb(hsv) {
            var h = hsv.h % 360;
            if (h < 0) h += 360;
            var s = Math.max(0, Math.min(hsv.s, 1));
            var v = Math.max(0, Math.min(hsv.v, 1));

            var i = Math.floor(h / 60);
            var f = h / 60 - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            var r = void 0;
            var g = void 0;
            var b = void 0;

            switch (i) {
                default:
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
            }

            return {
                r: Math.floor(r * 255),
                g: Math.floor(g * 255),
                b: Math.floor(b * 255)
            };
        }

        /**
         * Convert an RGB color to HSV format.
         * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
         * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
         */

    }, {
        key: 'rgbToHsv',
        value: function rgbToHsv(rgb) {
            var r = rgb.r / 255;
            var g = rgb.g / 255;
            var b = rgb.b / 255;
            var x = Math.min(Math.min(r, g), b);
            var v = Math.max(Math.max(r, g), b);

            // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
            var h = 0;
            var s = 0;
            if (x !== v) {
                var f = r === x ? g - b : g === x ? b - r : r - g;
                var i = r === x ? 3 : g === x ? 5 : 1;
                h = (i - f / (v - x)) * 60 % 360;
                s = (v - x) / v;
            }

            return { h: h, s: s, v: v };
        }

        /**
         * Linear interpolation between rgb0 and rgb1.
         * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
         * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
         * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
         * @return {RGBObject} the interpolated color.
         */

    }, {
        key: 'mixRgb',
        value: function mixRgb(rgb0, rgb1, fraction1) {
            if (fraction1 <= 0) return rgb0;
            if (fraction1 >= 1) return rgb1;
            var fraction0 = 1 - fraction1;
            return {
                r: fraction0 * rgb0.r + fraction1 * rgb1.r,
                g: fraction0 * rgb0.g + fraction1 * rgb1.g,
                b: fraction0 * rgb0.b + fraction1 * rgb1.b
            };
        }
    }, {
        key: 'RGB_BLACK',

        /**
         * @typedef {object} RGBObject - An object representing a color in RGB format.
         * @property {number} r - the red component, in the range [0, 255].
         * @property {number} g - the green component, in the range [0, 255].
         * @property {number} b - the blue component, in the range [0, 255].
         */

        /**
         * @typedef {object} HSVObject - An object representing a color in HSV format.
         * @property {number} h - hue, in the range [0-359).
         * @property {number} s - saturation, in the range [0,1].
         * @property {number} v - value, in the range [0,1].
         */

        /** @type {RGBObject} */
        get: function get() {
            return { r: 0, g: 0, b: 0 };
        }

        /** @type {RGBObject} */

    }, {
        key: 'RGB_WHITE',
        get: function get() {
            return { r: 255, g: 255, b: 255 };
        }
    }]);

    return Color;
}();

module.exports = Color;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @fileoverview
 * A utility for accurately measuring time.
 * To use:
 * ---
 * var timer = new Timer();
 * timer.start();
 * ... pass some time ...
 * var timeDifference = timer.timeElapsed();
 * ---
 * Or, you can use the `time` and `relativeTime`
 * to do some measurement yourself.
 */

var Timer = function () {
    function Timer() {
        _classCallCheck(this, Timer);

        /**
         * Used to store the start time of a timer action.
         * Updated when calling `timer.start`.
         */
        this.startTime = 0;
    }

    /**
     * Disable use of self.performance for now as it results in lower performance
     * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
     * @type {boolean}
     */


    _createClass(Timer, [{
        key: 'time',


        /**
         * Return the currently known absolute time, in ms precision.
         * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
         */
        value: function time() {
            return Timer.nowObj.now();
        }

        /**
         * Returns a time accurate relative to other times produced by this function.
         * If possible, will use sub-millisecond precision.
         * If not, will use millisecond precision.
         * Not guaranteed to produce the same absolute values per-system.
         * @returns {number} ms-scale accurate time relative to other relative times.
         */

    }, {
        key: 'relativeTime',
        value: function relativeTime() {
            return Timer.nowObj.now();
        }

        /**
         * Start a timer for measuring elapsed time,
         * at the most accurate precision possible.
         */

    }, {
        key: 'start',
        value: function start() {
            this.startTime = Timer.nowObj.now();
        }
    }, {
        key: 'timeElapsed',
        value: function timeElapsed() {
            return Timer.nowObj.now() - this.startTime;
        }
    }], [{
        key: 'USE_PERFORMANCE',
        get: function get() {
            return false;
        }

        /**
         * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
         * @deprecated This is only called via the nowObj.now() if no other means is possible...
         */

    }, {
        key: 'legacyDateCode',
        get: function get() {
            return {
                now: function now() {
                    return new Date().getTime();
                }
            };
        }

        /**
         * Use this object to route all time functions through single access points.
         */

    }, {
        key: 'nowObj',
        get: function get() {
            if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {
                return self.performance;
            } else if (Date.now) {
                return Date;
            }
            return Timer.legacyDateCode;
        }
    }]);

    return Timer;
}();

module.exports = Timer;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Immutable = factory());
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^321.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),
/* 26 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @fileoverview UID generator, from Blockly.
 */

/**
 * Legal characters for the unique ID.
 * Should be all on a US keyboard.  No XML special characters or control codes.
 * Removed $ due to issue 251.
 * @private
 */
var soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 * @return {string} A globally unique ID string.
 */
var uid = function uid() {
  var length = 20;
  var soupLength = soup_.length;
  var id = [];
  for (var i = 0; i < length; i++) {
    id[i] = soup_.charAt(Math.random() * soupLength);
  }
  return id.join('');
};

module.exports = uid;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = {"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

/***/ }),
/* 32 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(7).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var processNextTick = __webpack_require__(27);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(14);
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(145)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(52);
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(36).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = __webpack_require__(51);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(8);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(8);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), __webpack_require__(143).setImmediate, __webpack_require__(0)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(49);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(34);
exports.Duplex = __webpack_require__(8);
exports.Transform = __webpack_require__(50);
exports.PassThrough = __webpack_require__(132);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(7)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SharedDispatch = __webpack_require__(70);

var log = __webpack_require__(1);

/**
 * This class serves as the central broker for message dispatch. It expects to operate on the main thread / Window and
 * it must be informed of any Worker threads which will participate in the messaging system. From any context in the
 * messaging system, the dispatcher's "call" method can call any method on any "service" provided in any participating
 * context. The dispatch system will forward function arguments and return values across worker boundaries as needed.
 * @see {WorkerDispatch}
 */

var CentralDispatch = function (_SharedDispatch) {
    _inherits(CentralDispatch, _SharedDispatch);

    function CentralDispatch() {
        _classCallCheck(this, CentralDispatch);

        /**
         * Map of channel name to worker or local service provider.
         * If the entry is a Worker, the service is provided by an object on that worker.
         * Otherwise, the service is provided locally and methods on the service will be called directly.
         * @see {setService}
         * @type {object.<Worker|object>}
         */
        var _this = _possibleConstructorReturn(this, (CentralDispatch.__proto__ || Object.getPrototypeOf(CentralDispatch)).call(this));

        _this.services = {};

        /**
         * The constructor we will use to recognize workers.
         * @type {Function}
         */
        _this.workerClass = typeof Worker === 'undefined' ? null : Worker;

        /**
         * List of workers attached to this dispatcher.
         * @type {Array}
         */
        _this.workers = [];
        return _this;
    }

    /**
     * Set a local object as the global provider of the specified service.
     * WARNING: Any method on the provider can be called from any worker within the dispatch system.
     * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
     * @param {object} provider - a local object which provides this service.
     * @returns {Promise} - a promise which will resolve once the service is registered.
     */


    _createClass(CentralDispatch, [{
        key: 'setService',
        value: function setService(service, provider) {
            /** Return a promise for consistency with {@link WorkerDispatch#setService} */
            try {
                if (this.services.hasOwnProperty(service)) {
                    log.warn('Central dispatch replacing existing service provider for ' + service);
                }
                this.services[service] = provider;
                return Promise.resolve();
            } catch (e) {
                return Promise.reject(e);
            }
        }

        /**
         * Add a worker to the message dispatch system. The worker must implement a compatible message dispatch framework.
         * The dispatcher will immediately attempt to "handshake" with the worker.
         * @param {Worker} worker - the worker to add into the dispatch system.
         */

    }, {
        key: 'addWorker',
        value: function addWorker(worker) {
            if (this.workers.indexOf(worker) === -1) {
                this.workers.push(worker);
                worker.onmessage = this._onMessage.bind(this, worker);
                this._remoteCall(worker, 'dispatch', 'handshake').catch(function (e) {
                    log.error('Could not handshake with worker: ' + JSON.stringify(e));
                });
            } else {
                log.warn('Central dispatch ignoring attempt to add duplicate worker');
            }
        }

        /**
         * Fetch the service provider object for a particular service name.
         * @override
         * @param {string} service - the name of the service to look up
         * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
         * @protected
         */

    }, {
        key: '_getServiceProvider',
        value: function _getServiceProvider(service) {
            var provider = this.services[service];
            return provider && {
                provider: provider,
                isRemote: provider instanceof this.workerClass
            };
        }

        /**
         * Handle a call message sent to the dispatch service itself
         * @override
         * @param {Worker} worker - the worker which sent the message.
         * @param {DispatchCallMessage} message - the message to be handled.
         * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
         * @protected
         */

    }, {
        key: '_onDispatchMessage',
        value: function _onDispatchMessage(worker, message) {
            var promise = void 0;
            switch (message.method) {
                case 'setService':
                    promise = this.setService(message.args[0], worker);
                    break;
                default:
                    log.error('Central dispatch received message for unknown method: ' + message.method);
            }
            return promise;
        }
    }]);

    return CentralDispatch;
}(SharedDispatch);

module.exports = new CentralDispatch();

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var html = __webpack_require__(9);
var decodeHtml = __webpack_require__(92);

/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @return {object} Object representing useful parts of this mutation.
 */
var mutatorTagToObject = function mutatorTagToObject(dom) {
    var obj = Object.create(null);
    obj.tagName = dom.name;
    obj.children = [];
    for (var prop in dom.attribs) {
        if (prop === 'xmlns') continue;
        obj[prop] = decodeHtml(dom.attribs[prop]);
    }
    for (var i = 0; i < dom.children.length; i++) {
        obj.children.push(mutatorTagToObject(dom.children[i]));
    }
    return obj;
};

/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @return {object} Object representing the mutation.
 */
var mutationAdpater = function mutationAdpater(mutation) {
    var mutationParsed = void 0;
    // Check if the mutation is already parsed; if not, parse it.
    if ((typeof mutation === 'undefined' ? 'undefined' : _typeof(mutation)) === 'object') {
        mutationParsed = mutation;
    } else {
        mutationParsed = html.parseDOM(mutation)[0];
    }
    return mutatorTagToObject(mutationParsed);
};

module.exports = mutationAdpater;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RenderedTarget = __webpack_require__(22);
var Blocks = __webpack_require__(10);

var _require = __webpack_require__(21),
    loadSoundFromAsset = _require.loadSoundFromAsset;

var _require2 = __webpack_require__(20),
    loadCostumeFromAsset = _require2.loadCostumeFromAsset;

var StringUtil = __webpack_require__(13);

var Sprite = function () {
    /**
     * Sprite to be used on the Scratch stage.
     * All clones of a sprite have shared blocks, shared costumes, shared variables.
     * @param {?Blocks} blocks Shared blocks object for all clones of sprite.
     * @param {Runtime} runtime Reference to the runtime.
     * @constructor
     */
    function Sprite(blocks, runtime) {
        _classCallCheck(this, Sprite);

        this.runtime = runtime;
        if (!blocks) {
            // Shared set of blocks for all clones.
            blocks = new Blocks();
        }
        this.blocks = blocks;
        /**
         * Human-readable name for this sprite (and all clones).
         * @type {string}
         */
        this.name = '';
        /**
         * List of costumes for this sprite.
         * Each entry is an object, e.g.,
         * {
         *      skinId: 1,
         *      name: "Costume Name",
         *      bitmapResolution: 2,
         *      rotationCenterX: 0,
         *      rotationCenterY: 0
         * }
         * @type {Array.<!Object>}
         */
        this.costumes = [];
        /**
         * List of sounds for this sprite.
        */
        this.sounds = [];
        /**
         * List of clones for this sprite, including the original.
         * @type {Array.<!RenderedTarget>}
         */
        this.clones = [];
    }

    /**
     * Create a clone of this sprite.
     * @returns {!RenderedTarget} Newly created clone.
     */


    _createClass(Sprite, [{
        key: 'createClone',
        value: function createClone() {
            var newClone = new RenderedTarget(this, this.runtime);
            newClone.isOriginal = this.clones.length === 0;
            this.clones.push(newClone);
            if (newClone.isOriginal) {
                newClone.initDrawable();
                this.runtime.fireTargetWasCreated(newClone);
            } else {
                this.runtime.fireTargetWasCreated(newClone, this.clones[0]);
            }
            return newClone;
        }

        /**
         * Disconnect a clone from this sprite. The clone is unmodified.
         * In particular, the clone's dispose() method is not called.
         * @param {!RenderedTarget} clone - the clone to be removed.
         */

    }, {
        key: 'removeClone',
        value: function removeClone(clone) {
            this.runtime.fireTargetWasRemoved(clone);
            var cloneIndex = this.clones.indexOf(clone);
            if (cloneIndex >= 0) {
                this.clones.splice(cloneIndex, 1);
            }
        }
    }, {
        key: 'duplicate',
        value: function duplicate() {
            var _this = this;

            var newSprite = new Sprite(null, this.runtime);

            newSprite.blocks = this.blocks.duplicate();

            var allNames = this.runtime.targets.map(function (t) {
                return t.name;
            });
            newSprite.name = StringUtil.unusedName(this.name, allNames);

            var assetPromises = [];

            newSprite.costumes = this.costumes.map(function (costume) {
                var newCostume = Object.assign({}, costume);
                var costumeAsset = _this.runtime.storage.get(costume.assetId);
                assetPromises.push(loadCostumeFromAsset(newCostume, costumeAsset, _this.runtime));
                return newCostume;
            });

            newSprite.sounds = this.sounds.map(function (sound) {
                var newSound = Object.assign({}, sound);
                var soundAsset = _this.runtime.storage.get(sound.assetId);
                assetPromises.push(loadSoundFromAsset(newSound, soundAsset, _this.runtime));
                return newSound;
            });

            return Promise.all(assetPromises).then(function () {
                return newSprite;
            });
        }
    }]);

    return Sprite;
}();

module.exports = Sprite;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(107);

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}


/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(45);

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

__webpack_require__(3)(Parser, __webpack_require__(4).EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Tokenizer;

var decodeCodePoint = __webpack_require__(41),
    entityMap = __webpack_require__(30),
    legacyMap = __webpack_require__(42),
    xmlMap    = __webpack_require__(31),

    i = 0,

    TEXT                      = i++,
    BEFORE_TAG_NAME           = i++, //after <
    IN_TAG_NAME               = i++,
    IN_SELF_CLOSING_TAG       = i++,
    BEFORE_CLOSING_TAG_NAME   = i++,
    IN_CLOSING_TAG_NAME       = i++,
    AFTER_CLOSING_TAG_NAME    = i++,

    //attributes
    BEFORE_ATTRIBUTE_NAME     = i++,
    IN_ATTRIBUTE_NAME         = i++,
    AFTER_ATTRIBUTE_NAME      = i++,
    BEFORE_ATTRIBUTE_VALUE    = i++,
    IN_ATTRIBUTE_VALUE_DQ     = i++, // "
    IN_ATTRIBUTE_VALUE_SQ     = i++, // '
    IN_ATTRIBUTE_VALUE_NQ     = i++,

    //declarations
    BEFORE_DECLARATION        = i++, // !
    IN_DECLARATION            = i++,

    //processing instructions
    IN_PROCESSING_INSTRUCTION = i++, // ?

    //comments
    BEFORE_COMMENT            = i++,
    IN_COMMENT                = i++,
    AFTER_COMMENT_1           = i++,
    AFTER_COMMENT_2           = i++,

    //cdata
    BEFORE_CDATA_1            = i++, // [
    BEFORE_CDATA_2            = i++, // C
    BEFORE_CDATA_3            = i++, // D
    BEFORE_CDATA_4            = i++, // A
    BEFORE_CDATA_5            = i++, // T
    BEFORE_CDATA_6            = i++, // A
    IN_CDATA                  = i++, // [
    AFTER_CDATA_1             = i++, // ]
    AFTER_CDATA_2             = i++, // ]

    //special tags
    BEFORE_SPECIAL            = i++, //S
    BEFORE_SPECIAL_END        = i++,   //S

    BEFORE_SCRIPT_1           = i++, //C
    BEFORE_SCRIPT_2           = i++, //R
    BEFORE_SCRIPT_3           = i++, //I
    BEFORE_SCRIPT_4           = i++, //P
    BEFORE_SCRIPT_5           = i++, //T
    AFTER_SCRIPT_1            = i++, //C
    AFTER_SCRIPT_2            = i++, //R
    AFTER_SCRIPT_3            = i++, //I
    AFTER_SCRIPT_4            = i++, //P
    AFTER_SCRIPT_5            = i++, //T

    BEFORE_STYLE_1            = i++, //T
    BEFORE_STYLE_2            = i++, //Y
    BEFORE_STYLE_3            = i++, //L
    BEFORE_STYLE_4            = i++, //E
    AFTER_STYLE_1             = i++, //T
    AFTER_STYLE_2             = i++, //Y
    AFTER_STYLE_3             = i++, //L
    AFTER_STYLE_4             = i++, //E

    BEFORE_ENTITY             = i++, //&
    BEFORE_NUMERIC_ENTITY     = i++, //#
    IN_NAMED_ENTITY           = i++,
    IN_NUMERIC_ENTITY         = i++,
    IN_HEX_ENTITY             = i++, //X

    j = 0,

    SPECIAL_NONE              = j++,
    SPECIAL_SCRIPT            = j++,
    SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) this._state = SUCCESS;
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(44),
    WritableStream = __webpack_require__(142).Writable || __webpack_require__(150).Writable,
    StringDecoder = __webpack_require__(33).StringDecoder,
    Buffer = __webpack_require__(7).Buffer;

function Stream(cbs, options){
	var parser = this._parser = new Parser(cbs, options);
	var decoder = this._decoder = new StringDecoder();

	WritableStream.call(this, {decodeStrings: false});

	this.once("finish", function(){
		parser.end(decoder.end());
	});
}

__webpack_require__(3)(Stream, WritableStream);

WritableStream.prototype._write = function(chunk, encoding, cb){
	if(chunk instanceof Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};


/***/ }),
/* 48 */
/***/ (function(module, exports) {

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue:  '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};
function color(fg, isInverse) {
  if(isInverse) {
    return 'color: #fff; background: '+hex[fg]+';';
  } else {
    return 'color: '+hex[fg]+';';
  }
}

module.exports = color;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var processNextTick = __webpack_require__(27);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(26);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(4).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(52);
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = __webpack_require__(36).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(14);
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(151);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(133);
var destroyImpl = __webpack_require__(51);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(8);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(33).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(8);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(33).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(16)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(8);

/*<replacement>*/
var util = __webpack_require__(14);
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var processNextTick = __webpack_require__(27);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4).EventEmitter;


/***/ }),
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

const VirtualMachine = __webpack_require__(91);

module.exports = VirtualMachine;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

module.exports = global["VirtualMachine"] = __webpack_require__(59);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);

var Scratch3ControlBlocks = function () {
    function Scratch3ControlBlocks(runtime) {
        _classCallCheck(this, Scratch3ControlBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3ControlBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                control_repeat: this.repeat,
                control_repeat_until: this.repeatUntil,
                control_forever: this.forever,
                control_wait: this.wait,
                control_wait_until: this.waitUntil,
                control_if: this.if,
                control_if_else: this.ifElse,
                control_stop: this.stop,
                control_create_clone_of: this.createClone,
                control_delete_this_clone: this.deleteClone
            };
        }
    }, {
        key: 'getHats',
        value: function getHats() {
            return {
                control_start_as_clone: {
                    restartExistingThreads: false
                }
            };
        }
    }, {
        key: 'repeat',
        value: function repeat(args, util) {
            var times = Math.floor(Cast.toNumber(args.TIMES));
            // Initialize loop
            if (typeof util.stackFrame.loopCounter === 'undefined') {
                util.stackFrame.loopCounter = times;
            }
            // Only execute once per frame.
            // When the branch finishes, `repeat` will be executed again and
            // the second branch will be taken, yielding for the rest of the frame.
            // Decrease counter
            util.stackFrame.loopCounter--;
            // If we still have some left, start the branch.
            if (util.stackFrame.loopCounter >= 0) {
                util.startBranch(1, true);
            }
        }
    }, {
        key: 'repeatUntil',
        value: function repeatUntil(args, util) {
            var condition = Cast.toBoolean(args.CONDITION);
            // If the condition is true, start the branch.
            if (!condition) {
                util.startBranch(1, true);
            }
        }
    }, {
        key: 'waitUntil',
        value: function waitUntil(args, util) {
            var condition = Cast.toBoolean(args.CONDITION);
            if (!condition) {
                util.yield();
            }
        }
    }, {
        key: 'forever',
        value: function forever(args, util) {
            util.startBranch(1, true);
        }
    }, {
        key: 'wait',
        value: function wait(args) {
            var duration = Math.max(0, 1000 * Cast.toNumber(args.DURATION));
            return new Promise(function (resolve) {
                setTimeout(function () {
                    resolve();
                }, duration);
            });
        }
    }, {
        key: 'if',
        value: function _if(args, util) {
            var condition = Cast.toBoolean(args.CONDITION);
            if (condition) {
                util.startBranch(1, false);
            }
        }
    }, {
        key: 'ifElse',
        value: function ifElse(args, util) {
            var condition = Cast.toBoolean(args.CONDITION);
            if (condition) {
                util.startBranch(1, false);
            } else {
                util.startBranch(2, false);
            }
        }
    }, {
        key: 'stop',
        value: function stop(args, util) {
            var option = args.STOP_OPTION;
            if (option === 'all') {
                util.stopAll();
            } else if (option === 'other scripts in sprite' || option === 'other scripts in stage') {
                util.stopOtherTargetThreads();
            } else if (option === 'this script') {
                util.stopThisScript();
            }
        }
    }, {
        key: 'createClone',
        value: function createClone(args, util) {
            var cloneTarget = void 0;
            if (args.CLONE_OPTION === '_myself_') {
                cloneTarget = util.target;
            } else {
                cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);
            }
            if (!cloneTarget) {
                return;
            }
            var newClone = cloneTarget.makeClone();
            if (newClone) {
                this.runtime.targets.push(newClone);
            }
        }
    }, {
        key: 'deleteClone',
        value: function deleteClone(args, util) {
            if (util.target.isOriginal) return;
            this.runtime.disposeTarget(util.target);
            this.runtime.stopForTarget(util.target);
        }
    }]);

    return Scratch3ControlBlocks;
}();

module.exports = Scratch3ControlBlocks;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);

var Scratch3DataBlocks = function () {
    function Scratch3DataBlocks(runtime) {
        _classCallCheck(this, Scratch3DataBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3DataBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                data_variable: this.getVariable,
                data_setvariableto: this.setVariableTo,
                data_changevariableby: this.changeVariableBy,
                data_listcontents: this.getListContents,
                data_addtolist: this.addToList,
                data_deleteoflist: this.deleteOfList,
                data_insertatlist: this.insertAtList,
                data_replaceitemoflist: this.replaceItemOfList,
                data_itemoflist: this.getItemOfList,
                data_lengthoflist: this.lengthOfList,
                data_listcontainsitem: this.listContainsItem
            };
        }
    }, {
        key: 'getVariable',
        value: function getVariable(args, util) {
            var variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
            return variable.value;
        }
    }, {
        key: 'setVariableTo',
        value: function setVariableTo(args, util) {
            var variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
            variable.value = args.VALUE;
        }
    }, {
        key: 'changeVariableBy',
        value: function changeVariableBy(args, util) {
            var variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
            var castedValue = Cast.toNumber(variable.value);
            var dValue = Cast.toNumber(args.VALUE);
            variable.value = castedValue + dValue;
        }
    }, {
        key: 'getListContents',
        value: function getListContents(args, util) {
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            // Determine if the list is all single letters.
            // If it is, report contents joined together with no separator.
            // If it's not, report contents joined together with a space.
            var allSingleLetters = true;
            for (var i = 0; i < list.value.length; i++) {
                var listItem = list.value[i];
                if (!(typeof listItem === 'string' && listItem.length === 1)) {
                    allSingleLetters = false;
                    break;
                }
            }
            if (allSingleLetters) {
                return list.value.join('');
            }
            return list.value.join(' ');
        }
    }, {
        key: 'addToList',
        value: function addToList(args, util) {
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            list.value.push(args.ITEM);
        }
    }, {
        key: 'deleteOfList',
        value: function deleteOfList(args, util) {
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            var index = Cast.toListIndex(args.INDEX, list.value.length);
            if (index === Cast.LIST_INVALID) {
                return;
            } else if (index === Cast.LIST_ALL) {
                list.value = [];
                return;
            }
            list.value.splice(index - 1, 1);
        }
    }, {
        key: 'insertAtList',
        value: function insertAtList(args, util) {
            var item = args.ITEM;
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            var index = Cast.toListIndex(args.INDEX, list.value.length + 1);
            if (index === Cast.LIST_INVALID) {
                return;
            }
            list.value.splice(index - 1, 0, item);
        }
    }, {
        key: 'replaceItemOfList',
        value: function replaceItemOfList(args, util) {
            var item = args.ITEM;
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            var index = Cast.toListIndex(args.INDEX, list.value.length);
            if (index === Cast.LIST_INVALID) {
                return;
            }
            list.value.splice(index - 1, 1, item);
        }
    }, {
        key: 'getItemOfList',
        value: function getItemOfList(args, util) {
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            var index = Cast.toListIndex(args.INDEX, list.value.length);
            if (index === Cast.LIST_INVALID) {
                return '';
            }
            return list.value[index - 1];
        }
    }, {
        key: 'lengthOfList',
        value: function lengthOfList(args, util) {
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            return list.value.length;
        }
    }, {
        key: 'listContainsItem',
        value: function listContainsItem(args, util) {
            var item = args.ITEM;
            var list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
            if (list.value.indexOf(item) >= 0) {
                return true;
            }
            // Try using Scratch comparison operator on each item.
            // (Scratch considers the string '123' equal to the number 123).
            for (var i = 0; i < list.value.length; i++) {
                if (Cast.compare(list.value[i], item) === 0) {
                    return true;
                }
            }
            return false;
        }
    }]);

    return Scratch3DataBlocks;
}();

module.exports = Scratch3DataBlocks;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);

var Scratch3EventBlocks = function () {
    function Scratch3EventBlocks(runtime) {
        _classCallCheck(this, Scratch3EventBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3EventBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                event_broadcast: this.broadcast,
                event_broadcastandwait: this.broadcastAndWait,
                event_whengreaterthan: this.hatGreaterThanPredicate
            };
        }
    }, {
        key: 'getHats',
        value: function getHats() {
            return {
                event_whenflagclicked: {
                    restartExistingThreads: true
                },
                event_whenkeypressed: {
                    restartExistingThreads: false
                },
                event_whenthisspriteclicked: {
                    restartExistingThreads: true
                },
                event_whenbackdropswitchesto: {
                    restartExistingThreads: true
                },
                event_whengreaterthan: {
                    restartExistingThreads: false,
                    edgeActivated: true
                },
                event_whenbroadcastreceived: {
                    restartExistingThreads: true
                }
            };
        }
    }, {
        key: 'hatGreaterThanPredicate',
        value: function hatGreaterThanPredicate(args, util) {
            var option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();
            var value = Cast.toNumber(args.VALUE);
            // @todo: Other cases :)
            if (option === 'timer') {
                return util.ioQuery('clock', 'projectTimer') > value;
            }
            return false;
        }
    }, {
        key: 'broadcast',
        value: function broadcast(args, util) {
            var broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
            if (broadcastVar) {
                var broadcastOption = broadcastVar.name;
                util.startHats('event_whenbroadcastreceived', {
                    BROADCAST_OPTION: broadcastOption
                });
            }
        }
    }, {
        key: 'broadcastAndWait',
        value: function broadcastAndWait(args, util) {
            var broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
            if (broadcastVar) {
                var broadcastOption = broadcastVar.name;
                // Have we run before, starting threads?
                if (!util.stackFrame.startedThreads) {
                    // No - start hats for this broadcast.
                    util.stackFrame.startedThreads = util.startHats('event_whenbroadcastreceived', {
                        BROADCAST_OPTION: broadcastOption
                    });
                    if (util.stackFrame.startedThreads.length === 0) {
                        // Nothing was started.
                        return;
                    }
                }
                // We've run before; check if the wait is still going on.
                var instance = this;
                var waiting = util.stackFrame.startedThreads.some(function (thread) {
                    return instance.runtime.isActiveThread(thread);
                });
                if (waiting) {
                    util.yield();
                }
            }
        }
    }]);

    return Scratch3EventBlocks;
}();

module.exports = Scratch3EventBlocks;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);
var Clone = __webpack_require__(12);
var RenderedTarget = __webpack_require__(22);

/**
 * @typedef {object} BubbleState - the bubble state associated with a particular target.
 * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.
 * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.
 * @property {Boolean} drawableVisible - false if drawable has been hidden by blank text.
 *      See _renderBubble for explanation of this optimization.
 * @property {string} text - the text of the bubble.
 * @property {string} type - the type of the bubble, "say" or "think"
 */

var Scratch3LooksBlocks = function () {
    function Scratch3LooksBlocks(runtime) {
        _classCallCheck(this, Scratch3LooksBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        this._onTargetMoved = this._onTargetMoved.bind(this);
        this._onResetBubbles = this._onResetBubbles.bind(this);
        this._onTargetWillExit = this._onTargetWillExit.bind(this);
        this._updateBubble = this._updateBubble.bind(this);

        // Reset all bubbles on start/stop
        this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);
        this.runtime.on('targetWasRemoved', this._onTargetWillExit);

        // Enable other blocks to use bubbles like ask/answer
        this.runtime.on('SAY', this._updateBubble);
    }

    /**
     * The default bubble state, to be used when a target has no existing bubble state.
     * @type {BubbleState}
     */


    _createClass(Scratch3LooksBlocks, [{
        key: '_getBubbleState',


        /**
         * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.
         * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.
         * @private
         */
        value: function _getBubbleState(target) {
            var bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);
            if (!bubbleState) {
                bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);
                target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);
            }
            return bubbleState;
        }

        /**
         * Handle a target which has moved.
         * @param {RenderedTarget} target - the target which has moved.
         * @private
         */

    }, {
        key: '_onTargetMoved',
        value: function _onTargetMoved(target) {
            var bubbleState = this._getBubbleState(target);
            if (bubbleState.drawableId) {
                this._positionBubble(target);
            }
        }

        /**
         * Handle a target which is exiting.
         * @param {RenderedTarget} target - the target.
         * @private
         */

    }, {
        key: '_onTargetWillExit',
        value: function _onTargetWillExit(target) {
            var bubbleState = this._getBubbleState(target);
            if (bubbleState.drawableId && bubbleState.skinId) {
                this.runtime.renderer.destroyDrawable(bubbleState.drawableId);
                this.runtime.renderer.destroySkin(bubbleState.skinId);
                bubbleState.drawableId = null;
                bubbleState.skinId = null;
                bubbleState.drawableVisible = true; // Reset back to default value
                this.runtime.requestRedraw();
            }
            target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }

        /**
         * Handle project start/stop by clearing all visible bubbles.
         * @private
         */

    }, {
        key: '_onResetBubbles',
        value: function _onResetBubbles() {
            for (var n = 0; n < this.runtime.targets.length; n++) {
                this._onTargetWillExit(this.runtime.targets[n]);
            }
            clearTimeout(this._bubbleTimeout);
        }

        /**
         * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.
         * @param {!Target} target Target whose bubble needs positioning.
         * @private
         */

    }, {
        key: '_positionBubble',
        value: function _positionBubble(target) {
            var bubbleState = this._getBubbleState(target);

            var _runtime$renderer$get = this.runtime.renderer.getSkinSize(bubbleState.drawableId),
                _runtime$renderer$get2 = _slicedToArray(_runtime$renderer$get, 2),
                bubbleWidth = _runtime$renderer$get2[0],
                bubbleHeight = _runtime$renderer$get2[1];

            var targetBounds = target.getBounds();
            var stageBounds = this.runtime.getTargetForStage().getBounds();
            if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {
                // Only flip if it would fit
                bubbleState.onSpriteRight = false;
                this._renderBubble(target);
            } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {
                // Only flip if it would fit
                bubbleState.onSpriteRight = true;
                this._renderBubble(target);
            } else {
                this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
                    position: [bubbleState.onSpriteRight ? Math.min(stageBounds.right - bubbleWidth, targetBounds.right) : Math.max(stageBounds.left, targetBounds.left - bubbleWidth), Math.min(stageBounds.top, targetBounds.top + bubbleHeight)]
                });
                this.runtime.requestRedraw();
            }
        }

        /**
         * Create a visible bubble for a target. If a bubble exists for the target,
         * just set it to visible and update the type/text. Otherwise create a new
         * bubble and update the relevant custom state.
         * @param {!Target} target Target who needs a bubble.
         * @return {undefined} Early return if text is empty string.
         * @private
         */

    }, {
        key: '_renderBubble',
        value: function _renderBubble(target) {
            var bubbleState = this._getBubbleState(target);
            var drawableVisible = bubbleState.drawableVisible,
                type = bubbleState.type,
                text = bubbleState.text,
                onSpriteRight = bubbleState.onSpriteRight;

            // Remove the bubble if target is not visible, or text is being set to blank
            // without being initialized. See comment below about blank text optimization.

            if (!target.visible || text === '' && !bubbleState.skinId) {
                return this._onTargetWillExit(target);
            }

            if (bubbleState.skinId) {
                // Optimization: if text is set to blank, hide the drawable instead of
                // getting rid of it. This prevents flickering in "typewriter" projects
                if (text === '' && drawableVisible || text !== '' && !drawableVisible) {
                    bubbleState.drawableVisible = text !== '';
                    this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
                        visible: bubbleState.drawableVisible
                    });
                }
                if (bubbleState.drawableVisible) {
                    this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);
                }
            } else {
                target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);

                // TODO is there a way to figure out before rendering whether to default left or right?
                var targetBounds = target.getBounds();
                var stageBounds = this.runtime.getTargetForStage().getBounds();
                if (targetBounds.right + 170 > stageBounds.right) {
                    bubbleState.onSpriteRight = false;
                }

                bubbleState.drawableId = this.runtime.renderer.createDrawable();
                bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);

                this.runtime.renderer.setDrawableOrder(bubbleState.drawableId, Infinity);
                this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
                    skinId: bubbleState.skinId
                });
            }

            this._positionBubble(target);
        }

        /**
         * The entry point for say/think blocks. Clears existing bubble if the text is empty.
         * Set the bubble custom state and then call _renderBubble.
         * @param {!Target} target Target that say/think blocks are being called on.
         * @param {!string} type Either "say" or "think"
         * @param {!string} text The text for the bubble, empty string clears the bubble.
         * @private
         */

    }, {
        key: '_updateBubble',
        value: function _updateBubble(target, type, text) {
            var bubbleState = this._getBubbleState(target);
            bubbleState.type = type;
            bubbleState.text = text;
            this._renderBubble(target);
        }

        /**
         * Retrieve the block primitives implemented by this package.
         * @return {object.<string, Function>} Mapping of opcode to Function.
         */

    }, {
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                looks_say: this.say,
                looks_sayforsecs: this.sayforsecs,
                looks_think: this.think,
                looks_thinkforsecs: this.thinkforsecs,
                looks_show: this.show,
                looks_hide: this.hide,
                looks_switchcostumeto: this.switchCostume,
                looks_switchbackdropto: this.switchBackdrop,
                looks_switchbackdroptoandwait: this.switchBackdropAndWait,
                looks_nextcostume: this.nextCostume,
                looks_nextbackdrop: this.nextBackdrop,
                looks_changeeffectby: this.changeEffect,
                looks_seteffectto: this.setEffect,
                looks_cleargraphiceffects: this.clearEffects,
                looks_changesizeby: this.changeSize,
                looks_setsizeto: this.setSize,
                looks_gotofront: this.goToFront,
                looks_gobacklayers: this.goBackLayers,
                looks_size: this.getSize,
                looks_costumeorder: this.getCostumeIndex,
                looks_backdroporder: this.getBackdropIndex,
                looks_backdropname: this.getBackdropName
            };
        }
    }, {
        key: 'getMonitored',
        value: function getMonitored() {
            return {
                looks_size: { isSpriteSpecific: true },
                looks_costumeorder: { isSpriteSpecific: true },
                looks_backdroporder: {},
                looks_backdropname: {}
            };
        }
    }, {
        key: 'say',
        value: function say(args, util) {
            // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
            this._updateBubble(util.target, 'say', String(args.MESSAGE));
        }
    }, {
        key: 'sayforsecs',
        value: function sayforsecs(args, util) {
            var _this = this;

            this.say(args, util);
            var _target = util.target;
            return new Promise(function (resolve) {
                _this._bubbleTimeout = setTimeout(function () {
                    _this._bubbleTimeout = null;
                    // Clear say bubble and proceed.
                    _this._updateBubble(_target, 'say', '');
                    resolve();
                }, 1000 * args.SECS);
            });
        }
    }, {
        key: 'think',
        value: function think(args, util) {
            this._updateBubble(util.target, 'think', String(args.MESSAGE));
        }
    }, {
        key: 'thinkforsecs',
        value: function thinkforsecs(args, util) {
            var _this2 = this;

            this.think(args, util);
            var _target = util.target;
            return new Promise(function (resolve) {
                _this2._bubbleTimeout = setTimeout(function () {
                    _this2._bubbleTimeout = null;
                    // Clear say bubble and proceed.
                    _this2._updateBubble(_target, 'think', '');
                    resolve();
                }, 1000 * args.SECS);
            });
        }
    }, {
        key: 'show',
        value: function show(args, util) {
            util.target.setVisible(true);
            this._renderBubble(util.target);
        }
    }, {
        key: 'hide',
        value: function hide(args, util) {
            util.target.setVisible(false);
            this._renderBubble(util.target);
        }

        /**
         * Utility function to set the costume or backdrop of a target.
         * Matches the behavior of Scratch 2.0 for different types of arguments.
         * @param {!Target} target Target to set costume/backdrop to.
         * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.
         * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.
         * @return {Array.<!Thread>} Any threads started by this switch.
         */

    }, {
        key: '_setCostumeOrBackdrop',
        value: function _setCostumeOrBackdrop(target, requestedCostume, optZeroIndex) {
            if (typeof requestedCostume === 'number') {
                target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);
            } else {
                var costumeIndex = target.getCostumeIndexByName(requestedCostume);
                if (costumeIndex > -1) {
                    target.setCostume(costumeIndex);
                } else if (requestedCostume === 'previous costume' || requestedCostume === 'previous backdrop') {
                    target.setCostume(target.currentCostume - 1);
                } else if (requestedCostume === 'next costume' || requestedCostume === 'next backdrop') {
                    target.setCostume(target.currentCostume + 1);
                } else {
                    var forcedNumber = Number(requestedCostume);
                    if (!isNaN(forcedNumber)) {
                        target.setCostume(optZeroIndex ? forcedNumber : forcedNumber - 1);
                    }
                }
            }
            if (target === this.runtime.getTargetForStage()) {
                // Target is the stage - start hats.
                var newName = target.sprite.costumes[target.currentCostume].name;
                return this.runtime.startHats('event_whenbackdropswitchesto', {
                    BACKDROP: newName
                });
            }
            return [];
        }
    }, {
        key: 'switchCostume',
        value: function switchCostume(args, util) {
            this._setCostumeOrBackdrop(util.target, args.COSTUME);
        }
    }, {
        key: 'nextCostume',
        value: function nextCostume(args, util) {
            this._setCostumeOrBackdrop(util.target, util.target.currentCostume + 1, true);
        }
    }, {
        key: 'switchBackdrop',
        value: function switchBackdrop(args) {
            this._setCostumeOrBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
        }
    }, {
        key: 'switchBackdropAndWait',
        value: function switchBackdropAndWait(args, util) {
            // Have we run before, starting threads?
            if (!util.stackFrame.startedThreads) {
                // No - switch the backdrop.
                util.stackFrame.startedThreads = this._setCostumeOrBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
                if (util.stackFrame.startedThreads.length === 0) {
                    // Nothing was started.
                    return;
                }
            }
            // We've run before; check if the wait is still going on.
            var instance = this;
            var waiting = util.stackFrame.startedThreads.some(function (thread) {
                return instance.runtime.isActiveThread(thread);
            });
            if (waiting) {
                util.yield();
            }
        }
    }, {
        key: 'nextBackdrop',
        value: function nextBackdrop() {
            var stage = this.runtime.getTargetForStage();
            this._setCostumeOrBackdrop(stage, stage.currentCostume + 1, true);
        }
    }, {
        key: 'changeEffect',
        value: function changeEffect(args, util) {
            var effect = Cast.toString(args.EFFECT).toLowerCase();
            var change = Cast.toNumber(args.CHANGE);
            if (!util.target.effects.hasOwnProperty(effect)) return;
            var newValue = change + util.target.effects[effect];
            util.target.setEffect(effect, newValue);
        }
    }, {
        key: 'setEffect',
        value: function setEffect(args, util) {
            var effect = Cast.toString(args.EFFECT).toLowerCase();
            var value = Cast.toNumber(args.VALUE);
            util.target.setEffect(effect, value);
        }
    }, {
        key: 'clearEffects',
        value: function clearEffects(args, util) {
            util.target.clearEffects();
        }
    }, {
        key: 'changeSize',
        value: function changeSize(args, util) {
            var change = Cast.toNumber(args.CHANGE);
            util.target.setSize(util.target.size + change);
        }
    }, {
        key: 'setSize',
        value: function setSize(args, util) {
            var size = Cast.toNumber(args.SIZE);
            util.target.setSize(size);
        }
    }, {
        key: 'goToFront',
        value: function goToFront(args, util) {
            if (!util.target.isStage) {
                util.target.goToFront();
            }
        }
    }, {
        key: 'goBackLayers',
        value: function goBackLayers(args, util) {
            util.target.goBackLayers(args.NUM);
        }
    }, {
        key: 'getSize',
        value: function getSize(args, util) {
            return Math.round(util.target.size);
        }
    }, {
        key: 'getBackdropIndex',
        value: function getBackdropIndex() {
            var stage = this.runtime.getTargetForStage();
            return stage.currentCostume + 1;
        }
    }, {
        key: 'getBackdropName',
        value: function getBackdropName() {
            var stage = this.runtime.getTargetForStage();
            return stage.sprite.costumes[stage.currentCostume].name;
        }
    }, {
        key: 'getCostumeIndex',
        value: function getCostumeIndex(args, util) {
            return util.target.currentCostume + 1;
        }
    }], [{
        key: 'DEFAULT_BUBBLE_STATE',
        get: function get() {
            return {
                drawableId: null,
                drawableVisible: true,
                onSpriteRight: true,
                skinId: null,
                text: '',
                type: 'say'
            };
        }

        /**
         * The key to load & store a target's bubble-related state.
         * @type {string}
         */

    }, {
        key: 'STATE_KEY',
        get: function get() {
            return 'Scratch.looks';
        }
    }]);

    return Scratch3LooksBlocks;
}();

module.exports = Scratch3LooksBlocks;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);
var MathUtil = __webpack_require__(6);
var Timer = __webpack_require__(24);

var Scratch3MotionBlocks = function () {
    function Scratch3MotionBlocks(runtime) {
        _classCallCheck(this, Scratch3MotionBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3MotionBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                motion_movesteps: this.moveSteps,
                motion_gotoxy: this.goToXY,
                motion_goto: this.goTo,
                motion_turnright: this.turnRight,
                motion_turnleft: this.turnLeft,
                motion_pointindirection: this.pointInDirection,
                motion_pointtowards: this.pointTowards,
                motion_glidesecstoxy: this.glide,
                motion_glideto: this.glideTo,
                motion_ifonedgebounce: this.ifOnEdgeBounce,
                motion_setrotationstyle: this.setRotationStyle,
                motion_changexby: this.changeX,
                motion_setx: this.setX,
                motion_changeyby: this.changeY,
                motion_sety: this.setY,
                motion_xposition: this.getX,
                motion_yposition: this.getY,
                motion_direction: this.getDirection
            };
        }
    }, {
        key: 'getMonitored',
        value: function getMonitored() {
            return {
                motion_xposition: { isSpriteSpecific: true },
                motion_yposition: { isSpriteSpecific: true },
                motion_direction: { isSpriteSpecific: true }
            };
        }
    }, {
        key: 'moveSteps',
        value: function moveSteps(args, util) {
            var steps = Cast.toNumber(args.STEPS);
            var radians = MathUtil.degToRad(90 - util.target.direction);
            var dx = steps * Math.cos(radians);
            var dy = steps * Math.sin(radians);
            util.target.setXY(util.target.x + dx, util.target.y + dy);
        }
    }, {
        key: 'goToXY',
        value: function goToXY(args, util) {
            var x = Cast.toNumber(args.X);
            var y = Cast.toNumber(args.Y);
            util.target.setXY(x, y);
        }
    }, {
        key: 'getTargetXY',
        value: function getTargetXY(targetName, util) {
            var targetX = 0;
            var targetY = 0;
            if (targetName === '_mouse_') {
                targetX = util.ioQuery('mouse', 'getX');
                targetY = util.ioQuery('mouse', 'getY');
            } else if (targetName === '_random_') {
                var stageWidth = this.runtime.constructor.STAGE_WIDTH;
                var stageHeight = this.runtime.constructor.STAGE_HEIGHT;
                targetX = Math.round(stageWidth * (Math.random() - 0.5));
                targetY = Math.round(stageHeight * (Math.random() - 0.5));
            } else {
                var goToTarget = this.runtime.getSpriteTargetByName(targetName);
                if (!goToTarget) return;
                targetX = goToTarget.x;
                targetY = goToTarget.y;
            }
            return [targetX, targetY];
        }
    }, {
        key: 'goTo',
        value: function goTo(args, util) {
            var targetXY = this.getTargetXY(args.TO, util);
            if (targetXY) {
                util.target.setXY(targetXY[0], targetXY[1]);
            }
        }
    }, {
        key: 'turnRight',
        value: function turnRight(args, util) {
            var degrees = Cast.toNumber(args.DEGREES);
            util.target.setDirection(util.target.direction + degrees);
        }
    }, {
        key: 'turnLeft',
        value: function turnLeft(args, util) {
            var degrees = Cast.toNumber(args.DEGREES);
            util.target.setDirection(util.target.direction - degrees);
        }
    }, {
        key: 'pointInDirection',
        value: function pointInDirection(args, util) {
            var direction = Cast.toNumber(args.DIRECTION);
            util.target.setDirection(direction);
        }
    }, {
        key: 'pointTowards',
        value: function pointTowards(args, util) {
            var targetX = 0;
            var targetY = 0;
            if (args.TOWARDS === '_mouse_') {
                targetX = util.ioQuery('mouse', 'getX');
                targetY = util.ioQuery('mouse', 'getY');
            } else {
                var pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);
                if (!pointTarget) return;
                targetX = pointTarget.x;
                targetY = pointTarget.y;
            }

            var dx = targetX - util.target.x;
            var dy = targetY - util.target.y;
            var direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));
            util.target.setDirection(direction);
        }
    }, {
        key: 'glide',
        value: function glide(args, util) {
            if (util.stackFrame.timer) {
                var timeElapsed = util.stackFrame.timer.timeElapsed();
                if (timeElapsed < util.stackFrame.duration * 1000) {
                    // In progress: move to intermediate position.
                    var frac = timeElapsed / (util.stackFrame.duration * 1000);
                    var dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
                    var dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
                    util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);
                    util.yield();
                } else {
                    // Finished: move to final position.
                    util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
                }
            } else {
                // First time: save data for future use.
                util.stackFrame.timer = new Timer();
                util.stackFrame.timer.start();
                util.stackFrame.duration = Cast.toNumber(args.SECS);
                util.stackFrame.startX = util.target.x;
                util.stackFrame.startY = util.target.y;
                util.stackFrame.endX = Cast.toNumber(args.X);
                util.stackFrame.endY = Cast.toNumber(args.Y);
                if (util.stackFrame.duration <= 0) {
                    // Duration too short to glide.
                    util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
                    return;
                }
                util.yield();
            }
        }
    }, {
        key: 'glideTo',
        value: function glideTo(args, util) {
            var targetXY = this.getTargetXY(args.TO, util);
            if (targetXY) {
                this.glide({ SECS: args.SECS, X: targetXY[0], Y: targetXY[1] }, util);
            }
        }
    }, {
        key: 'ifOnEdgeBounce',
        value: function ifOnEdgeBounce(args, util) {
            var bounds = util.target.getBounds();
            if (!bounds) {
                return;
            }
            // Measure distance to edges.
            // Values are positive when the sprite is far away,
            // and clamped to zero when the sprite is beyond.
            var stageWidth = this.runtime.constructor.STAGE_WIDTH;
            var stageHeight = this.runtime.constructor.STAGE_HEIGHT;
            var distLeft = Math.max(0, stageWidth / 2 + bounds.left);
            var distTop = Math.max(0, stageHeight / 2 - bounds.top);
            var distRight = Math.max(0, stageWidth / 2 - bounds.right);
            var distBottom = Math.max(0, stageHeight / 2 + bounds.bottom);
            // Find the nearest edge.
            var nearestEdge = '';
            var minDist = Infinity;
            if (distLeft < minDist) {
                minDist = distLeft;
                nearestEdge = 'left';
            }
            if (distTop < minDist) {
                minDist = distTop;
                nearestEdge = 'top';
            }
            if (distRight < minDist) {
                minDist = distRight;
                nearestEdge = 'right';
            }
            if (distBottom < minDist) {
                minDist = distBottom;
                nearestEdge = 'bottom';
            }
            if (minDist > 0) {
                return; // Not touching any edge.
            }
            // Point away from the nearest edge.
            var radians = MathUtil.degToRad(90 - util.target.direction);
            var dx = Math.cos(radians);
            var dy = -Math.sin(radians);
            if (nearestEdge === 'left') {
                dx = Math.max(0.2, Math.abs(dx));
            } else if (nearestEdge === 'top') {
                dy = Math.max(0.2, Math.abs(dy));
            } else if (nearestEdge === 'right') {
                dx = 0 - Math.max(0.2, Math.abs(dx));
            } else if (nearestEdge === 'bottom') {
                dy = 0 - Math.max(0.2, Math.abs(dy));
            }
            var newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;
            util.target.setDirection(newDirection);
            // Keep within the stage.
            var fencedPosition = util.target.keepInFence(util.target.x, util.target.y);
            util.target.setXY(fencedPosition[0], fencedPosition[1]);
        }
    }, {
        key: 'setRotationStyle',
        value: function setRotationStyle(args, util) {
            util.target.setRotationStyle(args.STYLE);
        }
    }, {
        key: 'changeX',
        value: function changeX(args, util) {
            var dx = Cast.toNumber(args.DX);
            util.target.setXY(util.target.x + dx, util.target.y);
        }
    }, {
        key: 'setX',
        value: function setX(args, util) {
            var x = Cast.toNumber(args.X);
            util.target.setXY(x, util.target.y);
        }
    }, {
        key: 'changeY',
        value: function changeY(args, util) {
            var dy = Cast.toNumber(args.DY);
            util.target.setXY(util.target.x, util.target.y + dy);
        }
    }, {
        key: 'setY',
        value: function setY(args, util) {
            var y = Cast.toNumber(args.Y);
            util.target.setXY(util.target.x, y);
        }
    }, {
        key: 'getX',
        value: function getX(args, util) {
            return util.target.x;
        }
    }, {
        key: 'getY',
        value: function getY(args, util) {
            return util.target.y;
        }
    }, {
        key: 'getDirection',
        value: function getDirection(args, util) {
            return util.target.direction;
        }
    }]);

    return Scratch3MotionBlocks;
}();

module.exports = Scratch3MotionBlocks;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);
var MathUtil = __webpack_require__(6);

var Scratch3OperatorsBlocks = function () {
    function Scratch3OperatorsBlocks(runtime) {
        _classCallCheck(this, Scratch3OperatorsBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3OperatorsBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                operator_add: this.add,
                operator_subtract: this.subtract,
                operator_multiply: this.multiply,
                operator_divide: this.divide,
                operator_lt: this.lt,
                operator_equals: this.equals,
                operator_gt: this.gt,
                operator_and: this.and,
                operator_or: this.or,
                operator_not: this.not,
                operator_random: this.random,
                operator_join: this.join,
                operator_letter_of: this.letterOf,
                operator_length: this.length,
                operator_contains: this.contains,
                operator_mod: this.mod,
                operator_round: this.round,
                operator_mathop: this.mathop
            };
        }
    }, {
        key: 'add',
        value: function add(args) {
            return Cast.toNumber(args.NUM1) + Cast.toNumber(args.NUM2);
        }
    }, {
        key: 'subtract',
        value: function subtract(args) {
            return Cast.toNumber(args.NUM1) - Cast.toNumber(args.NUM2);
        }
    }, {
        key: 'multiply',
        value: function multiply(args) {
            return Cast.toNumber(args.NUM1) * Cast.toNumber(args.NUM2);
        }
    }, {
        key: 'divide',
        value: function divide(args) {
            return Cast.toNumber(args.NUM1) / Cast.toNumber(args.NUM2);
        }
    }, {
        key: 'lt',
        value: function lt(args) {
            return Cast.compare(args.OPERAND1, args.OPERAND2) < 0;
        }
    }, {
        key: 'equals',
        value: function equals(args) {
            return Cast.compare(args.OPERAND1, args.OPERAND2) === 0;
        }
    }, {
        key: 'gt',
        value: function gt(args) {
            return Cast.compare(args.OPERAND1, args.OPERAND2) > 0;
        }
    }, {
        key: 'and',
        value: function and(args) {
            return Cast.toBoolean(args.OPERAND1) && Cast.toBoolean(args.OPERAND2);
        }
    }, {
        key: 'or',
        value: function or(args) {
            return Cast.toBoolean(args.OPERAND1) || Cast.toBoolean(args.OPERAND2);
        }
    }, {
        key: 'not',
        value: function not(args) {
            return !Cast.toBoolean(args.OPERAND);
        }
    }, {
        key: 'random',
        value: function random(args) {
            var nFrom = Cast.toNumber(args.FROM);
            var nTo = Cast.toNumber(args.TO);
            var low = nFrom <= nTo ? nFrom : nTo;
            var high = nFrom <= nTo ? nTo : nFrom;
            if (low === high) return low;
            // If both arguments are ints, truncate the result to an int.
            if (Cast.isInt(args.FROM) && Cast.isInt(args.TO)) {
                return low + Math.floor(Math.random() * (high + 1 - low));
            }
            return Math.random() * (high - low) + low;
        }
    }, {
        key: 'join',
        value: function join(args) {
            return Cast.toString(args.STRING1) + Cast.toString(args.STRING2);
        }
    }, {
        key: 'letterOf',
        value: function letterOf(args) {
            var index = Cast.toNumber(args.LETTER) - 1;
            var str = Cast.toString(args.STRING);
            // Out of bounds?
            if (index < 0 || index >= str.length) {
                return '';
            }
            return str.charAt(index);
        }
    }, {
        key: 'length',
        value: function length(args) {
            return Cast.toString(args.STRING).length;
        }
    }, {
        key: 'contains',
        value: function contains(args) {
            var format = function format(string) {
                return Cast.toString(string).toLowerCase();
            };
            return format(args.STRING1).includes(format(args.STRING2));
        }
    }, {
        key: 'mod',
        value: function mod(args) {
            var n = Cast.toNumber(args.NUM1);
            var modulus = Cast.toNumber(args.NUM2);
            var result = n % modulus;
            // Scratch mod is kept positive.
            if (result / modulus < 0) result += modulus;
            return result;
        }
    }, {
        key: 'round',
        value: function round(args) {
            return Math.round(Cast.toNumber(args.NUM));
        }
    }, {
        key: 'mathop',
        value: function mathop(args) {
            var operator = Cast.toString(args.OPERATOR).toLowerCase();
            var n = Cast.toNumber(args.NUM);
            switch (operator) {
                case 'abs':
                    return Math.abs(n);
                case 'floor':
                    return Math.floor(n);
                case 'ceiling':
                    return Math.ceil(n);
                case 'sqrt':
                    return Math.sqrt(n);
                case 'sin':
                    return parseFloat(Math.sin(Math.PI * n / 180).toFixed(10));
                case 'cos':
                    return parseFloat(Math.cos(Math.PI * n / 180).toFixed(10));
                case 'tan':
                    return MathUtil.tan(n);
                case 'asin':
                    return Math.asin(n) * 180 / Math.PI;
                case 'acos':
                    return Math.acos(n) * 180 / Math.PI;
                case 'atan':
                    return Math.atan(n) * 180 / Math.PI;
                case 'ln':
                    return Math.log(n);
                case 'log':
                    return Math.log(n) / Math.LN10;
                case 'e ^':
                    return Math.exp(n);
                case '10 ^':
                    return Math.pow(10, n);
            }
            return 0;
        }
    }]);

    return Scratch3OperatorsBlocks;
}();

module.exports = Scratch3OperatorsBlocks;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scratch3ProcedureBlocks = function () {
    function Scratch3ProcedureBlocks(runtime) {
        _classCallCheck(this, Scratch3ProcedureBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3ProcedureBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                procedures_definition: this.definition,
                procedures_call: this.call,
                argument_reporter_string_number: this.argumentReporterStringNumber,
                argument_reporter_boolean: this.argumentReporterBoolean
            };
        }
    }, {
        key: 'definition',
        value: function definition() {
            // No-op: execute the blocks.
        }
    }, {
        key: 'call',
        value: function call(args, util) {
            if (!util.stackFrame.executed) {
                var procedureCode = args.mutation.proccode;

                var _util$getProcedurePar = util.getProcedureParamNamesAndIds(procedureCode),
                    _util$getProcedurePar2 = _slicedToArray(_util$getProcedurePar, 2),
                    paramNames = _util$getProcedurePar2[0],
                    paramIds = _util$getProcedurePar2[1];

                // If null, procedure could not be found, which can happen if custom
                // block is dragged between sprites without the definition.
                // Match Scratch 2.0 behavior and noop.


                if (paramNames === null) {
                    return;
                }

                for (var i = 0; i < paramIds.length; i++) {
                    if (args.hasOwnProperty(paramIds[i])) {
                        util.pushParam(paramNames[i], args[paramIds[i]]);
                    }
                }

                util.stackFrame.executed = true;
                util.startProcedure(procedureCode);
            }
        }
    }, {
        key: 'argumentReporterStringNumber',
        value: function argumentReporterStringNumber(args, util) {
            var value = util.getParam(args.VALUE);
            if (value === null) {
                return '';
            }
            return value;
        }
    }, {
        key: 'argumentReporterBoolean',
        value: function argumentReporterBoolean(args, util) {
            var value = util.getParam(args.VALUE);
            if (value === null) {
                return false;
            }
            return value;
        }
    }]);

    return Scratch3ProcedureBlocks;
}();

module.exports = Scratch3ProcedureBlocks;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);

var Scratch3SensingBlocks = function () {
    function Scratch3SensingBlocks(runtime) {
        _classCallCheck(this, Scratch3SensingBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The "answer" block value.
         * @type {string}
         */
        this._answer = '';

        /**
         * The list of queued questions and respective `resolve` callbacks.
         * @type {!Array}
         */
        this._questionList = [];

        this.runtime.on('ANSWER', this._onAnswer.bind(this));
        this.runtime.on('PROJECT_START', this._resetAnswer.bind(this));
        this.runtime.on('PROJECT_STOP_ALL', this._clearAllQuestions.bind(this));
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */


    _createClass(Scratch3SensingBlocks, [{
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                sensing_touchingobject: this.touchingObject,
                sensing_touchingcolor: this.touchingColor,
                sensing_coloristouchingcolor: this.colorTouchingColor,
                sensing_distanceto: this.distanceTo,
                sensing_timer: this.getTimer,
                sensing_resettimer: this.resetTimer,
                sensing_of: this.getAttributeOf,
                sensing_mousex: this.getMouseX,
                sensing_mousey: this.getMouseY,
                sensing_mousedown: this.getMouseDown,
                sensing_keypressed: this.getKeyPressed,
                sensing_current: this.current,
                sensing_dayssince2000: this.daysSince2000,
                sensing_loudness: this.getLoudness,
                sensing_askandwait: this.askAndWait,
                sensing_answer: this.getAnswer
            };
        }
    }, {
        key: 'getMonitored',
        value: function getMonitored() {
            return {
                sensing_answer: {},
                sensing_loudness: {},
                sensing_timer: {},
                sensing_of: {},
                sensing_current: {}
            };
        }
    }, {
        key: '_onAnswer',
        value: function _onAnswer(answer) {
            this._answer = answer;
            var questionObj = this._questionList.shift();
            if (questionObj) {
                var _questionObj = _slicedToArray(questionObj, 5),
                    _question = _questionObj[0],
                    resolve = _questionObj[1],
                    target = _questionObj[2],
                    wasVisible = _questionObj[3],
                    wasStage = _questionObj[4];
                // If the target was visible when asked, hide the say bubble unless the target was the stage.


                if (wasVisible && !wasStage) {
                    this.runtime.emit('SAY', target, 'say', '');
                }
                resolve();
                this._askNextQuestion();
            }
        }
    }, {
        key: '_resetAnswer',
        value: function _resetAnswer() {
            this._answer = '';
        }
    }, {
        key: '_enqueueAsk',
        value: function _enqueueAsk(question, resolve, target, wasVisible, wasStage) {
            this._questionList.push([question, resolve, target, wasVisible, wasStage]);
        }
    }, {
        key: '_askNextQuestion',
        value: function _askNextQuestion() {
            if (this._questionList.length > 0) {
                var _questionList$ = _slicedToArray(this._questionList[0], 5),
                    question = _questionList$[0],
                    _resolve = _questionList$[1],
                    target = _questionList$[2],
                    wasVisible = _questionList$[3],
                    wasStage = _questionList$[4];
                // If the target is visible, emit a blank question and use the
                // say event to trigger a bubble unless the target was the stage.


                if (wasVisible && !wasStage) {
                    this.runtime.emit('SAY', target, 'say', question);
                    this.runtime.emit('QUESTION', '');
                } else {
                    this.runtime.emit('QUESTION', question);
                }
            }
        }
    }, {
        key: '_clearAllQuestions',
        value: function _clearAllQuestions() {
            this._questionList = [];
            this.runtime.emit('QUESTION', null);
        }
    }, {
        key: 'askAndWait',
        value: function askAndWait(args, util) {
            var _this = this;

            var _target = util.target;
            return new Promise(function (resolve) {
                var isQuestionAsked = _this._questionList.length > 0;
                _this._enqueueAsk(args.QUESTION, resolve, _target, _target.visible, _target.isStage);
                if (!isQuestionAsked) {
                    _this._askNextQuestion();
                }
            });
        }
    }, {
        key: 'getAnswer',
        value: function getAnswer() {
            return this._answer;
        }
    }, {
        key: 'touchingObject',
        value: function touchingObject(args, util) {
            var requestedObject = args.TOUCHINGOBJECTMENU;
            if (requestedObject === '_mouse_') {
                var mouseX = util.ioQuery('mouse', 'getX');
                var mouseY = util.ioQuery('mouse', 'getY');
                return util.target.isTouchingPoint(mouseX, mouseY);
            } else if (requestedObject === '_edge_') {
                return util.target.isTouchingEdge();
            }
            return util.target.isTouchingSprite(requestedObject);
        }
    }, {
        key: 'touchingColor',
        value: function touchingColor(args, util) {
            var color = Cast.toRgbColorList(args.COLOR);
            return util.target.isTouchingColor(color);
        }
    }, {
        key: 'colorTouchingColor',
        value: function colorTouchingColor(args, util) {
            var maskColor = Cast.toRgbColorList(args.COLOR);
            var targetColor = Cast.toRgbColorList(args.COLOR2);
            return util.target.colorIsTouchingColor(targetColor, maskColor);
        }
    }, {
        key: 'distanceTo',
        value: function distanceTo(args, util) {
            if (util.target.isStage) return 10000;

            var targetX = 0;
            var targetY = 0;
            if (args.DISTANCETOMENU === '_mouse_') {
                targetX = util.ioQuery('mouse', 'getX');
                targetY = util.ioQuery('mouse', 'getY');
            } else {
                var distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);
                if (!distTarget) return 10000;
                targetX = distTarget.x;
                targetY = distTarget.y;
            }

            var dx = util.target.x - targetX;
            var dy = util.target.y - targetY;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }, {
        key: 'getTimer',
        value: function getTimer(args, util) {
            return util.ioQuery('clock', 'projectTimer');
        }
    }, {
        key: 'resetTimer',
        value: function resetTimer(args, util) {
            util.ioQuery('clock', 'resetProjectTimer');
        }
    }, {
        key: 'getMouseX',
        value: function getMouseX(args, util) {
            return util.ioQuery('mouse', 'getX');
        }
    }, {
        key: 'getMouseY',
        value: function getMouseY(args, util) {
            return util.ioQuery('mouse', 'getY');
        }
    }, {
        key: 'getMouseDown',
        value: function getMouseDown(args, util) {
            return util.ioQuery('mouse', 'getIsDown');
        }
    }, {
        key: 'current',
        value: function current(args) {
            var menuOption = Cast.toString(args.CURRENTMENU).toLowerCase();
            var date = new Date();
            switch (menuOption) {
                case 'year':
                    return date.getFullYear();
                case 'month':
                    return date.getMonth() + 1; // getMonth is zero-based
                case 'date':
                    return date.getDate();
                case 'dayofweek':
                    return date.getDay() + 1; // getDay is zero-based, Sun=0
                case 'hour':
                    return date.getHours();
                case 'minute':
                    return date.getMinutes();
                case 'second':
                    return date.getSeconds();
            }
            return 0;
        }
    }, {
        key: 'getKeyPressed',
        value: function getKeyPressed(args, util) {
            return util.ioQuery('keyboard', 'getKeyIsDown', [args.KEY_OPTION]);
        }
    }, {
        key: 'daysSince2000',
        value: function daysSince2000() {
            var msPerDay = 24 * 60 * 60 * 1000;
            var start = new Date(2000, 0, 1); // Months are 0-indexed.
            var today = new Date();
            var dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
            var mSecsSinceStart = today.valueOf() - start.valueOf();
            mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
            return mSecsSinceStart / msPerDay;
        }
    }, {
        key: 'getLoudness',
        value: function getLoudness() {
            if (typeof this.runtime.audioEngine === 'undefined') return -1;
            return this.runtime.audioEngine.getLoudness();
        }
    }, {
        key: 'getAttributeOf',
        value: function getAttributeOf(args) {
            var attrTarget = void 0;

            if (args.OBJECT === '_stage_') {
                attrTarget = this.runtime.getTargetForStage();
            } else {
                attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);
            }

            // Generic attributes
            if (attrTarget.isStage) {
                switch (args.PROPERTY) {
                    // Scratch 1.4 support
                    case 'background #':
                        return attrTarget.currentCostume + 1;

                    case 'backdrop #':
                        return attrTarget.currentCostume + 1;
                    case 'backdrop name':
                        return attrTarget.sprite.costumes[attrTarget.currentCostume].name;
                    case 'volume':
                        return; // @todo: Keep this in mind for sound blocks!
                }
            } else {
                switch (args.PROPERTY) {
                    case 'x position':
                        return attrTarget.x;
                    case 'y position':
                        return attrTarget.y;
                    case 'direction':
                        return attrTarget.direction;
                    case 'costume #':
                        return attrTarget.currentCostume + 1;
                    case 'costume name':
                        return attrTarget.sprite.costumes[attrTarget.currentCostume].name;
                    case 'size':
                        return attrTarget.size;
                    case 'volume':
                        return; // @todo: above, keep in mind for sound blocks..
                }
            }

            // Variables
            var varName = args.PROPERTY;
            for (var id in attrTarget.variables) {
                if (attrTarget.variables[id].name === varName) {
                    return attrTarget.variables[id].value;
                }
            }

            // Otherwise, 0
            return 0;
        }
    }]);

    return Scratch3SensingBlocks;
}();

module.exports = Scratch3SensingBlocks;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MathUtil = __webpack_require__(6);
var Cast = __webpack_require__(2);
var Clone = __webpack_require__(12);

var Scratch3SoundBlocks = function () {
    function Scratch3SoundBlocks(runtime) {
        _classCallCheck(this, Scratch3SoundBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * The key to load & store a target's sound-related state.
     * @type {string}
     */


    _createClass(Scratch3SoundBlocks, [{
        key: '_getSoundState',


        /**
         * @param {Target} target - collect sound state for this target.
         * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
         * @private
         */
        value: function _getSoundState(target) {
            var soundState = target.getCustomState(Scratch3SoundBlocks.STATE_KEY);
            if (!soundState) {
                soundState = Clone.simple(Scratch3SoundBlocks.DEFAULT_SOUND_STATE);
                target.setCustomState(Scratch3SoundBlocks.STATE_KEY, soundState);
            }
            return soundState;
        }

        /**
         * Retrieve the block primitives implemented by this package.
         * @return {object.<string, Function>} Mapping of opcode to Function.
         */

    }, {
        key: 'getPrimitives',
        value: function getPrimitives() {
            return {
                sound_play: this.playSound,
                sound_playuntildone: this.playSoundAndWait,
                sound_stopallsounds: this.stopAllSounds,
                sound_seteffectto: this.setEffect,
                sound_changeeffectby: this.changeEffect,
                sound_cleareffects: this.clearEffects,
                sound_sounds_menu: this.soundsMenu,
                sound_beats_menu: this.beatsMenu,
                sound_effects_menu: this.effectsMenu,
                sound_setvolumeto: this.setVolume,
                sound_changevolumeby: this.changeVolume,
                sound_volume: this.getVolume
            };
        }
    }, {
        key: 'getMonitored',
        value: function getMonitored() {
            return {
                sound_volume: {}
            };
        }
    }, {
        key: 'playSound',
        value: function playSound(args, util) {
            var index = this._getSoundIndex(args.SOUND_MENU, util);
            if (index >= 0) {
                var soundId = util.target.sprite.sounds[index].soundId;
                if (util.target.audioPlayer === null) return;
                util.target.audioPlayer.playSound(soundId);
            }
        }
    }, {
        key: 'playSoundAndWait',
        value: function playSoundAndWait(args, util) {
            var index = this._getSoundIndex(args.SOUND_MENU, util);
            if (index >= 0) {
                var soundId = util.target.sprite.sounds[index].soundId;
                if (util.target.audioPlayer === null) return;
                return util.target.audioPlayer.playSound(soundId);
            }
        }
    }, {
        key: '_getSoundIndex',
        value: function _getSoundIndex(soundName, util) {
            // if the sprite has no sounds, return -1
            var len = util.target.sprite.sounds.length;
            if (len === 0) {
                return -1;
            }

            // look up by name first
            var index = this.getSoundIndexByName(soundName, util);
            if (index !== -1) {
                return index;
            }

            // then try using the sound name as a 1-indexed index
            var oneIndexedIndex = parseInt(soundName, 10);
            if (!isNaN(oneIndexedIndex)) {
                return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
            }

            // could not be found as a name or converted to index, return -1
            return -1;
        }
    }, {
        key: 'getSoundIndexByName',
        value: function getSoundIndexByName(soundName, util) {
            var sounds = util.target.sprite.sounds;
            for (var i = 0; i < sounds.length; i++) {
                if (sounds[i].name === soundName) {
                    return i;
                }
            }
            // if there is no sound by that name, return -1
            return -1;
        }
    }, {
        key: 'stopAllSounds',
        value: function stopAllSounds(args, util) {
            if (util.target.audioPlayer === null) return;
            util.target.audioPlayer.stopAllSounds();
        }
    }, {
        key: 'setEffect',
        value: function setEffect(args, util) {
            this._updateEffect(args, util, false);
        }
    }, {
        key: 'changeEffect',
        value: function changeEffect(args, util) {
            this._updateEffect(args, util, true);
        }
    }, {
        key: '_updateEffect',
        value: function _updateEffect(args, util, change) {
            var effect = Cast.toString(args.EFFECT).toLowerCase();
            var value = Cast.toNumber(args.VALUE);

            var soundState = this._getSoundState(util.target);
            if (!soundState.effects.hasOwnProperty(effect)) return;

            if (change) {
                soundState.effects[effect] += value;
            } else {
                soundState.effects[effect] = value;
            }

            var effectRange = Scratch3SoundBlocks.EFFECT_RANGE[effect];
            soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], effectRange.min, effectRange.max);

            if (util.target.audioPlayer === null) return;
            util.target.audioPlayer.setEffect(effect, soundState.effects[effect]);
        }
    }, {
        key: 'clearEffects',
        value: function clearEffects(args, util) {
            var soundState = this._getSoundState(util.target);
            for (var effect in soundState.effects) {
                if (!soundState.effects.hasOwnProperty(effect)) continue;
                soundState.effects[effect] = 0;
            }
            if (util.target.audioPlayer === null) return;
            util.target.audioPlayer.clearEffects();
        }
    }, {
        key: 'setVolume',
        value: function setVolume(args, util) {
            var volume = Cast.toNumber(args.VOLUME);
            this._updateVolume(volume, util);
        }
    }, {
        key: 'changeVolume',
        value: function changeVolume(args, util) {
            var soundState = this._getSoundState(util.target);
            var volume = Cast.toNumber(args.VOLUME) + soundState.volume;
            this._updateVolume(volume, util);
        }
    }, {
        key: '_updateVolume',
        value: function _updateVolume(volume, util) {
            var soundState = this._getSoundState(util.target);
            volume = MathUtil.clamp(volume, 0, 100);
            soundState.volume = volume;
            if (util.target.audioPlayer === null) return;
            util.target.audioPlayer.setVolume(soundState.volume);
        }
    }, {
        key: 'getVolume',
        value: function getVolume(args, util) {
            var soundState = this._getSoundState(util.target);
            return soundState.volume;
        }
    }, {
        key: 'soundsMenu',
        value: function soundsMenu(args) {
            return args.SOUND_MENU;
        }
    }, {
        key: 'beatsMenu',
        value: function beatsMenu(args) {
            return args.BEATS;
        }
    }, {
        key: 'effectsMenu',
        value: function effectsMenu(args) {
            return args.EFFECT;
        }
    }], [{
        key: 'STATE_KEY',
        get: function get() {
            return 'Scratch.sound';
        }

        /**
         * The default sound-related state, to be used when a target has no existing sound state.
         * @type {SoundState}
         */

    }, {
        key: 'DEFAULT_SOUND_STATE',
        get: function get() {
            return {
                volume: 100,
                currentInstrument: 0,
                effects: {
                    pitch: 0,
                    pan: 0
                }
            };
        }

        /**
         * The minimum and maximum MIDI note numbers, for clamping the input to play note.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'MIDI_NOTE_RANGE',
        get: function get() {
            return { min: 36, max: 96 }; // C2 to C7
        }

        /**
         * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
         * 100 beats at the default tempo of 60bpm is 100 seconds.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'BEAT_RANGE',
        get: function get() {
            return { min: 0, max: 100 };
        }

        /** The minimum and maximum tempo values, in bpm.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'TEMPO_RANGE',
        get: function get() {
            return { min: 20, max: 500 };
        }

        /** The minimum and maximum values for each sound effect.
         * @type {{effect:{min: number, max: number}}}
         */

    }, {
        key: 'EFFECT_RANGE',
        get: function get() {
            return {
                pitch: { min: -600, max: 600 }, // -5 to 5 octaves
                pan: { min: -100, max: 100 // 100% left to 100% right
                } };
        }
    }]);

    return Scratch3SoundBlocks;
}();

module.exports = Scratch3SoundBlocks;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var log = __webpack_require__(1);

/**
 * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call
 * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}
 * @property {string} service - the name of the service to be called
 * @property {string} method - the name of the method to be called
 * @property {Array|undefined} args - the arguments to be passed to the method
 */

/**
 * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call
 * @property {*} responseId - a copy of the response ID from the call which generated this response
 * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)
 * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)
 */

/**
 * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage
 * Any message to the dispatch system.
 */

/**
 * The SharedDispatch class is responsible for dispatch features shared by
 * {@link CentralDispatch} and {@link WorkerDispatch}.
 */

var SharedDispatch = function () {
    function SharedDispatch() {
        _classCallCheck(this, SharedDispatch);

        /**
         * List of callback registrations for promises waiting for a response from a call to a service on another
         * worker. A callback registration is an array of [resolve,reject] Promise functions.
         * Calls to local services don't enter this list.
         * @type {Array.<[Function,Function]>}
         */
        this.callbacks = [];

        /**
         * The next response ID to be used.
         * @type {int}
         */
        this.nextResponseId = 0;
    }

    /**
     * Call a particular method on a particular service, regardless of whether that service is provided locally or on
     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
     * transferred to the worker, and they should not be used after this call.
     * @example
     *      dispatcher.call('vm', 'setData', 'cat', 42);
     *      // this finds the worker for the 'vm' service, then on that worker calls:
     *      vm.setData('cat', 42);
     * @param {string} service - the name of the service.
     * @param {string} method - the name of the method.
     * @param {*} [args] - the arguments to be copied to the method, if any.
     * @returns {Promise} - a promise for the return value of the service method.
     */


    _createClass(SharedDispatch, [{
        key: 'call',
        value: function call(service, method) {
            for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return this.transferCall.apply(this, [service, method, null].concat(args));
        }

        /**
         * Call a particular method on a particular service, regardless of whether that service is provided locally or on
         * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
         * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
         * transferred to the worker, and they should not be used after this call.
         * @example
         *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);
         *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:
         *      vm.setData('cat', myArrayBuffer);
         * @param {string} service - the name of the service.
         * @param {string} method - the name of the method.
         * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
         * @param {*} [args] - the arguments to be copied to the method, if any.
         * @returns {Promise} - a promise for the return value of the service method.
         */

    }, {
        key: 'transferCall',
        value: function transferCall(service, method, transfer) {
            try {
                var _getServiceProvider2 = this._getServiceProvider(service),
                    provider = _getServiceProvider2.provider,
                    isRemote = _getServiceProvider2.isRemote;

                if (provider) {
                    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
                        args[_key2 - 3] = arguments[_key2];
                    }

                    if (isRemote) {
                        return this._remoteTransferCall.apply(this, [provider, service, method, transfer].concat(args));
                    }

                    var result = provider[method].apply(provider, args);
                    return Promise.resolve(result);
                }
                return Promise.reject(new Error('Service not found: ' + service));
            } catch (e) {
                return Promise.reject(e);
            }
        }

        /**
         * Check if a particular service lives on another worker.
         * @param {string} service - the service to check.
         * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.
         * @private
         */

    }, {
        key: '_isRemoteService',
        value: function _isRemoteService(service) {
            return this._getServiceProvider(service).isRemote;
        }

        /**
         * Like {@link call}, but force the call to be posted through a particular communication channel.
         * @param {object} provider - send the call through this object's `postMessage` function.
         * @param {string} service - the name of the service.
         * @param {string} method - the name of the method.
         * @param {*} [args] - the arguments to be copied to the method, if any.
         * @returns {Promise} - a promise for the return value of the service method.
         */

    }, {
        key: '_remoteCall',
        value: function _remoteCall(provider, service, method) {
            for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
                args[_key3 - 3] = arguments[_key3];
            }

            return this._remoteTransferCall.apply(this, [provider, service, method, null].concat(args));
        }

        /**
         * Like {@link transferCall}, but force the call to be posted through a particular communication channel.
         * @param {object} provider - send the call through this object's `postMessage` function.
         * @param {string} service - the name of the service.
         * @param {string} method - the name of the method.
         * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
         * @param {*} [args] - the arguments to be copied to the method, if any.
         * @returns {Promise} - a promise for the return value of the service method.
         */

    }, {
        key: '_remoteTransferCall',
        value: function _remoteTransferCall(provider, service, method, transfer) {
            for (var _len4 = arguments.length, args = Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {
                args[_key4 - 4] = arguments[_key4];
            }

            var _this = this;

            return new Promise(function (resolve, reject) {
                var responseId = _this._storeCallbacks(resolve, reject);

                /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */
                if (args.length > 0 && typeof args[args.length - 1].yield === 'function') {
                    args.pop();
                }

                if (transfer) {
                    provider.postMessage({ service: service, method: method, responseId: responseId, args: args }, transfer);
                } else {
                    provider.postMessage({ service: service, method: method, responseId: responseId, args: args });
                }
            });
        }

        /**
         * Store callback functions pending a response message.
         * @param {Function} resolve - function to call if the service method returns.
         * @param {Function} reject - function to call if the service method throws.
         * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.
         * @protected
         */

    }, {
        key: '_storeCallbacks',
        value: function _storeCallbacks(resolve, reject) {
            var responseId = this.nextResponseId++;
            this.callbacks[responseId] = [resolve, reject];
            return responseId;
        }

        /**
         * Deliver call response from a worker. This should only be called as the result of a message from a worker.
         * @param {int} responseId - the response ID of the callback set to call.
         * @param {DispatchResponseMessage} message - the message containing the response value(s).
         * @protected
         */

    }, {
        key: '_deliverResponse',
        value: function _deliverResponse(responseId, message) {
            try {
                var _callbacks$responseId = _slicedToArray(this.callbacks[responseId], 2),
                    resolve = _callbacks$responseId[0],
                    reject = _callbacks$responseId[1];

                delete this.callbacks[responseId];
                if (message.error) {
                    reject(message.error);
                } else {
                    resolve(message.result);
                }
            } catch (e) {
                log.error('Dispatch callback failed: ' + JSON.stringify(e));
            }
        }

        /**
         * Handle a message event received from a connected worker.
         * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.
         * @param {MessageEvent} event - the message event to be handled.
         * @protected
         */

    }, {
        key: '_onMessage',
        value: function _onMessage(worker, event) {
            /** @type {DispatchMessage} */
            var message = event.data;
            message.args = message.args || [];
            var promise = void 0;
            if (message.service) {
                if (message.service === 'dispatch') {
                    promise = this._onDispatchMessage(worker, message);
                } else {
                    promise = this.call.apply(this, [message.service, message.method].concat(_toConsumableArray(message.args)));
                }
            } else if (typeof message.responseId === 'undefined') {
                log.error('Dispatch caught malformed message from a worker: ' + JSON.stringify(event));
            } else {
                this._deliverResponse(message.responseId, message);
            }
            if (promise) {
                if (typeof message.responseId === 'undefined') {
                    log.error('Dispatch message missing required response ID: ' + JSON.stringify(event));
                } else {
                    promise.then(function (result) {
                        return worker.postMessage({ responseId: message.responseId, result: result });
                    }, function (error) {
                        return worker.postMessage({ responseId: message.responseId, error: error });
                    });
                }
            }
        }

        /**
         * Fetch the service provider object for a particular service name.
         * @abstract
         * @param {string} service - the name of the service to look up
         * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
         * @protected
         */

    }, {
        key: '_getServiceProvider',
        value: function _getServiceProvider(service) {
            throw new Error('Could not get provider for ' + service + ': _getServiceProvider not implemented');
        }

        /**
         * Handle a call message sent to the dispatch service itself
         * @abstract
         * @param {Worker} worker - the worker which sent the message.
         * @param {DispatchCallMessage} message - the message to be handled.
         * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
         * @private
         */

    }, {
        key: '_onDispatchMessage',
        value: function _onDispatchMessage(worker, message) {
            throw new Error('Unimplemented dispatch message handler cannot handle ' + message.method + ' method');
        }
    }]);

    return SharedDispatch;
}();

module.exports = SharedDispatch;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var mutationAdapter = __webpack_require__(38);
var html = __webpack_require__(9);

/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @return {undefined}
 */
var domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {
    // Block skeleton.
    var block = {
        id: blockDOM.attribs.id, // Block ID
        opcode: blockDOM.attribs.type, // For execution, "event_whengreenflag".
        inputs: {}, // Inputs to this block and the blocks they point to.
        fields: {}, // Fields on this block and their values.
        next: null, // Next block in the stack, if one exists.
        topLevel: isTopBlock, // If this block starts a stack.
        parent: parent, // Parent block ID, if available.
        shadow: blockDOM.name === 'shadow', // If this represents a shadow/slot.
        x: blockDOM.attribs.x, // X position of script, if top-level.
        y: blockDOM.attribs.y // Y position of script, if top-level.
    };

    // Add the block to the representation tree.
    blocks[block.id] = block;

    // Process XML children and find enclosed blocks, fields, etc.
    for (var i = 0; i < blockDOM.children.length; i++) {
        var xmlChild = blockDOM.children[i];
        // Enclosed blocks and shadows
        var childBlockNode = null;
        var childShadowNode = null;
        for (var j = 0; j < xmlChild.children.length; j++) {
            var grandChildNode = xmlChild.children[j];
            if (!grandChildNode.name) {
                // Non-XML tag node.
                continue;
            }
            var grandChildNodeName = grandChildNode.name.toLowerCase();
            if (grandChildNodeName === 'block') {
                childBlockNode = grandChildNode;
            } else if (grandChildNodeName === 'shadow') {
                childShadowNode = grandChildNode;
            }
        }

        // Use shadow block only if there's no real block node.
        if (!childBlockNode && childShadowNode) {
            childBlockNode = childShadowNode;
        }

        // Not all Blockly-type blocks are handled here,
        // as we won't be using all of them for Scratch.
        switch (xmlChild.name.toLowerCase()) {
            case 'field':
                {
                    // Add the field to this block.
                    var fieldName = xmlChild.attribs.name;
                    // Add id in case it is a variable field
                    var fieldId = xmlChild.attribs.id;
                    var fieldData = '';
                    if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
                        fieldData = xmlChild.children[0].data;
                    } else {
                        // If the child of the field with a data property
                        // doesn't exist, set the data to an empty string.
                        fieldData = '';
                    }
                    block.fields[fieldName] = {
                        name: fieldName,
                        id: fieldId,
                        value: fieldData
                    };
                    var fieldVarType = xmlChild.attribs.variabletype;
                    if (typeof fieldVarType === 'string') {
                        block.fields[fieldName].variableType = fieldVarType;
                    }
                    break;
                }
            case 'value':
            case 'statement':
                {
                    // Recursively generate block structure for input block.
                    domToBlock(childBlockNode, blocks, false, block.id);
                    if (childShadowNode && childBlockNode !== childShadowNode) {
                        // Also generate the shadow block.
                        domToBlock(childShadowNode, blocks, false, block.id);
                    }
                    // Link this block's input to the child block.
                    var inputName = xmlChild.attribs.name;
                    block.inputs[inputName] = {
                        name: inputName,
                        block: childBlockNode.attribs.id,
                        shadow: childShadowNode ? childShadowNode.attribs.id : null
                    };
                    break;
                }
            case 'next':
                {
                    if (!childBlockNode || !childBlockNode.attribs) {
                        // Invalid child block.
                        continue;
                    }
                    // Recursively generate block structure for next block.
                    domToBlock(childBlockNode, blocks, false, block.id);
                    // Link next block to this block.
                    block.next = childBlockNode.attribs.id;
                    break;
                }
            case 'mutation':
                {
                    block.mutation = mutationAdapter(xmlChild);
                    break;
                }
        }
    }
};

/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @return {Array.<object>} Usable list of blocks from this CREATE event.
 */
var domToBlocks = function domToBlocks(blocksDOM) {
    // At this level, there could be multiple blocks adjacent in the DOM tree.
    var blocks = {};
    for (var i = 0; i < blocksDOM.length; i++) {
        var block = blocksDOM[i];
        if (!block.name || !block.attribs) {
            continue;
        }
        var tagName = block.name.toLowerCase();
        if (tagName === 'block' || tagName === 'shadow') {
            domToBlock(block, blocks, true, null);
        }
    }
    // Flatten blocks object into a list.
    var blocksList = [];
    for (var b in blocks) {
        if (!blocks.hasOwnProperty(b)) continue;
        blocksList.push(blocks[b]);
    }
    return blocksList;
};

/**
 * Adapter between block creation events and block representation which can be
 * used by the Scratch runtime.
 * @param {object} e `Blockly.events.create`
 * @return {Array.<object>} List of blocks from this CREATE event.
 */
var adapter = function adapter(e) {
    // Validate input
    if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) !== 'object') return;
    if (_typeof(e.xml) !== 'object') return;

    return domToBlocks(html.parseDOM(e.xml.outerHTML, { decodeEntities: true }));
};

module.exports = adapter;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Thread = __webpack_require__(17);

/**
 * @fileoverview
 * Interface provided to block primitive functions for interacting with the
 * runtime, thread, target, and convenient methods.
 */

var BlockUtility = function () {
    function BlockUtility() {
        var sequencer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var thread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, BlockUtility);

        /**
         * A sequencer block primitives use to branch or start procedures with
         * @type {?Sequencer}
         */
        this.sequencer = sequencer;

        /**
         * The block primitives thread with the block's target, stackFrame and
         * modifiable status.
         * @type {?Thread}
         */
        this.thread = thread;
    }

    /**
     * The target the primitive is working on.
     * @type {Target}
     */


    _createClass(BlockUtility, [{
        key: 'yield',


        /**
         * Set the thread to yield.
         */
        value: function _yield() {
            this.thread.status = Thread.STATUS_YIELD;
        }

        /**
         * Start a branch in the current block.
         * @param {number} branchNum Which branch to step to (i.e., 1, 2).
         * @param {boolean} isLoop Whether this block is a loop.
         */

    }, {
        key: 'startBranch',
        value: function startBranch(branchNum, isLoop) {
            this.sequencer.stepToBranch(this.thread, branchNum, isLoop);
        }

        /**
         * Stop all threads.
         */

    }, {
        key: 'stopAll',
        value: function stopAll() {
            this.sequencer.runtime.stopAll();
        }

        /**
         * Stop threads other on this target other than the thread holding the
         * executed block.
         */

    }, {
        key: 'stopOtherTargetThreads',
        value: function stopOtherTargetThreads() {
            this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);
        }

        /**
         * Stop this thread.
         */

    }, {
        key: 'stopThisScript',
        value: function stopThisScript() {
            this.thread.stopThisScript();
        }

        /**
         * Start a specified procedure on this thread.
         * @param {string} procedureCode Procedure code for procedure to start.
         */

    }, {
        key: 'startProcedure',
        value: function startProcedure(procedureCode) {
            this.sequencer.stepToProcedure(this.thread, procedureCode);
        }

        /**
         * Get names for parameters for the given procedure.
         * @param {string} procedureCode Procedure code for procedure to query.
         * @return {Array.<string>} List of param names for a procedure.
         */

    }, {
        key: 'getProcedureParamNamesAndIds',
        value: function getProcedureParamNamesAndIds(procedureCode) {
            return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);
        }

        /**
         * Store a procedure parameter value by its name.
         * @param {string} paramName The procedure's parameter name.
         * @param {*} paramValue The procedure's parameter value.
         */

    }, {
        key: 'pushParam',
        value: function pushParam(paramName, paramValue) {
            this.thread.pushParam(paramName, paramValue);
        }

        /**
         * Retrieve the stored parameter value for a given parameter name.
         * @param {string} paramName The procedure's parameter name.
         * @return {*} The parameter's current stored value.
         */

    }, {
        key: 'getParam',
        value: function getParam(paramName) {
            return this.thread.getParam(paramName);
        }

        /**
         * Start all relevant hats.
         * @param {!string} requestedHat Opcode of hats to start.
         * @param {object=} optMatchFields Optionally, fields to match on the hat.
         * @param {Target=} optTarget Optionally, a target to restrict to.
         * @return {Array.<Thread>} List of threads started by this function.
         */

    }, {
        key: 'startHats',
        value: function startHats(requestedHat, optMatchFields, optTarget) {
            return this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget);
        }

        /**
         * Query a named IO device.
         * @param {string} device The name of like the device, like keyboard.
         * @param {string} func The name of the device's function to query.
         * @param {Array.<*>} args Arguments to pass to the device's function.
         * @return {*} The expected output for the device's function.
         */

    }, {
        key: 'ioQuery',
        value: function ioQuery(device, func, args) {
            // Find the I/O device and execute the query/function call.
            if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {
                var devObject = this.sequencer.runtime.ioDevices[device];
                return devObject[func].apply(devObject, args);
            }
        }
    }, {
        key: 'target',
        get: function get() {
            return this.thread.target;
        }

        /**
         * The runtime the block primitive is running in.
         * @type {Runtime}
         */

    }, {
        key: 'runtime',
        get: function get() {
            return this.sequencer.runtime;
        }

        /**
         * The stack frame used by loop and other blocks to track internal state.
         * @type {object}
         */

    }, {
        key: 'stackFrame',
        get: function get() {
            return this.thread.peekStackFrame().executionContext;
        }
    }]);

    return BlockUtility;
}();

module.exports = BlockUtility;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var BlockUtility = __webpack_require__(72);
var log = __webpack_require__(1);
var Thread = __webpack_require__(17);

var _require = __webpack_require__(25),
    Map = _require.Map;

/**
 * Single BlockUtility instance reused by execute for every pritimive ran.
 * @const
 */


var blockUtility = new BlockUtility();

/**
 * Profiler frame name for block functions.
 * @const {string}
 */
var blockFunctionProfilerFrame = 'blockFunction';

/**
 * Profiler frame ID for 'blockFunction'.
 * @type {number}
 */
var blockFunctionProfilerId = -1;

/**
 * Utility function to determine if a value is a Promise.
 * @param {*} value Value to check for a Promise.
 * @return {boolean} True if the value appears to be a Promise.
 */
var isPromise = function isPromise(value) {
    return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.then === 'function';
};

/**
 * Handle any reported value from the primitive, either directly returned
 * or after a promise resolves.
 * @param {*} resolvedValue Value eventually returned from the primitive.
 * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran
 * primitive.
 * @param {!Thread} thread Thread containing the primitive.
 * @param {!string} currentBlockId Id of the block in its thread for value from
 * the primitive.
 * @param {!string} opcode opcode used to identify a block function primitive.
 * @param {!boolean} isHat Is the current block a hat?
 */
// @todo move this to callback attached to the thread when we have performance
// metrics (dd)
var handleReport = function handleReport(resolvedValue, sequencer, thread, currentBlockId, opcode, isHat) {
    thread.pushReportedValue(resolvedValue);
    if (isHat) {
        // Hat predicate was evaluated.
        if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {
            // If this is an edge-activated hat, only proceed if the value is
            // true and used to be false, or the stack was activated explicitly
            // via stack click
            if (!thread.stackClick) {
                var oldEdgeValue = sequencer.runtime.updateEdgeActivatedValue(currentBlockId, resolvedValue);
                var edgeWasActivated = !oldEdgeValue && resolvedValue;
                if (!edgeWasActivated) {
                    sequencer.retireThread(thread);
                }
            }
        } else if (!resolvedValue) {
            // Not an edge-activated hat: retire the thread
            // if predicate was false.
            sequencer.retireThread(thread);
        }
    } else {
        // In a non-hat, report the value visually if necessary if
        // at the top of the thread stack.
        if (typeof resolvedValue !== 'undefined' && thread.atStackTop()) {
            if (thread.stackClick) {
                sequencer.runtime.visualReport(currentBlockId, resolvedValue);
            }
            if (thread.updateMonitor) {
                var targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;
                if (targetId && !sequencer.runtime.getTargetById(targetId)) {
                    // Target no longer exists
                    return;
                }
                sequencer.runtime.requestUpdateMonitor(Map({
                    id: currentBlockId,
                    spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,
                    value: String(resolvedValue)
                }));
            }
        }
        // Finished any yields.
        thread.status = Thread.STATUS_RUNNING;
    }
};

/**
 * Execute a block.
 * @param {!Sequencer} sequencer Which sequencer is executing.
 * @param {!Thread} thread Thread which to read and execute.
 */
var execute = function execute(sequencer, thread) {
    var runtime = sequencer.runtime;
    var target = thread.target;

    // Stop if block or target no longer exists.
    if (target === null) {
        // No block found: stop the thread; script no longer exists.
        sequencer.retireThread(thread);
        return;
    }

    // Current block to execute is the one on the top of the stack.
    var currentBlockId = thread.peekStack();
    var currentStackFrame = thread.peekStackFrame();

    var blockContainer = void 0;
    if (thread.updateMonitor) {
        blockContainer = runtime.monitorBlocks;
    } else {
        blockContainer = target.blocks;
    }
    var block = blockContainer.getBlock(currentBlockId);
    if (typeof block === 'undefined') {
        blockContainer = runtime.flyoutBlocks;
        block = blockContainer.getBlock(currentBlockId);
        // Stop if block or target no longer exists.
        if (typeof block === 'undefined') {
            // No block found: stop the thread; script no longer exists.
            sequencer.retireThread(thread);
            return;
        }
    }

    var opcode = blockContainer.getOpcode(block);
    var fields = blockContainer.getFields(block);
    var inputs = blockContainer.getInputs(block);
    var blockFunction = runtime.getOpcodeFunction(opcode);
    var isHat = runtime.getIsHat(opcode);

    if (!opcode) {
        log.warn('Could not get opcode for block: ' + currentBlockId);
        return;
    }

    // Hats and single-field shadows are implemented slightly differently
    // from regular blocks.
    // For hats: if they have an associated block function,
    // it's treated as a predicate; if not, execution will proceed as a no-op.
    // For single-field shadows: If the block has a single field, and no inputs,
    // immediately return the value of the field.
    if (typeof blockFunction === 'undefined') {
        if (isHat) {
            // Skip through the block (hat with no predicate).
            return;
        }
        var keys = Object.keys(fields);
        if (keys.length === 1 && Object.keys(inputs).length === 0) {
            // One field and no inputs - treat as arg.
            handleReport(fields[keys[0]].value, sequencer, thread, currentBlockId, opcode, isHat);
        } else {
            log.warn('Could not get implementation for opcode: ' + opcode);
        }
        thread.requestScriptGlowInFrame = true;
        return;
    }

    // Generate values for arguments (inputs).
    var argValues = {};

    // Add all fields on this block to the argValues.
    for (var fieldName in fields) {
        if (!fields.hasOwnProperty(fieldName)) continue;
        if (fieldName === 'VARIABLE' || fieldName === 'LIST' || fieldName === 'BROADCAST_OPTION') {
            argValues[fieldName] = {
                id: fields[fieldName].id,
                name: fields[fieldName].value
            };
        } else {
            argValues[fieldName] = fields[fieldName].value;
        }
    }

    // Recursively evaluate input blocks.
    for (var inputName in inputs) {
        if (!inputs.hasOwnProperty(inputName)) continue;
        // Do not evaluate the internal custom command block within definition
        if (inputName === 'custom_block') continue;
        var input = inputs[inputName];
        var inputBlockId = input.block;
        // Is there no value for this input waiting in the stack frame?
        if (inputBlockId !== null && typeof currentStackFrame.reported[inputName] === 'undefined') {
            // If there's not, we need to evaluate the block.
            // Push to the stack to evaluate the reporter block.
            thread.pushStack(inputBlockId);
            // Save name of input for `Thread.pushReportedValue`.
            currentStackFrame.waitingReporter = inputName;
            // Actually execute the block.
            execute(sequencer, thread);
            if (thread.status === Thread.STATUS_PROMISE_WAIT) {
                return;
            }

            // Execution returned immediately,
            // and presumably a value was reported, so pop the stack.
            currentStackFrame.waitingReporter = null;
            thread.popStack();
        }
        argValues[inputName] = currentStackFrame.reported[inputName];
    }

    // Add any mutation to args (e.g., for procedures).
    var mutation = blockContainer.getMutation(block);
    if (mutation !== null) {
        argValues.mutation = mutation;
    }

    // If we've gotten this far, all of the input blocks are evaluated,
    // and `argValues` is fully populated. So, execute the block primitive.
    // First, clear `currentStackFrame.reported`, so any subsequent execution
    // (e.g., on return from a branch) gets fresh inputs.
    currentStackFrame.reported = {};

    var primitiveReportedValue = null;
    blockUtility.sequencer = sequencer;
    blockUtility.thread = thread;
    if (runtime.profiler !== null) {
        if (blockFunctionProfilerId === -1) {
            blockFunctionProfilerId = runtime.profiler.idByName(blockFunctionProfilerFrame);
        }
        // The method commented below has its code inlined underneath to reduce
        // the bias recorded for the profiler's calls in this time sensitive
        // execute function.
        //
        // runtime.profiler.start(blockFunctionProfilerId, opcode);
        runtime.profiler.records.push(runtime.profiler.START, blockFunctionProfilerId, opcode, performance.now());
    }
    primitiveReportedValue = blockFunction(argValues, blockUtility);
    if (runtime.profiler !== null) {
        // runtime.profiler.stop(blockFunctionProfilerId);
        runtime.profiler.records.push(runtime.profiler.STOP, performance.now());
    }

    if (typeof primitiveReportedValue === 'undefined') {
        // No value reported - potentially a command block.
        // Edge-activated hats don't request a glow; all commands do.
        thread.requestScriptGlowInFrame = true;
    }

    // If it's a promise, wait until promise resolves.
    if (isPromise(primitiveReportedValue)) {
        if (thread.status === Thread.STATUS_RUNNING) {
            // Primitive returned a promise; automatically yield thread.
            thread.status = Thread.STATUS_PROMISE_WAIT;
        }
        // Promise handlers
        primitiveReportedValue.then(function (resolvedValue) {
            handleReport(resolvedValue, sequencer, thread, currentBlockId, opcode, isHat);
            if (typeof resolvedValue === 'undefined') {
                var stackFrame = void 0;
                var nextBlockId = void 0;
                do {
                    // In the case that the promise is the last block in the current thread stack
                    // We need to pop out repeatedly until we find the next block.
                    var popped = thread.popStack();
                    if (popped === null) {
                        return;
                    }
                    nextBlockId = thread.target.blocks.getNextBlock(popped);
                    if (nextBlockId !== null) {
                        // A next block exists so break out this loop
                        break;
                    }
                    // Investigate the next block and if not in a loop,
                    // then repeat and pop the next item off the stack frame
                    stackFrame = thread.peekStackFrame();
                } while (stackFrame !== null && !stackFrame.isLoop);

                thread.pushStack(nextBlockId);
            } else {
                thread.popStack();
            }
        }, function (rejectionReason) {
            // Promise rejected: the primitive had some error.
            // Log it and proceed.
            log.warn('Primitive rejected promise: ', rejectionReason);
            thread.status = Thread.STATUS_RUNNING;
            thread.popStack();
        });
    } else if (thread.status === Thread.STATUS_RUNNING) {
        handleReport(primitiveReportedValue, sequencer, thread, currentBlockId, opcode, isHat);
    }
};

module.exports = execute;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(25),
    Record = _require.Record;

var MonitorRecord = Record({
    id: null,
    /** Present only if the monitor is sprite-specific, such as x position */
    spriteName: null,
    /** Present only if the monitor is sprite-specific, such as x position */
    targetId: null,
    opcode: null,
    value: null,
    params: null
});

module.exports = MonitorRecord;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @fileoverview
 * A way to profile Scratch internal performance. Like what blocks run during a
 * step? How much time do they take? How much time is spent inbetween blocks?
 *
 * Profiler aims for to spend as little time inside its functions while
 * recording. For this it has a simple internal record structure that records a
 * series of values for each START and STOP event in a single array. This lets
 * all the values be pushed in one call for the array. This simplicity allows
 * the contents of the start() and stop() calls to be inlined in areas that are
 * called frequently enough to want even greater performance from Profiler so
 * what is recorded better reflects on the profiled code and not Profiler
 * itself.
 */

/**
 * The next id returned for a new profile'd function.
 * @type {number}
 */
var nextId = 0;

/**
 * The mapping of names to ids.
 * @const {Object.<string, number>}
 */
var profilerNames = {};

/**
 * The START event identifier in Profiler records.
 * @const {number}
 */
var START = 0;

/**
 * The STOP event identifier in Profiler records.
 * @const {number}
 */
var STOP = 1;

/**
 * The number of cells used in the records array by a START event.
 * @const {number}
 */
var START_SIZE = 4;

/**
 * The number of cells used in the records array by a STOP event.
 * @const {number}
 */
var STOP_SIZE = 2;

/**
 * Stored reference to Performance instance provided by the Browser.
 * @const {Performance}
 */
var performance = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.performance;

/**
 * Callback handle called by Profiler for each frame it decodes from its
 * records.
 * @callback FrameCallback
 * @param {ProfilerFrame} frame
 */

/**
 * A set of information about a frame of execution that was recorded.
 */

var ProfilerFrame =
/**
 * @param {number} depth Depth of the frame in the recorded stack.
 */
function ProfilerFrame(depth) {
  _classCallCheck(this, ProfilerFrame);

  /**
   * The numeric id of a record symbol like Runtime._step or
   * blockFunction.
   * @type {number}
   */
  this.id = -1;

  /**
   * The amount of time spent inside the recorded frame and any deeper
   * frames.
   * @type {number}
   */
  this.totalTime = 0;

  /**
   * The amount of time spent only inside this record frame. Not
   * including time in any deeper frames.
   * @type {number}
   */
  this.selfTime = 0;

  /**
   * An arbitrary argument for the recorded frame. For example a block
   * function might record its opcode as an argument.
   * @type {*}
   */
  this.arg = null;

  /**
   * The depth of the recorded frame. This can help compare recursive
   * funtions that are recorded. Each level of recursion with have a
   * different depth value.
   * @type {number}
   */
  this.depth = depth;
};

var Profiler = function () {
  /**
   * @param {FrameCallback} onFrame a handle called for each recorded frame.
   * The passed frame value may not be stored as it'll be updated with later
   * frame information. Any information that is further stored by the handler
   * should make copies or reduce the information.
   */
  function Profiler() {
    var onFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

    _classCallCheck(this, Profiler);

    /**
     * A series of START and STOP values followed by arguments. After
     * recording is complete the full set of records is reported back by
     * stepping through the series to connect the relative START and STOP
     * information.
     * @type {Array.<*>}
     */
    this.records = [];

    /**
     * A cache of ProfilerFrames to reuse when reporting the recorded
     * frames in records.
     * @type {Array.<ProfilerFrame>}
     */
    this._stack = [new ProfilerFrame(0)];

    /**
     * A callback handle called with each decoded frame when reporting back
     * all the recorded times.
     * @type {FrameCallback}
     */
    this.onFrame = onFrame;

    /**
     * A reference to the START record id constant.
     * @const {number}
     */
    this.START = START;

    /**
     * A reference to the STOP record id constant.
     * @const {number}
     */
    this.STOP = STOP;
  }

  /**
   * Start recording a frame of time for an id and optional argument.
   * @param {number} id The id returned by idByName for a name symbol like
   * Runtime._step.
   * @param {?*} arg An arbitrary argument value to store with the frame.
   */


  _createClass(Profiler, [{
    key: 'start',
    value: function start(id, arg) {
      this.records.push(START, id, arg, performance.now());
    }

    /**
     * Stop the current frame.
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.records.push(STOP, performance.now());
    }

    /**
     * Decode records and report all frames to `this.onFrame`.
     */

  }, {
    key: 'reportFrames',
    value: function reportFrames() {
      var stack = this._stack;
      var depth = 1;

      // Step through the records and initialize Frame instances from the
      // START and STOP events. START and STOP events are separated by events
      // for deeper frames run by higher frames. Frames are stored on a stack
      // and reinitialized for each START event. When a stop event is reach
      // the Frame for the current depth has its final values stored and its
      // passed to the current onFrame callback. This way Frames are "pushed"
      // for each START event and "popped" for each STOP and handed to an
      // outside handle to any desired reduction of the collected data.
      for (var i = 0; i < this.records.length;) {
        if (this.records[i] === START) {
          if (depth >= stack.length) {
            stack.push(new ProfilerFrame(depth));
          }

          // Store id, arg, totalTime, and initialize selfTime.
          var frame = stack[depth++];
          frame.id = this.records[i + 1];
          frame.arg = this.records[i + 2];
          // totalTime is first set as the time recorded by this START
          // event. Once the STOP event is reached the stored start time
          // is subtracted from the recorded stop time. The resulting
          // difference is the actual totalTime, and replaces the start
          // time in frame.totalTime.
          //
          // totalTime is used this way as a convenient member to store a
          // value between the two events without needing additional
          // members on the Frame or in a shadow map.
          frame.totalTime = this.records[i + 3];
          // selfTime is decremented until we reach the STOP event for
          // this frame. totalTime will be added to it then to get the
          // time difference.
          frame.selfTime = 0;

          i += START_SIZE;
        } else if (this.records[i] === STOP) {
          var now = this.records[i + 1];

          var _frame = stack[--depth];
          // totalTime is the difference between the start event time
          // stored in totalTime and the stop event time pulled from this
          // record.
          _frame.totalTime = now - _frame.totalTime;
          // selfTime is the difference of this frame's totalTime and the
          // sum of totalTime of deeper frames.
          _frame.selfTime += _frame.totalTime;

          // Remove this frames totalTime from the parent's selfTime.
          stack[depth - 1].selfTime -= _frame.totalTime;

          this.onFrame(_frame);

          i += STOP_SIZE;
        } else {
          this.records.length = 0;
          throw new Error('Unable to decode Profiler records.');
        }
      }

      this.records.length = 0;
    }

    /**
     * Lookup or create an id for a frame name.
     * @param {string} name The name to return an id for.
     * @return {number} The id for the passed name.
     */

  }, {
    key: 'idByName',
    value: function idByName(name) {
      return Profiler.idByName(name);
    }

    /**
     * Reverse lookup the name from a given frame id.
     * @param {number} id The id to search for.
     * @return {string} The name for the given id.
     */

  }, {
    key: 'nameById',
    value: function nameById(id) {
      return Profiler.nameById(id);
    }

    /**
     * Lookup or create an id for a frame name.
     * @static
     * @param {string} name The name to return an id for.
     * @return {number} The id for the passed name.
     */

  }], [{
    key: 'idByName',
    value: function idByName(name) {
      if (typeof profilerNames[name] !== 'number') {
        profilerNames[name] = nextId++;
      }
      return profilerNames[name];
    }

    /**
     * Reverse lookup the name from a given frame id.
     * @static
     * @param {number} id The id to search for.
     * @return {string} The name for the given id.
     */

  }, {
    key: 'nameById',
    value: function nameById(id) {
      for (var name in profilerNames) {
        if (profilerNames[name] === id) {
          return name;
        }
      }
      return null;
    }

    /**
     * Profiler is only available on platforms with the Performance API.
     * @return {boolean} Can the Profiler run in this browser?
     */

  }, {
    key: 'available',
    value: function available() {
      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && typeof window.performance !== 'undefined';
    }
  }]);

  return Profiler;
}();

/**
 * A reference to the START record id constant.
 * @const {number}
 */


Profiler.START = START;

/**
 * A reference to the STOP record id constant.
 * @const {number}
 */
Profiler.STOP = STOP;

module.exports = Profiler;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = __webpack_require__(4);

var _require = __webpack_require__(25),
    OrderedMap = _require.OrderedMap;

var escapeHtml = __webpack_require__(108);

var ArgumentType = __webpack_require__(19);
var Blocks = __webpack_require__(10);
var BlockType = __webpack_require__(11);
var Sequencer = __webpack_require__(77);
var Thread = __webpack_require__(17);
var Profiler = __webpack_require__(75);

// Virtual I/O devices.
var Clock = __webpack_require__(83);
var DeviceManager = __webpack_require__(84);
var Keyboard = __webpack_require__(85);
var Mouse = __webpack_require__(86);

var defaultBlockPackages = {
    scratch3_control: __webpack_require__(61),
    scratch3_event: __webpack_require__(63),
    scratch3_looks: __webpack_require__(64),
    scratch3_motion: __webpack_require__(65),
    scratch3_operators: __webpack_require__(66),
    scratch3_sound: __webpack_require__(69),
    scratch3_sensing: __webpack_require__(68),
    scratch3_data: __webpack_require__(62),
    scratch3_procedures: __webpack_require__(67)
};

/**
 * Information used for converting Scratch argument types into scratch-blocks data.
 * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}}
 */
var ArgumentTypeMap = function () {
    var map = {};
    map[ArgumentType.ANGLE] = {
        shadowType: 'math_angle',
        fieldType: 'NUM'
    };
    map[ArgumentType.COLOR] = {
        shadowType: 'colour_picker'
    };
    map[ArgumentType.NUMBER] = {
        shadowType: 'math_number',
        fieldType: 'NUM'
    };
    map[ArgumentType.STRING] = {
        shadowType: 'text',
        fieldType: 'TEXT'
    };
    map[ArgumentType.BOOLEAN] = {
        check: 'Boolean'
    };
    return map;
}();

/**
 * These constants are copied from scratch-blocks/core/constants.js
 * @TODO find a way to require() these... maybe make a scratch-blocks/dist/constants.js or something like that?
 * @readonly
 * @enum {int}
 */
var ScratchBlocksConstants = {
    /**
     * ENUM for output shape: hexagonal (booleans/predicates).
     * @const
     */
    OUTPUT_SHAPE_HEXAGONAL: 1,

    /**
     * ENUM for output shape: rounded (numbers).
     * @const
     */
    OUTPUT_SHAPE_ROUND: 2,

    /**
     * ENUM for output shape: squared (any/all values; strings).
     * @const
     */
    OUTPUT_SHAPE_SQUARE: 3
};

/**
 * Numeric ID for Runtime._step in Profiler instances.
 * @type {number}
 */
var stepProfilerId = -1;

/**
 * Numeric ID for Sequencer.stepThreads in Profiler instances.
 * @type {number}
 */
var stepThreadsProfilerId = -1;

/**
 * Numeric ID for RenderWebGL.draw in Profiler instances.
 * @type {number}
 */
var rendererDrawProfilerId = -1;

/**
 * Manages targets, scripts, and the sequencer.
 * @constructor
 */

var Runtime = function (_EventEmitter) {
    _inherits(Runtime, _EventEmitter);

    function Runtime() {
        _classCallCheck(this, Runtime);

        /**
         * Target management and storage.
         * @type {Array.<!Target>}
         */
        var _this = _possibleConstructorReturn(this, (Runtime.__proto__ || Object.getPrototypeOf(Runtime)).call(this));

        _this.targets = [];

        /**
         * A list of threads that are currently running in the VM.
         * Threads are added when execution starts and pruned when execution ends.
         * @type {Array.<Thread>}
         */
        _this.threads = [];

        /** @type {!Sequencer} */
        _this.sequencer = new Sequencer(_this);

        /**
         * Storage container for flyout blocks.
         * These will execute on `_editingTarget.`
         * @type {!Blocks}
         */
        _this.flyoutBlocks = new Blocks();

        /**
         * Storage container for monitor blocks.
         * These will execute on a target maybe
         * @type {!Blocks}
         */
        _this.monitorBlocks = new Blocks();

        /**
         * Currently known editing target for the VM.
         * @type {?Target}
         */
        _this._editingTarget = null;

        /**
         * Map to look up a block primitive's implementation function by its opcode.
         * This is a two-step lookup: package name first, then primitive name.
         * @type {Object.<string, Function>}
         */
        _this._primitives = {};

        /**
         * Map to look up all block information by extended opcode.
         * @type {Array.<CategoryInfo>}
         * @private
         */
        _this._blockInfo = [];

        /**
         * Map to look up hat blocks' metadata.
         * Keys are opcode for hat, values are metadata objects.
         * @type {Object.<string, Object>}
         */
        _this._hats = {};

        /**
         * Currently known values for edge-activated hats.
         * Keys are block ID for the hat; values are the currently known values.
         * @type {Object.<string, *>}
         */
        _this._edgeActivatedHatValues = {};

        /**
         * A list of script block IDs that were glowing during the previous frame.
         * @type {!Array.<!string>}
         */
        _this._scriptGlowsPreviousFrame = [];

        /**
         * Number of non-monitor threads running during the previous frame.
         * @type {number}
         */
        _this._nonMonitorThreadCount = 0;

        /**
         * Currently known number of clones, used to enforce clone limit.
         * @type {number}
         */
        _this._cloneCounter = 0;

        /**
         * Flag to emit a targets update at the end of a step. When target data
         * changes, this flag is set to true.
         * @type {boolean}
         */
        _this._refreshTargets = false;

        /**
         * Map to look up all monitor block information by opcode.
         * @type {object}
         * @private
         */
        _this.monitorBlockInfo = {};

        /**
         * Ordered map of all monitors, which are MonitorReporter objects.
         */
        _this._monitorState = OrderedMap({});

        /**
         * Monitor state from last tick
         */
        _this._prevMonitorState = OrderedMap({});

        /**
         * Whether the project is in "turbo mode."
         * @type {Boolean}
         */
        _this.turboMode = false;

        /**
         * Whether the project is in "compatibility mode" (30 TPS).
         * @type {Boolean}
         */
        _this.compatibilityMode = false;

        /**
         * A reference to the current runtime stepping interval, set
         * by a `setInterval`.
         * @type {!number}
         */
        _this._steppingInterval = null;

        /**
         * Current length of a step.
         * Changes as mode switches, and used by the sequencer to calculate
         * WORK_TIME.
         * @type {!number}
         */
        _this.currentStepTime = null;

        /**
         * Whether any primitive has requested a redraw.
         * Affects whether `Sequencer.stepThreads` will yield
         * after stepping each thread.
         * Reset on every frame.
         * @type {boolean}
         */
        _this.redrawRequested = false;

        // Register all given block packages.
        _this._registerBlockPackages();

        // Register and initialize "IO devices", containers for processing
        // I/O related data.
        /** @type {Object.<string, Object>} */
        _this.ioDevices = {
            clock: new Clock(),
            deviceManager: new DeviceManager(),
            keyboard: new Keyboard(_this),
            mouse: new Mouse(_this)
        };

        /**
         * A runtime profiler that records timed events for later playback to
         * diagnose Scratch performance.
         * @type {Profiler}
         */
        _this.profiler = null;
        return _this;
    }

    /**
     * Width of the stage, in pixels.
     * @const {number}
     */


    _createClass(Runtime, [{
        key: '_registerBlockPackages',


        // -----------------------------------------------------------------------------
        // -----------------------------------------------------------------------------

        /**
         * Register default block packages with this runtime.
         * @todo Prefix opcodes with package name.
         * @private
         */
        value: function _registerBlockPackages() {
            for (var packageName in defaultBlockPackages) {
                if (defaultBlockPackages.hasOwnProperty(packageName)) {
                    // @todo pass a different runtime depending on package privilege?
                    var packageObject = new defaultBlockPackages[packageName](this);
                    // Collect primitives from package.
                    if (packageObject.getPrimitives) {
                        var packagePrimitives = packageObject.getPrimitives();
                        for (var op in packagePrimitives) {
                            if (packagePrimitives.hasOwnProperty(op)) {
                                this._primitives[op] = packagePrimitives[op].bind(packageObject);
                            }
                        }
                    }
                    // Collect hat metadata from package.
                    if (packageObject.getHats) {
                        var packageHats = packageObject.getHats();
                        for (var hatName in packageHats) {
                            if (packageHats.hasOwnProperty(hatName)) {
                                this._hats[hatName] = packageHats[hatName];
                            }
                        }
                    }
                    // Collect monitored from package.
                    if (packageObject.getMonitored) {
                        this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());
                    }
                }
            }
        }

        /**
         * Generate an extension-specific menu ID.
         * @param {string} menuName - the name of the menu.
         * @param {string} extensionId - the ID of the extension hosting the menu.
         * @returns {string} - the constructed ID.
         * @private
         */

    }, {
        key: '_makeExtensionMenuId',
        value: function _makeExtensionMenuId(menuName, extensionId) {
            return extensionId + '.menu.' + escapeHtml(menuName);
        }

        /**
         * Register the primitives provided by an extension.
         * @param {ExtensionInfo} extensionInfo - information about the extension (id, blocks, etc.)
         * @private
         */

    }, {
        key: '_registerExtensionPrimitives',
        value: function _registerExtensionPrimitives(extensionInfo) {
            var categoryInfo = {
                id: extensionInfo.id,
                name: extensionInfo.name,
                iconURI: extensionInfo.iconURI,
                color1: '#FF6680',
                color2: '#FF4D6A',
                color3: '#FF3355',
                blocks: [],
                menus: []
            };

            this._blockInfo.push(categoryInfo);

            for (var menuName in extensionInfo.menus) {
                if (extensionInfo.menus.hasOwnProperty(menuName)) {
                    var menuItems = extensionInfo.menus[menuName];
                    var convertedMenu = this._buildMenuForScratchBlocks(menuName, menuItems, categoryInfo);
                    categoryInfo.menus.push(convertedMenu);
                }
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = extensionInfo.blocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion = (_step2 = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var blockInfo = _step2.value;

                    var convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);
                    var opcode = convertedBlock.json.type;
                    categoryInfo.blocks.push(convertedBlock);
                    this._primitives[opcode] = convertedBlock.info.func;
                    if (blockInfo.blockType === BlockType.HAT) {
                        this._hats[opcode] = { edgeActivated: true }; /** @TODO let extension specify this */
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.emit(Runtime.EXTENSION_ADDED, categoryInfo.blocks.concat(categoryInfo.menus));
        }

        /**
         * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.
         * @param {string} menuName - the name of the menu
         * @param {array} menuItems - the list of items for this menu
         * @param {CategoryInfo} categoryInfo - the category for this block
         * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption
         * @private
         */

    }, {
        key: '_buildMenuForScratchBlocks',
        value: function _buildMenuForScratchBlocks(menuName, menuItems, categoryInfo) {
            var menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);

            /** @TODO: support dynamic menus when 'menuItems' is a method name string (see extension spec) */
            if (typeof menuItems === 'string') {
                throw new Error('Dynamic extension menus are not yet supported. Menu name: ' + menuName);
            }
            var options = menuItems.map(function (item) {
                switch (typeof item === 'undefined' ? 'undefined' : _typeof(item)) {
                    case 'string':
                        return [item, item];
                    case 'object':
                        return [item.text, item.value];
                    default:
                        throw new Error('Can\'t interpret menu item: ' + item);
                }
            });

            return {
                json: {
                    message0: '%1',
                    type: menuId,
                    inputsInline: true,
                    output: 'String',
                    colour: categoryInfo.color1,
                    colourSecondary: categoryInfo.color2,
                    colourTertiary: categoryInfo.color3,
                    outputShape: ScratchBlocksConstants.OUTPUT_SHAPE_ROUND,
                    args0: [{
                        type: 'field_dropdown',
                        name: menuName,
                        options: options
                    }]
                }
            };
        }

        /**
         * Convert BlockInfo into scratch-blocks JSON & XML, and generate a proxy function.
         * @param {BlockInfo} blockInfo - the block to convert
         * @param {CategoryInfo} categoryInfo - the category for this block
         * @returns {{info: BlockInfo, json: object, xml: string}} - the converted & original block information
         * @private
         */

    }, {
        key: '_convertForScratchBlocks',
        value: function _convertForScratchBlocks(blockInfo, categoryInfo) {
            var _this2 = this;

            var extendedOpcode = categoryInfo.id + '.' + blockInfo.opcode;
            var blockJSON = {
                type: extendedOpcode,
                inputsInline: true,
                category: categoryInfo.name,
                colour: categoryInfo.color1,
                colourSecondary: categoryInfo.color2,
                colorTertiary: categoryInfo.color3,
                args0: []
            };

            var inputList = [];

            // TODO: store this somewhere so that we can map args appropriately after translation.
            // This maps an arg name to its relative position in the original (usually English) block text.
            // When displaying a block in another language we'll need to run a `replace` action similar to the one below,
            // but each `[ARG]` will need to be replaced with the number in this map instead of `args0.length`.
            var argsMap = {};

            blockJSON.message0 = '';

            // If an icon for the extension exists, prepend it to each block
            if (categoryInfo.iconURI) {
                blockJSON.message0 = '%1';
                var iconJSON = {
                    type: 'field_image',
                    src: categoryInfo.iconURI,
                    width: 40,
                    height: 40
                };
                blockJSON.args0.push(iconJSON);
            }

            blockJSON.message0 += blockInfo.text.replace(/\[(.+?)]/g, function (match, placeholder) {
                // Sanitize the placeholder to ensure valid XML
                placeholder = placeholder.replace(/[<"&]/, '_');

                var argJSON = {
                    type: 'input_value',
                    name: placeholder
                };

                var argInfo = blockInfo.arguments[placeholder] || {};
                var argTypeInfo = ArgumentTypeMap[argInfo.type] || {};
                var defaultValue = typeof argInfo.defaultValue === 'undefined' ? '' : escapeHtml(argInfo.defaultValue.toString());

                if (argTypeInfo.check) {
                    argJSON.check = argTypeInfo.check;
                }

                var shadowType = argInfo.menu ? _this2._makeExtensionMenuId(argInfo.menu, categoryInfo.id) : argTypeInfo.shadowType;
                var fieldType = argInfo.menu || argTypeInfo.fieldType;

                // <value> is the ScratchBlocks name for a block input.
                inputList.push('<value name="' + placeholder + '">');

                // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.
                // Boolean inputs don't need to specify a shadow in the XML.
                if (shadowType) {
                    inputList.push('<shadow type="' + shadowType + '">');

                    // <field> is a text field that the user can type into. Some shadows, like the color picker, don't allow
                    // text input and therefore don't need a field element.
                    if (fieldType) {
                        inputList.push('<field name="' + fieldType + '">' + defaultValue + '</field>');
                    }

                    inputList.push('</shadow>');
                }

                inputList.push('</value>');

                // scratch-blocks uses 1-based argument indexing
                blockJSON.args0.push(argJSON);
                var argNum = blockJSON.args0.length;
                argsMap[placeholder] = argNum;
                return '%' + argNum;
            });

            switch (blockInfo.blockType) {
                case BlockType.COMMAND:
                    blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
                    blockJSON.previousStatement = null; // null = available connection; undefined = hat
                    if (!blockInfo.isTerminal) {
                        blockJSON.nextStatement = null; // null = available connection; undefined = terminal
                    }
                    break;
                case BlockType.REPORTER:
                    blockJSON.output = 'String'; // TODO: distinguish number & string here?
                    blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;
                    break;
                case BlockType.BOOLEAN:
                    blockJSON.output = 'Boolean';
                    blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;
                    break;
                case BlockType.HAT:
                    blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
                    blockJSON.nextStatement = null; // null = available connection; undefined = terminal
                    break;
                case BlockType.CONDITIONAL:
                    // Statement inputs get names like 'SUBSTACK', 'SUBSTACK2', 'SUBSTACK3', ...
                    for (var branchNum = 1; branchNum <= blockInfo.branchCount; ++branchNum) {
                        blockJSON['message' + branchNum] = '%1';
                        blockJSON['args' + branchNum] = [{
                            type: 'input_statement',
                            name: 'SUBSTACK' + (branchNum > 1 ? branchNum : '')
                        }];
                    }
                    blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
                    blockJSON.previousStatement = null; // null = available connection; undefined = hat
                    blockJSON.nextStatement = null; // null = available connection; undefined = terminal
                    break;
            }

            if (blockInfo.isTerminal) {
                delete blockJSON.nextStatement;
            }

            var blockXML = '<block type="' + extendedOpcode + '">' + inputList.join('') + '</block>';

            return {
                info: blockInfo,
                json: blockJSON,
                xml: blockXML
            };
        }

        /**
         * @returns {string} scratch-blocks XML description for all dynamic blocks, wrapped in <category> elements.
         */

    }, {
        key: 'getBlocksXML',
        value: function getBlocksXML() {
            var xmlParts = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this._blockInfo[Symbol.iterator](), _step3; !(_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var categoryInfo = _step3.value;
                    var name = categoryInfo.name,
                        color1 = categoryInfo.color1,
                        color2 = categoryInfo.color2;

                    var paletteBlocks = categoryInfo.blocks.filter(function (block) {
                        return !block.info.hideFromPalette;
                    });
                    xmlParts.push('<category name="' + name + '" colour="' + color1 + '" secondaryColour="' + color2 + '">');
                    xmlParts.push.apply(xmlParts, paletteBlocks.map(function (block) {
                        return block.xml;
                    }));
                    xmlParts.push('</category>');
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return xmlParts.join('\n');
        }

        /**
         * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
         */

    }, {
        key: 'getBlocksJSON',
        value: function getBlocksJSON() {
            return this._blockInfo.reduce(function (result, categoryInfo) {
                return result.concat(categoryInfo.blocks.map(function (blockInfo) {
                    return blockInfo.json;
                }));
            }, []);
        }

        /**
         * Retrieve the function associated with the given opcode.
         * @param {!string} opcode The opcode to look up.
         * @return {Function} The function which implements the opcode.
         */

    }, {
        key: 'getOpcodeFunction',
        value: function getOpcodeFunction(opcode) {
            return this._primitives[opcode];
        }

        /**
         * Return whether an opcode represents a hat block.
         * @param {!string} opcode The opcode to look up.
         * @return {boolean} True if the op is known to be a hat.
         */

    }, {
        key: 'getIsHat',
        value: function getIsHat(opcode) {
            return this._hats.hasOwnProperty(opcode);
        }

        /**
         * Return whether an opcode represents an edge-activated hat block.
         * @param {!string} opcode The opcode to look up.
         * @return {boolean} True if the op is known to be a edge-activated hat.
         */

    }, {
        key: 'getIsEdgeActivatedHat',
        value: function getIsEdgeActivatedHat(opcode) {
            return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;
        }

        /**
         * Update an edge-activated hat block value.
         * @param {!string} blockId ID of hat to store value for.
         * @param {*} newValue Value to store for edge-activated hat.
         * @return {*} The old value for the edge-activated hat.
         */

    }, {
        key: 'updateEdgeActivatedValue',
        value: function updateEdgeActivatedValue(blockId, newValue) {
            var oldValue = this._edgeActivatedHatValues[blockId];
            this._edgeActivatedHatValues[blockId] = newValue;
            return oldValue;
        }

        /**
         * Clear all edge-activaed hat values.
         */

    }, {
        key: 'clearEdgeActivatedValues',
        value: function clearEdgeActivatedValues() {
            this._edgeActivatedHatValues = {};
        }

        /**
         * Attach the audio engine
         * @param {!AudioEngine} audioEngine The audio engine to attach
         */

    }, {
        key: 'attachAudioEngine',
        value: function attachAudioEngine(audioEngine) {
            this.audioEngine = audioEngine;
        }

        /**
         * Attach the renderer
         * @param {!RenderWebGL} renderer The renderer to attach
         */

    }, {
        key: 'attachRenderer',
        value: function attachRenderer(renderer) {
            this.renderer = renderer;
        }

        /**
         * Attach the storage module
         * @param {!ScratchStorage} storage The storage module to attach
         */

    }, {
        key: 'attachStorage',
        value: function attachStorage(storage) {
            this.storage = storage;
        }

        // -----------------------------------------------------------------------------
        // -----------------------------------------------------------------------------

        /**
         * Create a thread and push it to the list of threads.
         * @param {!string} id ID of block that starts the stack.
         * @param {!Target} target Target to run thread on.
         * @param {?object} opts optional arguments
         * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack
         * @param {?boolean} opts.updateMonitor true if the script should update a monitor value
         * @return {!Thread} The newly created thread.
         */

    }, {
        key: '_pushThread',
        value: function _pushThread(id, target, opts) {
            opts = Object.assign({
                stackClick: false,
                updateMonitor: false
            }, opts);

            var thread = new Thread(id);
            thread.target = target;
            thread.stackClick = opts.stackClick;
            thread.updateMonitor = opts.updateMonitor;

            thread.pushStack(id);
            this.threads.push(thread);
            return thread;
        }

        /**
         * Stop a thread: stop running it immediately, and remove it from the thread list later.
         * @param {!Thread} thread Thread object to remove from actives
         */

    }, {
        key: '_stopThread',
        value: function _stopThread(thread) {
            // Mark the thread for later removal
            thread.isKilled = true;
            // Inform sequencer to stop executing that thread.
            this.sequencer.retireThread(thread);
        }

        /**
         * Restart a thread in place, maintaining its position in the list of threads.
         * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
         * Test project: https://scratch.mit.edu/projects/130183108/
         * @param {!Thread} thread Thread object to restart.
         * @return {Thread} The restarted thread.
         */

    }, {
        key: '_restartThread',
        value: function _restartThread(thread) {
            var newThread = new Thread(thread.topBlock);
            newThread.target = thread.target;
            newThread.stackClick = thread.stackClick;
            newThread.updateMonitor = thread.updateMonitor;
            newThread.pushStack(thread.topBlock);
            var i = this.threads.indexOf(thread);
            if (i > -1) {
                this.threads[i] = newThread;
                return newThread;
            }
            this.threads.push(thread);
            return thread;
        }

        /**
         * Return whether a thread is currently active/running.
         * @param {?Thread} thread Thread object to check.
         * @return {boolean} True if the thread is active/running.
         */

    }, {
        key: 'isActiveThread',
        value: function isActiveThread(thread) {
            return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;
        }

        /**
         * Toggle a script.
         * @param {!string} topBlockId ID of block that starts the script.
         * @param {?object} opts optional arguments to toggle script
         * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
         * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
         *     determines whether we show a visual report when turning on the script.
         */

    }, {
        key: 'toggleScript',
        value: function toggleScript(topBlockId, opts) {
            opts = Object.assign({
                target: this._editingTarget,
                stackClick: false
            }, opts);
            // Remove any existing thread.
            for (var i = 0; i < this.threads.length; i++) {
                // Toggling a script that's already running turns it off
                if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {
                    var blockContainer = opts.target.blocks;
                    var opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));

                    if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {
                        // Allow edge activated hat thread stack click to coexist with
                        // edge activated hat thread that runs every frame
                        continue;
                    }
                    this._stopThread(this.threads[i]);
                    return;
                }
            }
            // Otherwise add it.
            this._pushThread(topBlockId, opts.target, opts);
        }

        /**
         * Enqueue a script that when finished will update the monitor for the block.
         * @param {!string} topBlockId ID of block that starts the script.
         * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
         */

    }, {
        key: 'addMonitorScript',
        value: function addMonitorScript(topBlockId, optTarget) {
            if (!optTarget) optTarget = this._editingTarget;
            for (var i = 0; i < this.threads.length; i++) {
                // Don't re-add the script if it's already running
                if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {
                    return;
                }
            }
            // Otherwise add it.
            this._pushThread(topBlockId, optTarget, { updateMonitor: true });
        }

        /**
         * Run a function `f` for all scripts in a workspace.
         * `f` will be called with two parameters:
         *  - the top block ID of the script.
         *  - the target that owns the script.
         * @param {!Function} f Function to call for each script.
         * @param {Target=} optTarget Optionally, a target to restrict to.
         */

    }, {
        key: 'allScriptsDo',
        value: function allScriptsDo(f, optTarget) {
            var targets = this.targets;
            if (optTarget) {
                targets = [optTarget];
            }
            for (var t = targets.length - 1; t >= 0; t--) {
                var target = targets[t];
                var scripts = target.blocks.getScripts();
                for (var j = 0; j < scripts.length; j++) {
                    var topBlockId = scripts[j];
                    f(topBlockId, target);
                }
            }
        }

        /**
         * Start all relevant hats.
         * @param {!string} requestedHatOpcode Opcode of hats to start.
         * @param {object=} optMatchFields Optionally, fields to match on the hat.
         * @param {Target=} optTarget Optionally, a target to restrict to.
         * @return {Array.<Thread>} List of threads started by this function.
         */

    }, {
        key: 'startHats',
        value: function startHats(requestedHatOpcode, optMatchFields, optTarget) {
            if (!this._hats.hasOwnProperty(requestedHatOpcode)) {
                // No known hat with this opcode.
                return;
            }
            var instance = this;
            var newThreads = [];

            for (var opts in optMatchFields) {
                if (!optMatchFields.hasOwnProperty(opts)) continue;
                optMatchFields[opts] = optMatchFields[opts].toUpperCase();
            }

            // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.
            this.allScriptsDo(function (topBlockId, target) {
                var blocks = target.blocks;
                var block = blocks.getBlock(topBlockId);
                var potentialHatOpcode = block.opcode;
                if (potentialHatOpcode !== requestedHatOpcode) {
                    // Not the right hat.
                    return;
                }

                // Match any requested fields.
                // For example: ensures that broadcasts match.
                // This needs to happen before the block is evaluated
                // (i.e., before the predicate can be run) because "broadcast and wait"
                // needs to have a precise collection of started threads.
                var hatFields = blocks.getFields(block);

                // If no fields are present, check inputs (horizontal blocks)
                if (Object.keys(hatFields).length === 0) {
                    hatFields = {}; // don't overwrite the block's actual fields list
                    var hatInputs = blocks.getInputs(block);
                    for (var input in hatInputs) {
                        if (!hatInputs.hasOwnProperty(input)) continue;
                        var id = hatInputs[input].block;
                        var inpBlock = blocks.getBlock(id);
                        var fields = blocks.getFields(inpBlock);
                        Object.assign(hatFields, fields);
                    }
                }

                if (optMatchFields) {
                    for (var matchField in optMatchFields) {
                        if (hatFields[matchField].value.toUpperCase() !== optMatchFields[matchField]) {
                            // Field mismatch.
                            return;
                        }
                    }
                }

                // Look up metadata for the relevant hat.
                var hatMeta = instance._hats[requestedHatOpcode];
                if (hatMeta.restartExistingThreads) {
                    // If `restartExistingThreads` is true, we should stop
                    // any existing threads starting with the top block.
                    for (var i = 0; i < instance.threads.length; i++) {
                        if (instance.threads[i].topBlock === topBlockId && !instance.threads[i].stackClick && // stack click threads and hat threads can coexist
                        instance.threads[i].target === target) {
                            newThreads.push(instance._restartThread(instance.threads[i]));
                            return;
                        }
                    }
                } else {
                    // If `restartExistingThreads` is false, we should
                    // give up if any threads with the top block are running.
                    for (var j = 0; j < instance.threads.length; j++) {
                        if (instance.threads[j].topBlock === topBlockId && instance.threads[j].target === target && !instance.threads[j].stackClick && // stack click threads and hat threads can coexist
                        instance.threads[j].status !== Thread.STATUS_DONE) {
                            // Some thread is already running.
                            return;
                        }
                    }
                }
                // Start the thread with this top block.
                newThreads.push(instance._pushThread(topBlockId, target));
            }, optTarget);
            return newThreads;
        }

        /**
         * Dispose all targets. Return to clean state.
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this.stopAll();
            this.targets.map(this.disposeTarget, this);
        }

        /**
         * Dispose of a target.
         * @param {!Target} disposingTarget Target to dispose of.
         */

    }, {
        key: 'disposeTarget',
        value: function disposeTarget(disposingTarget) {
            this.targets = this.targets.filter(function (target) {
                if (disposingTarget !== target) return true;
                // Allow target to do dispose actions.
                target.dispose();
                // Remove from list of targets.
                return false;
            });
        }

        /**
         * Stop any threads acting on the target.
         * @param {!Target} target Target to stop threads for.
         * @param {Thread=} optThreadException Optional thread to skip.
         */

    }, {
        key: 'stopForTarget',
        value: function stopForTarget(target, optThreadException) {
            // Stop any threads on the target.
            for (var i = 0; i < this.threads.length; i++) {
                if (this.threads[i] === optThreadException) {
                    continue;
                }
                if (this.threads[i].target === target) {
                    this._stopThread(this.threads[i]);
                }
            }
        }

        /**
         * Start all threads that start with the green flag.
         */

    }, {
        key: 'greenFlag',
        value: function greenFlag() {
            this.stopAll();
            this.emit(Runtime.PROJECT_START);
            this.ioDevices.clock.resetProjectTimer();
            this.clearEdgeActivatedValues();
            // Inform all targets of the green flag.
            for (var i = 0; i < this.targets.length; i++) {
                this.targets[i].onGreenFlag();
            }
            this.startHats('event_whenflagclicked');
        }

        /**
         * Stop "everything."
         */

    }, {
        key: 'stopAll',
        value: function stopAll() {
            var _this3 = this;

            // Emit stop event to allow blocks to clean up any state.
            this.emit(Runtime.PROJECT_STOP_ALL);

            // Dispose all clones.
            var newTargets = [];
            for (var i = 0; i < this.targets.length; i++) {
                this.targets[i].onStopAll();
                if (this.targets[i].hasOwnProperty('isOriginal') && !this.targets[i].isOriginal) {
                    this.targets[i].dispose();
                } else {
                    newTargets.push(this.targets[i]);
                }
            }
            this.targets = newTargets;
            // Dispose all threads.
            this.threads.forEach(function (thread) {
                return _this3._stopThread(thread);
            });
        }

        /**
         * Repeatedly run `sequencer.stepThreads` and filter out
         * inactive threads after each iteration.
         */

    }, {
        key: '_step',
        value: function _step() {
            if (this.profiler !== null) {
                if (stepProfilerId === -1) {
                    stepProfilerId = this.profiler.idByName('Runtime._step');
                }
                this.profiler.start(stepProfilerId);
            }

            // Clean up threads that were told to stop during or since the last step
            this.threads = this.threads.filter(function (thread) {
                return !thread.isKilled;
            });

            // Find all edge-activated hats, and add them to threads to be evaluated.
            for (var hatType in this._hats) {
                if (!this._hats.hasOwnProperty(hatType)) continue;
                var hat = this._hats[hatType];
                if (hat.edgeActivated) {
                    this.startHats(hatType);
                }
            }
            this.redrawRequested = false;
            this._pushMonitors();
            if (this.profiler !== null) {
                if (stepThreadsProfilerId === -1) {
                    stepThreadsProfilerId = this.profiler.idByName('Sequencer.stepThreads');
                }
                this.profiler.start(stepThreadsProfilerId);
            }
            var doneThreads = this.sequencer.stepThreads();
            if (this.profiler !== null) {
                this.profiler.stop();
            }
            this._updateGlows(doneThreads);
            // Add done threads so that even if a thread finishes within 1 frame, the green
            // flag will still indicate that a script ran.
            this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([].concat(_toConsumableArray(this.threads), _toConsumableArray(doneThreads))));
            if (this.renderer) {
                // @todo: Only render when this.redrawRequested or clones rendered.
                if (this.profiler !== null) {
                    if (rendererDrawProfilerId === -1) {
                        rendererDrawProfilerId = this.profiler.idByName('RenderWebGL.draw');
                    }
                    this.profiler.start(rendererDrawProfilerId);
                }
                this.renderer.draw();
                if (this.profiler !== null) {
                    this.profiler.stop();
                }
            }

            if (this._refreshTargets) {
                this.emit(Runtime.TARGETS_UPDATE);
                this._refreshTargets = false;
            }

            if (!this._prevMonitorState.equals(this._monitorState)) {
                this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
                this._prevMonitorState = this._monitorState;
            }

            if (this.profiler !== null) {
                this.profiler.stop();
                this.profiler.reportFrames();
            }
        }

        /**
         * Get the number of threads in the given array that are monitor threads (threads
         * that update monitor values, and don't count as running a script).
         * @param {!Array.<Thread>} threads The set of threads to look through.
         * @return {number} The number of monitor threads in threads.
         */

    }, {
        key: '_getMonitorThreadCount',
        value: function _getMonitorThreadCount(threads) {
            var count = 0;
            threads.forEach(function (thread) {
                if (thread.updateMonitor) count++;
            });
            return count;
        }

        /**
         * Queue monitor blocks to sequencer to be run.
         */

    }, {
        key: '_pushMonitors',
        value: function _pushMonitors() {
            this.monitorBlocks.runAllMonitored(this);
        }

        /**
         * Set the current editing target known by the runtime.
         * @param {!Target} editingTarget New editing target.
         */

    }, {
        key: 'setEditingTarget',
        value: function setEditingTarget(editingTarget) {
            this._editingTarget = editingTarget;
            // Script glows must be cleared.
            this._scriptGlowsPreviousFrame = [];
            this._updateGlows();
            this.requestTargetsUpdate(editingTarget);
        }

        /**
         * Set whether we are in 30 TPS compatibility mode.
         * @param {boolean} compatibilityModeOn True iff in compatibility mode.
         */

    }, {
        key: 'setCompatibilityMode',
        value: function setCompatibilityMode(compatibilityModeOn) {
            this.compatibilityMode = compatibilityModeOn;
            if (this._steppingInterval) {
                clearInterval(this._steppingInterval);
                this.start();
            }
        }

        /**
         * Emit glows/glow clears for scripts after a single tick.
         * Looks at `this.threads` and notices which have turned on/off new glows.
         * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
         */

    }, {
        key: '_updateGlows',
        value: function _updateGlows(optExtraThreads) {
            var searchThreads = [];
            searchThreads.push.apply(searchThreads, this.threads);
            if (optExtraThreads) {
                searchThreads.push.apply(searchThreads, optExtraThreads);
            }
            // Set of scripts that request a glow this frame.
            var requestedGlowsThisFrame = [];
            // Final set of scripts glowing during this frame.
            var finalScriptGlows = [];
            // Find all scripts that should be glowing.
            for (var i = 0; i < searchThreads.length; i++) {
                var thread = searchThreads[i];
                var target = thread.target;
                if (target === this._editingTarget) {
                    var blockForThread = thread.blockGlowInFrame;
                    if (thread.requestScriptGlowInFrame) {
                        var script = target.blocks.getTopLevelScript(blockForThread);
                        if (!script) {
                            // Attempt to find in flyout blocks.
                            script = this.flyoutBlocks.getTopLevelScript(blockForThread);
                        }
                        if (script) {
                            requestedGlowsThisFrame.push(script);
                        }
                    }
                }
            }
            // Compare to previous frame.
            for (var j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {
                var previousFrameGlow = this._scriptGlowsPreviousFrame[j];
                if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {
                    // Glow turned off.
                    this.glowScript(previousFrameGlow, false);
                } else {
                    // Still glowing.
                    finalScriptGlows.push(previousFrameGlow);
                }
            }
            for (var k = 0; k < requestedGlowsThisFrame.length; k++) {
                var currentFrameGlow = requestedGlowsThisFrame[k];
                if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {
                    // Glow turned on.
                    this.glowScript(currentFrameGlow, true);
                    finalScriptGlows.push(currentFrameGlow);
                }
            }
            this._scriptGlowsPreviousFrame = finalScriptGlows;
        }

        /**
         * Emit run start/stop after each tick. Emits when `this.threads.length` goes
         * between non-zero and zero
         *
         * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
         */

    }, {
        key: '_emitProjectRunStatus',
        value: function _emitProjectRunStatus(nonMonitorThreadCount) {
            if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {
                this.emit(Runtime.PROJECT_RUN_START);
            }
            if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {
                this.emit(Runtime.PROJECT_RUN_STOP);
            }
            this._nonMonitorThreadCount = nonMonitorThreadCount;
        }

        /**
         * "Quiet" a script's glow: stop the VM from generating glow/unglow events
         * about that script. Use when a script has just been deleted, but we may
         * still be tracking glow data about it.
         * @param {!string} scriptBlockId Id of top-level block in script to quiet.
         */

    }, {
        key: 'quietGlow',
        value: function quietGlow(scriptBlockId) {
            var index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);
            if (index > -1) {
                this._scriptGlowsPreviousFrame.splice(index, 1);
            }
        }

        /**
         * Emit feedback for block glowing (used in the sequencer).
         * @param {?string} blockId ID for the block to update glow
         * @param {boolean} isGlowing True to turn on glow; false to turn off.
         */

    }, {
        key: 'glowBlock',
        value: function glowBlock(blockId, isGlowing) {
            if (isGlowing) {
                this.emit(Runtime.BLOCK_GLOW_ON, { id: blockId });
            } else {
                this.emit(Runtime.BLOCK_GLOW_OFF, { id: blockId });
            }
        }

        /**
         * Emit feedback for script glowing.
         * @param {?string} topBlockId ID for the top block to update glow
         * @param {boolean} isGlowing True to turn on glow; false to turn off.
         */

    }, {
        key: 'glowScript',
        value: function glowScript(topBlockId, isGlowing) {
            if (isGlowing) {
                this.emit(Runtime.SCRIPT_GLOW_ON, { id: topBlockId });
            } else {
                this.emit(Runtime.SCRIPT_GLOW_OFF, { id: topBlockId });
            }
        }

        /**
         * Emit value for reporter to show in the blocks.
         * @param {string} blockId ID for the block.
         * @param {string} value Value to show associated with the block.
         */

    }, {
        key: 'visualReport',
        value: function visualReport(blockId, value) {
            this.emit(Runtime.VISUAL_REPORT, { id: blockId, value: String(value) });
        }

        /**
         * Add a monitor to the state. If the monitor already exists in the state,
         * overwrites it.
         * @param {!MonitorRecord} monitor Monitor to add.
         */

    }, {
        key: 'requestAddMonitor',
        value: function requestAddMonitor(monitor) {
            this._monitorState = this._monitorState.set(monitor.get('id'), monitor);
        }

        /**
         * Update a monitor in the state. Does nothing if the monitor does not already
         * exist in the state.
         * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite
         *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,
         *     the old monitor will keep its old value.
         */

    }, {
        key: 'requestUpdateMonitor',
        value: function requestUpdateMonitor(monitor) {
            var id = monitor.get('id');
            if (this._monitorState.has(id)) {
                this._monitorState = this._monitorState.set(id, this._monitorState.get(id).merge(monitor));
            }
        }

        /**
         * Removes a monitor from the state. Does nothing if the monitor already does
         * not exist in the state.
         * @param {!string} monitorId ID of the monitor to remove.
         */

    }, {
        key: 'requestRemoveMonitor',
        value: function requestRemoveMonitor(monitorId) {
            this._monitorState = this._monitorState.delete(monitorId);
        }

        /**
         * Removes all monitors with the given target ID from the state. Does nothing if
         * the monitor already does not exist in the state.
         * @param {!string} targetId Remove all monitors with given target ID.
         */

    }, {
        key: 'requestRemoveMonitorByTargetId',
        value: function requestRemoveMonitorByTargetId(targetId) {
            this._monitorState = this._monitorState.filterNot(function (value) {
                return value.targetId === targetId;
            });
        }

        /**
         * Get a target by its id.
         * @param {string} targetId Id of target to find.
         * @return {?Target} The target, if found.
         */

    }, {
        key: 'getTargetById',
        value: function getTargetById(targetId) {
            for (var i = 0; i < this.targets.length; i++) {
                var target = this.targets[i];
                if (target.id === targetId) {
                    return target;
                }
            }
        }

        /**
         * Get the first original (non-clone-block-created) sprite given a name.
         * @param {string} spriteName Name of sprite to look for.
         * @return {?Target} Target representing a sprite of the given name.
         */

    }, {
        key: 'getSpriteTargetByName',
        value: function getSpriteTargetByName(spriteName) {
            for (var i = 0; i < this.targets.length; i++) {
                var target = this.targets[i];
                if (target.sprite && target.sprite.name === spriteName) {
                    return target;
                }
            }
        }

        /**
         * Get a target by its drawable id.
         * @param {number} drawableID drawable id of target to find
         * @return {?Target} The target, if found
         */

    }, {
        key: 'getTargetByDrawableId',
        value: function getTargetByDrawableId(drawableID) {
            for (var i = 0; i < this.targets.length; i++) {
                var target = this.targets[i];
                if (target.drawableID === drawableID) return target;
            }
        }

        /**
         * Update the clone counter to track how many clones are created.
         * @param {number} changeAmount How many clones have been created/destroyed.
         */

    }, {
        key: 'changeCloneCounter',
        value: function changeCloneCounter(changeAmount) {
            this._cloneCounter += changeAmount;
        }

        /**
         * Return whether there are clones available.
         * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.
         */

    }, {
        key: 'clonesAvailable',
        value: function clonesAvailable() {
            return this._cloneCounter < Runtime.MAX_CLONES;
        }

        /**
         * Report that a new target has been created, possibly by cloning an existing target.
         * @param {Target} newTarget - the newly created target.
         * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
         * @fires Runtime#targetWasCreated
         */

    }, {
        key: 'fireTargetWasCreated',
        value: function fireTargetWasCreated(newTarget, sourceTarget) {
            this.emit('targetWasCreated', newTarget, sourceTarget);
        }

        /**
         * Report that a clone target is being removed.
         * @param {Target} target - the target being removed
         * @fires Runtime#targetWasRemoved
         */

    }, {
        key: 'fireTargetWasRemoved',
        value: function fireTargetWasRemoved(target) {
            this.emit('targetWasRemoved', target);
        }

        /**
         * Get a target representing the Scratch stage, if one exists.
         * @return {?Target} The target, if found.
         */

    }, {
        key: 'getTargetForStage',
        value: function getTargetForStage() {
            for (var i = 0; i < this.targets.length; i++) {
                var target = this.targets[i];
                if (target.isStage) {
                    return target;
                }
            }
        }

        /**
         * Get the editing target.
         * @return {?Target} The editing target.
         */

    }, {
        key: 'getEditingTarget',
        value: function getEditingTarget() {
            return this._editingTarget;
        }

        /**
         * Tell the runtime to request a redraw.
         * Use after a clone/sprite has completed some visible operation on the stage.
         */

    }, {
        key: 'requestRedraw',
        value: function requestRedraw() {
            this.redrawRequested = true;
        }

        /**
         * Emit a targets update at the end of the step if the provided target is
         * the original sprite
         * @param {!Target} target Target requesting the targets update
         */

    }, {
        key: 'requestTargetsUpdate',
        value: function requestTargetsUpdate(target) {
            if (!target.isOriginal) return;
            this._refreshTargets = true;
        }

        /**
         * Set up timers to repeatedly step in a browser.
         */

    }, {
        key: 'start',
        value: function start() {
            var _this4 = this;

            var interval = Runtime.THREAD_STEP_INTERVAL;
            if (this.compatibilityMode) {
                interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;
            }
            this.currentStepTime = interval;
            this._steppingInterval = setInterval(function () {
                _this4._step();
            }, interval);
        }

        /**
         * Turn on profiling.
         * @param {Profiler/FrameCallback} onFrame A callback handle passed a
         * profiling frame when the profiler reports its collected data.
         */

    }, {
        key: 'enableProfiling',
        value: function enableProfiling(onFrame) {
            if (Profiler.available()) {
                this.profiler = new Profiler(onFrame);
            }
        }

        /**
         * Turn off profiling.
         */

    }, {
        key: 'disableProfiling',
        value: function disableProfiling() {
            this.profiler = null;
        }
    }], [{
        key: 'STAGE_WIDTH',
        get: function get() {
            return 480;
        }

        /**
         * Height of the stage, in pixels.
         * @const {number}
         */

    }, {
        key: 'STAGE_HEIGHT',
        get: function get() {
            return 360;
        }

        /**
         * Event name for glowing a script.
         * @const {string}
         */

    }, {
        key: 'SCRIPT_GLOW_ON',
        get: function get() {
            return 'SCRIPT_GLOW_ON';
        }

        /**
         * Event name for unglowing a script.
         * @const {string}
         */

    }, {
        key: 'SCRIPT_GLOW_OFF',
        get: function get() {
            return 'SCRIPT_GLOW_OFF';
        }

        /**
         * Event name for glowing a block.
         * @const {string}
         */

    }, {
        key: 'BLOCK_GLOW_ON',
        get: function get() {
            return 'BLOCK_GLOW_ON';
        }

        /**
         * Event name for unglowing a block.
         * @const {string}
         */

    }, {
        key: 'BLOCK_GLOW_OFF',
        get: function get() {
            return 'BLOCK_GLOW_OFF';
        }

        /**
         * Event name when the project is started (threads may not necessarily be
         * running).
         * @const {string}
         */

    }, {
        key: 'PROJECT_START',
        get: function get() {
            return 'PROJECT_START';
        }

        /**
         * Event name when threads start running.
         * Used by the UI to indicate running status.
         * @const {string}
         */

    }, {
        key: 'PROJECT_RUN_START',
        get: function get() {
            return 'PROJECT_RUN_START';
        }

        /**
         * Event name when threads stop running
         * Used by the UI to indicate not-running status.
         * @const {string}
         */

    }, {
        key: 'PROJECT_RUN_STOP',
        get: function get() {
            return 'PROJECT_RUN_STOP';
        }

        /**
         * Event name for project being stopped or restarted by the user.
         * Used by blocks that need to reset state.
         * @const {string}
         */

    }, {
        key: 'PROJECT_STOP_ALL',
        get: function get() {
            return 'PROJECT_STOP_ALL';
        }

        /**
         * Event name for visual value report.
         * @const {string}
         */

    }, {
        key: 'VISUAL_REPORT',
        get: function get() {
            return 'VISUAL_REPORT';
        }

        /**
         * Event name for targets update report.
         * @const {string}
         */

    }, {
        key: 'TARGETS_UPDATE',
        get: function get() {
            return 'TARGETS_UPDATE';
        }

        /**
         * Event name for monitors update.
         * @const {string}
         */

    }, {
        key: 'MONITORS_UPDATE',
        get: function get() {
            return 'MONITORS_UPDATE';
        }

        /**
         * Event name for reporting that an extension was added.
         * @const {string}
         */

    }, {
        key: 'EXTENSION_ADDED',
        get: function get() {
            return 'EXTENSION_ADDED';
        }

        /**
         * How rapidly we try to step threads by default, in ms.
         */

    }, {
        key: 'THREAD_STEP_INTERVAL',
        get: function get() {
            return 1000 / 60;
        }

        /**
         * In compatibility mode, how rapidly we try to step threads, in ms.
         */

    }, {
        key: 'THREAD_STEP_INTERVAL_COMPATIBILITY',
        get: function get() {
            return 1000 / 30;
        }

        /**
         * How many clones can be created at a time.
         * @const {number}
         */

    }, {
        key: 'MAX_CLONES',
        get: function get() {
            return 300;
        }
    }]);

    return Runtime;
}(EventEmitter);

/**
 * Event fired after a new target has been created, possibly by cloning an existing target.
 *
 * @event Runtime#targetWasCreated
 * @param {Target} newTarget - the newly created target.
 * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
 */

module.exports = Runtime;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Timer = __webpack_require__(24);
var Thread = __webpack_require__(17);
var execute = __webpack_require__(73);

/**
 * Profiler frame name for stepping a single thread.
 * @const {string}
 */
var stepThreadProfilerFrame = 'Sequencer.stepThread';

/**
 * Profiler frame name for the inner loop of stepThreads.
 * @const {string}
 */
var stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';

/**
 * Profiler frame name for execute.
 * @const {string}
 */
var executeProfilerFrame = 'execute';

/**
 * Profiler frame ID for stepThreadProfilerFrame.
 * @type {number}
 */
var stepThreadProfilerId = -1;

/**
 * Profiler frame ID for stepThreadsInnerProfilerFrame.
 * @type {number}
 */
var stepThreadsInnerProfilerId = -1;

/**
 * Profiler frame ID for executeProfilerFrame.
 * @type {number}
 */
var executeProfilerId = -1;

var Sequencer = function () {
    function Sequencer(runtime) {
        _classCallCheck(this, Sequencer);

        /**
         * A utility timer for timing thread sequencing.
         * @type {!Timer}
         */
        this.timer = new Timer();

        /**
         * Reference to the runtime owning this sequencer.
         * @type {!Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Time to run a warp-mode thread, in ms.
     * @type {number}
     */


    _createClass(Sequencer, [{
        key: 'stepThreads',


        /**
         * Step through all threads in `this.runtime.threads`, running them in order.
         * @return {Array.<!Thread>} List of inactive threads after stepping.
         */
        value: function stepThreads() {
            // Work time is 75% of the thread stepping interval.
            var WORK_TIME = 0.75 * this.runtime.currentStepTime;
            // Start counting toward WORK_TIME.
            this.timer.start();
            // Count of active threads.
            var numActiveThreads = Infinity;
            // Whether `stepThreads` has run through a full single tick.
            var ranFirstTick = false;
            var doneThreads = this.runtime.threads.map(function () {
                return null;
            });
            // Conditions for continuing to stepping threads:
            // 1. We must have threads in the list, and some must be active.
            // 2. Time elapsed must be less than WORK_TIME.
            // 3. Either turbo mode, or no redraw has been requested by a primitive.
            while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {
                if (this.runtime.profiler !== null) {
                    if (stepThreadsInnerProfilerId === -1) {
                        stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);
                    }
                    this.runtime.profiler.start(stepThreadsInnerProfilerId);
                }

                numActiveThreads = 0;
                // Attempt to run each thread one time.
                for (var i = 0; i < this.runtime.threads.length; i++) {
                    var activeThread = this.runtime.threads[i];
                    if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
                        // Finished with this thread.
                        doneThreads[i] = activeThread;
                        continue;
                    }
                    // A thread was removed, added or this thread was restarted.
                    if (doneThreads[i] !== null) {
                        doneThreads[i] = null;
                    }
                    if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {
                        // Clear single-tick yield from the last call of `stepThreads`.
                        activeThread.status = Thread.STATUS_RUNNING;
                    }
                    if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {
                        // Normal-mode thread: step.
                        if (this.runtime.profiler !== null) {
                            if (stepThreadProfilerId === -1) {
                                stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);
                            }
                            this.runtime.profiler.start(stepThreadProfilerId);
                        }
                        this.stepThread(activeThread);
                        if (this.runtime.profiler !== null) {
                            this.runtime.profiler.stop();
                        }
                        activeThread.warpTimer = null;
                        if (activeThread.isKilled) {
                            i--; // if the thread is removed from the list (killed), do not increase index
                        }
                    }
                    if (activeThread.status === Thread.STATUS_RUNNING) {
                        numActiveThreads++;
                    }
                }
                // We successfully ticked once. Prevents running STATUS_YIELD_TICK
                // threads on the next tick.
                ranFirstTick = true;

                if (this.runtime.profiler !== null) {
                    this.runtime.profiler.stop();
                }
            }
            // Filter inactive threads from `this.runtime.threads`.
            numActiveThreads = 0;
            for (var _i = 0; _i < this.runtime.threads.length; _i++) {
                var thread = this.runtime.threads[_i];
                if (doneThreads[_i] === null) {
                    this.runtime.threads[numActiveThreads] = thread;
                    numActiveThreads++;
                }
            }
            this.runtime.threads.length = numActiveThreads;

            // Filter undefined and null values from `doneThreads`.
            var numDoneThreads = 0;
            for (var _i2 = 0; _i2 < doneThreads.length; _i2++) {
                var maybeThread = doneThreads[_i2];
                if (maybeThread !== null) {
                    doneThreads[numDoneThreads] = maybeThread;
                    numDoneThreads++;
                }
            }
            doneThreads.length = numDoneThreads;

            return doneThreads;
        }

        /**
         * Step the requested thread for as long as necessary.
         * @param {!Thread} thread Thread object to step.
         */

    }, {
        key: 'stepThread',
        value: function stepThread(thread) {
            var currentBlockId = thread.peekStack();
            if (!currentBlockId) {
                // A "null block" - empty branch.
                thread.popStack();
            }
            while (thread.peekStack()) {
                var isWarpMode = thread.peekStackFrame().warpMode;
                if (isWarpMode && !thread.warpTimer) {
                    // Initialize warp-mode timer if it hasn't been already.
                    // This will start counting the thread toward `Sequencer.WARP_TIME`.
                    thread.warpTimer = new Timer();
                    thread.warpTimer.start();
                }
                // Execute the current block.
                // Save the current block ID to notice if we did control flow.
                currentBlockId = thread.peekStack();
                if (this.runtime.profiler !== null) {
                    if (executeProfilerId === -1) {
                        executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);
                    }
                    // The method commented below has its code inlined underneath to
                    // reduce the bias recorded for the profiler's calls in this
                    // time sensitive stepThread method.
                    //
                    // this.runtime.profiler.start(executeProfilerId, null);
                    this.runtime.profiler.records.push(this.runtime.profiler.START, executeProfilerId, null, performance.now());
                }
                execute(this, thread);
                if (this.runtime.profiler !== null) {
                    // this.runtime.profiler.stop();
                    this.runtime.profiler.records.push(this.runtime.profiler.STOP, performance.now());
                }
                thread.blockGlowInFrame = currentBlockId;
                // If the thread has yielded or is waiting, yield to other threads.
                if (thread.status === Thread.STATUS_YIELD) {
                    // Mark as running for next iteration.
                    thread.status = Thread.STATUS_RUNNING;
                    // In warp mode, yielded blocks are re-executed immediately.
                    if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {
                        continue;
                    }
                    return;
                } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {
                    // A promise was returned by the primitive. Yield the thread
                    // until the promise resolves. Promise resolution should reset
                    // thread.status to Thread.STATUS_RUNNING.
                    return;
                }
                // If no control flow has happened, switch to next block.
                if (thread.peekStack() === currentBlockId) {
                    thread.goToNextBlock();
                }
                // If no next block has been found at this point, look on the stack.
                while (!thread.peekStack()) {
                    thread.popStack();

                    if (thread.stack.length === 0) {
                        // No more stack to run!
                        thread.status = Thread.STATUS_DONE;
                        return;
                    }

                    var stackFrame = thread.peekStackFrame();
                    isWarpMode = stackFrame.warpMode;

                    if (stackFrame.isLoop) {
                        // The current level of the stack is marked as a loop.
                        // Return to yield for the frame/tick in general.
                        // Unless we're in warp mode - then only return if the
                        // warp timer is up.
                        if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
                            // Don't do anything to the stack, since loops need
                            // to be re-executed.
                            return;
                        }
                        // Don't go to the next block for this level of the stack,
                        // since loops need to be re-executed.
                        continue;
                    } else if (stackFrame.waitingReporter) {
                        // This level of the stack was waiting for a value.
                        // This means a reporter has just returned - so don't go
                        // to the next block for this level of the stack.
                        return;
                    }
                    // Get next block of existing block on the stack.
                    thread.goToNextBlock();
                }
            }
        }

        /**
         * Step a thread into a block's branch.
         * @param {!Thread} thread Thread object to step to branch.
         * @param {number} branchNum Which branch to step to (i.e., 1, 2).
         * @param {boolean} isLoop Whether this block is a loop.
         */

    }, {
        key: 'stepToBranch',
        value: function stepToBranch(thread, branchNum, isLoop) {
            if (!branchNum) {
                branchNum = 1;
            }
            var currentBlockId = thread.peekStack();
            var branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);
            thread.peekStackFrame().isLoop = isLoop;
            if (branchId) {
                // Push branch ID to the thread's stack.
                thread.pushStack(branchId);
            } else {
                thread.pushStack(null);
            }
        }

        /**
         * Step a procedure.
         * @param {!Thread} thread Thread object to step to procedure.
         * @param {!string} procedureCode Procedure code of procedure to step to.
         */

    }, {
        key: 'stepToProcedure',
        value: function stepToProcedure(thread, procedureCode) {
            var definition = thread.target.blocks.getProcedureDefinition(procedureCode);
            if (!definition) {
                return;
            }
            // Check if the call is recursive.
            // If so, set the thread to yield after pushing.
            var isRecursive = thread.isRecursiveCall(procedureCode);
            // To step to a procedure, we put its definition on the stack.
            // Execution for the thread will proceed through the definition hat
            // and on to the main definition of the procedure.
            // When that set of blocks finishes executing, it will be popped
            // from the stack by the sequencer, returning control to the caller.
            thread.pushStack(definition);
            // In known warp-mode threads, only yield when time is up.
            if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
                thread.status = Thread.STATUS_YIELD;
            } else {
                // Look for warp-mode flag on definition, and set the thread
                // to warp-mode if needed.
                var definitionBlock = thread.target.blocks.getBlock(definition);
                var innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);
                var doWarp = innerBlock.mutation.warp;
                if (doWarp) {
                    thread.peekStackFrame().warpMode = true;
                } else if (isRecursive) {
                    // In normal-mode threads, yield any time we have a recursive call.
                    thread.status = Thread.STATUS_YIELD;
                }
            }
        }

        /**
         * Retire a thread in the middle, without considering further blocks.
         * @param {!Thread} thread Thread object to retire.
         */

    }, {
        key: 'retireThread',
        value: function retireThread(thread) {
            thread.stack = [];
            thread.stackFrame = [];
            thread.requestScriptGlowInFrame = false;
            thread.status = Thread.STATUS_DONE;
        }
    }], [{
        key: 'WARP_TIME',
        get: function get() {
            return 500;
        }
    }]);

    return Sequencer;
}();

module.exports = Sequencer;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = __webpack_require__(4);

var Blocks = __webpack_require__(10);
var Variable = __webpack_require__(18);
var uid = __webpack_require__(28);

var _require = __webpack_require__(25),
    Map = _require.Map;

var log = __webpack_require__(1);

/**
 * @fileoverview
 * A Target is an abstract "code-running" object for the Scratch VM.
 * Examples include sprites/clones or potentially physical-world devices.
 */

var Target = function (_EventEmitter) {
    _inherits(Target, _EventEmitter);

    /**
     * @param {Runtime} runtime Reference to the runtime.
     * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.
     * @constructor
     */
    function Target(runtime, blocks) {
        _classCallCheck(this, Target);

        var _this = _possibleConstructorReturn(this, (Target.__proto__ || Object.getPrototypeOf(Target)).call(this));

        if (!blocks) {
            blocks = new Blocks();
        }

        /**
         * Reference to the runtime.
         * @type {Runtime}
         */
        _this.runtime = runtime;
        /**
         * A unique ID for this target.
         * @type {string}
         */
        _this.id = uid();
        /**
         * Blocks run as code for this target.
         * @type {!Blocks}
         */
        _this.blocks = blocks;
        /**
         * Dictionary of variables and their values for this target.
         * Key is the variable name.
         * @type {Object.<string,*>}
         */
        _this.variables = {};
        /**
         * Dictionary of lists and their contents for this target.
         * Key is the list name.
         * @type {Object.<string,*>}
         */
        _this.lists = {};
        /**
         * Dictionary of custom state for this target.
         * This can be used to store target-specific custom state for blocks which need it.
         * TODO: do we want to persist this in SB3 files?
         * @type {Object.<string,*>}
         */
        _this._customState = {};
        return _this;
    }

    /**
     * Called when the project receives a "green flag."
     * @abstract
     */


    _createClass(Target, [{
        key: 'onGreenFlag',
        value: function onGreenFlag() {}

        /**
         * Return a human-readable name for this target.
         * Target implementations should override this.
         * @abstract
         * @returns {string} Human-readable name for the target.
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this.id;
        }

        /**
         * Look up a variable object, and create it if one doesn't exist.
         * @param {string} id Id of the variable.
         * @param {string} name Name of the variable.
         * @return {!Variable} Variable object.
         */

    }, {
        key: 'lookupOrCreateVariable',
        value: function lookupOrCreateVariable(id, name) {
            var variable = this.lookupVariableById(id);
            if (variable) return variable;
            // No variable with this name exists - create it locally.
            var newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
            this.variables[id] = newVariable;
            return newVariable;
        }

        /**
         * Look up a broadcast message object with the given id and return it
         * if it exists.
         * @param {string} id Id of the variable.
         * @param {string} name Name of the variable.
         * @return {!Variable} Variable object.
         */

    }, {
        key: 'lookupBroadcastMsg',
        value: function lookupBroadcastMsg(id, name) {
            var broadcastMsg = this.lookupVariableById(id);
            if (broadcastMsg) {
                if (broadcastMsg.name !== name) {
                    log.error('Found broadcast message with id: ' + id + ', but' + ('its name, ' + broadcastMsg.name + ' did not match expected name ' + name + '.'));
                }
                if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
                    log.error('Found variable with id: ' + id + ', but its type ' + broadcastMsg.type + ('did not match expected type ' + Variable.BROADCAST_MESSAGE_TYPE));
                }
                return broadcastMsg;
            }
        }

        /**
         * Look up a variable object.
         * Search begins for local variables; then look for globals.
         * @param {string} id Id of the variable.
         * @param {string} name Name of the variable.
         * @return {!Variable} Variable object.
         */

    }, {
        key: 'lookupVariableById',
        value: function lookupVariableById(id) {
            // If we have a local copy, return it.
            if (this.variables.hasOwnProperty(id)) {
                return this.variables[id];
            }
            // If the stage has a global copy, return it.
            if (this.runtime && !this.isStage) {
                var stage = this.runtime.getTargetForStage();
                if (stage.variables.hasOwnProperty(id)) {
                    return stage.variables[id];
                }
            }
        }

        /**
        * Look up a list object for this target, and create it if one doesn't exist.
        * Search begins for local lists; then look for globals.
        * @param {!string} id Id of the list.
        * @param {!string} name Name of the list.
        * @return {!List} List object.
         */

    }, {
        key: 'lookupOrCreateList',
        value: function lookupOrCreateList(id, name) {
            var list = this.lookupVariableById(id);
            if (list) return list;
            // No variable with this name exists - create it locally.
            var newList = new Variable(id, name, Variable.LIST_TYPE, false);
            this.variables[id] = newList;
            return newList;
        }

        /**
         * Creates a variable with the given id and name and adds it to the
         * dictionary of variables.
         * @param {string} id Id of variable
         * @param {string} name Name of variable.
         * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
         */

    }, {
        key: 'createVariable',
        value: function createVariable(id, name, type) {
            if (!this.variables.hasOwnProperty(id)) {
                var newVariable = new Variable(id, name, type, false);
                this.variables[id] = newVariable;
            }
        }

        /**
         * Renames the variable with the given id to newName.
         * @param {string} id Id of renamed variable.
         * @param {string} newName New name for the variable.
         */

    }, {
        key: 'renameVariable',
        value: function renameVariable(id, newName) {
            if (this.variables.hasOwnProperty(id)) {
                var variable = this.variables[id];
                if (variable.id === id) {
                    variable.name = newName;

                    if (this.runtime) {
                        var blocks = this.runtime.monitorBlocks;
                        blocks.changeBlock({
                            id: id,
                            element: 'field',
                            name: 'VARIABLE',
                            value: id
                        }, this.runtime);
                        this.runtime.requestUpdateMonitor(Map({
                            id: id,
                            params: blocks._getBlockParams(blocks.getBlock(variable.id))
                        }));
                    }
                }
            }
        }

        /**
         * Removes the variable with the given id from the dictionary of variables.
         * @param {string} id Id of renamed variable.
         */

    }, {
        key: 'deleteVariable',
        value: function deleteVariable(id) {
            if (this.variables.hasOwnProperty(id)) {
                delete this.variables[id];
                if (this.runtime) {
                    this.runtime.monitorBlocks.deleteBlock(id);
                    this.runtime.requestRemoveMonitor(id);
                }
            }
        }

        /**
         * Post/edit sprite info.
         * @param {object} data An object with sprite info data to set.
         * @abstract
         */

    }, {
        key: 'postSpriteInfo',
        value: function postSpriteInfo() {}

        /**
         * Retrieve custom state associated with this target and the provided state ID.
         * @param {string} stateId - specify which piece of state to retrieve.
         * @returns {*} the associated state, if any was found.
         */

    }, {
        key: 'getCustomState',
        value: function getCustomState(stateId) {
            return this._customState[stateId];
        }

        /**
         * Store custom state associated with this target and the provided state ID.
         * @param {string} stateId - specify which piece of state to store on this target.
         * @param {*} newValue - the state value to store.
         */

    }, {
        key: 'setCustomState',
        value: function setCustomState(stateId, newValue) {
            this._customState[stateId] = newValue;
        }

        /**
         * Call to destroy a target.
         * @abstract
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this._customState = {};
        }
    }]);

    return Target;
}(EventEmitter);

module.exports = Target;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dispatch = __webpack_require__(37);
var log = __webpack_require__(1);

var BlockType = __webpack_require__(11);

// These extensions are currently built into the VM repository but should not be loaded at startup.
// TODO: move these out into a separate repository?
// TODO: change extension spec so that library info, including extension ID, can be collected through static methods
var Scratch3PenBlocks = __webpack_require__(81);
var Scratch3WeDo2Blocks = __webpack_require__(82);
var Scratch3MusicBlocks = __webpack_require__(80);
var builtinExtensions = {
    pen: Scratch3PenBlocks,
    wedo2: Scratch3WeDo2Blocks,
    music: Scratch3MusicBlocks
};

/**
 * @typedef {object} ArgumentInfo - Information about an extension block argument
 * @property {ArgumentType} type - the type of value this argument can take
 * @property {*|undefined} default - the default value of this argument (default: blank)
 */

/**
 * @typedef {object} BlockInfo - Information about an extension block
 * @property {string} opcode - the block opcode
 * @property {string|object} text - the human-readable text on this block
 * @property {BlockType|undefined} blockType - the type of block (default: BlockType.COMMAND)
 * @property {int|undefined} branchCount - the number of branches this block controls, if conditional (default: 0)
 * @property {Boolean|undefined} isTerminal - true if this block ends a stack (default: false)
 * @property {Boolean|undefined} blockAllThreads - true if all threads must wait for this block to run (default: false)
 * @property {object.<string,ArgumentInfo>|undefined} arguments - information about this block's arguments, if any
 * @property {string|Function|undefined} func - the method for this block on the extension service (default: opcode)
 * @property {Array.<string>|undefined} filter - the list of targets for which this block should appear (default: all)
 * @property {Boolean|undefined} hideFromPalette - true if should not be appear in the palette. (default false)
 */

/**
 * @typedef {object} CategoryInfo - Information about a block category
 * @property {string} id - the unique ID of this category
 * @property {string} color1 - the primary color for this category, in '#rrggbb' format
 * @property {string} color2 - the secondary color for this category, in '#rrggbb' format
 * @property {string} color3 - the tertiary color for this category, in '#rrggbb' format
 * @property {Array.<BlockInfo>} block - the blocks in this category
 */

/**
 * @typedef {object} PendingExtensionWorker - Information about an extension worker still initializing
 * @property {string} extensionURL - the URL of the extension to be loaded by this worker
 * @property {Function} resolve - function to call on successful worker startup
 * @property {Function} reject - function to call on failed worker startup
 */

var ExtensionManager = function () {
    function ExtensionManager(runtime) {
        _classCallCheck(this, ExtensionManager);

        /**
         * The ID number to provide to the next extension worker.
         * @type {int}
         */
        this.nextExtensionWorker = 0;

        /**
         * FIFO queue of extensions which have been requested but not yet loaded in a worker,
         * along with promise resolution functions to call once the worker is ready or failed.
         *
         * @type {Array.<PendingExtensionWorker>}
         */
        this.pendingExtensions = [];

        /**
         * Map of worker ID to workers which have been allocated but have not yet finished initialization.
         * @type {Array.<PendingExtensionWorker>}
         */
        this.pendingWorkers = [];

        /**
         * Set of loaded extension URLs/IDs (equivalent for built-in extensions).
         * @type {Set.<string>}
         * @private
         */
        this._loadedExtensions = new Set();

        /**
         * Keep a reference to the runtime so we can construct internal extension objects.
         * TODO: remove this in favor of extensions accessing the runtime as a service.
         * @type {Runtime}
         */
        this.runtime = runtime;

        dispatch.setService('extensions', this).catch(function (e) {
            log.error('ExtensionManager was unable to register extension service: ' + JSON.stringify(e));
        });
    }

    /**
     * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
     * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
     * `loadExtensionURL` if you need to wait until the extension is truly ready.
     * @param {string} extensionID - the ID of the extension.
     * @returns {boolean} - true if loaded, false otherwise.
     */


    _createClass(ExtensionManager, [{
        key: 'isExtensionLoaded',
        value: function isExtensionLoaded(extensionID) {
            return this._loadedExtensions.has(extensionID);
        }

        /**
         * Load an extension by URL or internal extension ID
         * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
         * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
         */

    }, {
        key: 'loadExtensionURL',
        value: function loadExtensionURL(extensionURL) {
            var _this = this;

            if (builtinExtensions.hasOwnProperty(extensionURL)) {
                /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
                if (this.isExtensionLoaded(extensionURL)) {
                    var message = 'Rejecting attempt to load a second extension with ID ' + extensionURL;
                    log.warn(message);
                    return Promise.reject(new Error(message));
                }

                var extension = builtinExtensions[extensionURL];
                var extensionInstance = new extension(this.runtime);
                return this._registerInternalExtension(extensionInstance).then(function () {
                    _this._loadedExtensions.add(extensionURL);
                });
            }

            return new Promise(function (resolve, reject) {
                // If we `require` this at the global level it breaks non-webpack targets, including tests
                var ExtensionWorker = __webpack_require__(146);

                _this.pendingExtensions.push({ extensionURL: extensionURL, resolve: resolve, reject: reject });
                dispatch.addWorker(new ExtensionWorker());
            });
        }
    }, {
        key: 'allocateWorker',
        value: function allocateWorker() {
            var id = this.nextExtensionWorker++;
            var workerInfo = this.pendingExtensions.shift();
            this.pendingWorkers[id] = workerInfo;
            return [id, workerInfo.extensionURL];
        }

        /**
         * Collect extension metadata from the specified service and begin the extension registration process.
         * @param {string} serviceName - the name of the service hosting the extension.
         */

    }, {
        key: 'registerExtensionService',
        value: function registerExtensionService(serviceName) {
            var _this2 = this;

            dispatch.call(serviceName, 'getInfo').then(function (info) {
                _this2._registerExtensionInfo(serviceName, info);
            });
        }

        /**
         * Called by an extension worker to indicate that the worker has finished initialization.
         * @param {int} id - the worker ID.
         * @param {*?} e - the error encountered during initialization, if any.
         */

    }, {
        key: 'onWorkerInit',
        value: function onWorkerInit(id, e) {
            var workerInfo = this.pendingWorkers[id];
            delete this.pendingWorkers[id];
            if (e) {
                workerInfo.reject(e);
            } else {
                workerInfo.resolve(id);
            }
        }

        /**
         * Register an internal (non-Worker) extension object
         * @param {object} extensionObject - the extension object to register
         * @returns {Promise} resolved once the extension is fully registered or rejected on failure
         */

    }, {
        key: '_registerInternalExtension',
        value: function _registerInternalExtension(extensionObject) {
            var extensionInfo = extensionObject.getInfo();
            var fakeWorkerId = this.nextExtensionWorker++;
            var serviceName = 'extension.' + fakeWorkerId + '.' + extensionInfo.id;
            return dispatch.setService(serviceName, extensionObject).then(function () {
                return dispatch.call('extensions', 'registerExtensionService', serviceName);
            });
        }

        /**
         * Sanitize extension info then register its primitives with the VM.
         * @param {string} serviceName - the name of the service hosting the extension
         * @param {ExtensionInfo} extensionInfo - the extension's metadata
         * @private
         */

    }, {
        key: '_registerExtensionInfo',
        value: function _registerExtensionInfo(serviceName, extensionInfo) {
            extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
            dispatch.call('runtime', '_registerExtensionPrimitives', extensionInfo).catch(function (e) {
                log.error('Failed to register primitives for extension on service ' + serviceName + ': ' + JSON.stringify(e));
            });
        }

        /**
         * Modify the provided text as necessary to ensure that it may be used as an attribute value in valid XML.
         * @param {string} text - the text to be sanitized
         * @returns {string} - the sanitized text
         * @private
         */

    }, {
        key: '_sanitizeID',
        value: function _sanitizeID(text) {
            return text.toString().replace(/[<"&]/, '_');
        }

        /**
         * Apply minor cleanup and defaults for optional extension fields.
         * TODO: make the ID unique in cases where two copies of the same extension are loaded.
         * @param {string} serviceName - the name of the service hosting this extension block
         * @param {ExtensionInfo} extensionInfo - the extension info to be sanitized
         * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
         * @private
         */

    }, {
        key: '_prepareExtensionInfo',
        value: function _prepareExtensionInfo(serviceName, extensionInfo) {
            var _this3 = this;

            extensionInfo = Object.assign({}, extensionInfo);
            extensionInfo.id = this._sanitizeID(extensionInfo.id);
            extensionInfo.name = extensionInfo.name || extensionInfo.id;
            extensionInfo.blocks = extensionInfo.blocks || [];
            extensionInfo.targetTypes = extensionInfo.targetTypes || [];
            extensionInfo.blocks = extensionInfo.blocks.reduce(function (result, blockInfo) {
                try {
                    result.push(_this3._prepareBlockInfo(serviceName, blockInfo));
                } catch (e) {
                    // TODO: more meaningful error reporting
                    log.error('Error processing block: ' + e.message + ', Block:\n' + JSON.stringify(blockInfo));
                }
                return result;
            }, []);
            return extensionInfo;
        }

        /**
         * Apply defaults for optional block fields.
         * @param {string} serviceName - the name of the service hosting this extension block
         * @param {BlockInfo} blockInfo - the block info from the extension
         * @returns {BlockInfo} - a new block info object which has values for all relevant optional fields.
         * @private
         */

    }, {
        key: '_prepareBlockInfo',
        value: function _prepareBlockInfo(serviceName, blockInfo) {
            blockInfo = Object.assign({}, {
                blockType: BlockType.COMMAND,
                terminal: false,
                blockAllThreads: false,
                arguments: {}
            }, blockInfo);
            blockInfo.opcode = this._sanitizeID(blockInfo.opcode);
            blockInfo.func = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
            blockInfo.text = blockInfo.text || blockInfo.opcode;

            /**
             * This is only here because the VM performs poorly when blocks return promises.
             * @TODO make it possible for the VM to resolve a promise and continue during the same frame.
             */
            if (dispatch._isRemoteService(serviceName)) {
                blockInfo.func = dispatch.call.bind(dispatch, serviceName, blockInfo.func);
            } else {
                var serviceObject = dispatch.services[serviceName];
                blockInfo.func = serviceObject[blockInfo.func].bind(serviceObject);
            }
            return blockInfo;
        }
    }]);

    return ExtensionManager;
}();

module.exports = ExtensionManager;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArgumentType = __webpack_require__(19);
var BlockType = __webpack_require__(11);
var Clone = __webpack_require__(12);
var Cast = __webpack_require__(2);
var MathUtil = __webpack_require__(6);
var Timer = __webpack_require__(24);

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
var iconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=';

/**
 * Class for the music-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

var Scratch3MusicBlocks = function () {
    function Scratch3MusicBlocks(runtime) {
        _classCallCheck(this, Scratch3MusicBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The current tempo in beats per minute. The tempo is a global property of the project,
         * not a property of each sprite, so it is not stored in the MusicState object.
         * @type {number}
         */
        this.tempo = 60;

        /**
         * The number of drum and instrument sounds currently being played simultaneously.
         * @type {number}
         * @private
         */
        this._concurrencyCounter = 0;

        /**
         * An array of audio buffers, one for each drum sound.
         * @type {Array}
         * @private
         */
        this._drumBuffers = [];

        /**
         * An array of arrays of audio buffers. Each instrument has one or more audio buffers.
         * @type {Array[]}
         * @private
         */
        this._instrumentBufferArrays = [];

        this._loadAllSounds();
    }

    /**
     * Download and decode the full set of drum and instrument sounds, and
     * store the audio buffers in arrays.
     */


    _createClass(Scratch3MusicBlocks, [{
        key: '_loadAllSounds',
        value: function _loadAllSounds() {
            var _this = this;

            var loadingPromises = [];
            this.DRUM_INFO.forEach(function (drumInfo, index) {
                var fileName = 'drums/' + drumInfo.fileName;
                var promise = _this._loadSound(fileName, index, _this._drumBuffers);
                loadingPromises.push(promise);
            });
            this.INSTRUMENT_INFO.forEach(function (instrumentInfo, instrumentIndex) {
                _this._instrumentBufferArrays[instrumentIndex] = [];
                instrumentInfo.samples.forEach(function (sample, noteIndex) {
                    var fileName = 'instruments/' + instrumentInfo.dirName + '/' + sample;
                    var promise = _this._loadSound(fileName, noteIndex, _this._instrumentBufferArrays[instrumentIndex]);
                    loadingPromises.push(promise);
                });
            });
            Promise.all(loadingPromises).then(function () {
                // @TODO: Update the extension status indicator.
            });
        }

        /**
         * Download and decode a sound, and store the buffer in an array.
         * @param {string} fileName - the audio file name.
         * @param {number} index - the index at which to store the audio buffer.
         * @param {array} bufferArray - the array of buffers in which to store it.
         * @return {Promise} - a promise which will resolve once the sound has loaded.
         */

    }, {
        key: '_loadSound',
        value: function _loadSound(fileName, index, bufferArray) {
            var _this2 = this;

            if (!this.runtime.storage) return;
            if (!this.runtime.audioEngine) return;
            return this.runtime.storage.load(this.runtime.storage.AssetType.Sound, fileName, 'mp3').then(function (soundAsset) {
                return _this2.runtime.audioEngine.audioContext.decodeAudioData(soundAsset.data.buffer);
            }).then(function (buffer) {
                bufferArray[index] = buffer;
            });
        }

        /**
         * Create data for a menu in scratch-blocks format, consisting of an array of objects with text and
         * value properties. The text is a translated string, and the value is one-indexed.
         * @param  {object[]} info - An array of info objects each having a name property.
         * @return {array} - An array of objects with text and value properties.
         * @private
         */

    }, {
        key: '_buildMenu',
        value: function _buildMenu(info) {
            return info.map(function (entry, index) {
                var obj = {};
                obj.text = entry.name;
                obj.value = String(index + 1);
                return obj;
            });
        }

        /**
         * An array of info about each drum.
         * @type {object[]} an array of objects.
         * @param {string} name - the translatable name to display in the drums menu.
         * @param {string} fileName - the name of the audio file containing the drum sound.
         */

    }, {
        key: '_getMusicState',


        /**
         * @param {Target} target - collect music state for this target.
         * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.
         * @private
         */
        value: function _getMusicState(target) {
            var musicState = target.getCustomState(Scratch3MusicBlocks.STATE_KEY);
            if (!musicState) {
                musicState = Clone.simple(Scratch3MusicBlocks.DEFAULT_MUSIC_STATE);
                target.setCustomState(Scratch3MusicBlocks.STATE_KEY, musicState);
            }
            return musicState;
        }

        /**
         * @returns {object} metadata for this extension and its blocks.
         */

    }, {
        key: 'getInfo',
        value: function getInfo() {
            return {
                id: 'music',
                name: 'Music',
                iconURI: iconURI,
                blocks: [{
                    opcode: 'playDrumForBeats',
                    blockType: BlockType.COMMAND,
                    text: 'play drum [DRUM] for [BEATS] beats',
                    arguments: {
                        DRUM: {
                            type: ArgumentType.NUMBER,
                            menu: 'drums',
                            defaultValue: 1
                        },
                        BEATS: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0.25
                        }
                    }
                }, {
                    opcode: 'restForBeats',
                    blockType: BlockType.COMMAND,
                    text: 'rest for [BEATS] beats',
                    arguments: {
                        BEATS: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0.25
                        }
                    }
                }, {
                    opcode: 'playNoteForBeats',
                    blockType: BlockType.COMMAND,
                    text: 'play note [NOTE] for [BEATS] beats',
                    arguments: {
                        NOTE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 60
                        },
                        BEATS: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0.25
                        }
                    }
                }, {
                    opcode: 'setInstrument',
                    blockType: BlockType.COMMAND,
                    text: 'set instrument to [INSTRUMENT]',
                    arguments: {
                        INSTRUMENT: {
                            type: ArgumentType.NUMBER,
                            menu: 'instruments',
                            defaultValue: 1
                        }
                    }
                }, {
                    opcode: 'setTempo',
                    blockType: BlockType.COMMAND,
                    text: 'set tempo to [TEMPO]',
                    arguments: {
                        TEMPO: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 60
                        }
                    }
                }, {
                    opcode: 'changeTempo',
                    blockType: BlockType.COMMAND,
                    text: 'change tempo by [TEMPO]',
                    arguments: {
                        TEMPO: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 20
                        }
                    }
                }, {
                    opcode: 'getTempo',
                    text: 'tempo',
                    blockType: BlockType.REPORTER
                }],
                menus: {
                    drums: this._buildMenu(this.DRUM_INFO),
                    instruments: this._buildMenu(this.INSTRUMENT_INFO)
                }
            };
        }

        /**
         * Play a drum sound for some number of beats.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         * @property {int} DRUM - the number of the drum to play.
         * @property {number} BEATS - the duration in beats of the drum sound.
         */

    }, {
        key: 'playDrumForBeats',
        value: function playDrumForBeats(args, util) {
            if (this._stackTimerNeedsInit(util)) {
                var drum = Cast.toNumber(args.DRUM);
                drum = Math.round(drum);
                drum -= 1; // drums are one-indexed
                drum = MathUtil.wrapClamp(drum, 0, this.DRUM_INFO.length - 1);
                var beats = Cast.toNumber(args.BEATS);
                beats = this._clampBeats(beats);
                this._playDrumNum(util, drum);
                this._startStackTimer(util, this._beatsToSec(beats));
            } else {
                this._checkStackTimer(util);
            }
        }

        /**
         * Play a drum sound using its 0-indexed number.
         * @param {object} util - utility object provided by the runtime.
         * @param  {number} drumNum - the number of the drum to play.
         * @private
         */

    }, {
        key: '_playDrumNum',
        value: function _playDrumNum(util, drumNum) {
            var _this3 = this;

            if (util.runtime.audioEngine === null) return;
            if (util.target.audioPlayer === null) return;
            // If we're playing too many sounds, do not play the drum sound.
            if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
                return;
            }
            var outputNode = util.target.audioPlayer.getInputNode();
            var context = util.runtime.audioEngine.audioContext;
            var bufferSource = context.createBufferSource();
            bufferSource.buffer = this._drumBuffers[drumNum];
            bufferSource.connect(outputNode);
            bufferSource.start();
            this._concurrencyCounter++;
            bufferSource.onended = function () {
                _this3._concurrencyCounter--;
            };
        }

        /**
         * Rest for some number of beats.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         * @property {number} BEATS - the duration in beats of the rest.
         */

    }, {
        key: 'restForBeats',
        value: function restForBeats(args, util) {
            if (this._stackTimerNeedsInit(util)) {
                var beats = Cast.toNumber(args.BEATS);
                beats = this._clampBeats(beats);
                this._startStackTimer(util, this._beatsToSec(beats));
            } else {
                this._checkStackTimer(util);
            }
        }

        /**
         * Play a note using the current musical instrument for some number of beats.
         * This function processes the arguments, and handles the timing of the block's execution.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.
         * @property {number} BEATS - the duration in beats of the note.
         */

    }, {
        key: 'playNoteForBeats',
        value: function playNoteForBeats(args, util) {
            if (this._stackTimerNeedsInit(util)) {
                var note = Cast.toNumber(args.NOTE);
                note = MathUtil.clamp(note, Scratch3MusicBlocks.MIDI_NOTE_RANGE.min, Scratch3MusicBlocks.MIDI_NOTE_RANGE.max);
                var beats = Cast.toNumber(args.BEATS);
                beats = this._clampBeats(beats);
                // If the duration is 0, do not play the note. In Scratch 2.0, "play drum for 0 beats" plays the drum,
                // but "play note for 0 beats" is silent.
                if (beats === 0) return;

                var durationSec = this._beatsToSec(beats);

                this._playNote(util, note, durationSec);

                this._startStackTimer(util, durationSec);
            } else {
                this._checkStackTimer(util);
            }
        }

        /**
         * Play a note using the current instrument for a duration in seconds.
         * This function actually plays the sound, and handles the timing of the sound, including the
         * "release" portion of the sound, which continues briefly after the block execution has finished.
         * @param {object} util - utility object provided by the runtime.
         * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.
         * @param {number} durationSec - the duration in seconds to play the note.
         * @private
         */

    }, {
        key: '_playNote',
        value: function _playNote(util, note, durationSec) {
            var _this4 = this;

            if (util.runtime.audioEngine === null) return;
            if (util.target.audioPlayer === null) return;

            // If we're playing too many sounds, do not play the note.
            if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
                return;
            }

            // Determine which of the audio samples for this instrument to play
            var musicState = this._getMusicState(util.target);
            var inst = musicState.currentInstrument;
            var instrumentInfo = this.INSTRUMENT_INFO[inst];
            var sampleArray = instrumentInfo.samples;
            var sampleIndex = this._selectSampleIndexForNote(note, sampleArray);

            // If the audio sample has not loaded yet, bail out
            if (typeof this._instrumentBufferArrays[inst] === 'undefined') return;
            if (typeof this._instrumentBufferArrays[inst][sampleIndex] === 'undefined') return;

            // Create the audio buffer to play the note, and set its pitch
            var context = util.runtime.audioEngine.audioContext;
            var bufferSource = context.createBufferSource();
            bufferSource.buffer = this._instrumentBufferArrays[inst][sampleIndex];
            var sampleNote = sampleArray[sampleIndex];
            bufferSource.playbackRate.value = this._ratioForPitchInterval(note - sampleNote);

            // Create a gain node for this note, and connect it to the sprite's audioPlayer.
            var gainNode = context.createGain();
            bufferSource.connect(gainNode);
            var outputNode = util.target.audioPlayer.getInputNode();
            gainNode.connect(outputNode);

            // Start playing the note
            bufferSource.start();

            // Schedule the release of the note, ramping its gain down to zero,
            // and then stopping the sound.
            var releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;
            if (typeof releaseDuration === 'undefined') {
                releaseDuration = 0.01;
            }
            var releaseStart = context.currentTime + durationSec;
            var releaseEnd = releaseStart + releaseDuration;
            gainNode.gain.setValueAtTime(1, releaseStart);
            gainNode.gain.linearRampToValueAtTime(0.0001, releaseEnd);
            bufferSource.stop(releaseEnd);

            // Update the concurrency counter
            this._concurrencyCounter++;
            bufferSource.onended = function () {
                _this4._concurrencyCounter--;
            };
        }

        /**
         * The samples array for each instrument is the set of pitches of the available audio samples.
         * This function selects the best one to use to play a given input note, and returns its index
         * in the samples array.
         * @param  {number} note - the input note to select a sample for.
         * @param  {number[]} samples - an array of the pitches of the available samples.
         * @return {index} the index of the selected sample in the samples array.
         * @private
         */

    }, {
        key: '_selectSampleIndexForNote',
        value: function _selectSampleIndexForNote(note, samples) {
            // Step backwards through the array of samples, i.e. in descending pitch, in order to find
            // the sample that is the closest one below (or matching) the pitch of the input note.
            for (var i = samples.length - 1; i >= 0; i--) {
                if (note >= samples[i]) {
                    return i;
                }
            }
            return 0;
        }

        /**
         * Calcuate the frequency ratio for a given musical interval.
         * @param  {number} interval - the pitch interval to convert.
         * @return {number} a ratio corresponding to the input interval.
         * @private
         */

    }, {
        key: '_ratioForPitchInterval',
        value: function _ratioForPitchInterval(interval) {
            return Math.pow(2, interval / 12);
        }

        /**
         * Clamp a duration in beats to the allowed min and max duration.
         * @param  {number} beats - a duration in beats.
         * @return {number} - the clamped duration.
         * @private
         */

    }, {
        key: '_clampBeats',
        value: function _clampBeats(beats) {
            return MathUtil.clamp(beats, Scratch3MusicBlocks.BEAT_RANGE.min, Scratch3MusicBlocks.BEAT_RANGE.max);
        }

        /**
         * Convert a number of beats to a number of seconds, using the current tempo.
         * @param  {number} beats - number of beats to convert to secs.
         * @return {number} seconds - number of seconds `beats` will last.
         * @private
         */

    }, {
        key: '_beatsToSec',
        value: function _beatsToSec(beats) {
            return 60 / this.tempo * beats;
        }

        /**
         * Check if the stack timer needs initialization.
         * @param {object} util - utility object provided by the runtime.
         * @return {boolean} - true if the stack timer needs to be initialized.
         * @private
         */

    }, {
        key: '_stackTimerNeedsInit',
        value: function _stackTimerNeedsInit(util) {
            return !util.stackFrame.timer;
        }

        /**
         * Start the stack timer and the yield the thread if necessary.
         * @param {object} util - utility object provided by the runtime.
         * @param {number} duration - a duration in seconds to set the timer for.
         * @private
         */

    }, {
        key: '_startStackTimer',
        value: function _startStackTimer(util, duration) {
            util.stackFrame.timer = new Timer();
            util.stackFrame.timer.start();
            util.stackFrame.duration = duration;
            util.yield();
        }

        /**
         * Check the stack timer, and if its time is not up yet, yield the thread.
         * @param {object} util - utility object provided by the runtime.
         * @private
         */

    }, {
        key: '_checkStackTimer',
        value: function _checkStackTimer(util) {
            var timeElapsed = util.stackFrame.timer.timeElapsed();
            if (timeElapsed < util.stackFrame.duration * 1000) {
                util.yield();
            }
        }

        /**
         * Select an instrument for playing notes.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         * @property {int} INSTRUMENT - the number of the instrument to select.
         */

    }, {
        key: 'setInstrument',
        value: function setInstrument(args, util) {
            var musicState = this._getMusicState(util.target);
            var instNum = Cast.toNumber(args.INSTRUMENT);
            instNum = Math.round(instNum);
            instNum -= 1; // instruments are one-indexed
            instNum = MathUtil.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);
            musicState.currentInstrument = instNum;
        }

        /**
         * Set the current tempo to a new value.
         * @param {object} args - the block arguments.
         * @property {number} TEMPO - the tempo, in beats per minute.
         */

    }, {
        key: 'setTempo',
        value: function setTempo(args) {
            var tempo = Cast.toNumber(args.TEMPO);
            this._updateTempo(tempo);
        }

        /**
         * Change the current tempo by some amount.
         * @param {object} args - the block arguments.
         * @property {number} TEMPO - the amount to change the tempo, in beats per minute.
         */

    }, {
        key: 'changeTempo',
        value: function changeTempo(args) {
            var change = Cast.toNumber(args.TEMPO);
            var tempo = change + this.tempo;
            this._updateTempo(tempo);
        }

        /**
         * Update the current tempo, clamping it to the min and max allowable range.
         * @param {number} tempo - the tempo to set, in beats per minute.
         * @private
         */

    }, {
        key: '_updateTempo',
        value: function _updateTempo(tempo) {
            tempo = MathUtil.clamp(tempo, Scratch3MusicBlocks.TEMPO_RANGE.min, Scratch3MusicBlocks.TEMPO_RANGE.max);
            this.tempo = tempo;
        }

        /**
         * Get the current tempo.
         * @return {number} - the current tempo, in beats per minute.
         */

    }, {
        key: 'getTempo',
        value: function getTempo() {
            return this.tempo;
        }
    }, {
        key: 'DRUM_INFO',
        get: function get() {
            return [{
                name: '(1) Snare Drum',
                fileName: '1-snare'
            }, {
                name: '(2) Bass Drum',
                fileName: '2-bass-drum'
            }, {
                name: '(3) Side Stick',
                fileName: '3-side-stick'
            }, {
                name: '(4) Crash Cymbal',
                fileName: '4-crash-cymbal'
            }, {
                name: '(5) Open Hi-Hat',
                fileName: '5-open-hi-hat'
            }, {
                name: '(6) Closed Hi-Hat',
                fileName: '6-closed-hi-hat'
            }, {
                name: '(7) Tambourine',
                fileName: '7-tambourine'
            }, {
                name: '(8) Hand Clap',
                fileName: '8-hand-clap'
            }, {
                name: '(9) Claves',
                fileName: '9-claves'
            }, {
                name: '(10) Wood Block',
                fileName: '10-wood-block'
            }, {
                name: '(11) Cowbell',
                fileName: '11-cowbell'
            }, {
                name: '(12) Triangle',
                fileName: '12-triangle'
            }, {
                name: '(13) Bongo',
                fileName: '13-bongo'
            }, {
                name: '(14) Conga',
                fileName: '14-conga'
            }, {
                name: '(15) Cabasa',
                fileName: '15-cabasa'
            }, {
                name: '(16) Guiro',
                fileName: '16-guiro'
            }, {
                name: '(17) Vibraslap',
                fileName: '17-vibraslap'
            }, {
                name: '(18) Cuica',
                fileName: '18-cuica'
            }];
        }

        /**
         * An array of info about each instrument.
         * @type {object[]} an array of objects.
         * @param {string} name - the translatable name to display in the instruments menu.
         * @param {string} dirName - the name of the directory containing audio samples for this instrument.
         * @param {number} [releaseTime] - an optional duration for the release portion of each note.
         * @param {number[]} samples - an array of numbers representing the MIDI note number for each
         *                           sampled sound used to play this instrument.
         */

    }, {
        key: 'INSTRUMENT_INFO',
        get: function get() {
            return [{
                name: '(1) Piano',
                dirName: '1-piano',
                releaseTime: 0.5,
                samples: [24, 36, 48, 60, 72, 84, 96, 108]
            }, {
                name: '(2) Electric Piano',
                dirName: '2-electric-piano',
                releaseTime: 0.5,
                samples: [60]
            }, {
                name: '(3) Organ',
                dirName: '3-organ',
                releaseTime: 0.5,
                samples: [60]
            }, {
                name: '(4) Guitar',
                dirName: '4-guitar',
                releaseTime: 0.5,
                samples: [60]
            }, {
                name: '(5) Electric Guitar',
                dirName: '5-electric-guitar',
                releaseTime: 0.5,
                samples: [60]
            }, {
                name: '(6) Bass',
                dirName: '6-bass',
                releaseTime: 0.25,
                samples: [36, 48]
            }, {
                name: '(7) Pizzicato',
                dirName: '7-pizzicato',
                releaseTime: 0.25,
                samples: [60]
            }, {
                name: '(8) Cello',
                dirName: '8-cello',
                releaseTime: 0.1,
                samples: [36, 48, 60]
            }, {
                name: '(9) Trombone',
                dirName: '9-trombone',
                samples: [36, 48, 60]
            }, {
                name: '(10) Clarinet',
                dirName: '10-clarinet',
                samples: [48, 60]
            }, {
                name: '(11) Saxophone',
                dirName: '11-saxophone',
                samples: [36, 60, 84]
            }, {
                name: '(12) Flute',
                dirName: '12-flute',
                samples: [60, 72]
            }, {
                name: '(13) Wooden Flute',
                dirName: '13-wooden-flute',
                samples: [60, 72]
            }, {
                name: '(14) Bassoon',
                dirName: '14-bassoon',
                samples: [36, 48, 60]
            }, {
                name: '(15) Choir',
                dirName: '15-choir',
                releaseTime: 0.25,
                samples: [48, 60, 72]
            }, {
                name: '(16) Vibraphone',
                dirName: '16-vibraphone',
                releaseTime: 0.5,
                samples: [60, 72]
            }, {
                name: '(17) Music Box',
                dirName: '17-music-box',
                releaseTime: 0.25,
                samples: [60]
            }, {
                name: '(18) Steel Drum',
                dirName: '18-steel-drum',
                releaseTime: 0.5,
                samples: [60]
            }, {
                name: '(19) Marimba',
                dirName: '19-marimba',
                samples: [60]
            }, {
                name: '(20) Synth Lead',
                dirName: '20-synth-lead',
                releaseTime: 0.1,
                samples: [60]
            }, {
                name: '(21) Synth Pad',
                dirName: '21-synth-pad',
                releaseTime: 0.25,
                samples: [60]
            }];
        }

        /**
         * The key to load & store a target's music-related state.
         * @type {string}
         */

    }], [{
        key: 'STATE_KEY',
        get: function get() {
            return 'Scratch.music';
        }

        /**
         * The default music-related state, to be used when a target has no existing music state.
         * @type {MusicState}
         */

    }, {
        key: 'DEFAULT_MUSIC_STATE',
        get: function get() {
            return {
                currentInstrument: 0
            };
        }

        /**
         * The minimum and maximum MIDI note numbers, for clamping the input to play note.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'MIDI_NOTE_RANGE',
        get: function get() {
            return { min: 0, max: 130 };
        }

        /**
         * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
         * 100 beats at the default tempo of 60bpm is 100 seconds.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'BEAT_RANGE',
        get: function get() {
            return { min: 0, max: 100 };
        }

        /** The minimum and maximum tempo values, in bpm.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'TEMPO_RANGE',
        get: function get() {
            return { min: 20, max: 500 };
        }

        /**
         * The maximum number of sounds to allow to play simultaneously.
         * @type {number}
         */

    }, {
        key: 'CONCURRENCY_LIMIT',
        get: function get() {
            return 30;
        }
    }]);

    return Scratch3MusicBlocks;
}();

module.exports = Scratch3MusicBlocks;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArgumentType = __webpack_require__(19);
var BlockType = __webpack_require__(11);
var Cast = __webpack_require__(2);
var Clone = __webpack_require__(12);
var Color = __webpack_require__(23);
var MathUtil = __webpack_require__(6);
var RenderedTarget = __webpack_require__(22);
var log = __webpack_require__(1);

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
var iconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==';

/**
 * Enum for pen color parameters.
 * @readonly
 * @enum {string}
 */
var ColorParam = {
    COLOR: 'color',
    SATURATION: 'saturation',
    BRIGHTNESS: 'brightness',
    TRANSPARENCY: 'transparency'
};

/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

var Scratch3PenBlocks = function () {
    function Scratch3PenBlocks(runtime) {
        _classCallCheck(this, Scratch3PenBlocks);

        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The ID of the renderer Drawable corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penDrawableId = -1;

        /**
         * The ID of the renderer Skin corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penSkinId = -1;

        this._onTargetCreated = this._onTargetCreated.bind(this);
        this._onTargetMoved = this._onTargetMoved.bind(this);

        runtime.on('targetWasCreated', this._onTargetCreated);
    }

    /**
     * The default pen state, to be used when a target has no existing pen state.
     * @type {PenState}
     */


    _createClass(Scratch3PenBlocks, [{
        key: '_clampPenSize',


        /**
         * Clamp a pen size value to the range allowed by the pen.
         * @param {number} requestedSize - the requested pen size.
         * @returns {number} the clamped size.
         * @private
         */
        value: function _clampPenSize(requestedSize) {
            return MathUtil.clamp(requestedSize, Scratch3PenBlocks.PEN_SIZE_RANGE.min, Scratch3PenBlocks.PEN_SIZE_RANGE.max);
        }

        /**
         * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
         * the pen Skin doesn't yet exist, create it.
         * @returns {int} the Skin ID of the pen layer, or -1 on failure.
         * @private
         */

    }, {
        key: '_getPenLayerID',
        value: function _getPenLayerID() {
            if (this._penSkinId < 0 && this.runtime.renderer) {
                this._penSkinId = this.runtime.renderer.createPenSkin();
                this._penDrawableId = this.runtime.renderer.createDrawable();
                this.runtime.renderer.setDrawableOrder(this._penDrawableId, Scratch3PenBlocks.PEN_ORDER);
                this.runtime.renderer.updateDrawableProperties(this._penDrawableId, { skinId: this._penSkinId });
            }
            return this._penSkinId;
        }

        /**
         * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
         * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
         * @private
         */

    }, {
        key: '_getPenState',
        value: function _getPenState(target) {
            var penState = target.getCustomState(Scratch3PenBlocks.STATE_KEY);
            if (!penState) {
                penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);
                target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);
            }
            return penState;
        }

        /**
         * When a pen-using Target is cloned, clone the pen state.
         * @param {Target} newTarget - the newly created target.
         * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
         * @listens Runtime#event:targetWasCreated
         * @private
         */

    }, {
        key: '_onTargetCreated',
        value: function _onTargetCreated(newTarget, sourceTarget) {
            if (sourceTarget) {
                var penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);
                if (penState) {
                    newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));
                    if (penState.penDown) {
                        newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
                    }
                }
            }
        }

        /**
         * Handle a target which has moved. This only fires when the pen is down.
         * @param {RenderedTarget} target - the target which has moved.
         * @param {number} oldX - the previous X position.
         * @param {number} oldY - the previous Y position.
         * @private
         */

    }, {
        key: '_onTargetMoved',
        value: function _onTargetMoved(target, oldX, oldY) {
            var penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                var penState = this._getPenState(target);
                this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
                this.runtime.requestRedraw();
            }
        }

        /**
         * Wrap a color input into the range (0,100).
         * @param {number} value - the value to be wrapped.
         * @returns {number} the wrapped value.
         * @private
         */

    }, {
        key: '_wrapColor',
        value: function _wrapColor(value) {
            return MathUtil.wrapClamp(value, 0, 100);
        }

        /**
         * Clamp a pen color parameter to the range (0,100).
         * @param {number} value - the value to be clamped.
         * @returns {number} the clamped value.
         * @private
         */

    }, {
        key: '_clampColorParam',
        value: function _clampColorParam(value) {
            return MathUtil.clamp(value, 0, 100);
        }

        /**
         * Convert an alpha value to a pen transparency value.
         * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
         * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
         * @param {number} alpha - the input alpha value.
         * @returns {number} the transparency value.
         * @private
         */

    }, {
        key: '_alphaToTransparency',
        value: function _alphaToTransparency(alpha) {
            return (1.0 - alpha) * 100.0;
        }

        /**
         * Convert a pen transparency value to an alpha value.
         * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
         * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
         * @param {number} transparency - the input transparency value.
         * @returns {number} the alpha value.
         * @private
         */

    }, {
        key: '_transparencyToAlpha',
        value: function _transparencyToAlpha(transparency) {
            return 1.0 - transparency / 100.0;
        }

        /**
         * @returns {object} metadata for this extension and its blocks.
         */

    }, {
        key: 'getInfo',
        value: function getInfo() {
            return {
                id: 'pen',
                name: 'Pen',
                iconURI: iconURI,
                blocks: [{
                    opcode: 'clear',
                    blockType: BlockType.COMMAND
                }, {
                    opcode: 'stamp',
                    blockType: BlockType.COMMAND
                }, {
                    opcode: 'penDown',
                    blockType: BlockType.COMMAND,
                    text: 'pen down'
                }, {
                    opcode: 'penUp',
                    blockType: BlockType.COMMAND,
                    text: 'pen up'
                }, {
                    opcode: 'setPenColorToColor',
                    blockType: BlockType.COMMAND,
                    text: 'set pen color to [COLOR]',
                    arguments: {
                        COLOR: {
                            type: ArgumentType.COLOR
                        }
                    }
                }, {
                    opcode: 'changePenColorParamBy',
                    blockType: BlockType.COMMAND,
                    text: 'change pen [COLOR_PARAM] by [VALUE]',
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 10
                        }
                    }
                }, {
                    opcode: 'setPenColorParamTo',
                    blockType: BlockType.COMMAND,
                    text: 'set pen [COLOR_PARAM] to [VALUE]',
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50
                        }
                    }
                }, {
                    opcode: 'changePenSizeBy',
                    blockType: BlockType.COMMAND,
                    text: 'change pen size by [SIZE]',
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    }
                }, {
                    opcode: 'setPenSizeTo',
                    blockType: BlockType.COMMAND,
                    text: 'set pen size to [SIZE]',
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    }
                },
                /* Legacy blocks, should not be shown in flyout */
                {
                    opcode: 'setPenShadeToNumber',
                    blockType: BlockType.COMMAND,
                    text: 'set pen shade to [SHADE]',
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }, {
                    opcode: 'changePenShadeBy',
                    blockType: BlockType.COMMAND,
                    text: 'change pen shade by [SHADE]',
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }, {
                    opcode: 'setPenHueToNumber',
                    blockType: BlockType.COMMAND,
                    text: 'set pen hue to [HUE]',
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }, {
                    opcode: 'changePenHueBy',
                    blockType: BlockType.COMMAND,
                    text: 'change pen hue by [HUE]',
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }],
                menus: {
                    colorParam: [ColorParam.COLOR, ColorParam.SATURATION, ColorParam.BRIGHTNESS, ColorParam.TRANSPARENCY]
                }
            };
        }

        /**
         * The pen "clear" block clears the pen layer's contents.
         */

    }, {
        key: 'clear',
        value: function clear() {
            var penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                this.runtime.renderer.penClear(penSkinId);
                this.runtime.requestRedraw();
            }
        }

        /**
         * The pen "stamp" block stamps the current drawable's image onto the pen layer.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'stamp',
        value: function stamp(args, util) {
            var penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                var target = util.target;
                this.runtime.renderer.penStamp(penSkinId, target.drawableID);
                this.runtime.requestRedraw();
            }
        }

        /**
         * The pen "pen down" block causes the target to leave pen trails on future motion.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'penDown',
        value: function penDown(args, util) {
            var target = util.target;
            var penState = this._getPenState(target);

            if (!penState.penDown) {
                penState.penDown = true;
                target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
            }

            var penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
                this.runtime.requestRedraw();
            }
        }

        /**
         * The pen "pen up" block stops the target from leaving pen trails.
         * @param {object} args - the block arguments.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'penUp',
        value: function penUp(args, util) {
            var target = util.target;
            var penState = this._getPenState(target);

            if (penState.penDown) {
                penState.penDown = false;
                target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
            }
        }

        /**
         * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
         * The transparency is reset to 0.
         * @param {object} args - the block arguments.
         *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'setPenColorToColor',
        value: function setPenColorToColor(args, util) {
            var penState = this._getPenState(util.target);
            var rgb = Cast.toRgbColorObject(args.COLOR);
            var hsv = Color.rgbToHsv(rgb);
            penState.color = hsv.h / 360 * 100;
            penState.saturation = hsv.s * 100;
            penState.brightness = hsv.v * 100;
            if (rgb.hasOwnProperty('a')) {
                penState.transparency = 100 * (1 - rgb.a / 255.0);
            } else {
                penState.transparency = 0;
            }

            // Set the legacy "shade" value the same way scratch 2 did.
            penState._shade = penState.brightness / 2;

            this._updatePenColor(penState);
        }

        /**
         * Update the cached color from the color, saturation, brightness and transparency values
         * in the provided PenState object.
         * @param {PenState} penState - the pen state to update.
         * @private
         */

    }, {
        key: '_updatePenColor',
        value: function _updatePenColor(penState) {
            var rgb = Color.hsvToRgb({
                h: penState.color * 360 / 100,
                s: penState.saturation / 100,
                v: penState.brightness / 100
            });
            penState.penAttributes.color4f[0] = rgb.r / 255.0;
            penState.penAttributes.color4f[1] = rgb.g / 255.0;
            penState.penAttributes.color4f[2] = rgb.b / 255.0;
            penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
        }

        /**
         * Set or change a single color parameter on the pen state, and update the pen color.
         * @param {ColorParam} param - the name of the color parameter to set or change.
         * @param {number} value - the value to set or change the param by.
         * @param {PenState} penState - the pen state to update.
         * @param {boolean} change - if true change param by value, if false set param to value.
         * @private
         */

    }, {
        key: '_setOrChangeColorParam',
        value: function _setOrChangeColorParam(param, value, penState, change) {
            switch (param) {
                case ColorParam.COLOR:
                    penState.color = this._wrapColor(value + (change ? penState.color : 0));
                    break;
                case ColorParam.SATURATION:
                    penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
                    break;
                case ColorParam.BRIGHTNESS:
                    penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
                    break;
                case ColorParam.TRANSPARENCY:
                    penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
                    break;
                default:
                    log.warn('Tried to set or change unknown color parameter: ' + param);
            }
            this._updatePenColor(penState);
        }

        /**
         * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
         * by a given amound.
         * @param {object} args - the block arguments.
         *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
         *  @property {number} VALUE - the amount to change the selected parameter by.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'changePenColorParamBy',
        value: function changePenColorParamBy(args, util) {
            var penState = this._getPenState(util.target);
            this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);
        }

        /**
         * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
         * to a given amound.
         * @param {object} args - the block arguments.
         *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
         *  @property {number} VALUE - the amount to set the selected parameter to.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'setPenColorParamTo',
        value: function setPenColorParamTo(args, util) {
            var penState = this._getPenState(util.target);
            this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);
        }

        /**
         * The pen "change pen size by {number}" block changes the pen size by the given amount.
         * @param {object} args - the block arguments.
         *  @property {number} SIZE - the amount of desired size change.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'changePenSizeBy',
        value: function changePenSizeBy(args, util) {
            var penAttributes = this._getPenState(util.target).penAttributes;
            penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Cast.toNumber(args.SIZE));
        }

        /**
         * The pen "set pen size to {number}" block sets the pen size to the given amount.
         * @param {object} args - the block arguments.
         *  @property {number} SIZE - the amount of desired size change.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'setPenSizeTo',
        value: function setPenSizeTo(args, util) {
            var penAttributes = this._getPenState(util.target).penAttributes;
            penAttributes.diameter = this._clampPenSize(Cast.toNumber(args.SIZE));
        }

        /* LEGACY OPCODES */
        /**
         * Scratch 2 "hue" param is equivelant to twice the new "color" param.
         * @param {object} args - the block arguments.
         *  @property {number} HUE - the amount to set the hue to.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'setPenHueToNumber',
        value: function setPenHueToNumber(args, util) {
            var penState = this._getPenState(util.target);
            var hueValue = Cast.toNumber(args.HUE);
            var colorValue = hueValue / 2;
            this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);
        }

        /**
         * Scratch 2 "hue" param is equivelant to twice the new "color" param.
         * @param {object} args - the block arguments.
         *  @property {number} HUE - the amount of desired hue change.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'changePenHueBy',
        value: function changePenHueBy(args, util) {
            var penState = this._getPenState(util.target);
            var hueChange = Cast.toNumber(args.HUE);
            var colorChange = hueChange / 2;
            this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);
        }

        /**
         * Use legacy "set shade" code to calculate RGB value for shade,
         * then convert back to HSV and store those components.
         * It is important to also track the given shade in penState._shade
         * because it cannot be accurately backed out of the new HSV later.
         * @param {object} args - the block arguments.
         *  @property {number} SHADE - the amount to set the shade to.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'setPenShadeToNumber',
        value: function setPenShadeToNumber(args, util) {
            var penState = this._getPenState(util.target);
            var newShade = Cast.toNumber(args.SHADE);

            // Wrap clamp the new shade value the way scratch 2 did.
            newShade = newShade % 200;
            if (newShade < 0) newShade += 200;

            // Create the new color in RGB using the scratch 2 "shade" model
            var rgb = Color.hsvToRgb({ h: penState.color * 360 / 100, s: 1, v: 1 });
            var shade = newShade > 100 ? 200 - newShade : newShade;
            if (shade < 50) {
                rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);
            } else {
                rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);
            }

            // Update the pen state according to new color
            var hsv = Color.rgbToHsv(rgb);
            penState.color = 100 * hsv.h / 360;
            penState.saturation = 100 * hsv.s;
            penState.brightness = 100 * hsv.v;

            // And store the shade that was used to compute this new color for later use.
            penState._shade = newShade;

            this._updatePenColor(penState);
        }

        /**
         * Because "shade" cannot be backed out of hsv consistently, use the previously
         * stored penState._shade to make the shade change.
         * @param {object} args - the block arguments.
         *  @property {number} SHADE - the amount of desired shade change.
         * @param {object} util - utility object provided by the runtime.
         */

    }, {
        key: 'changePenShadeBy',
        value: function changePenShadeBy(args, util) {
            var penState = this._getPenState(util.target);
            var shadeChange = Cast.toNumber(args.SHADE);
            this.setPenShadeToNumber({ SHADE: penState._shade + shadeChange }, util);
        }
    }], [{
        key: 'DEFAULT_PEN_STATE',
        get: function get() {
            return {
                penDown: false,
                color: 66.66,
                saturation: 100,
                brightness: 100,
                transparency: 0,
                _shade: 50, // Used only for legacy `change shade by` blocks
                penAttributes: {
                    color4f: [0, 0, 1, 1],
                    diameter: 1
                }
            };
        }

        /**
         * Place the pen layer in front of the backdrop but behind everything else.
         * We should probably handle this somewhere else... somewhere central that knows about pen, backdrop, video, etc.
         * Maybe it should be in the GUI?
         * @type {int}
         */

    }, {
        key: 'PEN_ORDER',
        get: function get() {
            return 1;
        }

        /**
         * The minimum and maximum allowed pen size.
         * @type {{min: number, max: number}}
         */

    }, {
        key: 'PEN_SIZE_RANGE',
        get: function get() {
            return { min: 1, max: 255 };
        }

        /**
         * The key to load & store a target's pen-related state.
         * @type {string}
         */

    }, {
        key: 'STATE_KEY',
        get: function get() {
            return 'Scratch.pen';
        }
    }]);

    return Scratch3PenBlocks;
}();

module.exports = Scratch3PenBlocks;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArgumentType = __webpack_require__(19);
var BlockType = __webpack_require__(11);
var color = __webpack_require__(23);
var log = __webpack_require__(1);

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
var iconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+d2VkbzItYmxvY2staWNvbjwvdGl0bGU+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMzUuMzEzIDEwLjQ2N0gzMi4wOVY4Ljg2NWMwLS4yMjMuMTgtLjQwNC40MDUtLjQwNGgyLjQxMmMuMjI0IDAgLjQwNi4xODIuNDA2LjQwNXYxLjYwMnpNMzAuNDc3IDEwLjQ2N2gtMy4yMjRWOC44NjVjMC0uMjIzLjE4My0uNDA0LjQwNy0uNDA0aDIuNDFjLjIyNiAwIC40MDcuMTgyLjQwNy40MDV2MS42MDJ6TTI1LjY0IDEwLjQ2N0gyMi40MlY4Ljg2NWMwLS4yMjMuMTgyLS40MDQuNDA2LS40MDRoMi40MWMuMjI2IDAgLjQwNy4xODIuNDA3LjQwNXYxLjYwMnpNMjAuODA2IDEwLjQ2N2gtMy4yMjRWOC44NjVjMC0uMjIzLjE4Mi0uNDA0LjQwNi0uNDA0SDIwLjRjLjIyNCAwIC40MDYuMTgyLjQwNi40MDV2MS42MDJ6TTE1Ljk3IDEwLjQ2N2gtMy4yMjRWOC44NjVjMC0uMjIzLjE4Mi0uNDA0LjQwNy0uNDA0aDIuNDFjLjIyNiAwIC40MDcuMTgyLjQwNy40MDV2MS42MDJ6TTExLjEzNSAxMC40NjdINy45MVY4Ljg2NWMwLS4yMjMuMTgzLS40MDQuNDA3LS40MDRoMi40MTJjLjIyMyAwIC40MDUuMTgyLjQwNS40MDV2MS42MDJ6IiBzdHJva2U9IiM2Rjc4OTMiIGZpbGw9IiNGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIGQ9Ik0zNy43MyAxMC40NjdINi4zYy0yLjY3IDAtNC44MzYgMi4xNTMtNC44MzYgNC44MDh2My4yMDVoMzcuMDczdi03LjIxYzAtLjQ0NC0uMzYyLS44MDMtLjgwNy0uODAzeiIgc3Ryb2tlPSIjNkY3ODkzIiBmaWxsPSIjRkZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48cGF0aCBkPSJNMzguMTM0IDMwLjk4SDEuODY3Yy0uMjI0IDAtLjQwMy0uMTgtLjQwMy0uNFYxNi4yMzZoMzIuNzFjLjczIDAgMS40My4yODcgMS45NDUuOC41MTUuNTE0IDEuMjE1LjgwMiAxLjk0NC44MDJoLjQ3M3YxMi43NGMwIC4yMi0uMTguNC0uNDAzLjR6IiBzdHJva2U9IiM2Rjc4OTMiIGZpbGw9IiNFNkU3RTgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIHN0cm9rZT0iIzZGNzg5MyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJNMzQuODMgMTYuMjM3bC40ODMtMi41NjVoMy4yMjMiLz48cGF0aCBkPSJNMzguNTM2IDExLjI2OFYzMC41OGMwIC4yMi0uMTguNC0uNDAzLjRIMS44NjZjLS4yMiAwLS40MDMtLjE4LS40MDMtLjR2LTEuMjAzaDM0LjI4MmMuNjUgMCAxLjE4LS41MjQgMS4xOC0xLjE3M1YxMC40NjdoLjgwNWMuNDQ2IDAgLjgwNi4zNi44MDYuOHoiIHN0cm9rZT0iIzZGNzg5MyIgZmlsbD0iIzZGNzg5MyIgb3BhY2l0eT0iLjE1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48cGF0aCBkPSJNMTEuNTM4IDE2LjI4aDIwLjE0OGMuMjIyIDAgLjQwMy4xOC40MDMuNHY2LjUyN2MwIC4yMjItLjE4Mi40LS40MDQuNEgxMS41MzhjLS4yMjMgMC0uNDA0LS4xNzgtLjQwNC0uNFYxNi42OGMwLS4yMi4xOC0uNC40MDQtLjQiIGZpbGw9IiNFNkU3RTgiLz48cGF0aCBkPSJNMTEuNTM4IDE2LjI4aDIwLjE0OGMuMjIyIDAgLjQwMy4xOC40MDMuNHY2LjUyN2MwIC4yMjItLjE4Mi40LS40MDQuNEgxMS41MzhjLS4yMjMgMC0uNDA0LS4xNzgtLjQwNC0uNFYxNi42OGMwLS4yMi4xOC0uNC40MDQtLjR6IiBzdHJva2U9IiM2Rjc4OTMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIGQ9Ik0zMi4wOSAxNi4yOHY2LjkyN2MwIC4yMjItLjE4LjQtLjQwNC40aC0yMC4xNWMtLjIyIDAtLjQtLjE4LS40LS40di0xLjJoMTguMTZjLjY1MyAwIDEuMTgtLjUyNiAxLjE4LTEuMTc0VjE2LjI4aDEuNjEzeiIgc3Ryb2tlPSIjNkY3ODkzIiBmaWxsPSIjNkU3NzkyIiBvcGFjaXR5PSIuMTUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIGQ9Ik0zMC40NzcgMTYuMjhoLTMuMjI0di0xLjYwNGMwLS4yMjMuMTgzLS40MDQuNDA3LS40MDRoMi40MWMuMjI2IDAgLjQwNy4xOC40MDcuNDA0djEuNjAzek0xNS45NyAxNi4yOGgtMy4yMjR2LTEuNjA0YzAtLjIyMy4xODItLjQwNC40MDctLjQwNGgyLjQxYy4yMjYgMCAuNDA3LjE4LjQwNy40MDR2MS42MDN6TTI1LjY0IDE2LjI4SDIyLjQydi0xLjYwNGMwLS4yMjMuMTgyLS40MDQuNDA2LS40MDRoMi40MWMuMjI2IDAgLjQwNy4xOC40MDcuNDA0djEuNjAzek0yMC44MDYgMTYuMjhoLTMuMjI0di0xLjYwNGMwLS4yMjMuMTgyLS40MDQuNDA2LS40MDRIMjAuNGMuMjI0IDAgLjQwNi4xOC40MDYuNDA0djEuNjAzeiIgc3Ryb2tlPSIjNkY3ODkzIiBmaWxsPSIjRTZFN0U4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48cGF0aCBkPSJNMTguNTU3IDE5LjkxYzAgMS4wMjUtLjgzNyAxLjg1Ny0xLjg3IDEuODU3LTEuMDMgMC0xLjg2Ny0uODMyLTEuODY3LTEuODU4IDAtMS4wMjcuODM3LTEuODU4IDEuODY4LTEuODU4IDEuMDMyIDAgMS44Ny44MyAxLjg3IDEuODU3ek0yMy40OCAxOS45MWMwIDEuMDI1LS44MzYgMS44NTctMS44NjggMS44NTdzLTEuODctLjgzMi0xLjg3LTEuODU4YzAtMS4wMjcuODM4LTEuODU4IDEuODctMS44NThzMS44NjguODMgMS44NjggMS44NTd6TTI4LjQwNCAxOS45MWMwIDEuMDI1LS44MzcgMS44NTctMS44NjggMS44NTctMS4wMzIgMC0xLjg3LS44MzItMS44Ny0xLjg1OCAwLTEuMDI3LjgzOC0xLjg1OCAxLjg3LTEuODU4IDEuMDMgMCAxLjg2OC44MyAxLjg2OCAxLjg1N3oiIHN0cm9rZT0iIzZGNzg5MyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PHBhdGggZD0iTTE4LjU1NyAxOS45MjJjMCAxLjAyNi0uODM3IDEuODU4LTEuODcgMS44NTgtMS4wMyAwLTEuODY3LS44MzItMS44NjctMS44NTggMC0xLjAyNS44MzctMS44NTcgMS44NjgtMS44NTcgMS4wMzIgMCAxLjg3LjgzMiAxLjg3IDEuODU3TTIzLjQ4IDE5LjkyMmMwIDEuMDI2LS44MzYgMS44NTgtMS44NjggMS44NThzLTEuODctLjgzMi0xLjg3LTEuODU4YzAtMS4wMjUuODM4LTEuODU3IDEuODctMS44NTdzMS44NjguODMyIDEuODY4IDEuODU3TTI4LjQwNCAxOS45MjJjMCAxLjAyNi0uODM3IDEuODU4LTEuODY4IDEuODU4LTEuMDMyIDAtMS44Ny0uODMyLTEuODctMS44NTggMC0xLjAyNS44MzgtMS44NTcgMS44Ny0xLjg1NyAxLjAzIDAgMS44NjguODMyIDEuODY4IDEuODU3IiBmaWxsPSIjNkY3ODkzIiBvcGFjaXR5PSIuNSIvPjwvZz48L3N2Zz4=';

/**
 * Manage power, direction, and timers for one WeDo 2.0 motor.
 */

var WeDo2Motor = function () {
    /**
     * Construct a WeDo2Motor instance.
     * @param {WeDo2} parent - the WeDo 2.0 device which owns this motor.
     * @param {int} index - the zero-based index of this motor on its parent device.
     */
    function WeDo2Motor(parent, index) {
        _classCallCheck(this, WeDo2Motor);

        /**
         * The WeDo 2.0 device which owns this motor.
         * @type {WeDo2}
         * @private
         */
        this._parent = parent;

        /**
         * The zero-based index of this motor on its parent device.
         * @type {int}
         * @private
         */
        this._index = index;

        /**
         * This motor's current direction: 1 for "this way" or -1 for "that way"
         * @type {number}
         * @private
         */
        this._direction = 1;

        /**
         * This motor's current power level, in the range [0,100].
         * @type {number}
         * @private
         */
        this._power = 100;

        /**
         * Is this motor currently moving?
         * @type {boolean}
         * @private
         */
        this._isOn = false;

        /**
         * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
         * the end-of-action handler. Cancel this when changing plans.
         * @type {Object}
         * @private
         */
        this._pendingTimeoutId = null;

        this.startBraking = this.startBraking.bind(this);
        this.setMotorOff = this.setMotorOff.bind(this);
    }

    /**
     * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.
     * @constructor
     */


    _createClass(WeDo2Motor, [{
        key: 'setMotorOn',


        /**
         * Turn this motor on indefinitely.
         */
        value: function setMotorOn() {
            this._parent._send('motorOn', { motorIndex: this._index, power: this._direction * this._power });
            this._isOn = true;
            this._clearTimeout();
        }

        /**
         * Turn this motor on for a specific duration.
         * @param {number} milliseconds - run the motor for this long.
         */

    }, {
        key: 'setMotorOnFor',
        value: function setMotorOnFor(milliseconds) {
            milliseconds = Math.max(0, milliseconds);
            this.setMotorOn();
            this._setNewTimeout(this.startBraking, milliseconds);
        }

        /**
         * Start active braking on this motor. After a short time, the motor will turn off.
         */

    }, {
        key: 'startBraking',
        value: function startBraking() {
            this._parent._send('motorBrake', { motorIndex: this._index });
            this._isOn = false;
            this._setNewTimeout(this.setMotorOff, WeDo2Motor.BRAKE_TIME_MS);
        }

        /**
         * Turn this motor off.
         */

    }, {
        key: 'setMotorOff',
        value: function setMotorOff() {
            this._parent._send('motorOff', { motorIndex: this._index });
            this._isOn = false;
        }

        /**
         * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
         * @private
         */

    }, {
        key: '_clearTimeout',
        value: function _clearTimeout() {
            if (this._pendingTimeoutId !== null) {
                clearTimeout(this._pendingTimeoutId);
                this._pendingTimeoutId = null;
            }
        }

        /**
         * Set a new motor action timeout, after clearing an existing one if necessary.
         * @param {Function} callback - to be called at the end of the timeout.
         * @param {int} delay - wait this many milliseconds before calling the callback.
         * @private
         */

    }, {
        key: '_setNewTimeout',
        value: function _setNewTimeout(callback, delay) {
            var _this = this;

            this._clearTimeout();
            var timeoutID = setTimeout(function () {
                if (_this._pendingTimeoutId === timeoutID) {
                    _this._pendingTimeoutId = null;
                }
                callback();
            }, delay);
            this._pendingTimeoutId = timeoutID;
        }
    }, {
        key: 'direction',


        /**
         * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
         */
        get: function get() {
            return this._direction;
        }

        /**
         * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
         */
        ,
        set: function set(value) {
            if (value < 0) {
                this._direction = -1;
            } else {
                this._direction = 1;
            }
        }

        /**
         * @return {int} - this motor's current power level, in the range [0,100].
         */

    }, {
        key: 'power',
        get: function get() {
            return this._power;
        }

        /**
         * @param {int} value - this motor's new power level, in the range [0,100].
         */
        ,
        set: function set(value) {
            this._power = Math.max(0, Math.min(value, 100));
        }

        /**
         * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
         */

    }, {
        key: 'isOn',
        get: function get() {
            return this._isOn;
        }
    }], [{
        key: 'BRAKE_TIME_MS',
        get: function get() {
            return 1000;
        }
    }]);

    return WeDo2Motor;
}();

/**
 * Manage communication with a WeDo 2.0 device over a Device Manager client socket.
 */


var WeDo2 = function () {
    _createClass(WeDo2, null, [{
        key: 'DEVICE_TYPE',


        /**
         * @return {string} - the type of Device Manager device socket that this class will handle.
         */
        get: function get() {
            return 'wedo2';
        }

        /**
         * Construct a WeDo2 communication object.
         * @param {Socket} socket - the socket for a WeDo 2.0 device, as provided by a Device Manager client.
         */

    }]);

    function WeDo2(socket) {
        _classCallCheck(this, WeDo2);

        /**
         * The socket-IO socket used to communicate with the Device Manager about this device.
         * @type {Socket}
         * @private
         */
        this._socket = socket;

        /**
         * The motors which this WeDo 2.0 could possibly have.
         * @type {[WeDo2Motor]}
         * @private
         */
        this._motors = [new WeDo2Motor(this, 0), new WeDo2Motor(this, 1)];

        /**
         * The most recently received value for each sensor.
         * @type {Object.<string, number>}
         * @private
         */
        this._sensors = {
            tiltX: 0,
            tiltY: 0,
            distance: 0
        };

        this._onSensorChanged = this._onSensorChanged.bind(this);
        this._onDisconnect = this._onDisconnect.bind(this);

        this._connectEvents();
    }

    /**
     * Manually dispose of this object.
     */


    _createClass(WeDo2, [{
        key: 'dispose',
        value: function dispose() {
            this._disconnectEvents();
        }

        /**
         * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
         */

    }, {
        key: 'motor',


        /**
         * Access a particular motor on this device.
         * @param {int} index - the zero-based index of the desired motor.
         * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
         */
        value: function motor(index) {
            return this._motors[index];
        }

        /**
         * Set the WeDo 2.0 hub's LED to a specific color.
         * @param {int} rgb - a 24-bit RGB color in 0xRRGGBB format.
         */

    }, {
        key: 'setLED',
        value: function setLED(rgb) {
            this._send('setLED', { rgb: rgb });
        }

        /**
         * Play a tone from the WeDo 2.0 hub for a specific amount of time.
         * @param {int} tone - the pitch of the tone, in Hz.
         * @param {int} milliseconds - the duration of the note, in milliseconds.
         */

    }, {
        key: 'playTone',
        value: function playTone(tone, milliseconds) {
            this._send('playTone', { tone: tone, ms: milliseconds });
        }

        /**
         * Stop the tone playing from the WeDo 2.0 hub, if any.
         */

    }, {
        key: 'stopTone',
        value: function stopTone() {
            this._send('stopTone');
        }

        /**
         * Attach event handlers to the device socket.
         * @private
         */

    }, {
        key: '_connectEvents',
        value: function _connectEvents() {
            this._socket.on('sensorChanged', this._onSensorChanged);
            this._socket.on('deviceWasClosed', this._onDisconnect);
            this._socket.on('disconnect', this._onDisconnect);
        }

        /**
         * Detach event handlers from the device socket.
         * @private
         */

    }, {
        key: '_disconnectEvents',
        value: function _disconnectEvents() {
            this._socket.off('sensorChanged', this._onSensorChanged);
            this._socket.off('deviceWasClosed', this._onDisconnect);
            this._socket.off('disconnect', this._onDisconnect);
        }

        /**
         * Store the sensor value from an incoming 'sensorChanged' event.
         * @param {object} event - the 'sensorChanged' event.
         * @property {string} sensorName - the name of the sensor which changed.
         * @property {number} sensorValue - the new value of the sensor.
         * @private
         */

    }, {
        key: '_onSensorChanged',
        value: function _onSensorChanged(event) {
            this._sensors[event.sensorName] = event.sensorValue;
        }

        /**
         * React to device disconnection. May be called more than once.
         * @private
         */

    }, {
        key: '_onDisconnect',
        value: function _onDisconnect() {
            this._disconnectEvents();
        }

        /**
         * Send a message to the device socket.
         * @param {string} message - the name of the message, such as 'playTone'.
         * @param {object} [details] - optional additional details for the message, such as tone duration and pitch.
         * @private
         */

    }, {
        key: '_send',
        value: function _send(message, details) {
            this._socket.emit(message, details);
        }
    }, {
        key: 'tiltX',
        get: function get() {
            return this._sensors.tiltX;
        }

        /**
         * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
         */

    }, {
        key: 'tiltY',
        get: function get() {
            return this._sensors.tiltY;
        }

        /**
         * @return {number} - the latest value received from the distance sensor.
         */

    }, {
        key: 'distance',
        get: function get() {
            return this._sensors.distance * 10;
        }
    }]);

    return WeDo2;
}();

/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


var MotorID = {
    DEFAULT: 'motor',
    A: 'motor A',
    B: 'motor B',
    ALL: 'all motors'
};

/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */
var MotorDirection = {
    FORWARD: 'this way',
    BACKWARD: 'that way',
    REVERSE: 'reverse'
};

/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */
var TiltDirection = {
    UP: 'up',
    DOWN: 'down',
    LEFT: 'left',
    RIGHT: 'right',
    ANY: 'any'
};

/**
 * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 device.
 */

var Scratch3WeDo2Blocks = function () {
    _createClass(Scratch3WeDo2Blocks, null, [{
        key: 'EXTENSION_ID',


        /**
         * @return {string} - the ID of this extension.
         */
        get: function get() {
            return 'wedo2';
        }

        /**
         * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
         */

    }, {
        key: 'TILT_THRESHOLD',
        get: function get() {
            return 15;
        }

        /**
         * Construct a set of WeDo 2.0 blocks.
         * @param {Runtime} runtime - the Scratch 3.0 runtime.
         */

    }]);

    function Scratch3WeDo2Blocks(runtime) {
        _classCallCheck(this, Scratch3WeDo2Blocks);

        /**
         * The Scratch 3.0 runtime.
         * @type {Runtime}
         */
        this.runtime = runtime;

        this.connect();
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */


    _createClass(Scratch3WeDo2Blocks, [{
        key: 'getInfo',
        value: function getInfo() {
            return {
                id: Scratch3WeDo2Blocks.EXTENSION_ID,
                name: 'WeDo 2.0',
                iconURI: iconURI,
                blocks: [{
                    opcode: 'motorOnFor',
                    text: 'turn [MOTOR_ID] on for [DURATION] seconds',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        MOTOR_ID: {
                            type: ArgumentType.STRING,
                            menu: 'motorID',
                            defaultValue: MotorID.DEFAULT
                        },
                        DURATION: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    }
                }, {
                    opcode: 'motorOn',
                    text: 'turn [MOTOR_ID] on',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        MOTOR_ID: {
                            type: ArgumentType.STRING,
                            menu: 'motorID',
                            defaultValue: MotorID.DEFAULT
                        }
                    }
                }, {
                    opcode: 'motorOff',
                    text: 'turn [MOTOR_ID] off',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        MOTOR_ID: {
                            type: ArgumentType.STRING,
                            menu: 'motorID',
                            defaultValue: MotorID.DEFAULT
                        }
                    }
                }, {
                    opcode: 'startMotorPower',
                    text: 'set [MOTOR_ID] power to [POWER]',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        MOTOR_ID: {
                            type: ArgumentType.STRING,
                            menu: 'motorID',
                            defaultValue: MotorID.DEFAULT
                        },
                        POWER: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 100
                        }
                    }
                }, {
                    opcode: 'setMotorDirection',
                    text: 'set [MOTOR_ID] direction to [DIRECTION]',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        MOTOR_ID: {
                            type: ArgumentType.STRING,
                            menu: 'motorID',
                            defaultValue: MotorID.DEFAULT
                        },
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'motorDirection',
                            defaultValue: MotorDirection.FORWARD
                        }
                    }
                }, {
                    opcode: 'setLightHue',
                    text: 'set light color to [HUE]',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50
                        }
                    }
                }, {
                    opcode: 'playNoteFor',
                    text: 'play note [NOTE] for [DURATION] seconds',
                    blockType: BlockType.COMMAND,
                    arguments: {
                        NOTE: {
                            type: ArgumentType.NUMBER, // TODO: ArgumentType.MIDI_NOTE?
                            defaultValue: 60
                        },
                        DURATION: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0.5
                        }
                    }
                }, {
                    opcode: 'whenDistance',
                    text: 'when distance [OP] [REFERENCE]',
                    blockType: BlockType.HAT,
                    arguments: {
                        OP: {
                            type: ArgumentType.STRING,
                            menu: 'lessMore',
                            defaultValue: '<'
                        },
                        REFERENCE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50
                        }
                    }
                }, {
                    opcode: 'whenTilted',
                    text: 'when tilted [DIRECTION]',
                    func: 'isTilted',
                    blockType: BlockType.HAT,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirectionAny',
                            defaultValue: TiltDirection.ANY
                        }
                    }
                }, {
                    opcode: 'getDistance',
                    text: 'distance',
                    blockType: BlockType.REPORTER
                }, {
                    opcode: 'isTilted',
                    text: 'tilted [DIRECTION]?',
                    blockType: BlockType.BOOLEAN,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirectionAny',
                            defaultValue: TiltDirection.ANY
                        }
                    }
                }, {
                    opcode: 'getTiltAngle',
                    text: 'tilt angle [DIRECTION]',
                    blockType: BlockType.REPORTER,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirection',
                            defaultValue: TiltDirection.UP
                        }
                    }
                }],
                menus: {
                    motorID: [MotorID.DEFAULT, MotorID.A, MotorID.B, MotorID.ALL],
                    motorDirection: [MotorDirection.FORWARD, MotorDirection.BACKWARD, MotorDirection.REVERSE],
                    tiltDirection: [TiltDirection.UP, TiltDirection.DOWN, TiltDirection.LEFT, TiltDirection.RIGHT],
                    tiltDirectionAny: [TiltDirection.UP, TiltDirection.DOWN, TiltDirection.LEFT, TiltDirection.RIGHT, TiltDirection.ANY],
                    lessMore: ['<', '>']
                }
            };
        }

        /**
         * Use the Device Manager client to attempt to connect to a WeDo 2.0 device.
         */

    }, {
        key: 'connect',
        value: function connect() {
            var _this2 = this;

            if (this._device || this._finder) {
                return;
            }
            var deviceManager = this.runtime.ioDevices.deviceManager;
            var finder = this._finder = deviceManager.searchAndConnect(Scratch3WeDo2Blocks.EXTENSION_ID, WeDo2.DEVICE_TYPE);
            this._finder.promise.then(function (socket) {
                if (_this2._finder === finder) {
                    _this2._finder = null;
                    _this2._device = new WeDo2(socket);
                } else {
                    log.warn('Ignoring success from stale WeDo 2.0 connection attempt');
                }
            }, function (reason) {
                if (_this2._finder === finder) {
                    _this2._finder = null;
                    log.warn('WeDo 2.0 connection failed: ' + reason);
                } else {
                    log.warn('Ignoring failure from stale WeDo 2.0 connection attempt');
                }
            });
        }

        /**
         * Turn specified motor(s) on for a specified duration.
         * @param {object} args - the block's arguments.
         * @property {MotorID} MOTOR_ID - the motor(s) to activate.
         * @property {int} DURATION - the amount of time to run the motors.
         * @return {Promise} - a promise which will resolve at the end of the duration.
         */

    }, {
        key: 'motorOnFor',
        value: function motorOnFor(args) {
            var _this3 = this;

            var durationMS = args.DURATION * 1000;
            return new Promise(function (resolve) {
                _this3._forEachMotor(args.MOTOR_ID, function (motorIndex) {
                    _this3._device.motor(motorIndex).setMotorOnFor(durationMS);
                });

                // Ensure this block runs for a fixed amount of time even when no device is connected.
                setTimeout(resolve, durationMS);
            });
        }

        /**
         * Turn specified motor(s) on indefinitely.
         * @param {object} args - the block's arguments.
         * @property {MotorID} MOTOR_ID - the motor(s) to activate.
         */

    }, {
        key: 'motorOn',
        value: function motorOn(args) {
            var _this4 = this;

            this._forEachMotor(args.MOTOR_ID, function (motorIndex) {
                _this4._device.motor(motorIndex).setMotorOn();
            });
        }

        /**
         * Turn specified motor(s) off.
         * @param {object} args - the block's arguments.
         * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
         */

    }, {
        key: 'motorOff',
        value: function motorOff(args) {
            var _this5 = this;

            this._forEachMotor(args.MOTOR_ID, function (motorIndex) {
                _this5._device.motor(motorIndex).setMotorOff();
            });
        }

        /**
         * Turn specified motor(s) off.
         * @param {object} args - the block's arguments.
         * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
         * @property {int} POWER - the new power level for the motor(s).
         */

    }, {
        key: 'startMotorPower',
        value: function startMotorPower(args) {
            var _this6 = this;

            this._forEachMotor(args.MOTOR_ID, function (motorIndex) {
                var motor = _this6._device.motor(motorIndex);
                motor.power = args.POWER;
                motor.setMotorOn();
            });
        }

        /**
         * Set the direction of rotation for specified motor(s).
         * If the direction is 'reverse' the motor(s) will be reversed individually.
         * @param {object} args - the block's arguments.
         * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
         * @property {MotorDirection} DIRECTION - the new direction for the motor(s).
         */

    }, {
        key: 'setMotorDirection',
        value: function setMotorDirection(args) {
            var _this7 = this;

            this._forEachMotor(args.MOTOR_ID, function (motorIndex) {
                var motor = _this7._device.motor(motorIndex);
                switch (args.DIRECTION) {
                    case MotorDirection.FORWARD:
                        motor.direction = 1;
                        break;
                    case MotorDirection.BACKWARD:
                        motor.direction = -1;
                        break;
                    case MotorDirection.REVERSE:
                        motor.direction = -motor.direction;
                        break;
                    default:
                        log.warn('Unknown motor direction in setMotorDirection: ' + args.DIRECTION);
                        break;
                }
            });
        }

        /**
         * Set the LED's hue.
         * @param {object} args - the block's arguments.
         * @property {number} HUE - the hue to set, in the range [0,100].
         */

    }, {
        key: 'setLightHue',
        value: function setLightHue(args) {
            // Convert from [0,100] to [0,360]
            var hue = args.HUE * 360 / 100;

            var rgbObject = color.hsvToRgb({ h: hue, s: 1, v: 1 });

            var rgbDecimal = color.rgbToDecimal(rgbObject);

            this._device.setLED(rgbDecimal);
        }

        /**
         * Make the WeDo 2.0 hub play a MIDI note for the specified duration.
         * @param {object} args - the block's arguments.
         * @property {number} NOTE - the MIDI note to play.
         * @property {number} DURATION - the duration of the note, in seconds.
         * @return {Promise} - a promise which will resolve at the end of the duration.
         */

    }, {
        key: 'playNoteFor',
        value: function playNoteFor(args) {
            var _this8 = this;

            return new Promise(function (resolve) {
                var durationMS = args.DURATION * 1000;
                var tone = _this8._noteToTone(args.NOTE);
                _this8._device.playTone(tone, durationMS);

                // Ensure this block runs for a fixed amount of time even when no device is connected.
                setTimeout(resolve, durationMS);
            });
        }

        /**
         * Compare the distance sensor's value to a reference.
         * @param {object} args - the block's arguments.
         * @property {string} OP - the comparison operation: '<' or '>'.
         * @property {number} REFERENCE - the value to compare against.
         * @return {boolean} - the result of the comparison, or false on error.
         */

    }, {
        key: 'whenDistance',
        value: function whenDistance(args) {
            switch (args.OP) {
                case '<':
                case '&lt;':
                    return this._device.distance < args.REFERENCE;
                case '>':
                case '&gt;':
                    return this._device.distance > args.REFERENCE;
                default:
                    log.warn('Unknown comparison operator in whenDistance: ' + args.OP);
                    return false;
            }
        }

        /**
         * Test whether the tilt sensor is currently tilted.
         * @param {object} args - the block's arguments.
         * @property {TiltDirection} DIRECTION - the tilt direction to test (up, down, left, right, or any).
         * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
         */

    }, {
        key: 'whenTilted',
        value: function whenTilted(args) {
            return this._isTilted(args.DIRECTION);
        }

        /**
         * @return {number} - the distance sensor's value, scaled to the [0,100] range.
         */

    }, {
        key: 'getDistance',
        value: function getDistance() {
            return this._device.distance;
        }

        /**
         * Test whether the tilt sensor is currently tilted.
         * @param {object} args - the block's arguments.
         * @property {TiltDirection} DIRECTION - the tilt direction to test (up, down, left, right, or any).
         * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
         */

    }, {
        key: 'isTilted',
        value: function isTilted(args) {
            return this._isTilted(args.DIRECTION);
        }

        /**
         * @param {object} args - the block's arguments.
         * @property {TiltDirection} DIRECTION - the direction (up, down, left, right) to check.
         * @return {number} - the tilt sensor's angle in the specified direction.
         * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
         */

    }, {
        key: 'getTiltAngle',
        value: function getTiltAngle(args) {
            return this._getTiltAngle(args.DIRECTION);
        }

        /**
         * Test whether the tilt sensor is currently tilted.
         * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
         * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
         * @private
         */

    }, {
        key: '_isTilted',
        value: function _isTilted(direction) {
            switch (direction) {
                case TiltDirection.ANY:
                    return Math.abs(this._device.tiltX) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || Math.abs(this._device.tiltY) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
                default:
                    return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
            }
        }

        /**
         * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
         * @return {number} - the tilt sensor's angle in the specified direction.
         * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
         * @private
         */

    }, {
        key: '_getTiltAngle',
        value: function _getTiltAngle(direction) {
            switch (direction) {
                case TiltDirection.UP:
                    return -this._device.tiltY;
                case TiltDirection.DOWN:
                    return this._device.tiltY;
                case TiltDirection.LEFT:
                    return -this._device.tiltX;
                case TiltDirection.RIGHT:
                    return this._device.tiltX;
                default:
                    log.warn('Unknown tilt direction in _getTiltAngle: ' + direction);
            }
        }

        /**
         * Call a callback for each motor indexed by the provided motor ID.
         * @param {MotorID} motorID - the ID specifier.
         * @param {Function} callback - the function to call with the numeric motor index for each motor.
         * @private
         */

    }, {
        key: '_forEachMotor',
        value: function _forEachMotor(motorID, callback) {
            var motors = void 0;
            switch (motorID) {
                case MotorID.A:
                    motors = [0];
                    break;
                case MotorID.B:
                    motors = [1];
                    break;
                case MotorID.ALL:
                case MotorID.DEFAULT:
                    motors = [0, 1];
                    break;
                default:
                    log.warn('Invalid motor ID: ' + motorID);
                    motors = [];
                    break;
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = motors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var index = _step.value;

                    callback(index);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        /**
         * @param {number} midiNote - the MIDI note value to convert.
         * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.
         * @private
         */

    }, {
        key: '_noteToTone',
        value: function _noteToTone(midiNote) {
            // Note that MIDI note 69 is A4, 440 Hz
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
    }]);

    return Scratch3WeDo2Blocks;
}();

module.exports = Scratch3WeDo2Blocks;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Timer = __webpack_require__(24);

var Clock = function () {
    function Clock(runtime) {
        _classCallCheck(this, Clock);

        this._projectTimer = new Timer();
        this._projectTimer.start();
        this._pausedTime = null;
        this._paused = false;
        /**
         * Reference to the owning Runtime.
         * @type{!Runtime}
         */
        this.runtime = runtime;
    }

    _createClass(Clock, [{
        key: 'projectTimer',
        value: function projectTimer() {
            if (this._paused) {
                return this._pausedTime / 1000;
            }
            return this._projectTimer.timeElapsed() / 1000;
        }
    }, {
        key: 'pause',
        value: function pause() {
            this._paused = true;
            this._pausedTime = this._projectTimer.timeElapsed();
        }
    }, {
        key: 'resume',
        value: function resume() {
            this._paused = false;
            var dt = this._projectTimer.timeElapsed() - this._pausedTime;
            this._projectTimer.startTime += dt;
        }
    }, {
        key: 'resetProjectTimer',
        value: function resetProjectTimer() {
            this._projectTimer.start();
        }
    }]);

    return Clock;
}();

module.exports = Clock;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var nets = __webpack_require__(124);
var io = __webpack_require__(141);
var querystring = __webpack_require__(128);

/**
 * Internal class used by the Device Manager client to manage making a connection to a particular device.
 */

var DeviceOpener = function () {
    _createClass(DeviceOpener, null, [{
        key: 'CONNECTION_TIMEOUT_MS',

        /**
         * @return {number} - The number of milliseconds to allow before deciding a connection attempt has timed out.
         */
        get: function get() {
            return 10 * 1000;
        }

        /**
         * Construct a DeviceOpener to help connect to a particular device.
         * @param {DeviceManager} deviceManager - the Device Manager client which instigated this action.
         * @param {function} resolve - callback to be called if the device is successfully found, connected, and opened.
         * @param {function} reject - callback to be called if an error or timeout is encountered.
         */

    }]);

    function DeviceOpener(deviceManager, resolve, reject) {
        _classCallCheck(this, DeviceOpener);

        /**
         * The DeviceManager client which wants to open a device.
         * @type {DeviceManager}
         * @private
         */
        this._deviceManager = deviceManager;

        /**
         * Callback to be called if the device is successfully found, connected, and opened.
         * @type {Function}
         * @private
         */
        this._resolve = resolve;

        /**
         * Callback to be called if an error or timeout is encountered.
         * @type {Function}
         * @private
         */
        this._reject = reject;

        /**
         * The socket for the device being opened.
         * @type {Socket}
         * @private
         */
        this._socket = null;

        /**
         * If this timeout expires before a successful connection, the connection attempt will be canceled.
         * @type {Object}
         * @private
         */
        this._connectionTimeout = null;
    }

    /**
     * Attempt to open a particular device. This will cause `resolve` or `reject` to be called.
     * Note that in some cases it's possible that both `resolve` and `reject` will be called. In that event, ignore all
     * calls after the first. If `resolve` and `reject` are from a Promise, then the Promise will do this for you.
     * @param {string} extensionName - human-readable name of the extension requesting the device
     * @param {string} deviceType - the type of device to open, such as 'wedo2'
     * @param {string} deviceId - the ID of the particular device to open, usually from list results
     */


    _createClass(DeviceOpener, [{
        key: 'open',
        value: function open(extensionName, deviceType, deviceId) {
            var _this = this;

            this._socket = io(this._deviceManager._serverURL + '/' + deviceType);

            this._socket.on('deviceWasOpened', function () {
                return _this.onDeviceWasOpened();
            });
            this._socket.on('disconnect', function () {
                return _this.onDisconnect();
            });
            this._connectionTimeout = setTimeout(function () {
                return _this.onTimeout();
            }, DeviceOpener.CONNECTION_TIMEOUT_MS);

            this._socket.emit('open', { deviceId: deviceId, name: extensionName });
        }

        /**
         * React to a 'deviceWasOpened' message from the Device Manager application.
         */

    }, {
        key: 'onDeviceWasOpened',
        value: function onDeviceWasOpened() {
            this.clearConnectionTimeout();
            this._resolve(this._socket);
        }

        /**
         * React to the socket becoming disconnected.
         */

    }, {
        key: 'onDisconnect',
        value: function onDisconnect() {
            this.clearConnectionTimeout();
            this._reject('device disconnected');
        }

        /**
         * React to the connection timeout expiring. This could mean that the socket itself timed out, or that the Device
         * Manager took too long to send a 'deviceWasOpened' message back.
         */

    }, {
        key: 'onTimeout',
        value: function onTimeout() {
            this.clearConnectionTimeout();

            // `socket.disconnect()` triggers `onDisconnect` only for connected sockets
            if (this._socket.connected) {
                this._socket.disconnect();
            } else {
                this._reject('connection attempt timed out');
            }
        }

        /**
         * Cancel the connection timeout.
         */

    }, {
        key: 'clearConnectionTimeout',
        value: function clearConnectionTimeout() {
            if (this._connectionTimeout !== null) {
                clearTimeout(this._connectionTimeout);
                this._connectionTimeout = null;
            }
        }
    }]);

    return DeviceOpener;
}();

/**
 * A DeviceFinder implements the Device Manager client's `searchAndConnect` functionality.
 * Use the `promise` property to access a promise for a device socket.
 * Call `cancel()` to cancel the search. Once the search finds a device it cannot be canceled.
 */


var DeviceFinder = function () {
    _createClass(DeviceFinder, null, [{
        key: 'SEARCH_RETRY_MS',

        /**
         * @return {number} - the number of milliseconds to wait between search attempts (calls to 'list')
         */
        get: function get() {
            return 1000;
        }

        /**
         * Construct a DeviceFinder to help find and connect to a device satisfying specific conditions.
         * @param {DeviceManager} deviceManager - the Device Manager client which instigated this action.
         * @param {string} extensionName - human-readable name of the extension requesting the search
         * @param {string} deviceType - the type of device to find, such as 'wedo2'.
         * @param {object} [deviceSpec] - optional additional information about the specific devices to list
         */

    }]);

    function DeviceFinder(deviceManager, extensionName, deviceType, deviceSpec) {
        _classCallCheck(this, DeviceFinder);

        /**
         * The Device Manager client which wants to find a device.
         * @type {DeviceManager}
         * @private
         */
        this._deviceManager = deviceManager;

        /**
         * The human-readable name of the extension requesting the search.
         * @type {string}
         * @private
         */
        this._extensionName = extensionName;

        /**
         * The type of device to find, such as 'wedo2'.
         * @type {string}
         * @private
         */
        this._deviceType = deviceType;

        /**
         * Optional additional information about the specific devices to list.
         * @type {Object}
         * @private
         */
        this._deviceSpec = deviceSpec;

        /**
         * Flag indicating that the search should be canceled.
         * @type {boolean}
         * @private
         */
        this._cancel = false;

        /**
         * The promise representing this search's results.
         * @type {Promise}
         * @private
         */
        this._promise = null;

        /**
         * The fulfillment function for `this._promise`.
         * @type {Function}
         * @private
         */
        this._fulfill = null;
    }

    /**
     * @return {Promise} - A promise for a device socket.
     */


    _createClass(DeviceFinder, [{
        key: 'start',


        /**
         * Start searching for a device.
         */
        value: function start() {
            var _this2 = this;

            this._promise = new Promise(function (fulfill, reject) {
                _this2._fulfill = fulfill;
                _this2._reject = reject;
                _this2._getList();
            });
        }

        /**
         * Cancel the search for a device. Effective only before the promise resolves.
         */

    }, {
        key: 'cancel',
        value: function cancel() {
            this._cancel = true;
            this._reject('canceled');
        }

        /**
         * Fetch the list of devices matching the parameters provided in the constructor.
         * @private
         */

    }, {
        key: '_getList',
        value: function _getList() {
            var _this3 = this;

            this._deviceManager.list(this._extensionName, this._deviceType, this._deviceSpec).then(function (listResult) {
                return _this3._listResultHandler(listResult);
            }, function () {
                return _this3._listResultHandler(null);
            });
        }

        /**
         * Handle the list of devices returned by the Device Manager.
         * @param {Array} listResult - an array of device information objects.
         * @private
         */

    }, {
        key: '_listResultHandler',
        value: function _listResultHandler(listResult) {
            var _this4 = this;

            if (this._cancel) {
                return;
            }

            if (listResult && listResult.length > 0) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = listResult[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var deviceInfo = _step.value;

                        if (!deviceInfo.connected) {
                            this._fulfill(this._deviceManager.open(this._extensionName, this._deviceType, deviceInfo.id));
                            return;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            setTimeout(function () {
                return _this4._getList();
            }, DeviceFinder.SEARCH_RETRY_MS);
        }
    }, {
        key: 'promise',
        get: function get() {
            return this._promise;
        }
    }]);

    return DeviceFinder;
}();

/**
 * A Scratch 3.0 "I/O Device" representing a client for the Scratch Device Manager.
 */


var DeviceManager = function () {
    _createClass(DeviceManager, null, [{
        key: 'DEFAULT_SERVER_URL',

        /**
         * @return {string} - The default Scratch Device Manager connection URL.
         */
        get: function get() {
            return 'https://device-manager.scratch.mit.edu:3030';
        }
    }]);

    function DeviceManager() {
        _classCallCheck(this, DeviceManager);

        /**
         * The URL this client will use for Device Manager communication both HTTP(S) and WS(S).
         * @type {string}
         * @private
         */
        this._serverURL = DeviceManager.DEFAULT_SERVER_URL;

        /**
         * True if there is no known problem connecting to the Scratch Device Manager, false otherwise.
         * @type {boolean}
         * @private
         */
        this._isConnected = true;
    }

    /**
     * @return {boolean} - True if there is no known problem connecting to the Scratch Device Manager, false otherwise.
     */


    _createClass(DeviceManager, [{
        key: 'searchAndConnect',


        /**
         * High-level request to find and connect to a device satisfying the specified characteristics.
         * This function will repeatedly call list() until the list is non-empty, then it will open() the first suitable
         * item in the list and provide the socket for that device.
         * @todo Offer a way to filter results. See the Scratch 2.0 PicoBoard extension for details on why that's important.
         * @param {string} extensionName - human-readable name of the extension requesting the search
         * @param {string} deviceType - the type of device to list, such as 'wedo2'
         * @param {object} [deviceSpec] - optional additional information about the specific devices to list
         * @return {DeviceFinder} - An object providing a Promise for an opened device and a way to cancel the search.
         */
        value: function searchAndConnect(extensionName, deviceType, deviceSpec) {
            var finder = new DeviceFinder(this, extensionName, deviceType, deviceSpec);
            finder.start();
            return finder;
        }

        /**
         * Request a list of available devices.
         * @param {string} extensionName - human-readable name of the extension requesting the list
         * @param {string} deviceType - the type of device to list, such as 'wedo2'
         * @param {object} [deviceSpec] - optional additional information about the specific devices to list
         * @return {Promise} - A Promise for an Array of available devices.
         */

    }, {
        key: 'list',
        value: function list(extensionName, deviceType, deviceSpec) {
            var queryObject = {
                name: extensionName
            };
            if (deviceSpec) queryObject.spec = deviceSpec;
            var url = this._serverURL + '/' + encodeURIComponent(deviceType) + '/list?' + querystring.stringify(queryObject);
            return new Promise(function (resolve, reject) {
                nets({
                    method: 'GET',
                    url: url,
                    json: {}
                }, function (err, res, body) {
                    if (err) return reject(err);
                    if (res.statusCode !== 200) return reject(body);
                    resolve(body);
                });
            });
        }

        /**
         * Attempt to open a particular device.
         * @param {string} extensionName - human-readable name of the extension requesting the device
         * @param {string} deviceType - the type of device to open, such as 'wedo2'
         * @param {string} deviceId - the ID of the particular device to open, usually from list results
         * @return {Promise} - A Promise for a Socket which can be used to communicate with the device
         */

    }, {
        key: 'open',
        value: function open(extensionName, deviceType, deviceId) {
            var _this5 = this;

            return new Promise(function (resolve, reject) {
                var opener = new DeviceOpener(_this5, resolve, reject);
                opener.open(extensionName, deviceType, deviceId);
            });
        }
    }, {
        key: 'isConnected',
        get: function get() {
            return this._isConnected;
        }
    }]);

    return DeviceManager;
}();

module.exports = DeviceManager;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Cast = __webpack_require__(2);

var Keyboard = function () {
    function Keyboard(runtime) {
        _classCallCheck(this, Keyboard);

        /**
         * List of currently pressed keys.
         * @type{Array.<number>}
         */
        this._keysPressed = [];
        /**
         * Reference to the owning Runtime.
         * Can be used, for example, to activate hats.
         * @type{!Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Convert a Scratch key name to a DOM keyCode.
     * @param {Any} keyName Scratch key argument.
     * @return {number} Key code corresponding to a DOM event.
     * @private
     */


    _createClass(Keyboard, [{
        key: '_scratchKeyToKeyCode',
        value: function _scratchKeyToKeyCode(keyName) {
            if (typeof keyName === 'number') {
                // Key codes placed in with number blocks.
                return keyName;
            }
            var keyString = Cast.toString(keyName);
            switch (keyString) {
                case 'space':
                    return 32;
                case 'left arrow':
                    return 37;
                case 'up arrow':
                    return 38;
                case 'right arrow':
                    return 39;
                case 'down arrow':
                    return 40;
                // @todo: Consider adding other special keys here.
            }
            // Keys reported by DOM keyCode are upper case.
            return keyString.toUpperCase().charCodeAt(0);
        }

        /**
         * Convert a DOM keyCode into a Scratch key name.
         * @param  {number} keyCode Key code from DOM event.
         * @return {Any} Scratch key argument.
         * @private
         */

    }, {
        key: '_keyCodeToScratchKey',
        value: function _keyCodeToScratchKey(keyCode) {
            if (keyCode >= 48 && keyCode <= 90) {
                // Standard letter.
                return String.fromCharCode(keyCode).toLowerCase();
            }
            switch (keyCode) {
                case 32:
                    return 'space';
                case 37:
                    return 'left arrow';
                case 38:
                    return 'up arrow';
                case 39:
                    return 'right arrow';
                case 40:
                    return 'down arrow';
            }
            return '';
        }

        /**
         * Keyboard DOM event handler.
         * @param  {object} data Data from DOM event.
         */

    }, {
        key: 'postData',
        value: function postData(data) {
            if (data.keyCode) {
                var index = this._keysPressed.indexOf(data.keyCode);
                if (data.isDown) {
                    // If not already present, add to the list.
                    if (index < 0) {
                        this._keysPressed.push(data.keyCode);
                    }
                    // Always trigger hats, even if it was already pressed.
                    this.runtime.startHats('event_whenkeypressed', {
                        KEY_OPTION: this._keyCodeToScratchKey(data.keyCode)
                    });
                    this.runtime.startHats('event_whenkeypressed', {
                        KEY_OPTION: 'any'
                    });
                } else if (index > -1) {
                    // If already present, remove from the list.
                    this._keysPressed.splice(index, 1);
                }
            }
        }

        /**
         * Get key down state for a specified Scratch key name.
         * @param  {Any} key Scratch key argument.
         * @return {boolean} Is the specified key down?
         */

    }, {
        key: 'getKeyIsDown',
        value: function getKeyIsDown(key) {
            if (key === 'any') {
                return this._keysPressed.length > 0;
            }
            var keyCode = this._scratchKeyToKeyCode(key);
            return this._keysPressed.indexOf(keyCode) > -1;
        }
    }]);

    return Keyboard;
}();

module.exports = Keyboard;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MathUtil = __webpack_require__(6);

var Mouse = function () {
    function Mouse(runtime) {
        _classCallCheck(this, Mouse);

        this._x = 0;
        this._y = 0;
        this._isDown = false;
        /**
         * Reference to the owning Runtime.
         * Can be used, for example, to activate hats.
         * @type{!Runtime}
         */
        this.runtime = runtime;
    }

    /**
     * Activate "event_whenthisspriteclicked" hats if needed.
     * @param  {number} x X position to be sent to the renderer.
     * @param  {number} y Y position to be sent to the renderer.
     * @private
     */


    _createClass(Mouse, [{
        key: '_activateClickHats',
        value: function _activateClickHats(x, y) {
            if (this.runtime.renderer) {
                var drawableID = this.runtime.renderer.pick(x, y);
                for (var i = 0; i < this.runtime.targets.length; i++) {
                    var target = this.runtime.targets[i];
                    if (target.hasOwnProperty('drawableID') && target.drawableID === drawableID) {
                        this.runtime.startHats('event_whenthisspriteclicked', null, target);
                        return;
                    }
                }
            }
        }

        /**
         * Mouse DOM event handler.
         * @param  {object} data Data from DOM event.
         */

    }, {
        key: 'postData',
        value: function postData(data) {
            if (data.x) {
                this._x = data.x - data.canvasWidth / 2;
            }
            if (data.y) {
                this._y = data.y - data.canvasHeight / 2;
            }
            if (typeof data.isDown !== 'undefined') {
                this._isDown = data.isDown;
                if (!this._isDown) {
                    this._activateClickHats(data.x, data.y);
                }
            }
        }

        /**
         * Get the X position of the mouse.
         * @return {number} Clamped X position of the mouse cursor.
         */

    }, {
        key: 'getX',
        value: function getX() {
            return MathUtil.clamp(this._x, -240, 240);
        }

        /**
         * Get the Y position of the mouse.
         * @return {number} Clamped Y position of the mouse cursor.
         */

    }, {
        key: 'getY',
        value: function getY() {
            return MathUtil.clamp(-this._y, -180, 180);
        }

        /**
         * Get the down state of the mouse.
         * @return {boolean} Is the mouse down?
         */

    }, {
        key: 'getIsDown',
        value: function getIsDown() {
            return this._isDown;
        }
    }]);

    return Mouse;
}();

module.exports = Mouse;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @fileoverview
 * Partial implementation of an SB2 JSON importer.
 * Parses provided JSON and then generates all needed
 * scratch-vm runtime structures.
 */

var Blocks = __webpack_require__(10);
var RenderedTarget = __webpack_require__(22);
var Sprite = __webpack_require__(39);
var Color = __webpack_require__(23);
var log = __webpack_require__(1);
var uid = __webpack_require__(28);
var specMap = __webpack_require__(88);
var Variable = __webpack_require__(18);

var _require = __webpack_require__(20),
    loadCostume = _require.loadCostume;

var _require2 = __webpack_require__(21),
    loadSound = _require2.loadSound;

/**
 * Convert a Scratch 2.0 procedure string (e.g., "my_procedure %s %b %n")
 * into an argument map. This allows us to provide the expected inputs
 * to a mutated procedure call.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {object} Argument map compatible with those in sb2specmap.
 */


var parseProcedureArgMap = function parseProcedureArgMap(procCode) {
    var argMap = [{} // First item in list is op string.
    ];
    var INPUT_PREFIX = 'input';
    var inputCount = 0;
    // Split by %n, %b, %s.
    var parts = procCode.split(/(?=[^\\]%[nbs])/);
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i].trim();
        if (part.substring(0, 1) === '%') {
            var argType = part.substring(1, 2);
            var arg = {
                type: 'input',
                inputName: INPUT_PREFIX + inputCount++
            };
            if (argType === 'n') {
                arg.inputOp = 'math_number';
            } else if (argType === 's') {
                arg.inputOp = 'text';
            }
            argMap.push(arg);
        }
    }
    return argMap;
};

/**
 * Generate a list of "argument IDs" for procdefs and caller mutations.
 * IDs just end up being `input0`, `input1`, ... which is good enough.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {Array.<string>} Array of argument id strings.
 */
var parseProcedureArgIds = function parseProcedureArgIds(procCode) {
    return parseProcedureArgMap(procCode).map(function (arg) {
        return arg.inputName;
    }).filter(function (name) {
        return name;
    }); // Filter out unnamed inputs which are labels
};

/**
 * Flatten a block tree into a block list.
 * Children are temporarily stored on the `block.children` property.
 * @param {Array.<object>} blocks list generated by `parseBlockList`.
 * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.
 */
var flatten = function flatten(blocks) {
    var finalBlocks = [];
    for (var i = 0; i < blocks.length; i++) {
        var block = blocks[i];
        finalBlocks.push(block);
        if (block.children) {
            finalBlocks = finalBlocks.concat(flatten(block.children));
        }
        delete block.children;
    }
    return finalBlocks;
};

/**
 * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.
 * Could be used to parse a top-level script,
 * a list of blocks in a branch (e.g., in forever),
 * or a list of blocks in an argument (e.g., move [pick random...]).
 * @param {Array.<object>} blockList SB2 JSON-format block list.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @return {Array.<object>} Scratch VM-format block list.
 */
var parseBlockList = function parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions) {
    var resultingList = [];
    var previousBlock = null; // For setting next.
    for (var i = 0; i < blockList.length; i++) {
        var block = blockList[i];
        // eslint-disable-next-line no-use-before-define
        var parsedBlock = parseBlock(block, addBroadcastMsg, getVariableId, extensions);
        if (typeof parsedBlock === 'undefined') continue;
        if (previousBlock) {
            parsedBlock.parent = previousBlock.id;
            previousBlock.next = parsedBlock.id;
        }
        previousBlock = parsedBlock;
        resultingList.push(parsedBlock);
    }
    return resultingList;
};

/**
 * Parse a Scratch object's scripts into VM blocks.
 * This should only handle top-level scripts that include X, Y coordinates.
 * @param {!object} scripts Scripts object from SB2 JSON.
 * @param {!Blocks} blocks Blocks object to load parsed blocks into.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 */
var parseScripts = function parseScripts(scripts, blocks, addBroadcastMsg, getVariableId, extensions) {
    for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        var scriptX = script[0];
        var scriptY = script[1];
        var blockList = script[2];
        var parsedBlockList = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions);
        if (parsedBlockList[0]) {
            // Adjust script coordinates to account for
            // larger block size in scratch-blocks.
            // @todo: Determine more precisely the right formulas here.
            parsedBlockList[0].x = scriptX * 1.5;
            parsedBlockList[0].y = scriptY * 2.2;
            parsedBlockList[0].topLevel = true;
            parsedBlockList[0].parent = null;
        }
        // Flatten children and create add the blocks.
        var convertedBlocks = flatten(parsedBlockList);
        for (var j = 0; j < convertedBlocks.length; j++) {
            blocks.createBlock(convertedBlocks[j]);
        }
    }
};

/**
 * Create a callback for assigning fixed IDs to imported variables
 * Generator stores the global variable mapping in a closure
 * @param {!string} targetId the id of the target to scope the variable to
 * @return {string} variable ID
 */
var generateVariableIdGetter = function () {
    var globalVariableNameMap = {};
    var namer = function namer(targetId, name) {
        return targetId + '-' + name;
    };
    return function (targetId, topLevel) {
        // Reset the global variable map if topLevel
        if (topLevel) globalVariableNameMap = {};
        return function (name) {
            if (topLevel) {
                // Store the name/id pair in the globalVariableNameMap
                globalVariableNameMap[name] = namer(targetId, name);
                return globalVariableNameMap[name];
            }
            // Not top-level, so first check the global name map
            if (globalVariableNameMap[name]) return globalVariableNameMap[name];
            return namer(targetId, name);
        };
    };
}();

var globalBroadcastMsgStateGenerator = function () {
    var broadcastMsgNameMap = {};
    return function (topLevel) {
        if (topLevel) broadcastMsgNameMap = {};
        return {
            broadcastMsgMapUpdater: function broadcastMsgMapUpdater(name) {
                broadcastMsgNameMap[name] = 'broadcastMsgId-' + name;
                return broadcastMsgNameMap[name];
            },
            globalBroadcastMsgs: broadcastMsgNameMap
        };
    };
}();

/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * TODO: parse the "info" section, especially "savedExtensions"
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.
 */
var parseScratchObject = function parseScratchObject(object, runtime, extensions, topLevel) {
    if (!object.hasOwnProperty('objName')) {
        // Watcher/monitor - skip this object until those are implemented in VM.
        // @todo
        return Promise.resolve(null);
    }
    // Blocks container for this object.
    var blocks = new Blocks();
    // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.
    var sprite = new Sprite(blocks, runtime);
    // Sprite/stage name from JSON.
    if (object.hasOwnProperty('objName')) {
        sprite.name = object.objName;
    }
    // Costumes from JSON.
    var costumePromises = [];
    if (object.hasOwnProperty('costumes')) {
        for (var i = 0; i < object.costumes.length; i++) {
            var costumeSource = object.costumes[i];
            var costume = {
                name: costumeSource.costumeName,
                bitmapResolution: costumeSource.bitmapResolution || 1,
                rotationCenterX: costumeSource.rotationCenterX,
                rotationCenterY: costumeSource.rotationCenterY,
                skinId: null
            };
            costumePromises.push(loadCostume(costumeSource.baseLayerMD5, costume, runtime));
        }
    }
    // Sounds from JSON
    var soundPromises = [];
    if (object.hasOwnProperty('sounds')) {
        for (var s = 0; s < object.sounds.length; s++) {
            var soundSource = object.sounds[s];
            var sound = {
                name: soundSource.soundName,
                format: soundSource.format,
                rate: soundSource.rate,
                sampleCount: soundSource.sampleCount,
                soundID: soundSource.soundID,
                md5: soundSource.md5,
                data: null
            };
            soundPromises.push(loadSound(sound, runtime));
        }
    }

    // Create the first clone, and load its run-state from JSON.
    var target = sprite.createClone();

    var getVariableId = generateVariableIdGetter(target.id, topLevel);

    var globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);
    var addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater;

    // Load target properties from JSON.
    if (object.hasOwnProperty('variables')) {
        for (var j = 0; j < object.variables.length; j++) {
            var variable = object.variables[j];
            var newVariable = new Variable(getVariableId(variable.name), variable.name, Variable.SCALAR_TYPE, variable.isPersistent);
            newVariable.value = variable.value;
            target.variables[newVariable.id] = newVariable;
        }
    }

    // If included, parse any and all scripts/blocks on the object.
    if (object.hasOwnProperty('scripts')) {
        parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions);
    }

    if (object.hasOwnProperty('lists')) {
        for (var k = 0; k < object.lists.length; k++) {
            var list = object.lists[k];
            // @todo: monitor properties.
            var _newVariable = new Variable(getVariableId(list.listName), list.listName, Variable.LIST_TYPE, false);
            _newVariable.value = list.contents;
            target.variables[_newVariable.id] = _newVariable;
        }
    }
    if (object.hasOwnProperty('scratchX')) {
        target.x = object.scratchX;
    }
    if (object.hasOwnProperty('scratchY')) {
        target.y = object.scratchY;
    }
    if (object.hasOwnProperty('direction')) {
        target.direction = object.direction;
    }
    if (object.hasOwnProperty('isDraggable')) {
        target.draggable = object.isDraggable;
    }
    if (object.hasOwnProperty('scale')) {
        // SB2 stores as 1.0 = 100%; we use % in the VM.
        target.size = object.scale * 100;
    }
    if (object.hasOwnProperty('visible')) {
        target.visible = object.visible;
    }
    if (object.hasOwnProperty('currentCostumeIndex')) {
        target.currentCostume = Math.round(object.currentCostumeIndex);
    }
    if (object.hasOwnProperty('rotationStyle')) {
        if (object.rotationStyle === 'none') {
            target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
        } else if (object.rotationStyle === 'leftRight') {
            target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
        } else if (object.rotationStyle === 'normal') {
            target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
        }
    }

    target.isStage = topLevel;

    Promise.all(costumePromises).then(function (costumes) {
        sprite.costumes = costumes;
    });

    Promise.all(soundPromises).then(function (sounds) {
        sprite.sounds = sounds;
    });

    // The stage will have child objects; recursively process them.
    var childrenPromises = [];
    if (object.children) {
        for (var m = 0; m < object.children.length; m++) {
            childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false));
        }
    }

    return Promise.all(costumePromises.concat(soundPromises)).then(function () {
        return Promise.all(childrenPromises).then(function (children) {
            // Need create broadcast msgs as variables after
            // all other targets have finished processing.
            if (target.isStage) {
                var allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;
                for (var msgName in allBroadcastMsgs) {
                    var msgId = allBroadcastMsgs[msgName];
                    var newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);
                    target.variables[newMsg.id] = newMsg;
                }
            }
            var targets = [target];
            for (var n = 0; n < children.length; n++) {
                targets = targets.concat(children[n]);
            }
            return targets;
        });
    });
};

/**
 * Top-level handler. Parse provided JSON,
 * and process the top-level object (the stage object).
 * @param {!object} json SB2-format JSON to load.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).
 * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.
 */
var sb2import = function sb2import(json, runtime, optForceSprite) {
    var extensions = {
        extensionIDs: new Set(),
        extensionURLs: new Map()
    };
    return parseScratchObject(json, runtime, extensions, !optForceSprite).then(function (targets) {
        return {
            targets: targets,
            extensions: extensions
        };
    });
};

/**
 * Parse a single SB2 JSON-formatted block and its children.
 * @param {!object} sb2block SB2 JSON-formatted block.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retrieve a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @return {object} Scratch VM format block, or null if unsupported object.
 */
var parseBlock = function parseBlock(sb2block, addBroadcastMsg, getVariableId, extensions) {
    // First item in block object is the old opcode (e.g., 'forward:').
    var oldOpcode = sb2block[0];
    // Convert the block using the specMap. See sb2specmap.js.
    if (!oldOpcode || !specMap[oldOpcode]) {
        log.warn('Couldn\'t find SB2 block: ', oldOpcode);
        return null;
    }
    var blockMetadata = specMap[oldOpcode];
    // If the block is from an extension, record it.
    var dotIndex = blockMetadata.opcode.indexOf('.');
    if (dotIndex >= 0) {
        var extension = blockMetadata.opcode.substring(0, dotIndex);
        extensions.extensionIDs.add(extension);
    }
    // Block skeleton.
    var activeBlock = {
        id: uid(), // Generate a new block unique ID.
        opcode: blockMetadata.opcode, // Converted, e.g. "motion_movesteps".
        inputs: {}, // Inputs to this block and the blocks they point to.
        fields: {}, // Fields on this block and their values.
        next: null, // Next block.
        shadow: false, // No shadow blocks in an SB2 by default.
        children: [] // Store any generated children, flattened in `flatten`.
    };
    // For a procedure call, generate argument map from proc string.
    if (oldOpcode === 'call') {
        blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);
    }
    // Look at the expected arguments in `blockMetadata.argMap.`
    // The basic problem here is to turn positional SB2 arguments into
    // non-positional named Scratch VM arguments.
    for (var i = 0; i < blockMetadata.argMap.length; i++) {
        var expectedArg = blockMetadata.argMap[i];
        var providedArg = sb2block[i + 1]; // (i = 0 is opcode)
        // Whether the input is obscuring a shadow.
        var shadowObscured = false;
        // Positional argument is an input.
        if (expectedArg.type === 'input') {
            // Create a new block and input metadata.
            var inputUid = uid();
            activeBlock.inputs[expectedArg.inputName] = {
                name: expectedArg.inputName,
                block: null,
                shadow: null
            };
            if ((typeof providedArg === 'undefined' ? 'undefined' : _typeof(providedArg)) === 'object' && providedArg) {
                // Block or block list occupies the input.
                var innerBlocks = void 0;
                if (_typeof(providedArg[0]) === 'object' && providedArg[0]) {
                    // Block list occupies the input.
                    innerBlocks = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions);
                } else {
                    // Single block occupies the input.
                    innerBlocks = [parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions)];
                }
                var previousBlock = null;
                for (var j = 0; j < innerBlocks.length; j++) {
                    if (j === 0) {
                        innerBlocks[j].parent = activeBlock.id;
                    } else {
                        innerBlocks[j].parent = previousBlock;
                    }
                    previousBlock = innerBlocks[j].id;
                }
                // Obscures any shadow.
                shadowObscured = true;
                activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;
                activeBlock.children = activeBlock.children.concat(innerBlocks);
            }
            // Generate a shadow block to occupy the input.
            if (!expectedArg.inputOp) {
                // No editable shadow input; e.g., for a boolean.
                continue;
            }
            // Each shadow has a field generated for it automatically.
            // Value to be filled in the field.
            var fieldValue = providedArg;
            // Shadows' field names match the input name, except for these:
            var fieldName = expectedArg.inputName;
            if (expectedArg.inputOp === 'math_number' || expectedArg.inputOp === 'math_whole_number' || expectedArg.inputOp === 'math_positive_number' || expectedArg.inputOp === 'math_integer' || expectedArg.inputOp === 'math_angle') {
                fieldName = 'NUM';
                // Fields are given Scratch 2.0 default values if obscured.
                if (shadowObscured) {
                    fieldValue = 10;
                }
            } else if (expectedArg.inputOp === 'text') {
                fieldName = 'TEXT';
                if (shadowObscured) {
                    fieldValue = '';
                }
            } else if (expectedArg.inputOp === 'colour_picker') {
                // Convert SB2 color to hex.
                fieldValue = Color.decimalToHex(providedArg);
                fieldName = 'COLOUR';
                if (shadowObscured) {
                    fieldValue = '#990000';
                }
            } else if (shadowObscured) {
                // Filled drop-down menu.
                fieldValue = '';
            }
            var fields = {};
            fields[fieldName] = {
                name: fieldName,
                value: fieldValue
            };
            activeBlock.children.push({
                id: inputUid,
                opcode: expectedArg.inputOp,
                inputs: {},
                fields: fields,
                next: null,
                topLevel: false,
                parent: activeBlock.id,
                shadow: true
            });
            activeBlock.inputs[expectedArg.inputName].shadow = inputUid;
            // If no block occupying the input, alias to the shadow.
            if (!activeBlock.inputs[expectedArg.inputName].block) {
                activeBlock.inputs[expectedArg.inputName].block = inputUid;
            }
        } else if (expectedArg.type === 'field') {
            // Add as a field on this block.
            activeBlock.fields[expectedArg.fieldName] = {
                name: expectedArg.fieldName,
                value: providedArg
            };

            if (expectedArg.fieldName === 'VARIABLE' || expectedArg.fieldName === 'LIST') {
                // Add `id` property to variable fields
                activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg);
            } else if (expectedArg.fieldName === 'BROADCAST_OPTION') {
                // add the name in this field to the broadcast msg name map
                var broadcastId = addBroadcastMsg(providedArg);
                activeBlock.fields[expectedArg.fieldName].id = broadcastId;
            }
            var varType = expectedArg.variableType;
            if (typeof varType === 'string') {
                activeBlock.fields[expectedArg.fieldName].variableType = varType;
            }
        }
    }
    // Special cases to generate mutations.
    if (oldOpcode === 'stopScripts') {
        // Mutation for stop block: if the argument is 'other scripts',
        // the block needs a next connection.
        if (sb2block[1] === 'other scripts in sprite' || sb2block[1] === 'other scripts in stage') {
            activeBlock.mutation = {
                tagName: 'mutation',
                hasnext: 'true',
                children: []
            };
        }
    } else if (oldOpcode === 'procDef') {
        // Mutation for procedure definition:
        // store all 2.0 proc data.
        var procData = sb2block.slice(1);
        // Create a new block and input metadata.
        var _inputUid = uid();
        var inputName = 'custom_block';
        activeBlock.inputs[inputName] = {
            name: inputName,
            block: _inputUid,
            shadow: _inputUid
        };
        activeBlock.children = [{
            id: _inputUid,
            opcode: 'procedures_prototype',
            inputs: {},
            fields: {},
            next: null,
            shadow: true,
            children: [],
            mutation: {
                tagName: 'mutation',
                proccode: procData[0], // e.g., "abc %n %b %s"
                argumentnames: JSON.stringify(procData[1]), // e.g. ['arg1', 'arg2']
                argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),
                argumentdefaults: JSON.stringify(procData[2]), // e.g., [1, 'abc']
                warp: procData[3], // Warp mode, e.g., true/false.
                children: []
            }
        }];
    } else if (oldOpcode === 'call') {
        // Mutation for procedure call:
        // string for proc code (e.g., "abc %n %b %s").
        activeBlock.mutation = {
            tagName: 'mutation',
            children: [],
            proccode: sb2block[1],
            argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))
        };
    } else if (oldOpcode === 'getParam') {
        // Assign correct opcode based on the block shape.
        switch (sb2block[2]) {
            case 'r':
                activeBlock.opcode = 'argument_reporter_string_number';
                break;
            case 'b':
                activeBlock.opcode = 'argument_reporter_boolean';
                break;
        }
    }
    return activeBlock;
};

module.exports = {
    deserialize: sb2import
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @fileoverview
 * The specMap below handles a few pieces of "translation" work between
 * the SB2 JSON format and the data we need to run a project
 * in the Scratch 3.0 VM.
 * Notably:
 *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).
 *  - Map ordered, unnamed args to unordered, named inputs and fields.
 * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.
 * Originally this was generated largely by a hand-guided scripting process.
 * The relevant data lives here:
 * https://github.com/LLK/scratch-flash/blob/master/src/Specs.as
 * (for the old opcode and argument order).
 * and here:
 * https://github.com/LLK/scratch-blocks/tree/develop/blocks_vertical
 * (for the new opcodes and argument names).
 * and here:
 * https://github.com/LLK/scratch-blocks/blob/develop/tests/
 * (for the shadow blocks created for each block).
 * I started with the `commands` array in Specs.as, and discarded irrelevant
 * properties. By hand, I matched the opcode name to the 3.0 opcode.
 * Finally, I filled in the expected arguments as below.
 */

var Variable = __webpack_require__(18);

/**
 * @typedef {object} SB2SpecMap_blockInfo
 * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.
 * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.
 */

/**
 * @typedef {object} SB2SpecMap_argInfo
 * @property {string} type - the type of this arg (such as 'input' or 'field')
 * @property {string} inputOp - the scratch-blocks shadow type for this arg
 * @property {string} inputName - the name this argument will take when provided to the block implementation
 */

/**
 * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.
 * @type {object.<SB2SpecMap_blockInfo>}
 */
var specMap = {
    'forward:': {
        opcode: 'motion_movesteps',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'STEPS'
        }]
    },
    'turnRight:': {
        opcode: 'motion_turnright',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'DEGREES'
        }]
    },
    'turnLeft:': {
        opcode: 'motion_turnleft',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'DEGREES'
        }]
    },
    'heading:': {
        opcode: 'motion_pointindirection',
        argMap: [{
            type: 'input',
            inputOp: 'math_angle',
            inputName: 'DIRECTION'
        }]
    },
    'pointTowards:': {
        opcode: 'motion_pointtowards',
        argMap: [{
            type: 'input',
            inputOp: 'motion_pointtowards_menu',
            inputName: 'TOWARDS'
        }]
    },
    'gotoX:y:': {
        opcode: 'motion_gotoxy',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'X'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'Y'
        }]
    },
    'gotoSpriteOrMouse:': {
        opcode: 'motion_goto',
        argMap: [{
            type: 'input',
            inputOp: 'motion_goto_menu',
            inputName: 'TO'
        }]
    },
    'glideSecs:toX:y:elapsed:from:': {
        opcode: 'motion_glidesecstoxy',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SECS'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'X'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'Y'
        }]
    },
    'changeXposBy:': {
        opcode: 'motion_changexby',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'DX'
        }]
    },
    'xpos:': {
        opcode: 'motion_setx',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'X'
        }]
    },
    'changeYposBy:': {
        opcode: 'motion_changeyby',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'DY'
        }]
    },
    'ypos:': {
        opcode: 'motion_sety',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'Y'
        }]
    },
    'bounceOffEdge': {
        opcode: 'motion_ifonedgebounce',
        argMap: []
    },
    'setRotationStyle': {
        opcode: 'motion_setrotationstyle',
        argMap: [{
            type: 'field',
            fieldName: 'STYLE'
        }]
    },
    'xpos': {
        opcode: 'motion_xposition',
        argMap: []
    },
    'ypos': {
        opcode: 'motion_yposition',
        argMap: []
    },
    'heading': {
        opcode: 'motion_direction',
        argMap: []
    },
    'say:duration:elapsed:from:': {
        opcode: 'looks_sayforsecs',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'MESSAGE'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SECS'
        }]
    },
    'say:': {
        opcode: 'looks_say',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'MESSAGE'
        }]
    },
    'think:duration:elapsed:from:': {
        opcode: 'looks_thinkforsecs',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'MESSAGE'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SECS'
        }]
    },
    'think:': {
        opcode: 'looks_think',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'MESSAGE'
        }]
    },
    'show': {
        opcode: 'looks_show',
        argMap: []
    },
    'hide': {
        opcode: 'looks_hide',
        argMap: []
    },
    'lookLike:': {
        opcode: 'looks_switchcostumeto',
        argMap: [{
            type: 'input',
            inputOp: 'looks_costume',
            inputName: 'COSTUME'
        }]
    },
    'nextCostume': {
        opcode: 'looks_nextcostume',
        argMap: []
    },
    'startScene': {
        opcode: 'looks_switchbackdropto',
        argMap: [{
            type: 'input',
            inputOp: 'looks_backdrops',
            inputName: 'BACKDROP'
        }]
    },
    'changeGraphicEffect:by:': {
        opcode: 'looks_changeeffectby',
        argMap: [{
            type: 'field',
            fieldName: 'EFFECT'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'CHANGE'
        }]
    },
    'setGraphicEffect:to:': {
        opcode: 'looks_seteffectto',
        argMap: [{
            type: 'field',
            fieldName: 'EFFECT'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'VALUE'
        }]
    },
    'filterReset': {
        opcode: 'looks_cleargraphiceffects',
        argMap: []
    },
    'changeSizeBy:': {
        opcode: 'looks_changesizeby',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'CHANGE'
        }]
    },
    'setSizeTo:': {
        opcode: 'looks_setsizeto',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SIZE'
        }]
    },
    'comeToFront': {
        opcode: 'looks_gotofront',
        argMap: []
    },
    'goBackByLayers:': {
        opcode: 'looks_gobacklayers',
        argMap: [{
            type: 'input',
            inputOp: 'math_integer',
            inputName: 'NUM'
        }]
    },
    'costumeIndex': {
        opcode: 'looks_costumeorder',
        argMap: []
    },
    'sceneName': {
        opcode: 'looks_backdropname',
        argMap: []
    },
    'scale': {
        opcode: 'looks_size',
        argMap: []
    },
    'startSceneAndWait': {
        opcode: 'looks_switchbackdroptoandwait',
        argMap: [{
            type: 'input',
            inputOp: 'looks_backdrops',
            inputName: 'BACKDROP'
        }]
    },
    'nextScene': {
        opcode: 'looks_nextbackdrop',
        argMap: []
    },
    'backgroundIndex': {
        opcode: 'looks_backdroporder',
        argMap: []
    },
    'playSound:': {
        opcode: 'sound_play',
        argMap: [{
            type: 'input',
            inputOp: 'sound_sounds_menu',
            inputName: 'SOUND_MENU'
        }]
    },
    'doPlaySoundAndWait': {
        opcode: 'sound_playuntildone',
        argMap: [{
            type: 'input',
            inputOp: 'sound_sounds_menu',
            inputName: 'SOUND_MENU'
        }]
    },
    'stopAllSounds': {
        opcode: 'sound_stopallsounds',
        argMap: []
    },
    'playDrum': {
        opcode: 'music.playDrumForBeats',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'DRUM'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'BEATS'
        }]
    },
    'rest:elapsed:from:': {
        opcode: 'music.restForBeats',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'BEATS'
        }]
    },
    'noteOn:duration:elapsed:from:': {
        opcode: 'music.playNoteForBeats',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NOTE'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'BEATS'
        }]
    },
    'instrument:': {
        opcode: 'music.setInstrument',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'INSTRUMENT'
        }]
    },
    'changeVolumeBy:': {
        opcode: 'sound_changevolumeby',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'VOLUME'
        }]
    },
    'setVolumeTo:': {
        opcode: 'sound_setvolumeto',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'VOLUME'
        }]
    },
    'volume': {
        opcode: 'sound_volume',
        argMap: []
    },
    'changeTempoBy:': {
        opcode: 'music.changeTempo',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'TEMPO'
        }]
    },
    'setTempoTo:': {
        opcode: 'music.setTempo',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'TEMPO'
        }]
    },
    'tempo': {
        opcode: 'music.getTempo',
        argMap: []
    },
    'clearPenTrails': {
        opcode: 'pen.clear',
        argMap: []
    },
    'stampCostume': {
        opcode: 'pen.stamp',
        argMap: []
    },
    'putPenDown': {
        opcode: 'pen.penDown',
        argMap: []
    },
    'putPenUp': {
        opcode: 'pen.penUp',
        argMap: []
    },
    'penColor:': {
        opcode: 'pen.setPenColorToColor',
        argMap: [{
            type: 'input',
            inputOp: 'colour_picker',
            inputName: 'COLOR'
        }]
    },
    'changePenHueBy:': {
        opcode: 'pen.changePenHueBy',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'HUE'
        }]
    },
    'setPenHueTo:': {
        opcode: 'pen.setPenHueToNumber',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'HUE'
        }]
    },
    'changePenShadeBy:': {
        opcode: 'pen.changePenShadeBy',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SHADE'
        }]
    },
    'setPenShadeTo:': {
        opcode: 'pen.setPenShadeToNumber',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SHADE'
        }]
    },
    'changePenSizeBy:': {
        opcode: 'pen.changePenSizeBy',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SIZE'
        }]
    },
    'penSize:': {
        opcode: 'pen.setPenSizeTo',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'SIZE'
        }]
    },
    'whenGreenFlag': {
        opcode: 'event_whenflagclicked',
        argMap: []
    },
    'whenKeyPressed': {
        opcode: 'event_whenkeypressed',
        argMap: [{
            type: 'field',
            fieldName: 'KEY_OPTION'
        }]
    },
    'whenClicked': {
        opcode: 'event_whenthisspriteclicked',
        argMap: []
    },
    'whenSceneStarts': {
        opcode: 'event_whenbackdropswitchesto',
        argMap: [{
            type: 'field',
            fieldName: 'BACKDROP'
        }]
    },
    'whenSensorGreaterThan': {
        opcode: 'event_whengreaterthan',
        argMap: [{
            type: 'field',
            fieldName: 'WHENGREATERTHANMENU'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'VALUE'
        }]
    },
    'whenIReceive': {
        opcode: 'event_whenbroadcastreceived',
        argMap: [{
            type: 'field',
            fieldName: 'BROADCAST_OPTION',
            variableType: Variable.BROADCAST_MESSAGE_TYPE
        }]
    },
    'broadcast:': {
        opcode: 'event_broadcast',
        argMap: [{
            type: 'field',
            fieldName: 'BROADCAST_OPTION',
            variableType: Variable.BROADCAST_MESSAGE_TYPE
        }]
    },
    'doBroadcastAndWait': {
        opcode: 'event_broadcastandwait',
        argMap: [{
            type: 'field',
            fieldName: 'BROADCAST_OPTION',
            variableType: Variable.BROADCAST_MESSAGE_TYPE
        }]
    },
    'wait:elapsed:from:': {
        opcode: 'control_wait',
        argMap: [{
            type: 'input',
            inputOp: 'math_positive_number',
            inputName: 'DURATION'
        }]
    },
    'doRepeat': {
        opcode: 'control_repeat',
        argMap: [{
            type: 'input',
            inputOp: 'math_whole_number',
            inputName: 'TIMES'
        }, {
            type: 'input',
            inputName: 'SUBSTACK'
        }]
    },
    'doForever': {
        opcode: 'control_forever',
        argMap: [{
            type: 'input',
            inputName: 'SUBSTACK'
        }]
    },
    'doIf': {
        opcode: 'control_if',
        argMap: [{
            type: 'input',
            inputName: 'CONDITION'
        }, {
            type: 'input',
            inputName: 'SUBSTACK'
        }]
    },
    'doIfElse': {
        opcode: 'control_if_else',
        argMap: [{
            type: 'input',
            inputName: 'CONDITION'
        }, {
            type: 'input',
            inputName: 'SUBSTACK'
        }, {
            type: 'input',
            inputName: 'SUBSTACK2'
        }]
    },
    'doWaitUntil': {
        opcode: 'control_wait_until',
        argMap: [{
            type: 'input',
            inputName: 'CONDITION'
        }]
    },
    'doUntil': {
        opcode: 'control_repeat_until',
        argMap: [{
            type: 'input',
            inputName: 'CONDITION'
        }, {
            type: 'input',
            inputName: 'SUBSTACK'
        }]
    },
    'stopScripts': {
        opcode: 'control_stop',
        argMap: [{
            type: 'field',
            fieldName: 'STOP_OPTION'
        }]
    },
    'whenCloned': {
        opcode: 'control_start_as_clone',
        argMap: []
    },
    'createCloneOf': {
        opcode: 'control_create_clone_of',
        argMap: [{
            type: 'input',
            inputOp: 'control_create_clone_of_menu',
            inputName: 'CLONE_OPTION'
        }]
    },
    'deleteClone': {
        opcode: 'control_delete_this_clone',
        argMap: []
    },
    'touching:': {
        opcode: 'sensing_touchingobject',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_touchingobjectmenu',
            inputName: 'TOUCHINGOBJECTMENU'
        }]
    },
    'touchingColor:': {
        opcode: 'sensing_touchingcolor',
        argMap: [{
            type: 'input',
            inputOp: 'colour_picker',
            inputName: 'COLOR'
        }]
    },
    'color:sees:': {
        opcode: 'sensing_coloristouchingcolor',
        argMap: [{
            type: 'input',
            inputOp: 'colour_picker',
            inputName: 'COLOR'
        }, {
            type: 'input',
            inputOp: 'colour_picker',
            inputName: 'COLOR2'
        }]
    },
    'distanceTo:': {
        opcode: 'sensing_distanceto',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_distancetomenu',
            inputName: 'DISTANCETOMENU'
        }]
    },
    'doAsk': {
        opcode: 'sensing_askandwait',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'QUESTION'
        }]
    },
    'answer': {
        opcode: 'sensing_answer',
        argMap: []
    },
    'keyPressed:': {
        opcode: 'sensing_keypressed',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_keyoptions',
            inputName: 'KEY_OPTION'
        }]
    },
    'mousePressed': {
        opcode: 'sensing_mousedown',
        argMap: []
    },
    'mouseX': {
        opcode: 'sensing_mousex',
        argMap: []
    },
    'mouseY': {
        opcode: 'sensing_mousey',
        argMap: []
    },
    'soundLevel': {
        opcode: 'sensing_loudness',
        argMap: []
    },
    'senseVideoMotion': {
        opcode: 'sensing_videoon',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_videoonmenuone',
            inputName: 'VIDEOONMENU1'
        }, {
            type: 'input',
            inputOp: 'sensing_videoonmenutwo',
            inputName: 'VIDEOONMENU2'
        }]
    },
    'setVideoState': {
        opcode: 'sensing_videotoggle',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_videotogglemenu',
            inputName: 'VIDEOTOGGLEMENU'
        }]
    },
    'setVideoTransparency': {
        opcode: 'sensing_setvideotransparency',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'TRANSPARENCY'
        }]
    },
    'timer': {
        opcode: 'sensing_timer',
        argMap: []
    },
    'timerReset': {
        opcode: 'sensing_resettimer',
        argMap: []
    },
    'getAttribute:of:': {
        opcode: 'sensing_of',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_of_property_menu',
            inputName: 'PROPERTY'
        }, {
            type: 'input',
            inputOp: 'sensing_of_object_menu',
            inputName: 'OBJECT'
        }]
    },
    'timeAndDate': {
        opcode: 'sensing_current',
        argMap: [{
            type: 'input',
            inputOp: 'sensing_currentmenu',
            inputName: 'CURRENTMENU'
        }]
    },
    'timestamp': {
        opcode: 'sensing_dayssince2000',
        argMap: []
    },
    'getUserName': {
        opcode: 'sensing_username',
        argMap: []
    },
    '+': {
        opcode: 'operator_add',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM1'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM2'
        }]
    },
    '-': {
        opcode: 'operator_subtract',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM1'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM2'
        }]
    },
    '*': {
        opcode: 'operator_multiply',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM1'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM2'
        }]
    },
    '/': {
        opcode: 'operator_divide',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM1'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM2'
        }]
    },
    'randomFrom:to:': {
        opcode: 'operator_random',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'FROM'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'TO'
        }]
    },
    '<': {
        opcode: 'operator_lt',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND1'
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND2'
        }]
    },
    '=': {
        opcode: 'operator_equals',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND1'
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND2'
        }]
    },
    '>': {
        opcode: 'operator_gt',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND1'
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'OPERAND2'
        }]
    },
    '&': {
        opcode: 'operator_and',
        argMap: [{
            type: 'input',
            inputName: 'OPERAND1'
        }, {
            type: 'input',
            inputName: 'OPERAND2'
        }]
    },
    '|': {
        opcode: 'operator_or',
        argMap: [{
            type: 'input',
            inputName: 'OPERAND1'
        }, {
            type: 'input',
            inputName: 'OPERAND2'
        }]
    },
    'not': {
        opcode: 'operator_not',
        argMap: [{
            type: 'input',
            inputName: 'OPERAND'
        }]
    },
    'concatenate:with:': {
        opcode: 'operator_join',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'STRING1'
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'STRING2'
        }]
    },
    'letter:of:': {
        opcode: 'operator_letter_of',
        argMap: [{
            type: 'input',
            inputOp: 'math_whole_number',
            inputName: 'LETTER'
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'STRING'
        }]
    },
    'stringLength:': {
        opcode: 'operator_length',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'STRING'
        }]
    },
    '%': {
        opcode: 'operator_mod',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM1'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM2'
        }]
    },
    'rounded': {
        opcode: 'operator_round',
        argMap: [{
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM'
        }]
    },
    'computeFunction:of:': {
        opcode: 'operator_mathop',
        argMap: [{
            type: 'field',
            fieldName: 'OPERATOR'
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'NUM'
        }]
    },
    'readVariable': {
        opcode: 'data_variable',
        argMap: [{
            type: 'field',
            fieldName: 'VARIABLE',
            variableType: Variable.SCALAR_TYPE
        }]
    },
    'setVar:to:': {
        opcode: 'data_setvariableto',
        argMap: [{
            type: 'field',
            fieldName: 'VARIABLE',
            variableType: Variable.SCALAR_TYPE
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'VALUE'
        }]
    },
    'changeVar:by:': {
        opcode: 'data_changevariableby',
        argMap: [{
            type: 'field',
            fieldName: 'VARIABLE',
            variableType: Variable.SCALAR_TYPE
        }, {
            type: 'input',
            inputOp: 'math_number',
            inputName: 'VALUE'
        }]
    },
    'showVariable:': {
        opcode: 'data_showvariable',
        argMap: [{
            type: 'field',
            fieldName: 'VARIABLE',
            variableType: Variable.SCALAR_TYPE
        }]
    },
    'hideVariable:': {
        opcode: 'data_hidevariable',
        argMap: [{
            type: 'field',
            fieldName: 'VARIABLE',
            variableType: Variable.SCALAR_TYPE
        }]
    },
    'contentsOfList:': {
        opcode: 'data_listcontents',
        argMap: [{
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'append:toList:': {
        opcode: 'data_addtolist',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'ITEM'
        }, {
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'deleteLine:ofList:': {
        opcode: 'data_deleteoflist',
        argMap: [{
            type: 'input',
            inputOp: 'math_integer',
            inputName: 'INDEX'
        }, {
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'insert:at:ofList:': {
        opcode: 'data_insertatlist',
        argMap: [{
            type: 'input',
            inputOp: 'text',
            inputName: 'ITEM'
        }, {
            type: 'input',
            inputOp: 'math_integer',
            inputName: 'INDEX'
        }, {
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'setLine:ofList:to:': {
        opcode: 'data_replaceitemoflist',
        argMap: [{
            type: 'input',
            inputOp: 'math_integer',
            inputName: 'INDEX'
        }, {
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'ITEM'
        }]
    },
    'getLine:ofList:': {
        opcode: 'data_itemoflist',
        argMap: [{
            type: 'input',
            inputOp: 'math_integer',
            inputName: 'INDEX'
        }, {
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'lineCountOfList:': {
        opcode: 'data_lengthoflist',
        argMap: [{
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'list:contains:': {
        opcode: 'data_listcontainsitem',
        argMap: [{
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }, {
            type: 'input',
            inputOp: 'text',
            inputName: 'ITEM'
        }]
    },
    'showList:': {
        opcode: 'data_showlist',
        argMap: [{
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'hideList:': {
        opcode: 'data_hidelist',
        argMap: [{
            type: 'field',
            fieldName: 'LIST',
            variableType: Variable.LIST_TYPE
        }]
    },
    'procDef': {
        opcode: 'procedures_definition',
        argMap: []
    },
    'getParam': {
        // Doesn't map to single opcode. Import step assigns final correct opcode.
        opcode: 'argument_reporter_string_number',
        argMap: [{
            type: 'field',
            fieldName: 'VALUE'
        }]
    },
    'call': {
        opcode: 'procedures_call',
        argMap: []
    }
};

/**
 * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same
 * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.
 * @param {string} sb2Extension - the Scratch 2.0 name of the extension
 * @param {string} sb2Opcode - the Scratch 2.0 opcode
 * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info
 */
var addExtensionOp = function addExtensionOp(sb2Extension, sb2Opcode, blockInfo) {
    /**
     * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.
     * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...
     * @type {string}
     */
    var sep = '\x1F'; // Unicode Unit Separator

    // make one entry for projects saved by recent versions of the Scratch 2.0 editor
    specMap['' + sb2Extension + sep + sb2Opcode] = blockInfo;

    // make a second for projects saved by older versions of the Scratch 2.0 editor
    specMap[sb2Extension + '.' + sb2Opcode] = blockInfo;
};

var weDo2 = 'LEGO WeDo 2.0';

addExtensionOp(weDo2, 'motorOnFor', {
    opcode: 'wedo2.motorOnFor',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.motorID',
        inputName: 'MOTOR_ID'
    }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'DURATION'
    }]
});

addExtensionOp(weDo2, 'motorOn', {
    opcode: 'wedo2.motorOn',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.motorID',
        inputName: 'MOTOR_ID'
    }]
});

addExtensionOp(weDo2, 'motorOff', {
    opcode: 'wedo2.motorOff',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.motorID',
        inputName: 'MOTOR_ID'
    }]
});

addExtensionOp(weDo2, 'startMotorPower', {
    opcode: 'wedo2.startMotorPower',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.motorID',
        inputName: 'MOTOR_ID'
    }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'POWER'
    }]
});

addExtensionOp(weDo2, 'setMotorDirection', {
    opcode: 'wedo2.setMotorDirection',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.motorID',
        inputName: 'MOTOR_ID'
    }, {
        type: 'input',
        inputOp: 'wedo2.menu.motorDirection',
        inputName: 'DIRECTION'
    }]
});

addExtensionOp(weDo2, 'setLED', {
    opcode: 'wedo2.setLightHue',
    argMap: [{
        type: 'input',
        inputOp: 'math_number',
        inputName: 'HUE'
    }]
});

addExtensionOp(weDo2, 'playNote', {
    opcode: 'wedo2.playNoteFor',
    argMap: [{
        type: 'input',
        inputOp: 'math_number',
        inputName: 'NOTE'
    }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'DURATION'
    }]
});

addExtensionOp(weDo2, 'whenDistance', {
    opcode: 'wedo2.whenDistance',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.lessMore',
        inputName: 'OP'
    }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'REFERENCE'
    }]
});

addExtensionOp(weDo2, 'whenTilted', {
    opcode: 'wedo2.whenTilted',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.tiltDirectionAny',
        inputName: 'DIRECTION'
    }]
});

addExtensionOp(weDo2, 'getDistance', {
    opcode: 'wedo2.getDistance',
    argMap: []
});

addExtensionOp(weDo2, 'isTilted', {
    opcode: 'wedo2.isTilted',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.tiltDirectionAny',
        inputName: 'DIRECTION'
    }]
});

addExtensionOp(weDo2, 'getTilt', {
    opcode: 'wedo2.getTiltAngle',
    argMap: [{
        type: 'input',
        inputOp: 'wedo2.menu.tiltDirection',
        inputName: 'DIRECTION'
    }]
});

module.exports = specMap;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @fileoverview
 * Partial implementation of a SB3 serializer and deserializer. Parses provided
 * JSON and then generates all needed scratch-vm runtime structures.
 */

var vmPackage = __webpack_require__(149);
var Blocks = __webpack_require__(10);
var Sprite = __webpack_require__(39);
var Variable = __webpack_require__(18);

var _require = __webpack_require__(20),
    loadCostume = _require.loadCostume;

var _require2 = __webpack_require__(21),
    loadSound = _require2.loadSound;

/**
 * @typedef {object} ImportedProject
 * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.
 * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.
 */

/**
 * @typedef {object} ImportedExtensionsInfo
 * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.
 * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.
 */

/**
 * Serializes the specified VM runtime.
 * @param  {!Runtime} runtime VM runtime instance to be serialized.
 * @return {object}    Serialized runtime instance.
 */


var serialize = function serialize(runtime) {
    // Fetch targets
    var obj = Object.create(null);
    obj.targets = runtime.targets.filter(function (target) {
        return target.isOriginal;
    });

    // Assemble metadata
    var meta = Object.create(null);
    meta.semver = '3.0.0';
    meta.vm = vmPackage.version;

    // Attach full user agent string to metadata if available
    meta.agent = null;
    if (typeof navigator !== 'undefined') meta.agent = navigator.userAgent;

    // Assemble payload and return
    obj.meta = meta;
    return obj;
};

/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.
 */
var parseScratchObject = function parseScratchObject(object, runtime, extensions) {
    if (!object.hasOwnProperty('name')) {
        // Watcher/monitor - skip this object until those are implemented in VM.
        // @todo
        return Promise.resolve(null);
    }
    // Blocks container for this object.
    var blocks = new Blocks();

    // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.
    var sprite = new Sprite(blocks, runtime);

    // Sprite/stage name from JSON.
    if (object.hasOwnProperty('name')) {
        sprite.name = object.name;
    }
    if (object.hasOwnProperty('blocks')) {
        for (var blockId in object.blocks) {
            var blockJSON = object.blocks[blockId];
            blocks.createBlock(blockJSON);

            var dotIndex = blockJSON.opcode.indexOf('.');
            if (dotIndex >= 0) {
                var extensionId = blockJSON.opcode.substring(0, dotIndex);
                extensions.extensionIDs.add(extensionId);
            }
        }
        // console.log(blocks);
    }
    // Costumes from JSON.
    var costumePromises = (object.costumes || []).map(function (costumeSource) {
        // @todo: Make sure all the relevant metadata is being pulled out.
        var costume = {
            skinId: null,
            name: costumeSource.name,
            bitmapResolution: costumeSource.bitmapResolution,
            rotationCenterX: costumeSource.rotationCenterX,
            rotationCenterY: costumeSource.rotationCenterY
        };
        var dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || // older format
        'png'; // if all else fails, guess that it might be a PNG
        var costumeMd5 = costumeSource.assetId + '.' + dataFormat;
        return loadCostume(costumeMd5, costume, runtime);
    });
    // Sounds from JSON
    var soundPromises = (object.sounds || []).map(function (soundSource) {
        var sound = {
            format: soundSource.format,
            fileUrl: soundSource.fileUrl,
            rate: soundSource.rate,
            sampleCount: soundSource.sampleCount,
            soundID: soundSource.soundID,
            name: soundSource.name,
            md5: soundSource.md5,
            data: null
        };
        return loadSound(sound, runtime);
    });
    // Create the first clone, and load its run-state from JSON.
    var target = sprite.createClone();
    // Load target properties from JSON.
    if (object.hasOwnProperty('variables')) {
        for (var j in object.variables) {
            var variable = object.variables[j];
            var newVariable = new Variable(variable.id, variable.name, variable.type, variable.isPersistent);
            newVariable.value = variable.value;
            target.variables[newVariable.id] = newVariable;
        }
    }
    if (object.hasOwnProperty('x')) {
        target.x = object.x;
    }
    if (object.hasOwnProperty('y')) {
        target.y = object.y;
    }
    if (object.hasOwnProperty('direction')) {
        target.direction = object.direction;
    }
    if (object.hasOwnProperty('size')) {
        target.size = object.size;
    }
    if (object.hasOwnProperty('visible')) {
        target.visible = object.visible;
    }
    if (object.hasOwnProperty('currentCostume')) {
        target.currentCostume = object.currentCostume;
    }
    if (object.hasOwnProperty('rotationStyle')) {
        target.rotationStyle = object.rotationStyle;
    }
    if (object.hasOwnProperty('isStage')) {
        target.isStage = object.isStage;
    }
    Promise.all(costumePromises).then(function (costumes) {
        sprite.costumes = costumes;
    });
    Promise.all(soundPromises).then(function (sounds) {
        sprite.sounds = sounds;
    });
    return Promise.all(costumePromises.concat(soundPromises)).then(function () {
        return target;
    });
};

/**
 * Deserialize the specified representation of a VM runtime and loads it into the provided runtime instance.
 * TODO: parse extension info (also, design extension info storage...)
 * @param  {object} json - JSON representation of a VM runtime.
 * @param  {Runtime} runtime - Runtime instance
 * @returns {Promise.<ImportedProject>} Promise that resolves to the list of targets after the project is deserialized
 */
var deserialize = function deserialize(json, runtime) {
    var extensions = {
        extensionIDs: new Set(),
        extensionURLs: new Map()
    };
    return Promise.all((json.targets || []).map(function (target) {
        return parseScratchObject(target, runtime, extensions);
    })).then(function (targets) {
        return {
            targets: targets,
            extensions: extensions
        };
    });
};

module.exports = {
    serialize: serialize,
    deserialize: deserialize
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Escape a string to be safe to use in XML content.
 * CC-BY-SA: hgoebl
 * https://stackoverflow.com/questions/7918868/
 * how-to-escape-xml-entities-in-javascript
 * @param {!string} unsafe Unsafe string.
 * @return {string} XML-escaped string, for use within an XML tag.
 */
var xmlEscape = function xmlEscape(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            case '\'':
                return '&apos;';
            case '"':
                return '&quot;';
        }
    });
};

module.exports = xmlEscape;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = __webpack_require__(4);

var centralDispatch = __webpack_require__(37);
var ExtensionManager = __webpack_require__(79);
var log = __webpack_require__(1);
var Runtime = __webpack_require__(76);
var sb2 = __webpack_require__(87);
var sb3 = __webpack_require__(89);
var StringUtil = __webpack_require__(13);

var _require = __webpack_require__(20),
    loadCostume = _require.loadCostume;

var _require2 = __webpack_require__(21),
    loadSound = _require2.loadSound;

var RESERVED_NAMES = ['_mouse_', '_stage_', '_edge_', '_myself_', '_random_'];

/**
 * Handles connections between blocks, stage, and extensions.
 * @constructor
 */

var VirtualMachine = function (_EventEmitter) {
    _inherits(VirtualMachine, _EventEmitter);

    function VirtualMachine() {
        _classCallCheck(this, VirtualMachine);

        /**
         * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
         * @type {!Runtime}
         */
        var _this = _possibleConstructorReturn(this, (VirtualMachine.__proto__ || Object.getPrototypeOf(VirtualMachine)).call(this));

        _this.runtime = new Runtime();
        centralDispatch.setService('runtime', _this.runtime).catch(function (e) {
            log.error('Failed to register runtime service: ' + JSON.stringify(e));
        });

        /**
         * The "currently editing"/selected target ID for the VM.
         * Block events from any Blockly workspace are routed to this target.
         * @type {Target}
         */
        _this.editingTarget = null;
        // Runtime emits are passed along as VM emits.
        _this.runtime.on(Runtime.SCRIPT_GLOW_ON, function (glowData) {
            _this.emit(Runtime.SCRIPT_GLOW_ON, glowData);
        });
        _this.runtime.on(Runtime.SCRIPT_GLOW_OFF, function (glowData) {
            _this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);
        });
        _this.runtime.on(Runtime.BLOCK_GLOW_ON, function (glowData) {
            _this.emit(Runtime.BLOCK_GLOW_ON, glowData);
        });
        _this.runtime.on(Runtime.BLOCK_GLOW_OFF, function (glowData) {
            _this.emit(Runtime.BLOCK_GLOW_OFF, glowData);
        });
        _this.runtime.on(Runtime.PROJECT_RUN_START, function () {
            _this.emit(Runtime.PROJECT_RUN_START);
        });
        _this.runtime.on(Runtime.PROJECT_RUN_STOP, function () {
            _this.emit(Runtime.PROJECT_RUN_STOP);
        });
        _this.runtime.on(Runtime.VISUAL_REPORT, function (visualReport) {
            _this.emit(Runtime.VISUAL_REPORT, visualReport);
        });
        _this.runtime.on(Runtime.TARGETS_UPDATE, function () {
            _this.emitTargetsUpdate();
        });
        _this.runtime.on(Runtime.MONITORS_UPDATE, function (monitorList) {
            _this.emit(Runtime.MONITORS_UPDATE, monitorList);
        });
        _this.runtime.on(Runtime.EXTENSION_ADDED, function (blocksInfo) {
            _this.emit(Runtime.EXTENSION_ADDED, blocksInfo);
        });

        _this.extensionManager = new ExtensionManager(_this.runtime);

        _this.blockListener = _this.blockListener.bind(_this);
        _this.flyoutBlockListener = _this.flyoutBlockListener.bind(_this);
        _this.monitorBlockListener = _this.monitorBlockListener.bind(_this);
        _this.variableListener = _this.variableListener.bind(_this);
        return _this;
    }

    /**
     * Start running the VM - do this before anything else.
     */


    _createClass(VirtualMachine, [{
        key: 'start',
        value: function start() {
            this.runtime.start();
        }

        /**
         * "Green flag" handler - start all threads starting with a green flag.
         */

    }, {
        key: 'greenFlag',
        value: function greenFlag() {
            this.runtime.greenFlag();
        }

        /**
         * Set whether the VM is in "turbo mode."
         * When true, loops don't yield to redraw.
         * @param {boolean} turboModeOn Whether turbo mode should be set.
         */

    }, {
        key: 'setTurboMode',
        value: function setTurboMode(turboModeOn) {
            this.runtime.turboMode = !!turboModeOn;
        }

        /**
         * Set whether the VM is in 2.0 "compatibility mode."
         * When true, ticks go at 2.0 speed (30 TPS).
         * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
         */

    }, {
        key: 'setCompatibilityMode',
        value: function setCompatibilityMode(compatibilityModeOn) {
            this.runtime.setCompatibilityMode(!!compatibilityModeOn);
        }

        /**
         * Stop all threads and running activities.
         */

    }, {
        key: 'stopAll',
        value: function stopAll() {
            this.runtime.stopAll();
        }

        /**
         * Clear out current running project data.
         */

    }, {
        key: 'clear',
        value: function clear() {
            this.runtime.dispose();
            this.editingTarget = null;
            this.emitTargetsUpdate();
        }

        /**
         * Get data for playground. Data comes back in an emitted event.
         */

    }, {
        key: 'getPlaygroundData',
        value: function getPlaygroundData() {
            var instance = this;
            // Only send back thread data for the current editingTarget.
            var threadData = this.runtime.threads.filter(function (thread) {
                return thread.target === instance.editingTarget;
            });
            // Remove the target key, since it's a circular reference.
            var filteredThreadData = JSON.stringify(threadData, function (key, value) {
                if (key === 'target') return;
                return value;
            }, 2);
            this.emit('playgroundData', {
                blocks: this.editingTarget.blocks,
                threads: filteredThreadData
            });
        }

        /**
         * Post I/O data to the virtual devices.
         * @param {?string} device Name of virtual I/O device.
         * @param {object} data Any data object to post to the I/O device.
         */

    }, {
        key: 'postIOData',
        value: function postIOData(device, data) {
            if (this.runtime.ioDevices[device]) {
                this.runtime.ioDevices[device].postData(data);
            }
        }

        /**
         * Load a project from a Scratch 2.0 JSON representation.
         * @param {?string} json JSON string representing the project.
         * @return {!Promise} Promise that resolves after targets are installed.
         */

    }, {
        key: 'loadProject',
        value: function loadProject(json) {
            // @todo: Handle other formats, e.g., Scratch 1.4, Scratch 3.0.
            return this.fromJSON(json);
        }

        /**
         * Load a project from the Scratch web site, by ID.
         * @param {string} id - the ID of the project to download, as a string.
         */

    }, {
        key: 'downloadProjectId',
        value: function downloadProjectId(id) {
            var storage = this.runtime.storage;
            if (!storage) {
                log.error('No storage module present; cannot load project: ', id);
                return;
            }
            var vm = this;
            var promise = storage.load(storage.AssetType.Project, id);
            promise.then(function (projectAsset) {
                vm.loadProject(projectAsset.decodeText());
            });
        }

        /**
         * @returns {string} Project in a Scratch 3.0 JSON representation.
         */

    }, {
        key: 'saveProjectSb3',
        value: function saveProjectSb3() {
            // @todo: Handle other formats, e.g., Scratch 1.4, Scratch 2.0.
            return this.toJSON();
        }

        /**
         * Export project as a Scratch 3.0 JSON representation.
         * @return {string} Serialized state of the runtime.
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return JSON.stringify(sb3.serialize(this.runtime));
        }

        /**
         * Load a project from a Scratch JSON representation.
         * @param {string} json JSON string representing a project.
         * @returns {Promise} Promise that resolves after the project has loaded
         */

    }, {
        key: 'fromJSON',
        value: function fromJSON(json) {
            var _this2 = this;

            // Clear the current runtime
            this.clear();

            // Validate & parse
            if (typeof json !== 'string') {
                log.error('Failed to parse project. Non-string supplied to fromJSON.');
                return;
            }
            json = JSON.parse(json);
            if ((typeof json === 'undefined' ? 'undefined' : _typeof(json)) !== 'object') {
                log.error('Failed to parse project. JSON supplied to fromJSON is not an object.');
                return;
            }

            // Establish version, deserialize, and load into runtime
            // @todo Support Scratch 1.4
            // @todo This is an extremely nave / dangerous way of determining version.
            //       See `scratch-parser` for a more sophisticated validation
            //       methodology that should be adapted for use here
            var deserializer = void 0;
            if (typeof json.meta !== 'undefined' && typeof json.meta.semver !== 'undefined') {
                deserializer = sb3;
            } else {
                deserializer = sb2;
            }

            return deserializer.deserialize(json, this.runtime).then(function (_ref) {
                var targets = _ref.targets,
                    extensions = _ref.extensions;
                return _this2.installTargets(targets, extensions, true);
            });
        }

        /**
         * Install `deserialize` results: zero or more targets after the extensions (if any) used by those targets.
         * @param {Array.<Target>} targets - the targets to be installed
         * @param {ImportedExtensionsInfo} extensions - metadata about extensions used by these targets
         * @param {boolean} wholeProject - set to true if installing a whole project, as opposed to a single sprite.
         * @returns {Promise} resolved once targets have been installed
         */

    }, {
        key: 'installTargets',
        value: function installTargets(targets, extensions, wholeProject) {
            var _this3 = this;

            var extensionPromises = [];
            extensions.extensionIDs.forEach(function (extensionID) {
                if (!_this3.extensionManager.isExtensionLoaded(extensionID)) {
                    var extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;
                    extensionPromises.push(_this3.extensionManager.loadExtensionURL(extensionURL));
                }
            });

            targets = targets.filter(function (target) {
                return !!target;
            });

            return Promise.all(extensionPromises).then(function () {
                if (wholeProject) {
                    _this3.clear();
                }
                targets.forEach(function (target) {
                    _this3.runtime.targets.push(target);
                    /** @type RenderedTarget */target.updateAllDrawableProperties();
                });
                // Select the first target for editing, e.g., the first sprite.
                if (wholeProject && targets.length > 1) {
                    _this3.editingTarget = targets[1];
                } else {
                    _this3.editingTarget = targets[0];
                }

                // Update the VM user's knowledge of targets and blocks on the workspace.
                _this3.emitTargetsUpdate();
                _this3.emitWorkspaceUpdate();
                _this3.runtime.setEditingTarget(_this3.editingTarget);
            });
        }

        /**
         * Add a single sprite from the "Sprite2" (i.e., SB2 sprite) format.
         * @param {string} json JSON string representing the sprite.
         * @returns {Promise} Promise that resolves after the sprite is added
         */

    }, {
        key: 'addSprite2',
        value: function addSprite2(json) {
            var _this4 = this;

            // Validate & parse
            if (typeof json !== 'string') {
                log.error('Failed to parse sprite. Non-string supplied to addSprite2.');
                return;
            }
            json = JSON.parse(json);
            if ((typeof json === 'undefined' ? 'undefined' : _typeof(json)) !== 'object') {
                log.error('Failed to parse sprite. JSON supplied to addSprite2 is not an object.');
                return;
            }

            return sb2.deserialize(json, this.runtime, true).then(function (_ref2) {
                var targets = _ref2.targets,
                    extensions = _ref2.extensions;
                return _this4.installTargets(targets, extensions, false);
            });
        }

        /**
         * Add a costume to the current editing target.
         * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
         * @param {!object} costumeObject Object representing the costume.
         * @property {int} skinId - the ID of the costume's render skin, once installed.
         * @property {number} rotationCenterX - the X component of the costume's origin.
         * @property {number} rotationCenterY - the Y component of the costume's origin.
         * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
         */

    }, {
        key: 'addCostume',
        value: function addCostume(md5ext, costumeObject) {
            var _this5 = this;

            loadCostume(md5ext, costumeObject, this.runtime).then(function () {
                _this5.editingTarget.addCostume(costumeObject);
                _this5.editingTarget.setCostume(_this5.editingTarget.sprite.costumes.length - 1);
            });
        }

        /**
         * Rename a costume on the current editing target.
         * @param {int} costumeIndex - the index of the costume to be renamed.
         * @param {string} newName - the desired new name of the costume (will be modified if already in use).
         */

    }, {
        key: 'renameCostume',
        value: function renameCostume(costumeIndex, newName) {
            this.editingTarget.renameCostume(costumeIndex, newName);
            this.emitTargetsUpdate();
        }

        /**
         * Delete a costume from the current editing target.
         * @param {int} costumeIndex - the index of the costume to be removed.
         */

    }, {
        key: 'deleteCostume',
        value: function deleteCostume(costumeIndex) {
            this.editingTarget.deleteCostume(costumeIndex);
        }

        /**
         * Add a sound to the current editing target.
         * @param {!object} soundObject Object representing the costume.
         * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
         */

    }, {
        key: 'addSound',
        value: function addSound(soundObject) {
            var _this6 = this;

            return loadSound(soundObject, this.runtime).then(function () {
                _this6.editingTarget.addSound(soundObject);
                _this6.emitTargetsUpdate();
            });
        }

        /**
         * Rename a sound on the current editing target.
         * @param {int} soundIndex - the index of the sound to be renamed.
         * @param {string} newName - the desired new name of the sound (will be modified if already in use).
         */

    }, {
        key: 'renameSound',
        value: function renameSound(soundIndex, newName) {
            this.editingTarget.renameSound(soundIndex, newName);
            this.emitTargetsUpdate();
        }

        /**
         * Get a sound buffer from the audio engine.
         * @param {int} soundIndex - the index of the sound to be got.
         * @return {AudioBuffer} the sound's audio buffer.
         */

    }, {
        key: 'getSoundBuffer',
        value: function getSoundBuffer(soundIndex) {
            var id = this.editingTarget.sprite.sounds[soundIndex].soundId;
            if (id && this.runtime && this.runtime.audioEngine) {
                return this.runtime.audioEngine.getSoundBuffer(id);
            }
            return null;
        }

        /**
         * Update a sound buffer.
         * @param {int} soundIndex - the index of the sound to be updated.
         * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
         */

    }, {
        key: 'updateSoundBuffer',
        value: function updateSoundBuffer(soundIndex, newBuffer) {
            var id = this.editingTarget.sprite.sounds[soundIndex].soundId;
            if (id && this.runtime && this.runtime.audioEngine) {
                this.runtime.audioEngine.updateSoundBuffer(id, newBuffer);
            }
            this.emitTargetsUpdate();
        }

        /**
         * Delete a sound from the current editing target.
         * @param {int} soundIndex - the index of the sound to be removed.
         */

    }, {
        key: 'deleteSound',
        value: function deleteSound(soundIndex) {
            this.editingTarget.deleteSound(soundIndex);
        }

        /**
         * Get an SVG string from storage.
         * @param {int} costumeIndex - the index of the costume to be got.
         * @return {string} the costume's SVG string, or null if it's not an SVG costume.
         */

    }, {
        key: 'getCostumeSvg',
        value: function getCostumeSvg(costumeIndex) {
            var id = this.editingTarget.sprite.costumes[costumeIndex].assetId;
            if (id && this.runtime && this.runtime.storage && this.runtime.storage.get(id).dataFormat === 'svg') {
                return this.runtime.storage.get(id).decodeText();
            }
            return null;
        }

        /**
         * Update a costume with the given SVG
         * @param {int} costumeIndex - the index of the costume to be updated.
         * @param {string} svg - new SVG for the renderer.
         * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
         * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
         */

    }, {
        key: 'updateSvg',
        value: function updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {
            var costume = this.editingTarget.sprite.costumes[costumeIndex];
            if (costume && this.runtime && this.runtime.renderer) {
                costume.rotationCenterX = rotationCenterX;
                costume.rotationCenterY = rotationCenterY;
                this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);
            }
            var storage = this.runtime.storage;
            costume.assetId = storage.builtinHelper.cache(storage.AssetType.ImageVector, storage.DataFormat.SVG, new TextEncoder().encode(svg));
            this.emitTargetsUpdate();
        }

        /**
         * Add a backdrop to the stage.
         * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
         * @param {!object} backdropObject Object representing the backdrop.
         * @property {int} skinId - the ID of the backdrop's render skin, once installed.
         * @property {number} rotationCenterX - the X component of the backdrop's origin.
         * @property {number} rotationCenterY - the Y component of the backdrop's origin.
         * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
         */

    }, {
        key: 'addBackdrop',
        value: function addBackdrop(md5ext, backdropObject) {
            var _this7 = this;

            loadCostume(md5ext, backdropObject, this.runtime).then(function () {
                var stage = _this7.runtime.getTargetForStage();
                stage.sprite.costumes.push(backdropObject);
                stage.setCostume(stage.sprite.costumes.length - 1);
            });
        }

        /**
         * Rename a sprite.
         * @param {string} targetId ID of a target whose sprite to rename.
         * @param {string} newName New name of the sprite.
         */

    }, {
        key: 'renameSprite',
        value: function renameSprite(targetId, newName) {
            var target = this.runtime.getTargetById(targetId);
            if (target) {
                if (!target.isSprite()) {
                    throw new Error('Cannot rename non-sprite targets.');
                }
                var sprite = target.sprite;
                if (!sprite) {
                    throw new Error('No sprite associated with this target.');
                }
                if (newName && RESERVED_NAMES.indexOf(newName) === -1) {
                    var names = this.runtime.targets.filter(function (runtimeTarget) {
                        return runtimeTarget.isSprite() && runtimeTarget.id !== target.id;
                    }).map(function (runtimeTarget) {
                        return runtimeTarget.sprite.name;
                    });
                    sprite.name = StringUtil.unusedName(newName, names);
                }
                this.emitTargetsUpdate();
            } else {
                throw new Error('No target with the provided id.');
            }
        }

        /**
         * Delete a sprite and all its clones.
         * @param {string} targetId ID of a target whose sprite to delete.
         */

    }, {
        key: 'deleteSprite',
        value: function deleteSprite(targetId) {
            var target = this.runtime.getTargetById(targetId);

            if (target) {
                var targetIndexBeforeDelete = this.runtime.targets.map(function (t) {
                    return t.id;
                }).indexOf(target.id);
                if (!target.isSprite()) {
                    throw new Error('Cannot delete non-sprite targets.');
                }
                var sprite = target.sprite;
                if (!sprite) {
                    throw new Error('No sprite associated with this target.');
                }
                this.runtime.requestRemoveMonitorByTargetId(targetId);
                var currentEditingTarget = this.editingTarget;
                for (var i = 0; i < sprite.clones.length; i++) {
                    var clone = sprite.clones[i];
                    this.runtime.stopForTarget(sprite.clones[i]);
                    this.runtime.disposeTarget(sprite.clones[i]);
                    // Ensure editing target is switched if we are deleting it.
                    if (clone === currentEditingTarget) {
                        var nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);
                        if (this.runtime.targets.length > 0) {
                            this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);
                        } else {
                            this.editingTarget = null;
                        }
                    }
                }
                // Sprite object should be deleted by GC.
                this.emitTargetsUpdate();
            } else {
                throw new Error('No target with the provided id.');
            }
        }

        /**
         * Duplicate a sprite.
         * @param {string} targetId ID of a target whose sprite to duplicate.
         * @returns {Promise} Promise that resolves when duplicated target has
         *     been added to the runtime.
         */

    }, {
        key: 'duplicateSprite',
        value: function duplicateSprite(targetId) {
            var _this8 = this;

            var target = this.runtime.getTargetById(targetId);
            if (!target) {
                throw new Error('No target with the provided id.');
            } else if (!target.isSprite()) {
                throw new Error('Cannot duplicate non-sprite targets.');
            } else if (!target.sprite) {
                throw new Error('No sprite associated with this target.');
            }
            return target.duplicate().then(function (newTarget) {
                _this8.runtime.targets.push(newTarget);
                _this8.setEditingTarget(newTarget.id);
            });
        }

        /**
         * Set the audio engine for the VM/runtime
         * @param {!AudioEngine} audioEngine The audio engine to attach
         */

    }, {
        key: 'attachAudioEngine',
        value: function attachAudioEngine(audioEngine) {
            this.runtime.attachAudioEngine(audioEngine);
        }

        /**
         * Set the renderer for the VM/runtime
         * @param {!RenderWebGL} renderer The renderer to attach
         */

    }, {
        key: 'attachRenderer',
        value: function attachRenderer(renderer) {
            this.runtime.attachRenderer(renderer);
        }

        /**
         * Set the storage module for the VM/runtime
         * @param {!ScratchStorage} storage The storage module to attach
         */

    }, {
        key: 'attachStorage',
        value: function attachStorage(storage) {
            this.runtime.attachStorage(storage);
        }

        /**
         * Handle a Blockly event for the current editing target.
         * @param {!Blockly.Event} e Any Blockly event.
         */

    }, {
        key: 'blockListener',
        value: function blockListener(e) {
            if (this.editingTarget) {
                this.editingTarget.blocks.blocklyListen(e, this.runtime);
            }
        }

        /**
         * Handle a Blockly event for the flyout.
         * @param {!Blockly.Event} e Any Blockly event.
         */

    }, {
        key: 'flyoutBlockListener',
        value: function flyoutBlockListener(e) {
            this.runtime.flyoutBlocks.blocklyListen(e, this.runtime);
        }

        /**
         * Handle a Blockly event for the flyout to be passed to the monitor container.
         * @param {!Blockly.Event} e Any Blockly event.
         */

    }, {
        key: 'monitorBlockListener',
        value: function monitorBlockListener(e) {
            // Filter events by type, since monitor blocks only need to listen to these events.
            // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.
            if (['create', 'change'].indexOf(e.type) !== -1) {
                this.runtime.monitorBlocks.blocklyListen(e, this.runtime);
            }
        }

        /**
         * Handle a Blockly event for the variable map.
         * @param {!Blockly.Event} e Any Blockly event.
         */

    }, {
        key: 'variableListener',
        value: function variableListener(e) {
            // Filter events by type, since blocks only needs to listen to these
            // var events.
            if (['var_create', 'var_rename', 'var_delete'].indexOf(e.type) !== -1) {
                this.runtime.getTargetForStage().blocks.blocklyListen(e, this.runtime);
            }
        }

        /**
         * Set an editing target. An editor UI can use this function to switch
         * between editing different targets, sprites, etc.
         * After switching the editing target, the VM may emit updates
         * to the list of targets and any attached workspace blocks
         * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
         * @param {string} targetId Id of target to set as editing.
         */

    }, {
        key: 'setEditingTarget',
        value: function setEditingTarget(targetId) {
            // Has the target id changed? If not, exit.
            if (targetId === this.editingTarget.id) {
                return;
            }
            var target = this.runtime.getTargetById(targetId);
            if (target) {
                this.editingTarget = target;
                // Emit appropriate UI updates.
                this.emitTargetsUpdate();
                this.emitWorkspaceUpdate();
                this.runtime.setEditingTarget(target);
            }
        }

        /**
         * Repopulate the workspace with the blocks of the current editingTarget. This
         * allows us to get around bugs like gui#413.
         */

    }, {
        key: 'refreshWorkspace',
        value: function refreshWorkspace() {
            if (this.editingTarget) {
                this.emitWorkspaceUpdate();
                this.runtime.setEditingTarget(this.editingTarget);
            }
        }

        /**
         * Emit metadata about available targets.
         * An editor UI could use this to display a list of targets and show
         * the currently editing one.
         */

    }, {
        key: 'emitTargetsUpdate',
        value: function emitTargetsUpdate() {
            this.emit('targetsUpdate', {
                // [[target id, human readable target name], ...].
                targetList: this.runtime.targets.filter(
                // Don't report clones.
                function (target) {
                    return !target.hasOwnProperty('isOriginal') || target.isOriginal;
                }).map(function (target) {
                    return target.toJSON();
                }),
                // Currently editing target id.
                editingTarget: this.editingTarget ? this.editingTarget.id : null
            });
        }

        /**
         * Emit an Blockly/scratch-blocks compatible XML representation
         * of the current editing target's blocks.
         */

    }, {
        key: 'emitWorkspaceUpdate',
        value: function emitWorkspaceUpdate() {
            var variableMap = Object.assign({}, this.runtime.getTargetForStage().variables, this.editingTarget.variables);

            var variables = Object.keys(variableMap).map(function (k) {
                return variableMap[k];
            });

            var xmlString = '<xml xmlns="http://www.w3.org/1999/xhtml">\n                            <variables>\n                                ' + variables.map(function (v) {
                return v.toXML();
            }).join() + '\n                            </variables>\n                            ' + this.editingTarget.blocks.toXML() + '\n                        </xml>';

            this.emit('workspaceUpdate', { xml: xmlString });
        }

        /**
         * Get a target id for a drawable id. Useful for interacting with the renderer
         * @param {int} drawableId The drawable id to request the target id for
         * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
         */

    }, {
        key: 'getTargetIdForDrawableId',
        value: function getTargetIdForDrawableId(drawableId) {
            var target = this.runtime.getTargetByDrawableId(drawableId);
            if (target && target.hasOwnProperty('id') && target.hasOwnProperty('isStage') && !target.isStage) {
                return target.id;
            }
            return null;
        }

        /**
         * Put a target into a "drag" state, during which its X/Y positions will be unaffected
         * by blocks.
         * @param {string} targetId The id for the target to put into a drag state
         */

    }, {
        key: 'startDrag',
        value: function startDrag(targetId) {
            var target = this.runtime.getTargetById(targetId);
            if (target) {
                target.startDrag();
                this.setEditingTarget(target.id);
            }
        }

        /**
         * Remove a target from a drag state, so blocks may begin affecting X/Y position again
         * @param {string} targetId The id for the target to remove from the drag state
         */

    }, {
        key: 'stopDrag',
        value: function stopDrag(targetId) {
            var target = this.runtime.getTargetById(targetId);
            if (target) target.stopDrag();
        }

        /**
         * Post/edit sprite info for the current editing target.
         * @param {object} data An object with sprite info data to set.
         */

    }, {
        key: 'postSpriteInfo',
        value: function postSpriteInfo(data) {
            this.editingTarget.postSpriteInfo(data);
        }
    }]);

    return VirtualMachine;
}(EventEmitter);

module.exports = VirtualMachine;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

// Store markers outside of the function scope,
// not to recreate them on every call
var entities = {
  'amp': '&',
  'apos': '\'',
  'lt': '<',
  'gt': '>',
  'quot': '"',
  'nbsp': '\xa0'
};
var entityPattern = /&([a-z]+);/ig;

module.exports = function decodeHTMLEntities(text) {
  // A single replace pass with a static RegExp is faster than a loop
  return text.replace(entityPattern, function(match, entity) {
    entity = entity.toLowerCase();
    if (entities.hasOwnProperty(entity)) {
      return entities[entity];
    }
    // return original string if there is no matching entity (no replace)
    return match;
  });
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Module dependencies
*/
var ElementType = __webpack_require__(94);
var entities = __webpack_require__(104);

/*
  Boolean Attributes
*/
var booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (!value && booleanAttributes[key]) {
      output += key;
    } else {
      output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};


var render = module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root')
      output += render(elem.children, opts);
    else if (ElementType.isTag(elem))
      output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment)
      output += renderComment(elem);
    else if (elem.type === ElementType.CDATA)
      output += renderCdata(elem);
    else
      output += renderText(elem, opts);
  }

  return output;
};

function renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = {decodeEntities: opts.decodeEntities, xmlMode: true};

  var tag = '<' + elem.name,
      attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.children || elem.children.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}


/***/ }),
/* 94 */
/***/ (function(module, exports) {

//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(15);

var re_whitespace = /\s+/g;
var NodePrototype = __webpack_require__(40);
var ElementPrototype = __webpack_require__(96);

function DomHandler(callback, options, elementCB){
	if(typeof callback === "object"){
		elementCB = options;
		options = callback;
		callback = null;
	} else if(typeof options === "function"){
		elementCB = options;
		options = defaultOpts;
	}
	this._callback = callback;
	this._options = options || defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false, //Add startIndex properties to nodes
	withEndIndices: false, //Add endIndex properties to nodes
};

DomHandler.prototype.onparserinit = function(parser){
	this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function(){
	DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function(){
	if(this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

DomHandler.prototype._handleCallback =
DomHandler.prototype.onerror = function(error){
	if(typeof this._callback === "function"){
		this._callback(error, this.dom);
	} else {
		if(error) throw error;
	}
};

DomHandler.prototype.onclosetag = function(){
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	
	var elem = this._tagStack.pop();

	if(this._options.withEndIndices){
		elem.endIndex = this._parser.endIndex;
	}

	if(this._elementCB) this._elementCB(elem);
};

DomHandler.prototype._createDomElement = function(properties){
	if (!this._options.withDomLvl1) return properties;

	var element;
	if (properties.type === "tag") {
		element = Object.create(ElementPrototype);
	} else {
		element = Object.create(NodePrototype);
	}

	for (var key in properties) {
		if (properties.hasOwnProperty(key)) {
			element[key] = properties[key];
		}
	}

	return element;
};

DomHandler.prototype._addDomElement = function(element){
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if(this._options.withStartIndices){
		element.startIndex = this._parser.startIndex;
	}
	if(this._options.withEndIndices){
		element.endIndex = this._parser.endIndex;
	}

	if(previousSibling){
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

DomHandler.prototype.onopentag = function(name, attribs){
	var properties = {
		type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);

	this._tagStack.push(element);
};

DomHandler.prototype.ontext = function(data){
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
		if(normalize){
			lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if(
			this._tagStack.length &&
			(lastTag = this._tagStack[this._tagStack.length - 1]) &&
			(lastTag = lastTag.children[lastTag.children.length - 1]) &&
			lastTag.type === ElementType.Text
		){
			if(normalize){
				lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if(normalize){
				data = data.replace(re_whitespace, " ");
			}

			var element = this._createDomElement({
				data: data,
				type: ElementType.Text
			});

			this._addDomElement(element);
		}
	}
};

DomHandler.prototype.oncomment = function(data){
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if(lastTag && lastTag.type === ElementType.Comment){
		lastTag.data += data;
		return;
	}

	var properties = {
		data: data,
		type: ElementType.Comment
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncdatastart = function(){
	var properties = {
		children: [{
			data: "",
			type: ElementType.Text
		}],
		type: ElementType.CDATA
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
	this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function(name, data){
	var element = this._createDomElement({
		name: name,
		data: data,
		type: ElementType.Directive
	});

	this._addDomElement(element);
};

module.exports = DomHandler;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

// DOM-Level-1-compliant structure
var NodePrototype = __webpack_require__(40);
var ElementPrototype = module.exports = Object.create(NodePrototype);

var domLvl1 = {
	tagName: "name"
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(ElementPrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var DomUtils = module.exports;

[
	__webpack_require__(102),
	__webpack_require__(103),
	__webpack_require__(100),
	__webpack_require__(101),
	__webpack_require__(99),
	__webpack_require__(98)
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});


/***/ }),
/* 98 */
/***/ (function(module, exports) {

// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(15);
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};


/***/ }),
/* 100 */
/***/ (function(module, exports) {

exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};




/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var isTag = __webpack_require__(15).isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, rootElems){
	var result = [];
	var stack = [rootElems];
	while(stack.length){
		var elems = stack.pop();
		for(var i = 0, j = elems.length; i < j; i++){
			if(!isTag(elems[i])) continue;
			if(test(elems[i])) result.push(elems[i]);
		}
		while(j-- > 0){
			if(elems[j].children && elems[j].children.length > 0){
				stack.push(elems[j].children);
			}
		}
	}
	return result;
}


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(15),
    getOuterHTML = __webpack_require__(93),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
	if(elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var encode = __webpack_require__(106),
    decode = __webpack_require__(105);

exports.decode = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level){
	return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 =
exports.encodeHTML5 =
exports.encodeHTML  = encode.HTML;

exports.decodeXML =
exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 =
exports.decodeHTML5 =
exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict =
exports.decodeHTML5Strict =
exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var entityMap = __webpack_require__(30),
    legacyMap = __webpack_require__(42),
    xmlMap    = __webpack_require__(31),
    decodeCodePoint = __webpack_require__(41);

var decodeXMLStrict  = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map){
	var keys = Object.keys(map).join("|"),
	    replace = getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function(str){
		return String(str).replace(re, replace);
	};
}

var decodeHTML = (function(){
	var legacy = Object.keys(legacyMap)
		.sort(sorter);

	var keys = Object.keys(entityMap)
		.sort(sorter);

	for(var i = 0, j = 0; i < keys.length; i++){
		if(legacy[j] === keys[i]){
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = getReplacer(entityMap);

	function replacer(str){
		if(str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function(str){
		return String(str).replace(re, replacer);
	};
}());

function sorter(a, b){
	return a < b ? 1 : -1;
}

function getReplacer(map){
	return function replace(str){
		if(str.charAt(1) === "#"){
			if(str.charAt(2) === "X" || str.charAt(2) === "x"){
				return decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

module.exports = {
	XML: decodeXMLStrict,
	HTML: decodeHTML,
	HTMLStrict: decodeHTMLStrict
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var inverseXML = getInverseObj(__webpack_require__(31)),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(__webpack_require__(30)),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(47)

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = CollectingHandler;

function CollectingHandler(cbs){
	this._cbs = cbs || {};
	this.events = [];
}

var EVENTS = __webpack_require__(9).EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(){
			this.events.push([name]);
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a){
			this.events.push([name, a]);
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a, b){
			this.events.push([name, a, b]);
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

CollectingHandler.prototype.onreset = function(){
	this.events = [];
	if(this._cbs.onreset) this._cbs.onreset();
};

CollectingHandler.prototype.restart = function(){
	if(this._cbs.onreset) this._cbs.onreset();

	for(var i = 0, len = this.events.length; i < len; i++){
		if(this._cbs[this.events[i][0]]){

			var num = this.events[i].length;

			if(num === 1){
				this._cbs[this.events[i][0]]();
			} else if(num === 2){
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var index = __webpack_require__(9),
    DomHandler = index.DomHandler,
    DomUtils = index.DomUtils;

//TODO: make this a streamable handler
function FeedHandler(callback, options){
	this.init(callback, options);
}

__webpack_require__(3)(FeedHandler, DomHandler);

FeedHandler.prototype.init = DomHandler;

function getElements(what, where){
	return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where){
	return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse){
	return DomUtils.getText(
		DomUtils.getElementsByTagName(what, where, recurse, 1)
	).trim();
}

function addConditionally(obj, prop, what, where, recurse){
	var tmp = fetch(what, where, recurse);
	if(tmp) obj[prop] = tmp;
}

var isValidFeed = function(value){
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

FeedHandler.prototype.onend = function(){
	var feed = {},
	    feedRoot = getOneElement(isValidFeed, this.dom),
	    tmp, childs;

	if(feedRoot){
		if(feedRoot.name === "feed"){
			childs = feedRoot.children;

			feed.type = "atom";
			addConditionally(feed, "id", "id", childs);
			addConditionally(feed, "title", "title", childs);
			if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			addConditionally(feed, "description", "subtitle", childs);
			if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "email", childs, true);

			feed.items = getElements("entry", childs).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "id", item);
				addConditionally(entry, "title", "title", item);
				if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
				if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			addConditionally(feed, "title", "title", childs);
			addConditionally(feed, "link", "link", childs);
			addConditionally(feed, "description", "description", childs);
			if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = getElements("item", feedRoot.children).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "guid", item);
				addConditionally(entry, "title", "title", item);
				addConditionally(entry, "link", "link", item);
				addConditionally(entry, "description", "description", item);
				if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	DomHandler.prototype._handleCallback.call(
		this, feedRoot ? null : Error("couldn't find root of feed")
	);
};

module.exports = FeedHandler;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = __webpack_require__(9).EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(46);

function Stream(options){
	Parser.call(this, new Cbs(this), options);
}

__webpack_require__(3)(Stream, Parser);

Stream.prototype.readable = true;

function Cbs(scope){
	this.scope = scope;
}

var EVENTS = __webpack_require__(9).EVENTS;

Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		Cbs.prototype["on" + name] = function(){
			this.scope.emit(name);
		};
	} else if(EVENTS[name] === 1){
		Cbs.prototype["on" + name] = function(a){
			this.scope.emit(name, a);
		};
	} else if(EVENTS[name] === 2){
		Cbs.prototype["on" + name] = function(a, b){
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});

/***/ }),
/* 114 */
/***/ (function(module, exports) {

function M() { this._events = {}; }
M.prototype = {
  on: function(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function(ev, cb) {
    var e = this._events[ev] || [], i;
    for(i = e.length-1; i >= 0 && e[i]; i--){
      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }
    }
  },
  removeAllListeners: function(ev) {
    if(!ev) { this._events = {}; }
    else { this._events[ev] && (this._events[ev] = []); }
  },
  listeners: function(ev) {
    return (this._events ? this._events[ev] || [] : []);
  },
  emit: function(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];
    for(i = e.length-1; i >= 0 && e[i]; i--){
      e[i].apply(this, args);
    }
    return this;
  },
  when: function(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function(ev, cb, when) {
    if(!cb) return this;
    function c() {
      if(!when) this.removeListener(ev, c);
      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }
    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};
M.mixin = function(dest) {
  var o = M.prototype, k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};
module.exports = M;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// default filter
var Transform = __webpack_require__(5);

var levelMap = { debug: 1, info: 2, warn: 3, error: 4 };

function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}

Transform.mixin(Filter);

// allow all matching, with level >= given level
Filter.prototype.allow = function(name, level) {
  this._white.push({ n: name, l: levelMap[level] });
  return this;
};

// deny all matching, with level <= given level
Filter.prototype.deny = function(name, level) {
  this._black.push({ n: name, l: levelMap[level] });
  return this;
};

Filter.prototype.clear = function() {
  this._white = [];
  this._black = [];
  return this;
};

function test(rule, name) {
  // use .test for RegExps
  return (rule.n.test ? rule.n.test(name) : rule.n == name);
};

Filter.prototype.test = function(name, level) {
  var i, len = Math.max(this._white.length, this._black.length);
  for(i = 0; i < len; i++) {
    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }
    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }
  return this.defaultResult;
};

Filter.prototype.write = function(name, level, args) {
  if(!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};

module.exports = Filter;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5),
    Filter = __webpack_require__(115);

var log = new Transform(),
    slice = Array.prototype.slice;

exports = module.exports = function create(name) {
  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };
  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };
  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };
  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };
  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };
  o.log   = o.debug; // for interface compliance with Node and browser consoles
  o.suggest = exports.suggest;
  o.format = log.format;
  return o;
};

// filled in separately
exports.defaultBackend = exports.defaultFormatter = null;

exports.pipe = function(dest) {
  return log.pipe(dest);
};

exports.end = exports.unpipe = exports.disable = function(from) {
  return log.unpipe(from);
};

exports.Transform = Transform;
exports.Filter = Filter;
// this is the default filter that's applied when .enable() is called normally
// you can bypass it completely and set up your own pipes
exports.suggest = new Filter();

exports.enable = function() {
  if(exports.defaultFormatter) {
    return log.pipe(exports.suggest) // filter
              .pipe(exports.defaultFormatter) // formatter
              .pipe(exports.defaultBackend); // backend
  }
  return log.pipe(exports.suggest) // filter
            .pipe(exports.defaultBackend); // formatter
};



/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5),
    cache = [ ];

var logger = new Transform();

logger.write = function(name, level, args) {
  cache.push([ name, level, args ]);
};

// utility functions
logger.get = function() { return cache; };
logger.empty = function() { cache = []; };

module.exports = logger;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5);

var newlines = /\n+$/,
    logger = new Transform();

logger.write = function(name, level, args) {
  var i = args.length-1;
  if (typeof console === 'undefined' || !console.log) {
    return;
  }
  if(console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if(JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if(args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }
    try {
      for(i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch(e) {}
    console.log(args.join(' '));
  }
};

logger.formatters = ['color', 'minilog'];
logger.color = __webpack_require__(119);
logger.minilog = __webpack_require__(120);

module.exports = logger;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5),
    color = __webpack_require__(48);

var colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },
    logger = new Transform();

logger.write = function(name, level, args) {
  var fn = console.log;
  if(console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger.pipe = function() { };

module.exports = logger;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5),
    color = __webpack_require__(48),
    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },
    logger = new Transform();

logger.write = function(name, level, args) {
  var fn = console.log;
  if(level != 'debug' && console[level]) {
    fn = console[level];
  }

  var subset = [], i = 0;
  if(level != 'info') {
    for(; i < args.length; i++) {
      if(typeof args[i] != 'string') break;
    }
    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));
  } else {
    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger.pipe = function() { };

module.exports = logger;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var Minilog = __webpack_require__(116);

var oldEnable = Minilog.enable,
    oldDisable = Minilog.disable,
    isChrome = (typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent)),
    console = __webpack_require__(118);

// Use a more capable logging backend if on Chrome
Minilog.defaultBackend = (isChrome ? console.minilog : console);

// apply enable inputs from localStorage and from the URL
if(typeof window != 'undefined') {
  try {
    Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
  } catch(e) {}
  if(window.location && window.location.search) {
    var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
    match && Minilog.enable(decodeURIComponent(match[1]));
  }
}

// Make enable also add to localStorage
Minilog.enable = function() {
  oldEnable.call(Minilog, true);
  try { window.localStorage['minilogSettings'] = JSON.stringify(true); } catch(e) {}
  return this;
};

Minilog.disable = function() {
  oldDisable.call(Minilog);
  try { delete window.localStorage.minilogSettings; } catch(e) {}
  return this;
};

exports = module.exports = Minilog;

exports.backends = {
  array: __webpack_require__(117),
  browser: Minilog.defaultBackend,
  localStorage: __webpack_require__(123),
  jQuery: __webpack_require__(122)
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5);

var cid = new Date().valueOf().toString(36);

function AjaxLogger(options) {
  this.url = options.url || '';
  this.cache = [];
  this.timer = null;
  this.interval = options.interval || 30*1000;
  this.enabled = true;
  this.jQuery = window.jQuery;
  this.extras = {};
}

Transform.mixin(AjaxLogger);

AjaxLogger.prototype.write = function(name, level, args) {
  if(!this.timer) { this.init(); }
  this.cache.push([name, level].concat(args));
};

AjaxLogger.prototype.init = function() {
  if(!this.enabled || !this.jQuery) return;
  var self = this;
  this.timer = setTimeout(function() {
    var i, logs = [], ajaxData, url = self.url;
    if(self.cache.length == 0) return self.init();
    // Test each log line and only log the ones that are valid (e.g. don't have circular references).
    // Slight performance hit but benefit is we log all valid lines.
    for(i = 0; i < self.cache.length; i++) {
      try {
        JSON.stringify(self.cache[i]);
        logs.push(self.cache[i]);
      } catch(e) { }
    }
    if(self.jQuery.isEmptyObject(self.extras)) {
        ajaxData = JSON.stringify({ logs: logs });
        url = self.url + '?client_id=' + cid;
    } else {
        ajaxData = JSON.stringify(self.jQuery.extend({logs: logs}, self.extras));
    }

    self.jQuery.ajax(url, {
      type: 'POST',
      cache: false,
      processData: false,
      data: ajaxData,
      contentType: 'application/json',
      timeout: 10000
    }).success(function(data, status, jqxhr) {
      if(data.interval) {
        self.interval = Math.max(1000, data.interval);
      }
    }).error(function() {
      self.interval = 30000;
    }).always(function() {
      self.init();
    });
    self.cache = [];
  }, this.interval);
};

AjaxLogger.prototype.end = function() {};

// wait until jQuery is defined. Useful if you don't control the load order.
AjaxLogger.jQueryWait = function(onDone) {
  if(typeof window !== 'undefined' && (window.jQuery || window.$)) {
    return onDone(window.jQuery || window.$);
  } else if (typeof window !== 'undefined') {
    setTimeout(function() { AjaxLogger.jQueryWait(onDone); }, 200);
  }
};

module.exports = AjaxLogger;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(5),
    cache = false;

var logger = new Transform();

logger.write = function(name, level, args) {
  if(typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;
  try {
    if(!cache) { cache = (window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []); }
    cache.push([ new Date().toString(), name, level, args ]);
    window.localStorage.minilog = JSON.stringify(cache);
  } catch(e) {}
};

module.exports = logger;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var req = __webpack_require__(147)

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), __webpack_require__(7).Buffer))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var trim = __webpack_require__(144)
  , forEach = __webpack_require__(109)
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(126);
exports.encode = exports.stringify = __webpack_require__(127);


/***/ }),
/* 129 */,
/* 130 */,
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(8);


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(50);

/*<replacement>*/
var util = __webpack_require__(14);
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(36).Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(35).PassThrough


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(35).Transform


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(34);


/***/ }),
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(16)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,u=r.id,h=r.path,f=p[u]&&h in p[u].nsps,l=e.forceNew||e["force new connection"]||!1===e.multiplex||f;return l?(c("ignoring socket cache for %s",s),n=a(s,e)):(p[u]||(c("new io instance for %s",s),p[u]=a(s,e)),n=p[u]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(1),s=n(7),a=n(13),c=n(3)("socket.io-client");t.exports=e=r;var p=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(13),e.Socket=n(37)},function(t,e,n){(function(e){"use strict";function r(t,n){var r=t;n=n||e.location,null==t&&(t=n.protocol+"//"+n.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof n?n.protocol+"//"+t:"https://"+t),i("parse %s",t),r=o(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var s=r.host.indexOf(":")!==-1,a=s?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+a+":"+r.port,r.href=r.protocol+"://"+a+(n&&n.port===r.port?"":":"+r.port),r}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r}).call(e,function(){return this}())},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function p(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:p(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function p(){}var u,h,f=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=p,f.addListener=p,f.once=p,f.off=p,f.removeListener=p,f.removeAllListeners=p,f.emit=p,f.prependListener=p,f.prependOnceListener=p,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,o=r-(p||r);t.diff=o,t.prev=p,t.curr=r,p=r;for(var i=new Array(arguments.length),s=0;s<i.length;s++)i[s]=arguments[s];i[0]=e.coerce(i[0]),"string"!=typeof i[0]&&i.unshift("%O");var a=0;i[0]=i[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;a++;var o=e.formatters[r];if("function"==typeof o){var s=i[a];n=o.call(t,s),i.splice(a,1),a--}return n}),e.formatArgs.call(t,i);var c=n.log||e.log||console.log.bind(console);c.apply(t,i)}}return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),"function"==typeof e.init&&e.init(n),n}function i(t){e.save(t),e.names=[],e.skips=[];for(var n=("string"==typeof t?t:"").split(/[\s,]+/),r=n.length,o=0;o<r;o++)n[o]&&(t=n[o].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")))}function s(){e.enable("")}function a(t){var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function c(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=c,e.disable=s,e.enable=i,e.enabled=a,e.humanize=n(6),e.names=[],e.skips=[],e.formatters={};var p},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*u;case"days":case"day":case"d":return n*p;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=p?Math.round(t/p)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,p,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,p=24*c,u=365.25*p;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;return e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data&&(n+=JSON.stringify(t.data)),h("encoded %j as %s",t,n),n}function i(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function s(){this.reconstructor=null}function a(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return u();if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}return t.charAt(++n)&&(r=c(r,t.substr(n))),h("decoded %s as %j",t,r),r}function c(t,e){try{t.data=JSON.parse(e)}catch(n){return u()}return t}function p(t){this.reconPack=t,this.buffers=[]}function u(){return{type:e.ERROR,data:"parser error"}}var h=n(3)("socket.io-parser"),f=n(8),l=n(9),d=n(11),y=n(12);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=s,r.prototype.encode=function(t,n){if(t.type!==e.EVENT&&t.type!==e.ACK||!l(t.data)||(t.type=t.type===e.EVENT?e.BINARY_EVENT:e.BINARY_ACK),h("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)i(t,n);else{var r=o(t);n([r])}},f(s.prototype),s.prototype.add=function(t){var n;if("string"==typeof t)n=a(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new p(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!y(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},s.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){(function(e){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var n=0,i=t.length;n<i;n++)if(r(t[n]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&r(t[c]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=r}).call(e,function(){return this}())},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){(function(t){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(12),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),p="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,u){if(!t)return t;if(c&&t instanceof Blob||p&&t instanceof File){r++;var h=new FileReader;h.onload=function(){u?u[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}}).call(e,function(){return this}())},function(t,e){(function(e){function n(t){return e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer}t.exports=n}).call(e,function(){return this}())},function(t,e,n){"use strict";function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(14),s=n(37),a=n(8),c=n(7),p=n(39),u=n(40),h=n(3)("socket.io-client:manager"),f=n(36),l=n(41),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var o=p(n,"open",function(){r.onopen(),t&&t()}),s=p(n,"error",function(e){if(h("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h("connect attempt will timeout after %d",a);var c=setTimeout(function(){h("connect attempt timed out after %d",a),o.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(p(t,"data",u(this,"ondata"))),this.subs.push(p(t,"ping",u(this,"onping"))),this.subs.push(p(t,"pong",u(this,"onpong"))),this.subs.push(p(t,"error",u(this,"onerror"))),this.subs.push(p(t,"close",u(this,"onclose"))),this.subs.push(p(this.decoder,"decoded",u(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){h("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){h("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();h("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(h("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(15),t.exports.parser=n(22)},function(t,e,n){(function(e){function r(t,n){if(!(this instanceof r))return new r(t,n);n=n||{},t&&"object"==typeof t&&(n=t,t=null),t?(t=u(t),n.hostname=t.host,n.secure="https"===t.protocol||"wss"===t.protocol,n.port=t.port,t.query&&(n.query=t.query)):n.host&&(n.hostname=u(n.host).host),this.secure=null!=n.secure?n.secure:e.location&&"https:"===location.protocol,n.hostname&&!n.port&&(n.port=this.secure?"443":"80"),this.agent=n.agent||!1,this.hostname=n.hostname||(e.location?location.hostname:"localhost"),this.port=n.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=n.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==n.upgrade,this.path=(n.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!n.forceJSONP,this.jsonp=!1!==n.jsonp,this.forceBase64=!!n.forceBase64,this.enablesXDR=!!n.enablesXDR,this.timestampParam=n.timestampParam||"t",this.timestampRequests=n.timestampRequests,this.transports=n.transports||["polling","websocket"],this.transportOptions=n.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=n.policyPort||843,this.rememberUpgrade=n.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=n.onlyBinaryUpgrades,this.perMessageDeflate=!1!==n.perMessageDeflate&&(n.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=n.pfx||null,this.key=n.key||null,this.passphrase=n.passphrase||null,this.cert=n.cert||null,this.ca=n.ca||null,this.ciphers=n.ciphers||null,this.rejectUnauthorized=void 0===n.rejectUnauthorized||n.rejectUnauthorized,this.forceNode=!!n.forceNode;var o="object"==typeof e&&e;o.global===o&&(n.extraHeaders&&Object.keys(n.extraHeaders).length>0&&(this.extraHeaders=n.extraHeaders),n.localAddress&&(this.localAddress=n.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(16),s=n(8),a=n(3)("engine.io-client:socket"),c=n(36),p=n(22),u=n(2),h=n(30);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=p.protocol,r.Socket=r,r.Transport=n(21),r.transports=n(16),r.parser=n(22),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=p.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),u.send([{type:"ping",data:"probe"}]),u.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",u),!u)return;r.priorWebsocketSuccess="websocket"===u.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),p(),f.setTransport(u),u.send([{type:"upgrade"}]),f.emit("upgrade",u),u=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=u.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,p(),u.close(),u=null)}function o(e){var r=new Error("probe error: "+e);r.transport=u.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){u&&t.name!==u.name&&(a('"%s" works - aborting "%s"',t.name,u.name),n())}function p(){u.removeListener("open",e),u.removeListener("error",o),u.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var u=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,u.once("open",e),u.once("error",o),u.once("close",i),this.once("close",s),this.once("upgrading",c),u.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}}).call(e,function(){return this}())},function(t,e,n){(function(t){function r(e){var n,r=!1,a=!1,c=!1!==e.jsonp;if(t.location){var p="https:"===location.protocol,u=location.port;u||(u=p?443:80),r=e.hostname!==location.hostname||u!==e.port,a=e.secure!==p}if(e.xdomain=r,e.xscheme=a,n=new o(e),"open"in n&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=n(17),i=n(19),s=n(33),a=n(34);e.polling=r,e.websocket=a}).call(e,function(){return this}())},function(t,e,n){(function(e){var r=n(18);t.exports=function(t){var n=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!n||r))return new XMLHttpRequest}catch(s){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(s){}if(!n)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP");
}catch(s){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){(function(e){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var n="https:"===location.protocol,r=location.port;r||(r=n?443:80),this.xd=t.hostname!==e.location.hostname||r!==t.port,this.xs=t.secure!==n}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(17),c=n(20),p=n(8),u=n(31),h=n(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,u(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},p(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var n=this.xhr=new a(t),r=this;try{h("xhr open %s: %s",this.method,this.uri),n.open(this.method,this.uri,this.async);try{if(this.extraHeaders){n.setDisableHeaderCheck&&n.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&n.setRequestHeader(o,this.extraHeaders[o])}}catch(s){}if("POST"===this.method)try{this.isBinary?n.setRequestHeader("Content-type","application/octet-stream"):n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(s){}try{n.setRequestHeader("Accept","*/*")}catch(s){}"withCredentials"in n&&(n.withCredentials=!0),this.requestTimeout&&(n.timeout=this.requestTimeout),this.hasXDR()?(n.onload=function(){r.onLoad()},n.onerror=function(){r.onError(n.responseText)}):n.onreadystatechange=function(){if(2===n.readyState){var t;try{t=n.getResponseHeader("Content-Type")}catch(e){}"application/octet-stream"===t&&(n.responseType="arraybuffer")}4===n.readyState&&(200===n.status||1223===n.status?r.onLoad():setTimeout(function(){r.onError(n.status)},0))},h("xhr data %s",this.data),n.send(this.data)}catch(s){return void setTimeout(function(){r.onError(s)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(n){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;u&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(21),i=n(30),s=n(22),a=n(31),c=n(32),p=n(3)("engine.io-client:polling");t.exports=r;var u=function(){var t=n(17),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){p("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(p("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){p("pre-pause polling complete"),--r||e()})),this.writable||(p("we are currently writing - waiting to pause"),r++,this.once("drain",function(){p("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){p("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;p("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():p('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){p("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(p("transport open - closing"),t()):(p("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(22),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){(function(t){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var p,u=n(23),h=n(9),f=n(24),l=n(25),d=n(26);t&&t.ArrayBuffer&&(p=n(28));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=u(v),w={type:"error",data:"parser error"},k=n(29);e.encodePacket=function(e,n,i,a){"function"==typeof n&&(a=n,n=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,n,a);if(k&&c instanceof t.Blob)return s(e,n,a);if(c&&c.base64)return r(e,a);var p=v[e.type];return void 0!==e.data&&(p+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+p)},e.encodeBase64Packet=function(n,r){var o="b"+e.packets[n.type];if(k&&n.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];r(o+t)},i.readAsDataURL(n.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(n.data))}catch(a){for(var c=new Uint8Array(n.data),p=new Array(c.length),u=0;u<c.length;u++)p[u]=c[u];s=String.fromCharCode.apply(null,p)}return o+=t.btoa(s),r(o)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===n&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!p)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=p.decode(t.substr(1));return"blob"===e&&k&&(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?k&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(w,0,1);for(var i,s,a="",c=0,p=t.length;c<p;c++){var u=t.charAt(c);if(":"===u){if(""===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&&w.data===o.data)return r(w,0,1);var h=r(o,c+i,p);if(!1===h)return}c+=i,a=""}else a+=u}return""!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",p=1;255!==s[p];p++){if(c.length>310)return r(w,0,1);c+=s[p]}o=f(o,2+c.length),c=parseInt(c);var u=f(o,0,c);if(a)try{u=String.fromCharCode.apply(null,new Uint8Array(u))}catch(h){var l=new Uint8Array(u);u="";for(var p=0;p<l.length;p++)u+=String.fromCharCode(l[p])}i.push(u),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e,n){var r;(function(t,o){!function(i){function s(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function a(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=w(e>>>10&1023|55296),e=56320|1023&e),o+=w(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function p(t,e){return w(t>>e&63|128)}function u(t,e){if(0==(4294967168&t))return w(t);var n="";return 0==(4294965248&t)?n=w(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),n=w(t>>12&15|224),n+=p(t,6)):0==(4292870144&t)&&(n=w(t>>18&7|240),n+=p(t,12),n+=p(t,6)),n+=w(63&t|128)}function h(t,e){e=e||{};for(var n,r=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)n=o[a],c+=u(n,r);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,n,r,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(n=f(),i=(31&e)<<6|n,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=f(),r=f(),i=(15&e)<<12|n<<6|r,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=f(),r=f(),o=f(),i=(7&e)<<18|n<<12|r<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var n=!1!==e.strict;g=s(t),v=g.length,b=0;for(var r,o=[];(r=l(n))!==!1;)o.push(r);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,w=String.fromCharCode,k={version:"2.1.2",encode:h,decode:d};r=function(){return k}.call(e,n,e,t),!(void 0!==r&&(t.exports=r))}(this)}).call(e,n(27)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,p=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var u=new ArrayBuffer(a),h=new Uint8Array(u);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[p++]=r<<2|o>>4,h[p++]=(15&o)<<4|i>>2,h[p++]=(3&i)<<6|63&s;return u}}()},function(t,e){(function(e){function n(t){for(var e=0;e<t.length;e++){var n=t[e];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}t[e]=r}}}function r(t,e){e=e||{};var r=new i;n(t);for(var o=0;o<t.length;o++)r.append(t[o]);return e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return n(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?r:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(u=0;u<t.length;u++)e=e*a+c[t.charAt(u)];return e}function o(){var t=n(+new Date);return t!==i?(p=0,i=t):t+"."+n(p++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},p=0,u=0;u<a;u++)c[s[u]]=u;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var n=this;a.push(function(t){n.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var i=n(20),s=n(31);t.exports=o;var a,c=/\n/g,p=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),u=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=u,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(p,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){(function(e){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=h&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=o),i.call(this,t)}var o,i=n(21),s=n(22),a=n(30),c=n(31),p=n(32),u=n(3)("engine.io-client:websocket"),h=e.WebSocket||e.MozWebSocket;if("undefined"==typeof window)try{o=n(35)}catch(f){}var l=h;l||"undefined"!=typeof window||(l=o),t.exports=r,c(r,i),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function n(){r.emit("flush"),setTimeout(function(){r.writable=!0,r.emit("drain")},0)}var r=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,r.supportsBinary,function(i){if(!r.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),r.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<r.perMessageDeflate.threshold&&(s.compress=!1)}}try{r.usingBrowserWebSocket?r.ws.send(i):r.ws.send(i,s)}catch(c){u("websocket closed before onclose event")}--o||n()})}(t[i])},r.prototype.onClose=function(){i.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=p()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){"use strict";function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(7),s=n(8),a=n(38),c=n(39),p=n(40),u=n(3)("socket.io-client:socket"),h=n(30);t.exports=e=r;var f={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},l=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",p(this,"onopen")),c(t,"packet",p(this,"onpacket")),c(t,"close",p(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(f.hasOwnProperty(t))return l.apply(this,arguments),this;var e=a(arguments),n={type:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),delete this.flags,this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(u("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;u("sending connect packet with query %s",t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?l.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);u("sending ack %j",r),e.packet({type:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)l.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags=this.flags||{},this.flags.compress=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){"use strict";function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(4).EventEmitter;
var inherits = __webpack_require__(3);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(35);
Stream.Writable = __webpack_require__(136);
Stream.Duplex = __webpack_require__(131);
Stream.Transform = __webpack_require__(135);
Stream.PassThrough = __webpack_require__(134);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(140);
var global = __webpack_require__(43);
exports.setImmediate = global.setImmediate;
exports.clearImmediate = global.clearImmediate;


/***/ }),
/* 144 */
/***/ (function(module, exports) {


exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "extension-worker.js");
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var window = __webpack_require__(43)
var isFunction = __webpack_require__(47)
var parseHeaders = __webpack_require__(125)
var xtend = __webpack_require__(148)

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}


/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = {"name":"scratch-vm","version":"0.1.0","description":"Virtual Machine for Scratch 3.0","author":"Massachusetts Institute of Technology","license":"BSD-3-Clause","homepage":"https://github.com/LLK/scratch-vm#readme","repository":{"type":"git","url":"git+ssh://git@github.com/LLK/scratch-vm.git"},"main":"./dist/node/scratch-vm.js","browser":"./dist/web/scratch-vm.js","scripts":{"build":"webpack --progress --colors --bail","coverage":"tap ./test/{unit,integration}/*.js --coverage --coverage-report=lcov","deploy":"touch playground/.nojekyll && gh-pages -t -d playground -m \"Build for $(git log --pretty=format:%H -n1)\"","lint":"eslint .","prepublish":"in-publish && npm run build || not-in-publish","start":"webpack-dev-server","tap":"tap ./test/{unit,integration}/*.js","tap:unit":"tap ./test/unit/*.js","tap:integration":"tap ./test/integration/*.js","test":"npm run lint && npm run tap","watch":"webpack --progress --colors --watch","version":"json -f package.json -I -e \"this.repository.sha = '$(git log -n1 --pretty=format:%H)'\""},"devDependencies":{"adm-zip":"0.4.7","babel-core":"^6.24.1","babel-eslint":"^7.1.1","babel-loader":"^7.0.0","babel-preset-es2015":"^6.24.1","copy-webpack-plugin":"4.2.1","decode-html":"2.0.0","escape-html":"1.0.3","eslint":"^4.5.0","eslint-config-scratch":"^5.0.0","expose-loader":"0.7.4","gh-pages":"^1.1.0","highlightjs":"^9.8.0","htmlparser2":"3.9.2","immutable":"3.8.1","in-publish":"^2.0.0","json":"^9.0.4","lodash.defaultsdeep":"4.6.0","minilog":"3.1.0","nets":"3.2.0","promise":"8.0.1","scratch-audio":"latest","scratch-blocks":"latest","scratch-render":"latest","scratch-storage":"^0.3.0","script-loader":"0.7.2","socket.io-client":"2.0.4","stats.js":"^0.17.0","tap":"^10.2.0","tiny-worker":"^2.1.1","webpack":"^2.4.1","webpack-dev-server":"^2.4.1","worker-loader":"1.1.0"}}

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 151 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);
});
//# sourceMappingURL=scratch-vm.js.map